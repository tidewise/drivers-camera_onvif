/* soapStub.h
   Generated by gSOAP 2.8.60 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_WSDD_2005
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsdd	"http://schemas.xmlsoap.org/ws/2005/04/discovery"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_tev	"http://www.onvif.org/ver10/events/wsdl"
#define SOAP_NAMESPACE_OF_wsrfrw	"http://docs.oasis-open.org/wsrf/rw-2"
#define SOAP_NAMESPACE_OF_wsrfr	"http://docs.oasis-open.org/wsrf/r-2"
#define SOAP_NAMESPACE_OF_tmd	"http://www.onvif.org/ver10/deviceIO/wsdl"
#define SOAP_NAMESPACE_OF_timg	"http://www.onvif.org/ver20/imaging/wsdl"
#define SOAP_NAMESPACE_OF_trt	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_tptz	"http://www.onvif.org/ver20/ptz/wsdl"
#define SOAP_NAMESPACE_OF_tdn	"http://www.onvif.org/ver10/network/wsdl"
#define SOAP_NAMESPACE_OF_tas	"http://www.onvif.org/ver10/advancedsecurity/wsdl"
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_saml1	"urn:oasis:names:tc:SAML:1.0:assertion"
#define SOAP_NAMESPACE_OF_saml2	"urn:oasis:names:tc:SAML:2.0:assertion"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20860
# error "GSOAP VERSION 20860 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsa5.h:94 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (15)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:102 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (16)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:252 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (36)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* wsdd5.h:100 */
#ifndef SOAP_TYPE_wsdd__FaultCodeType
#define SOAP_TYPE_wsdd__FaultCodeType (68)
/* wsdd:FaultCodeType */
enum wsdd__FaultCodeType {
	wsdd__MatchingRuleNotSupported = 0
};
#endif

/* onvif.h:3569 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (1167)
/* tt:RotateMode */
enum tt__RotateMode {
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* onvif.h:3588 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (1168)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode {
	tt__SceneOrientationMode__MANUAL = 0,
	tt__SceneOrientationMode__AUTO = 1
};
#endif

/* onvif.h:3601 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (1169)
/* tt:VideoEncoding */
enum tt__VideoEncoding {
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* onvif.h:3611 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (1170)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile {
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* onvif.h:3620 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (1171)
/* tt:H264Profile */
enum tt__H264Profile {
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* onvif.h:3635 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (1172)
/* tt:AudioEncoding */
enum tt__AudioEncoding {
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* onvif.h:3649 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (1173)
/* tt:StreamType */
enum tt__StreamType {
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* onvif.h:3658 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (1174)
/* tt:TransportProtocol */
enum tt__TransportProtocol {
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* onvif.h:3672 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (1175)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition {
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* onvif.h:3681 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (1176)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode {
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* onvif.h:3695 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (1178)
/* tt:Duplex */
enum tt__Duplex {
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* onvif.h:3711 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (1180)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration {
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* onvif.h:3722 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (1181)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType {
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* onvif.h:3732 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (1182)
/* tt:NetworkHostType */
enum tt__NetworkHostType {
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* onvif.h:3754 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (1186)
/* tt:IPType */
enum tt__IPType {
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* onvif.h:3769 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (1188)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType {
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* onvif.h:3778 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (1189)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType {
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* onvif.h:3793 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (1191)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode {
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* onvif.h:3803 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (1192)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode {
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* onvif.h:3815 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (1193)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher {
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* onvif.h:3836 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (1196)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength {
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* onvif.h:3849 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (1197)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite {
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* onvif.h:3860 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (1198)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory {
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* onvif.h:3877 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (1199)
/* tt:SystemLogType */
enum tt__SystemLogType {
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* onvif.h:3895 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (1200)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType {
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* onvif.h:3910 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (1201)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType {
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* onvif.h:3925 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (1202)
/* tt:UserLevel */
enum tt__UserLevel {
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* onvif.h:3937 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (1203)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState {
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* onvif.h:3946 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (1204)
/* tt:RelayIdleState */
enum tt__RelayIdleState {
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* onvif.h:3955 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (1205)
/* tt:RelayMode */
enum tt__RelayMode {
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* onvif.h:3964 */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (1206)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState {
	tt__DigitalIdleState__closed = 0,
	tt__DigitalIdleState__open = 1
};
#endif

/* onvif.h:3973 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (1207)
/* tt:EFlipMode */
enum tt__EFlipMode {
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* onvif.h:3983 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (1208)
/* tt:ReverseMode */
enum tt__ReverseMode {
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* onvif.h:3999 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (1210)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState {
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* onvif.h:4010 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (1211)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection {
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* onvif.h:4020 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (1212)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation {
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* onvif.h:4031 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (1213)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode {
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* onvif.h:4042 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (1214)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode {
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* onvif.h:4054 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (1215)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode {
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* onvif.h:4069 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (1216)
/* tt:ExposurePriority */
enum tt__ExposurePriority {
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* onvif.h:4078 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (1217)
/* tt:ExposureMode */
enum tt__ExposureMode {
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* onvif.h:4089 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (1218)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode {
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* onvif.h:4098 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (1219)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode {
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* onvif.h:4108 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (1220)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode {
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* onvif.h:4127 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (1221)
/* tt:PropertyOperation */
enum tt__PropertyOperation {
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* onvif.h:4163 */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (1223)
/* tt:OSDType */
enum tt__OSDType {
	tt__OSDType__Text = 0,
	tt__OSDType__Image = 1,
	tt__OSDType__Extended = 2
};
#endif

/* onvif.h:4183 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1225)
/* tt:MoveStatus */
enum tt__MoveStatus {
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/* onvif.h:4275 */
#ifndef SOAP_TYPE_tmd__SerialPortType
#define SOAP_TYPE_tmd__SerialPortType (1227)
/* tmd:SerialPortType */
enum tmd__SerialPortType {
	tmd__SerialPortType__RS232 = 0,
	tmd__SerialPortType__RS422HalfDuplex = 1,
	tmd__SerialPortType__RS422FullDuplex = 2,
	tmd__SerialPortType__RS485HalfDuplex = 3,
	tmd__SerialPortType__RS485FullDuplex = 4,
	tmd__SerialPortType__Generic = 5
};
#endif

/* onvif.h:4291 */
#ifndef SOAP_TYPE_tmd__ParityBit
#define SOAP_TYPE_tmd__ParityBit (1228)
/* tmd:ParityBit */
enum tmd__ParityBit {
	tmd__ParityBit__None = 0,
	tmd__ParityBit__Even = 1,
	tmd__ParityBit__Odd = 2,
	tmd__ParityBit__Mark = 3,
	tmd__ParityBit__Space = 4,
	tmd__ParityBit__Extended = 5
};
#endif

/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (3269)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:100 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (3272)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (3346)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/* saml1.h:113 */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (3375)
/* saml1:DecisionType */
enum saml1__DecisionType {
	saml1__DecisionType__Permit = 0,
	saml1__DecisionType__Deny = 1,
	saml1__DecisionType__Indeterminate = 2
};
#endif

/* saml2.h:119 */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (3453)
/* saml2:DecisionType */
enum saml2__DecisionType {
	saml2__DecisionType__Permit = 0,
	saml2__DecisionType__Deny = 1,
	saml2__DecisionType__Indeterminate = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* onvif.h:227 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (117)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct wsa5__EndpointReferenceType;	/* wsa5.h:63 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:66 */
struct wsa5__MetadataType;	/* wsa5.h:69 */
struct wsa5__ProblemActionType;	/* wsa5.h:84 */
struct wsa5__RelatesToType;	/* wsa5.h:72 */
struct chan__ChannelInstanceType;	/* wsa5.h:258 */
struct wsdd__HelloType;	/* wsdd5.h:55 */
struct wsdd__ByeType;	/* wsdd5.h:57 */
struct wsdd__ProbeType;	/* wsdd5.h:59 */
struct wsdd__ProbeMatchesType;	/* wsdd5.h:61 */
struct wsdd__ProbeMatchType;	/* wsdd5.h:63 */
struct wsdd__ResolveType;	/* wsdd5.h:65 */
struct wsdd__ResolveMatchesType;	/* wsdd5.h:67 */
struct wsdd__ResolveMatchType;	/* wsdd5.h:69 */
struct wsdd__SecurityType;	/* wsdd5.h:73 */
struct wsdd__SigType;	/* wsdd5.h:75 */
struct wsdd__ScopesType;	/* wsdd5.h:71 */
struct wsdd__AppSequenceType;	/* wsdd5.h:77 */
struct __wsdd__Hello;	/* wsdx.h:67 */
struct __wsdd__Bye;	/* wsdx.h:76 */
struct __wsdd__Probe;	/* wsdx.h:85 */
struct __wsdd__ProbeMatches;	/* wsdx.h:94 */
struct __wsdd__Resolve;	/* wsdx.h:103 */
struct __wsdd__ResolveMatches;	/* wsdx.h:112 */
struct _xop__Include;	/* xop.h:58 */
class xsd__anyType;	/* onvif.h:221 */
struct SOAP_ENV__Envelope;	/* onvif.h:224 */
class xsd__base64Binary;	/* onvif.h:230 */
class xsd__hexBinary;	/* onvif.h:237 */
class _tds__Service_Capabilities;	/* onvif.h:4579 */
class tds__Service;	/* onvif.h:277 */
class tds__DeviceServiceCapabilities;	/* onvif.h:280 */
class tds__NetworkCapabilities;	/* onvif.h:283 */
class tds__SecurityCapabilities;	/* onvif.h:286 */
class tds__SystemCapabilities;	/* onvif.h:289 */
class tds__MiscCapabilities;	/* onvif.h:292 */
class _tds__UserCredential_Extension;	/* onvif.h:4981 */
class tds__UserCredential;	/* onvif.h:295 */
class _tds__StorageConfigurationData_Extension;	/* onvif.h:5032 */
class tds__StorageConfigurationData;	/* onvif.h:298 */
class _tds__GetServices;	/* onvif.h:304 */
class _tds__GetServicesResponse;	/* onvif.h:307 */
class _tds__GetServiceCapabilities;	/* onvif.h:310 */
class _tds__GetServiceCapabilitiesResponse;	/* onvif.h:313 */
class _tds__GetDeviceInformation;	/* onvif.h:316 */
class _tds__GetDeviceInformationResponse;	/* onvif.h:319 */
class _tds__SetSystemDateAndTime;	/* onvif.h:322 */
class _tds__SetSystemDateAndTimeResponse;	/* onvif.h:325 */
class _tds__GetSystemDateAndTime;	/* onvif.h:328 */
class _tds__GetSystemDateAndTimeResponse;	/* onvif.h:331 */
class _tds__SetSystemFactoryDefault;	/* onvif.h:334 */
class _tds__SetSystemFactoryDefaultResponse;	/* onvif.h:337 */
class _tds__UpgradeSystemFirmware;	/* onvif.h:340 */
class _tds__UpgradeSystemFirmwareResponse;	/* onvif.h:343 */
class _tds__SystemReboot;	/* onvif.h:346 */
class _tds__SystemRebootResponse;	/* onvif.h:349 */
class _tds__RestoreSystem;	/* onvif.h:352 */
class _tds__RestoreSystemResponse;	/* onvif.h:355 */
class _tds__GetSystemBackup;	/* onvif.h:358 */
class _tds__GetSystemBackupResponse;	/* onvif.h:361 */
class _tds__GetSystemSupportInformation;	/* onvif.h:364 */
class _tds__GetSystemSupportInformationResponse;	/* onvif.h:367 */
class _tds__GetSystemLog;	/* onvif.h:370 */
class _tds__GetSystemLogResponse;	/* onvif.h:373 */
class _tds__GetScopes;	/* onvif.h:376 */
class _tds__GetScopesResponse;	/* onvif.h:379 */
class _tds__SetScopes;	/* onvif.h:382 */
class _tds__SetScopesResponse;	/* onvif.h:385 */
class _tds__AddScopes;	/* onvif.h:388 */
class _tds__AddScopesResponse;	/* onvif.h:391 */
class _tds__RemoveScopes;	/* onvif.h:394 */
class _tds__RemoveScopesResponse;	/* onvif.h:397 */
class _tds__GetDiscoveryMode;	/* onvif.h:400 */
class _tds__GetDiscoveryModeResponse;	/* onvif.h:403 */
class _tds__SetDiscoveryMode;	/* onvif.h:406 */
class _tds__SetDiscoveryModeResponse;	/* onvif.h:409 */
class _tds__GetRemoteDiscoveryMode;	/* onvif.h:412 */
class _tds__GetRemoteDiscoveryModeResponse;	/* onvif.h:415 */
class _tds__SetRemoteDiscoveryMode;	/* onvif.h:418 */
class _tds__SetRemoteDiscoveryModeResponse;	/* onvif.h:421 */
class _tds__GetDPAddresses;	/* onvif.h:424 */
class _tds__GetDPAddressesResponse;	/* onvif.h:427 */
class _tds__SetDPAddresses;	/* onvif.h:430 */
class _tds__SetDPAddressesResponse;	/* onvif.h:433 */
class _tds__GetEndpointReference;	/* onvif.h:436 */
class _tds__GetEndpointReferenceResponse;	/* onvif.h:439 */
class _tds__GetRemoteUser;	/* onvif.h:442 */
class _tds__GetRemoteUserResponse;	/* onvif.h:445 */
class _tds__SetRemoteUser;	/* onvif.h:448 */
class _tds__SetRemoteUserResponse;	/* onvif.h:451 */
class _tds__GetUsers;	/* onvif.h:454 */
class _tds__GetUsersResponse;	/* onvif.h:457 */
class _tds__CreateUsers;	/* onvif.h:460 */
class _tds__CreateUsersResponse;	/* onvif.h:463 */
class _tds__DeleteUsers;	/* onvif.h:466 */
class _tds__DeleteUsersResponse;	/* onvif.h:469 */
class _tds__SetUser;	/* onvif.h:472 */
class _tds__SetUserResponse;	/* onvif.h:475 */
class _tds__GetWsdlUrl;	/* onvif.h:478 */
class _tds__GetWsdlUrlResponse;	/* onvif.h:481 */
class _tds__GetCapabilities;	/* onvif.h:484 */
class _tds__GetCapabilitiesResponse;	/* onvif.h:487 */
class _tds__GetHostname;	/* onvif.h:490 */
class _tds__GetHostnameResponse;	/* onvif.h:493 */
class _tds__SetHostname;	/* onvif.h:496 */
class _tds__SetHostnameResponse;	/* onvif.h:499 */
class _tds__SetHostnameFromDHCP;	/* onvif.h:502 */
class _tds__SetHostnameFromDHCPResponse;	/* onvif.h:505 */
class _tds__GetDNS;	/* onvif.h:508 */
class _tds__GetDNSResponse;	/* onvif.h:511 */
class _tds__SetDNS;	/* onvif.h:514 */
class _tds__SetDNSResponse;	/* onvif.h:517 */
class _tds__GetNTP;	/* onvif.h:520 */
class _tds__GetNTPResponse;	/* onvif.h:523 */
class _tds__SetNTP;	/* onvif.h:526 */
class _tds__SetNTPResponse;	/* onvif.h:529 */
class _tds__GetDynamicDNS;	/* onvif.h:532 */
class _tds__GetDynamicDNSResponse;	/* onvif.h:535 */
class _tds__SetDynamicDNS;	/* onvif.h:538 */
class _tds__SetDynamicDNSResponse;	/* onvif.h:541 */
class _tds__GetNetworkInterfaces;	/* onvif.h:544 */
class _tds__GetNetworkInterfacesResponse;	/* onvif.h:547 */
class _tds__SetNetworkInterfaces;	/* onvif.h:550 */
class _tds__SetNetworkInterfacesResponse;	/* onvif.h:553 */
class _tds__GetNetworkProtocols;	/* onvif.h:556 */
class _tds__GetNetworkProtocolsResponse;	/* onvif.h:559 */
class _tds__SetNetworkProtocols;	/* onvif.h:562 */
class _tds__SetNetworkProtocolsResponse;	/* onvif.h:565 */
class _tds__GetNetworkDefaultGateway;	/* onvif.h:568 */
class _tds__GetNetworkDefaultGatewayResponse;	/* onvif.h:571 */
class _tds__SetNetworkDefaultGateway;	/* onvif.h:574 */
class _tds__SetNetworkDefaultGatewayResponse;	/* onvif.h:577 */
class _tds__GetZeroConfiguration;	/* onvif.h:580 */
class _tds__GetZeroConfigurationResponse;	/* onvif.h:583 */
class _tds__SetZeroConfiguration;	/* onvif.h:586 */
class _tds__SetZeroConfigurationResponse;	/* onvif.h:589 */
class _tds__GetIPAddressFilter;	/* onvif.h:592 */
class _tds__GetIPAddressFilterResponse;	/* onvif.h:595 */
class _tds__SetIPAddressFilter;	/* onvif.h:598 */
class _tds__SetIPAddressFilterResponse;	/* onvif.h:601 */
class _tds__AddIPAddressFilter;	/* onvif.h:604 */
class _tds__AddIPAddressFilterResponse;	/* onvif.h:607 */
class _tds__RemoveIPAddressFilter;	/* onvif.h:610 */
class _tds__RemoveIPAddressFilterResponse;	/* onvif.h:613 */
class _tds__GetAccessPolicy;	/* onvif.h:616 */
class _tds__GetAccessPolicyResponse;	/* onvif.h:619 */
class _tds__SetAccessPolicy;	/* onvif.h:622 */
class _tds__SetAccessPolicyResponse;	/* onvif.h:625 */
class _tds__CreateCertificate;	/* onvif.h:628 */
class _tds__CreateCertificateResponse;	/* onvif.h:631 */
class _tds__GetCertificates;	/* onvif.h:634 */
class _tds__GetCertificatesResponse;	/* onvif.h:637 */
class _tds__GetCertificatesStatus;	/* onvif.h:640 */
class _tds__GetCertificatesStatusResponse;	/* onvif.h:643 */
class _tds__SetCertificatesStatus;	/* onvif.h:646 */
class _tds__SetCertificatesStatusResponse;	/* onvif.h:649 */
class _tds__DeleteCertificates;	/* onvif.h:652 */
class _tds__DeleteCertificatesResponse;	/* onvif.h:655 */
class _tds__GetPkcs10Request;	/* onvif.h:658 */
class _tds__GetPkcs10RequestResponse;	/* onvif.h:661 */
class _tds__LoadCertificates;	/* onvif.h:664 */
class _tds__LoadCertificatesResponse;	/* onvif.h:667 */
class _tds__GetClientCertificateMode;	/* onvif.h:670 */
class _tds__GetClientCertificateModeResponse;	/* onvif.h:673 */
class _tds__SetClientCertificateMode;	/* onvif.h:676 */
class _tds__SetClientCertificateModeResponse;	/* onvif.h:679 */
class _tds__GetCACertificates;	/* onvif.h:682 */
class _tds__GetCACertificatesResponse;	/* onvif.h:685 */
class _tds__LoadCertificateWithPrivateKey;	/* onvif.h:688 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* onvif.h:691 */
class _tds__GetCertificateInformation;	/* onvif.h:694 */
class _tds__GetCertificateInformationResponse;	/* onvif.h:697 */
class _tds__LoadCACertificates;	/* onvif.h:700 */
class _tds__LoadCACertificatesResponse;	/* onvif.h:703 */
class _tds__CreateDot1XConfiguration;	/* onvif.h:706 */
class _tds__CreateDot1XConfigurationResponse;	/* onvif.h:709 */
class _tds__SetDot1XConfiguration;	/* onvif.h:712 */
class _tds__SetDot1XConfigurationResponse;	/* onvif.h:715 */
class _tds__GetDot1XConfiguration;	/* onvif.h:718 */
class _tds__GetDot1XConfigurationResponse;	/* onvif.h:721 */
class _tds__GetDot1XConfigurations;	/* onvif.h:724 */
class _tds__GetDot1XConfigurationsResponse;	/* onvif.h:727 */
class _tds__DeleteDot1XConfiguration;	/* onvif.h:730 */
class _tds__DeleteDot1XConfigurationResponse;	/* onvif.h:733 */
class _tds__GetRelayOutputs;	/* onvif.h:736 */
class _tds__GetRelayOutputsResponse;	/* onvif.h:739 */
class _tds__SetRelayOutputSettings;	/* onvif.h:742 */
class _tds__SetRelayOutputSettingsResponse;	/* onvif.h:745 */
class _tds__SetRelayOutputState;	/* onvif.h:748 */
class _tds__SetRelayOutputStateResponse;	/* onvif.h:751 */
class _tds__SendAuxiliaryCommand;	/* onvif.h:754 */
class _tds__SendAuxiliaryCommandResponse;	/* onvif.h:757 */
class _tds__GetDot11Capabilities;	/* onvif.h:760 */
class _tds__GetDot11CapabilitiesResponse;	/* onvif.h:763 */
class _tds__GetDot11Status;	/* onvif.h:766 */
class _tds__GetDot11StatusResponse;	/* onvif.h:769 */
class _tds__ScanAvailableDot11Networks;	/* onvif.h:772 */
class _tds__ScanAvailableDot11NetworksResponse;	/* onvif.h:775 */
class _tds__GetSystemUris;	/* onvif.h:778 */
class _tds__GetSystemUrisResponse_Extension;	/* onvif.h:8425 */
class _tds__GetSystemUrisResponse;	/* onvif.h:781 */
class _tds__StartFirmwareUpgrade;	/* onvif.h:784 */
class _tds__StartFirmwareUpgradeResponse;	/* onvif.h:787 */
class _tds__StartSystemRestore;	/* onvif.h:790 */
class _tds__StartSystemRestoreResponse;	/* onvif.h:793 */
class _tds__GetStorageConfigurations;	/* onvif.h:796 */
class _tds__GetStorageConfigurationsResponse;	/* onvif.h:799 */
class _tds__CreateStorageConfiguration;	/* onvif.h:802 */
class _tds__CreateStorageConfigurationResponse;	/* onvif.h:805 */
class _tds__GetStorageConfiguration;	/* onvif.h:808 */
class _tds__GetStorageConfigurationResponse;	/* onvif.h:811 */
class _tds__SetStorageConfiguration;	/* onvif.h:814 */
class _tds__SetStorageConfigurationResponse;	/* onvif.h:817 */
class _tds__DeleteStorageConfiguration;	/* onvif.h:820 */
class _tds__DeleteStorageConfigurationResponse;	/* onvif.h:823 */
class _tds__GetGeoLocation;	/* onvif.h:826 */
class _tds__GetGeoLocationResponse;	/* onvif.h:829 */
class _tds__SetGeoLocation;	/* onvif.h:832 */
class _tds__SetGeoLocationResponse;	/* onvif.h:835 */
class _tds__DeleteGeoLocation;	/* onvif.h:838 */
class _tds__DeleteGeoLocationResponse;	/* onvif.h:841 */
class tt__DeviceEntity;	/* onvif.h:844 */
class tt__IntRectangle;	/* onvif.h:847 */
class tt__IntRectangleRange;	/* onvif.h:850 */
class tt__FloatRange;	/* onvif.h:853 */
class tt__DurationRange;	/* onvif.h:856 */
class tt__IntList;	/* onvif.h:859 */
class tt__FloatList;	/* onvif.h:862 */
class tt__VideoSourceExtension;	/* onvif.h:868 */
class tt__VideoSourceExtension2;	/* onvif.h:871 */
class tt__Profile;	/* onvif.h:877 */
class tt__ProfileExtension;	/* onvif.h:880 */
class tt__ProfileExtension2;	/* onvif.h:883 */
class tt__ConfigurationEntity;	/* onvif.h:886 */
class tt__VideoSourceConfigurationExtension;	/* onvif.h:892 */
class tt__VideoSourceConfigurationExtension2;	/* onvif.h:895 */
class tt__Rotate;	/* onvif.h:898 */
class tt__RotateExtension;	/* onvif.h:901 */
class tt__LensProjection;	/* onvif.h:904 */
class tt__LensOffset;	/* onvif.h:907 */
class tt__LensDescription;	/* onvif.h:910 */
class tt__VideoSourceConfigurationOptions;	/* onvif.h:913 */
class tt__VideoSourceConfigurationOptionsExtension;	/* onvif.h:916 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* onvif.h:919 */
class tt__RotateOptions;	/* onvif.h:922 */
class tt__RotateOptionsExtension;	/* onvif.h:925 */
class tt__SceneOrientation;	/* onvif.h:928 */
class tt__VideoResolution;	/* onvif.h:934 */
class tt__VideoRateControl;	/* onvif.h:937 */
class tt__Mpeg4Configuration;	/* onvif.h:940 */
class tt__H264Configuration;	/* onvif.h:943 */
class tt__VideoEncoderConfigurationOptions;	/* onvif.h:946 */
class tt__VideoEncoderOptionsExtension;	/* onvif.h:949 */
class tt__VideoEncoderOptionsExtension2;	/* onvif.h:952 */
class tt__JpegOptions;	/* onvif.h:955 */
class tt__Mpeg4Options;	/* onvif.h:961 */
class tt__H264Options;	/* onvif.h:967 */
class tt__AudioSourceConfigurationOptions;	/* onvif.h:976 */
class tt__AudioSourceOptionsExtension;	/* onvif.h:979 */
class tt__AudioEncoderConfigurationOptions;	/* onvif.h:985 */
class tt__AudioEncoderConfigurationOption;	/* onvif.h:988 */
class tt__MetadataConfigurationExtension;	/* onvif.h:997 */
class tt__PTZFilter;	/* onvif.h:1000 */
class _tt__EventSubscription_SubscriptionPolicy;	/* onvif.h:10241 */
class tt__EventSubscription;	/* onvif.h:1003 */
class tt__MetadataConfigurationOptions;	/* onvif.h:1006 */
class tt__MetadataConfigurationOptionsExtension;	/* onvif.h:1009 */
class tt__MetadataConfigurationOptionsExtension2;	/* onvif.h:1012 */
class tt__PTZStatusFilterOptions;	/* onvif.h:1015 */
class tt__PTZStatusFilterOptionsExtension;	/* onvif.h:1018 */
class tt__VideoOutputExtension;	/* onvif.h:1024 */
class tt__VideoOutputConfigurationOptions;	/* onvif.h:1030 */
class tt__AudioOutputConfigurationOptions;	/* onvif.h:1039 */
class tt__AudioDecoderConfigurationOptions;	/* onvif.h:1045 */
class tt__G711DecOptions;	/* onvif.h:1048 */
class tt__AACDecOptions;	/* onvif.h:1051 */
class tt__G726DecOptions;	/* onvif.h:1054 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* onvif.h:1057 */
class tt__MulticastConfiguration;	/* onvif.h:1060 */
class tt__StreamSetup;	/* onvif.h:1063 */
class tt__Transport;	/* onvif.h:1066 */
class tt__MediaUri;	/* onvif.h:1069 */
class tt__Scope;	/* onvif.h:1072 */
class tt__NetworkInterfaceExtension;	/* onvif.h:1078 */
class tt__Dot3Configuration;	/* onvif.h:1081 */
class tt__NetworkInterfaceExtension2;	/* onvif.h:1084 */
class tt__NetworkInterfaceLink;	/* onvif.h:1087 */
class tt__NetworkInterfaceConnectionSetting;	/* onvif.h:1090 */
class tt__NetworkInterfaceInfo;	/* onvif.h:1093 */
class tt__IPv6NetworkInterface;	/* onvif.h:1096 */
class tt__IPv4NetworkInterface;	/* onvif.h:1099 */
class tt__IPv4Configuration;	/* onvif.h:1102 */
class tt__IPv6Configuration;	/* onvif.h:1105 */
class tt__IPv6ConfigurationExtension;	/* onvif.h:1108 */
class tt__NetworkProtocol;	/* onvif.h:1111 */
class tt__NetworkProtocolExtension;	/* onvif.h:1114 */
class tt__NetworkHost;	/* onvif.h:1117 */
class tt__NetworkHostExtension;	/* onvif.h:1120 */
class tt__IPAddress;	/* onvif.h:1123 */
class tt__PrefixedIPv4Address;	/* onvif.h:1126 */
class tt__PrefixedIPv6Address;	/* onvif.h:1129 */
class tt__HostnameInformation;	/* onvif.h:1132 */
class tt__HostnameInformationExtension;	/* onvif.h:1135 */
class tt__DNSInformation;	/* onvif.h:1138 */
class tt__DNSInformationExtension;	/* onvif.h:1141 */
class tt__NTPInformation;	/* onvif.h:1144 */
class tt__NTPInformationExtension;	/* onvif.h:1147 */
class tt__DynamicDNSInformation;	/* onvif.h:1150 */
class tt__DynamicDNSInformationExtension;	/* onvif.h:1153 */
class tt__NetworkInterfaceSetConfiguration;	/* onvif.h:1156 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* onvif.h:1159 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* onvif.h:1162 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* onvif.h:1165 */
class tt__NetworkGateway;	/* onvif.h:1168 */
class tt__NetworkZeroConfiguration;	/* onvif.h:1171 */
class tt__NetworkZeroConfigurationExtension;	/* onvif.h:1174 */
class tt__NetworkZeroConfigurationExtension2;	/* onvif.h:1177 */
class tt__IPAddressFilter;	/* onvif.h:1180 */
class tt__IPAddressFilterExtension;	/* onvif.h:1183 */
class tt__Dot11Configuration;	/* onvif.h:1186 */
class tt__Dot11SecurityConfiguration;	/* onvif.h:1189 */
class tt__Dot11SecurityConfigurationExtension;	/* onvif.h:1192 */
class tt__Dot11PSKSet;	/* onvif.h:1195 */
class tt__Dot11PSKSetExtension;	/* onvif.h:1198 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* onvif.h:1201 */
class tt__Dot11Capabilities;	/* onvif.h:1204 */
class tt__Dot11Status;	/* onvif.h:1207 */
class tt__Dot11AvailableNetworks;	/* onvif.h:1210 */
class tt__Dot11AvailableNetworksExtension;	/* onvif.h:1213 */
class tt__Capabilities;	/* onvif.h:1216 */
class tt__CapabilitiesExtension;	/* onvif.h:1219 */
class tt__CapabilitiesExtension2;	/* onvif.h:1222 */
class tt__AnalyticsCapabilities;	/* onvif.h:1225 */
class tt__DeviceCapabilities;	/* onvif.h:1228 */
class tt__DeviceCapabilitiesExtension;	/* onvif.h:1231 */
class tt__EventCapabilities;	/* onvif.h:1234 */
class tt__IOCapabilities;	/* onvif.h:1237 */
class tt__IOCapabilitiesExtension;	/* onvif.h:1240 */
class tt__IOCapabilitiesExtension2;	/* onvif.h:1243 */
class tt__MediaCapabilities;	/* onvif.h:1246 */
class tt__MediaCapabilitiesExtension;	/* onvif.h:1249 */
class tt__RealTimeStreamingCapabilities;	/* onvif.h:1252 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* onvif.h:1255 */
class tt__ProfileCapabilities;	/* onvif.h:1258 */
class tt__NetworkCapabilities;	/* onvif.h:1261 */
class tt__NetworkCapabilitiesExtension;	/* onvif.h:1264 */
class tt__NetworkCapabilitiesExtension2;	/* onvif.h:1267 */
class tt__SecurityCapabilities;	/* onvif.h:1270 */
class tt__SecurityCapabilitiesExtension;	/* onvif.h:1273 */
class tt__SecurityCapabilitiesExtension2;	/* onvif.h:1276 */
class tt__SystemCapabilities;	/* onvif.h:1279 */
class tt__SystemCapabilitiesExtension;	/* onvif.h:1282 */
class tt__SystemCapabilitiesExtension2;	/* onvif.h:1285 */
class tt__OnvifVersion;	/* onvif.h:1288 */
class tt__ImagingCapabilities;	/* onvif.h:1291 */
class tt__PTZCapabilities;	/* onvif.h:1294 */
class tt__DeviceIOCapabilities;	/* onvif.h:1297 */
class tt__DisplayCapabilities;	/* onvif.h:1300 */
class tt__RecordingCapabilities;	/* onvif.h:1303 */
class tt__SearchCapabilities;	/* onvif.h:1306 */
class tt__ReplayCapabilities;	/* onvif.h:1309 */
class tt__ReceiverCapabilities;	/* onvif.h:1312 */
class tt__AnalyticsDeviceCapabilities;	/* onvif.h:1315 */
class tt__AnalyticsDeviceExtension;	/* onvif.h:1318 */
class tt__SystemLog;	/* onvif.h:1321 */
class tt__SupportInformation;	/* onvif.h:1324 */
class tt__BinaryData;	/* onvif.h:1327 */
class tt__AttachmentData;	/* onvif.h:1330 */
class tt__BackupFile;	/* onvif.h:1333 */
class tt__SystemLogUriList;	/* onvif.h:1336 */
class tt__SystemLogUri;	/* onvif.h:1339 */
class tt__SystemDateTime;	/* onvif.h:1342 */
class tt__SystemDateTimeExtension;	/* onvif.h:1345 */
class tt__DateTime;	/* onvif.h:1348 */
class tt__Date;	/* onvif.h:1351 */
class tt__Time;	/* onvif.h:1354 */
class tt__TimeZone;	/* onvif.h:1357 */
class tt__RemoteUser;	/* onvif.h:1360 */
class tt__User;	/* onvif.h:1363 */
class tt__UserExtension;	/* onvif.h:1366 */
class tt__Certificate;	/* onvif.h:1369 */
class tt__CertificateStatus;	/* onvif.h:1372 */
class tt__CertificateWithPrivateKey;	/* onvif.h:1375 */
class tt__CertificateInformation;	/* onvif.h:1378 */
class tt__CertificateInformationExtension;	/* onvif.h:1384 */
class tt__Dot1XConfiguration;	/* onvif.h:1387 */
class tt__Dot1XConfigurationExtension;	/* onvif.h:1390 */
class tt__EAPMethodConfiguration;	/* onvif.h:1393 */
class tt__EapMethodExtension;	/* onvif.h:1396 */
class tt__TLSConfiguration;	/* onvif.h:1399 */
class tt__RelayOutputSettings;	/* onvif.h:1402 */
class tt__PTZNodeExtension;	/* onvif.h:1414 */
class tt__PTZNodeExtension2;	/* onvif.h:1417 */
class tt__PTZPresetTourSupported;	/* onvif.h:1420 */
class tt__PTZPresetTourSupportedExtension;	/* onvif.h:1423 */
class tt__PTZConfigurationExtension;	/* onvif.h:1429 */
class tt__PTZConfigurationExtension2;	/* onvif.h:1432 */
class tt__PTControlDirection;	/* onvif.h:1435 */
class tt__PTControlDirectionExtension;	/* onvif.h:1438 */
class tt__EFlip;	/* onvif.h:1441 */
class tt__Reverse;	/* onvif.h:1444 */
class tt__PTZConfigurationOptions;	/* onvif.h:1447 */
class tt__PTZConfigurationOptions2;	/* onvif.h:1450 */
class tt__PTControlDirectionOptions;	/* onvif.h:1453 */
class tt__PTControlDirectionOptionsExtension;	/* onvif.h:1456 */
class tt__EFlipOptions;	/* onvif.h:1459 */
class tt__EFlipOptionsExtension;	/* onvif.h:1462 */
class tt__ReverseOptions;	/* onvif.h:1465 */
class tt__ReverseOptionsExtension;	/* onvif.h:1468 */
class tt__PanTiltLimits;	/* onvif.h:1471 */
class tt__ZoomLimits;	/* onvif.h:1474 */
class tt__PTZSpaces;	/* onvif.h:1477 */
class tt__PTZSpacesExtension;	/* onvif.h:1480 */
class tt__Space2DDescription;	/* onvif.h:1483 */
class tt__Space1DDescription;	/* onvif.h:1486 */
class tt__PTZSpeed;	/* onvif.h:1489 */
class tt__PTZPreset;	/* onvif.h:1492 */
class tt__PresetTour;	/* onvif.h:1495 */
class tt__PTZPresetTourExtension;	/* onvif.h:1498 */
class tt__PTZPresetTourSpot;	/* onvif.h:1501 */
class tt__PTZPresetTourSpotExtension;	/* onvif.h:1504 */
union _tt__union_PTZPresetTourPresetDetail;	/* onvif.h:15389 */
class tt__PTZPresetTourPresetDetail;	/* onvif.h:1507 */
class tt__PTZPresetTourTypeExtension;	/* onvif.h:1510 */
class tt__PTZPresetTourStatus;	/* onvif.h:1513 */
class tt__PTZPresetTourStatusExtension;	/* onvif.h:1516 */
class tt__PTZPresetTourStartingCondition;	/* onvif.h:1519 */
class tt__PTZPresetTourStartingConditionExtension;	/* onvif.h:1522 */
class tt__PTZPresetTourOptions;	/* onvif.h:1525 */
class tt__PTZPresetTourSpotOptions;	/* onvif.h:1528 */
class tt__PTZPresetTourPresetDetailOptions;	/* onvif.h:1531 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* onvif.h:1534 */
class tt__PTZPresetTourStartingConditionOptions;	/* onvif.h:1537 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* onvif.h:1540 */
class tt__FocusConfiguration;	/* onvif.h:1543 */
class tt__ImagingSettings;	/* onvif.h:1546 */
class tt__ImagingSettingsExtension;	/* onvif.h:1549 */
class tt__Exposure;	/* onvif.h:1552 */
class tt__WideDynamicRange;	/* onvif.h:1555 */
class tt__BacklightCompensation;	/* onvif.h:1558 */
class tt__FocusMove;	/* onvif.h:1561 */
class tt__AbsoluteFocus;	/* onvif.h:1564 */
class tt__RelativeFocus;	/* onvif.h:1567 */
class tt__ContinuousFocus;	/* onvif.h:1570 */
class tt__AbsoluteFocusOptions;	/* onvif.h:1573 */
class tt__ContinuousFocusOptions;	/* onvif.h:1576 */
class tt__WhiteBalance;	/* onvif.h:1579 */
class tt__ImagingStatus20;	/* onvif.h:1582 */
class tt__ImagingStatus20Extension;	/* onvif.h:1585 */
class tt__FocusStatus20;	/* onvif.h:1588 */
class tt__FocusStatus20Extension;	/* onvif.h:1591 */
class tt__ImagingSettings20;	/* onvif.h:1594 */
class tt__ImagingSettingsExtension20;	/* onvif.h:1597 */
class tt__ImagingSettingsExtension202;	/* onvif.h:1600 */
class tt__ImagingSettingsExtension203;	/* onvif.h:1603 */
class tt__ImagingSettingsExtension204;	/* onvif.h:1606 */
class tt__ImageStabilization;	/* onvif.h:1609 */
class tt__ImageStabilizationExtension;	/* onvif.h:1612 */
class tt__IrCutFilterAutoAdjustment;	/* onvif.h:1615 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* onvif.h:1618 */
class tt__WideDynamicRange20;	/* onvif.h:1621 */
class tt__BacklightCompensation20;	/* onvif.h:1624 */
class tt__Exposure20;	/* onvif.h:1627 */
class tt__ToneCompensation;	/* onvif.h:1630 */
class tt__ToneCompensationExtension;	/* onvif.h:1633 */
class tt__Defogging;	/* onvif.h:1636 */
class tt__DefoggingExtension;	/* onvif.h:1639 */
class tt__NoiseReduction;	/* onvif.h:1642 */
class tt__ImagingOptions20;	/* onvif.h:1645 */
class tt__ImagingOptions20Extension;	/* onvif.h:1648 */
class tt__ImagingOptions20Extension2;	/* onvif.h:1651 */
class tt__ImagingOptions20Extension3;	/* onvif.h:1654 */
class tt__ImagingOptions20Extension4;	/* onvif.h:1657 */
class tt__ImageStabilizationOptions;	/* onvif.h:1660 */
class tt__ImageStabilizationOptionsExtension;	/* onvif.h:1663 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* onvif.h:1666 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvif.h:1669 */
class tt__WideDynamicRangeOptions20;	/* onvif.h:1672 */
class tt__BacklightCompensationOptions20;	/* onvif.h:1675 */
class tt__ExposureOptions20;	/* onvif.h:1678 */
class tt__MoveOptions20;	/* onvif.h:1681 */
class tt__RelativeFocusOptions20;	/* onvif.h:1684 */
class tt__WhiteBalance20;	/* onvif.h:1687 */
class tt__WhiteBalance20Extension;	/* onvif.h:1690 */
class tt__FocusConfiguration20;	/* onvif.h:1693 */
class tt__FocusConfiguration20Extension;	/* onvif.h:1696 */
class tt__WhiteBalanceOptions20;	/* onvif.h:1699 */
class tt__WhiteBalanceOptions20Extension;	/* onvif.h:1702 */
class tt__FocusOptions20;	/* onvif.h:1705 */
class tt__FocusOptions20Extension;	/* onvif.h:1708 */
class tt__ToneCompensationOptions;	/* onvif.h:1711 */
class tt__DefoggingOptions;	/* onvif.h:1714 */
class tt__NoiseReductionOptions;	/* onvif.h:1717 */
class tt__MessageExtension;	/* onvif.h:1720 */
class _tt__ItemList_SimpleItem;	/* onvif.h:17883 */
class _tt__ItemList_ElementItem;	/* onvif.h:17911 */
class tt__ItemList;	/* onvif.h:1723 */
class tt__ItemListExtension;	/* onvif.h:1726 */
class tt__Polyline;	/* onvif.h:1729 */
class tt__AnalyticsEngineConfiguration;	/* onvif.h:1732 */
class tt__AnalyticsEngineConfigurationExtension;	/* onvif.h:1735 */
class tt__RuleEngineConfiguration;	/* onvif.h:1738 */
class tt__RuleEngineConfigurationExtension;	/* onvif.h:1741 */
class tt__Config;	/* onvif.h:1744 */
class tt__PaneLayout;	/* onvif.h:1747 */
class tt__Layout;	/* onvif.h:1750 */
class tt__LayoutExtension;	/* onvif.h:1753 */
class tt__DateTimeRange;	/* onvif.h:1756 */
class tt__OSDPosConfiguration;	/* onvif.h:1762 */
class tt__OSDPosConfigurationExtension;	/* onvif.h:1765 */
class tt__OSDColor;	/* onvif.h:1768 */
class tt__OSDTextConfiguration;	/* onvif.h:1771 */
class tt__OSDTextConfigurationExtension;	/* onvif.h:1774 */
class tt__OSDImgConfiguration;	/* onvif.h:1777 */
class tt__OSDImgConfigurationExtension;	/* onvif.h:1780 */
class tt__ColorspaceRange;	/* onvif.h:1783 */
union _tt__union_ColorOptions;	/* onvif.h:18728 */
class tt__ColorOptions;	/* onvif.h:1786 */
class tt__OSDColorOptions;	/* onvif.h:1789 */
class tt__OSDColorOptionsExtension;	/* onvif.h:1792 */
class tt__OSDTextOptions;	/* onvif.h:1795 */
class tt__OSDTextOptionsExtension;	/* onvif.h:1798 */
class tt__OSDImgOptions;	/* onvif.h:1801 */
class tt__OSDImgOptionsExtension;	/* onvif.h:1804 */
class tt__OSDConfigurationExtension;	/* onvif.h:1810 */
class tt__MaximumNumberOfOSDs;	/* onvif.h:1813 */
class tt__OSDConfigurationOptions;	/* onvif.h:1816 */
class tt__OSDConfigurationOptionsExtension;	/* onvif.h:1819 */
class tt__IntRange;	/* onvif.h:1822 */
class tt__Vector2D;	/* onvif.h:1825 */
class tt__Vector1D;	/* onvif.h:1828 */
class tt__PTZVector;	/* onvif.h:1831 */
class tt__PTZStatus;	/* onvif.h:1834 */
class tt__PTZMoveStatus;	/* onvif.h:1837 */
class tt__Vector;	/* onvif.h:1840 */
class tt__Rectangle;	/* onvif.h:1843 */
class tt__Polygon;	/* onvif.h:1846 */
class tt__Color;	/* onvif.h:1849 */
class tt__GeoLocation;	/* onvif.h:1852 */
class tt__GeoOrientation;	/* onvif.h:1855 */
class tt__LocalLocation;	/* onvif.h:1858 */
class tt__LocalOrientation;	/* onvif.h:1861 */
class tt__LocationEntity;	/* onvif.h:1864 */
class _tt__StringItems;	/* onvif.h:1867 */
class _tt__Message;	/* onvif.h:1870 */
class wsnt__QueryExpressionType;	/* onvif.h:1873 */
class wsnt__TopicExpressionType;	/* onvif.h:1876 */
class wsnt__FilterType;	/* onvif.h:1879 */
class wsnt__SubscriptionPolicyType;	/* onvif.h:1882 */
class _wsnt__NotificationMessageHolderType_Message;	/* onvif.h:19856 */
class wsnt__NotificationMessageHolderType;	/* onvif.h:1885 */
class _wsnt__NotificationProducerRP;	/* onvif.h:1948 */
class _wsnt__SubscriptionManagerRP;	/* onvif.h:1951 */
class _wsnt__Notify;	/* onvif.h:1954 */
class _wsnt__UseRaw;	/* onvif.h:1957 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* onvif.h:19995 */
class _wsnt__Subscribe;	/* onvif.h:1960 */
class _wsnt__SubscribeResponse;	/* onvif.h:1963 */
class _wsnt__GetCurrentMessage;	/* onvif.h:1966 */
class _wsnt__GetCurrentMessageResponse;	/* onvif.h:1969 */
class _wsnt__GetMessages;	/* onvif.h:1972 */
class _wsnt__GetMessagesResponse;	/* onvif.h:1975 */
class _wsnt__DestroyPullPoint;	/* onvif.h:1978 */
class _wsnt__DestroyPullPointResponse;	/* onvif.h:1981 */
class _wsnt__CreatePullPoint;	/* onvif.h:1984 */
class _wsnt__CreatePullPointResponse;	/* onvif.h:1987 */
class _wsnt__Renew;	/* onvif.h:1990 */
class _wsnt__RenewResponse;	/* onvif.h:1993 */
class _wsnt__Unsubscribe;	/* onvif.h:1996 */
class _wsnt__UnsubscribeResponse;	/* onvif.h:1999 */
class _wsnt__PauseSubscription;	/* onvif.h:2002 */
class _wsnt__PauseSubscriptionResponse;	/* onvif.h:2005 */
class _wsnt__ResumeSubscription;	/* onvif.h:2008 */
class _wsnt__ResumeSubscriptionResponse;	/* onvif.h:2011 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* onvif.h:20513 */
class _wsrfbf__BaseFaultType_Description;	/* onvif.h:20534 */
class _wsrfbf__BaseFaultType_FaultCause;	/* onvif.h:20551 */
class wsrfbf__BaseFaultType;	/* onvif.h:2014 */
class wstop__Documentation;	/* onvif.h:2017 */
class wstop__ExtensibleDocumented;	/* onvif.h:2020 */
class wstop__QueryExpressionType;	/* onvif.h:2023 */
class tev__Capabilities;	/* onvif.h:2035 */
class _tev__GetServiceCapabilities;	/* onvif.h:2038 */
class _tev__GetServiceCapabilitiesResponse;	/* onvif.h:2041 */
class _tev__CreatePullPointSubscription_SubscriptionPolicy;	/* onvif.h:20801 */
class _tev__CreatePullPointSubscription;	/* onvif.h:2044 */
class _tev__CreatePullPointSubscriptionResponse;	/* onvif.h:2047 */
class _tev__PullMessages;	/* onvif.h:2050 */
class _tev__PullMessagesResponse;	/* onvif.h:2053 */
class _tev__PullMessagesFaultResponse;	/* onvif.h:2056 */
class _tev__Seek;	/* onvif.h:2059 */
class _tev__SeekResponse;	/* onvif.h:2062 */
class _tev__SetSynchronizationPoint;	/* onvif.h:2065 */
class _tev__SetSynchronizationPointResponse;	/* onvif.h:2068 */
class _tev__GetEventProperties;	/* onvif.h:2071 */
class _tev__GetEventPropertiesResponse;	/* onvif.h:2074 */
class tmd__Capabilities;	/* onvif.h:2086 */
class tmd__RelayOutputOptions;	/* onvif.h:2089 */
class tmd__RelayOutputOptionsExtension;	/* onvif.h:2092 */
class tmd__Get;	/* onvif.h:2095 */
class tmd__GetResponse;	/* onvif.h:2098 */
class tmd__DigitalInputConfigurationOptions;	/* onvif.h:2101 */
union _tmd__union_SerialData;	/* onvif.h:21401 */
class tmd__SerialData;	/* onvif.h:2104 */
class tmd__SerialPortConfiguration;	/* onvif.h:2110 */
class tmd__SerialPortConfigurationOptions;	/* onvif.h:2113 */
class tmd__ParityBitList;	/* onvif.h:2116 */
class _tmd__GetServiceCapabilities;	/* onvif.h:2119 */
class _tmd__GetServiceCapabilitiesResponse;	/* onvif.h:2122 */
class _tmd__GetRelayOutputOptions;	/* onvif.h:2125 */
class _tmd__GetRelayOutputOptionsResponse;	/* onvif.h:2128 */
class _tmd__GetVideoOutputs;	/* onvif.h:2131 */
class _tmd__GetVideoOutputsResponse;	/* onvif.h:2134 */
class _tmd__GetAudioSourceConfiguration;	/* onvif.h:2137 */
class _tmd__GetAudioSourceConfigurationResponse;	/* onvif.h:2140 */
class _tmd__GetAudioOutputConfiguration;	/* onvif.h:2143 */
class _tmd__GetAudioOutputConfigurationResponse;	/* onvif.h:2146 */
class _tmd__GetVideoSourceConfiguration;	/* onvif.h:2149 */
class _tmd__GetVideoSourceConfigurationResponse;	/* onvif.h:2152 */
class _tmd__GetVideoOutputConfiguration;	/* onvif.h:2155 */
class _tmd__GetVideoOutputConfigurationResponse;	/* onvif.h:2158 */
class _tmd__SetAudioSourceConfiguration;	/* onvif.h:2161 */
class _tmd__SetAudioSourceConfigurationResponse;	/* onvif.h:2164 */
class _tmd__SetAudioOutputConfiguration;	/* onvif.h:2167 */
class _tmd__SetAudioOutputConfigurationResponse;	/* onvif.h:2170 */
class _tmd__SetVideoSourceConfiguration;	/* onvif.h:2173 */
class _tmd__SetVideoSourceConfigurationResponse;	/* onvif.h:2176 */
class _tmd__SetVideoOutputConfiguration;	/* onvif.h:2179 */
class _tmd__SetVideoOutputConfigurationResponse;	/* onvif.h:2182 */
class _tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:2185 */
class _tmd__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:2188 */
class _tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:2191 */
class _tmd__GetVideoOutputConfigurationOptionsResponse;	/* onvif.h:2194 */
class _tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:2197 */
class _tmd__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:2200 */
class _tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:2203 */
class _tmd__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:2206 */
class _tmd__SetRelayOutputSettings;	/* onvif.h:2209 */
class _tmd__SetRelayOutputSettingsResponse;	/* onvif.h:2212 */
class _tmd__GetDigitalInputs;	/* onvif.h:2215 */
class _tmd__GetDigitalInputsResponse;	/* onvif.h:2218 */
class _tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:2221 */
class _tmd__GetDigitalInputConfigurationOptionsResponse;	/* onvif.h:2224 */
class _tmd__SetDigitalInputConfigurations;	/* onvif.h:2227 */
class _tmd__SetDigitalInputConfigurationsResponse;	/* onvif.h:2230 */
class _tmd__GetSerialPorts;	/* onvif.h:2233 */
class _tmd__GetSerialPortsResponse;	/* onvif.h:2236 */
class _tmd__GetSerialPortConfiguration;	/* onvif.h:2239 */
class _tmd__GetSerialPortConfigurationResponse;	/* onvif.h:2242 */
class _tmd__SetSerialPortConfiguration;	/* onvif.h:2245 */
class _tmd__SetSerialPortConfigurationResponse;	/* onvif.h:2248 */
class _tmd__GetSerialPortConfigurationOptions;	/* onvif.h:2251 */
class _tmd__GetSerialPortConfigurationOptionsResponse;	/* onvif.h:2254 */
class _tmd__SendReceiveSerialCommand;	/* onvif.h:2257 */
class _tmd__SendReceiveSerialCommandResponse;	/* onvif.h:2260 */
class timg__Capabilities;	/* onvif.h:2263 */
class timg__ImagingPreset;	/* onvif.h:2266 */
class _timg__GetServiceCapabilities;	/* onvif.h:2269 */
class _timg__GetServiceCapabilitiesResponse;	/* onvif.h:2272 */
class _timg__GetImagingSettings;	/* onvif.h:2275 */
class _timg__GetImagingSettingsResponse;	/* onvif.h:2278 */
class _timg__SetImagingSettings;	/* onvif.h:2281 */
class _timg__SetImagingSettingsResponse;	/* onvif.h:2284 */
class _timg__GetOptions;	/* onvif.h:2287 */
class _timg__GetOptionsResponse;	/* onvif.h:2290 */
class _timg__Move;	/* onvif.h:2293 */
class _timg__MoveResponse;	/* onvif.h:2296 */
class _timg__GetMoveOptions;	/* onvif.h:2299 */
class _timg__GetMoveOptionsResponse;	/* onvif.h:2302 */
class _timg__Stop;	/* onvif.h:2305 */
class _timg__StopResponse;	/* onvif.h:2308 */
class _timg__GetStatus;	/* onvif.h:2311 */
class _timg__GetStatusResponse;	/* onvif.h:2314 */
class _timg__GetPresets;	/* onvif.h:2317 */
class _timg__GetPresetsResponse;	/* onvif.h:2320 */
class _timg__GetCurrentPreset;	/* onvif.h:2323 */
class _timg__GetCurrentPresetResponse;	/* onvif.h:2326 */
class _timg__SetCurrentPreset;	/* onvif.h:2329 */
class _timg__SetCurrentPresetResponse;	/* onvif.h:2332 */
class trt__Capabilities;	/* onvif.h:2335 */
class trt__ProfileCapabilities;	/* onvif.h:2338 */
class trt__StreamingCapabilities;	/* onvif.h:2341 */
class trt__VideoSourceMode;	/* onvif.h:2344 */
class trt__VideoSourceModeExtension;	/* onvif.h:2347 */
class _trt__GetServiceCapabilities;	/* onvif.h:2350 */
class _trt__GetServiceCapabilitiesResponse;	/* onvif.h:2353 */
class _trt__GetVideoSources;	/* onvif.h:2356 */
class _trt__GetVideoSourcesResponse;	/* onvif.h:2359 */
class _trt__GetAudioSources;	/* onvif.h:2362 */
class _trt__GetAudioSourcesResponse;	/* onvif.h:2365 */
class _trt__GetAudioOutputs;	/* onvif.h:2368 */
class _trt__GetAudioOutputsResponse;	/* onvif.h:2371 */
class _trt__CreateProfile;	/* onvif.h:2374 */
class _trt__CreateProfileResponse;	/* onvif.h:2377 */
class _trt__GetProfile;	/* onvif.h:2380 */
class _trt__GetProfileResponse;	/* onvif.h:2383 */
class _trt__GetProfiles;	/* onvif.h:2386 */
class _trt__GetProfilesResponse;	/* onvif.h:2389 */
class _trt__AddVideoEncoderConfiguration;	/* onvif.h:2392 */
class _trt__AddVideoEncoderConfigurationResponse;	/* onvif.h:2395 */
class _trt__RemoveVideoEncoderConfiguration;	/* onvif.h:2398 */
class _trt__RemoveVideoEncoderConfigurationResponse;	/* onvif.h:2401 */
class _trt__AddVideoSourceConfiguration;	/* onvif.h:2404 */
class _trt__AddVideoSourceConfigurationResponse;	/* onvif.h:2407 */
class _trt__RemoveVideoSourceConfiguration;	/* onvif.h:2410 */
class _trt__RemoveVideoSourceConfigurationResponse;	/* onvif.h:2413 */
class _trt__AddAudioEncoderConfiguration;	/* onvif.h:2416 */
class _trt__AddAudioEncoderConfigurationResponse;	/* onvif.h:2419 */
class _trt__RemoveAudioEncoderConfiguration;	/* onvif.h:2422 */
class _trt__RemoveAudioEncoderConfigurationResponse;	/* onvif.h:2425 */
class _trt__AddAudioSourceConfiguration;	/* onvif.h:2428 */
class _trt__AddAudioSourceConfigurationResponse;	/* onvif.h:2431 */
class _trt__RemoveAudioSourceConfiguration;	/* onvif.h:2434 */
class _trt__RemoveAudioSourceConfigurationResponse;	/* onvif.h:2437 */
class _trt__AddPTZConfiguration;	/* onvif.h:2440 */
class _trt__AddPTZConfigurationResponse;	/* onvif.h:2443 */
class _trt__RemovePTZConfiguration;	/* onvif.h:2446 */
class _trt__RemovePTZConfigurationResponse;	/* onvif.h:2449 */
class _trt__AddVideoAnalyticsConfiguration;	/* onvif.h:2452 */
class _trt__AddVideoAnalyticsConfigurationResponse;	/* onvif.h:2455 */
class _trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:2458 */
class _trt__RemoveVideoAnalyticsConfigurationResponse;	/* onvif.h:2461 */
class _trt__AddMetadataConfiguration;	/* onvif.h:2464 */
class _trt__AddMetadataConfigurationResponse;	/* onvif.h:2467 */
class _trt__RemoveMetadataConfiguration;	/* onvif.h:2470 */
class _trt__RemoveMetadataConfigurationResponse;	/* onvif.h:2473 */
class _trt__AddAudioOutputConfiguration;	/* onvif.h:2476 */
class _trt__AddAudioOutputConfigurationResponse;	/* onvif.h:2479 */
class _trt__RemoveAudioOutputConfiguration;	/* onvif.h:2482 */
class _trt__RemoveAudioOutputConfigurationResponse;	/* onvif.h:2485 */
class _trt__AddAudioDecoderConfiguration;	/* onvif.h:2488 */
class _trt__AddAudioDecoderConfigurationResponse;	/* onvif.h:2491 */
class _trt__RemoveAudioDecoderConfiguration;	/* onvif.h:2494 */
class _trt__RemoveAudioDecoderConfigurationResponse;	/* onvif.h:2497 */
class _trt__DeleteProfile;	/* onvif.h:2500 */
class _trt__DeleteProfileResponse;	/* onvif.h:2503 */
class _trt__GetVideoEncoderConfigurations;	/* onvif.h:2506 */
class _trt__GetVideoEncoderConfigurationsResponse;	/* onvif.h:2509 */
class _trt__GetVideoSourceConfigurations;	/* onvif.h:2512 */
class _trt__GetVideoSourceConfigurationsResponse;	/* onvif.h:2515 */
class _trt__GetAudioEncoderConfigurations;	/* onvif.h:2518 */
class _trt__GetAudioEncoderConfigurationsResponse;	/* onvif.h:2521 */
class _trt__GetAudioSourceConfigurations;	/* onvif.h:2524 */
class _trt__GetAudioSourceConfigurationsResponse;	/* onvif.h:2527 */
class _trt__GetVideoAnalyticsConfigurations;	/* onvif.h:2530 */
class _trt__GetVideoAnalyticsConfigurationsResponse;	/* onvif.h:2533 */
class _trt__GetMetadataConfigurations;	/* onvif.h:2536 */
class _trt__GetMetadataConfigurationsResponse;	/* onvif.h:2539 */
class _trt__GetAudioOutputConfigurations;	/* onvif.h:2542 */
class _trt__GetAudioOutputConfigurationsResponse;	/* onvif.h:2545 */
class _trt__GetAudioDecoderConfigurations;	/* onvif.h:2548 */
class _trt__GetAudioDecoderConfigurationsResponse;	/* onvif.h:2551 */
class _trt__GetVideoSourceConfiguration;	/* onvif.h:2554 */
class _trt__GetVideoSourceConfigurationResponse;	/* onvif.h:2557 */
class _trt__GetVideoEncoderConfiguration;	/* onvif.h:2560 */
class _trt__GetVideoEncoderConfigurationResponse;	/* onvif.h:2563 */
class _trt__GetAudioSourceConfiguration;	/* onvif.h:2566 */
class _trt__GetAudioSourceConfigurationResponse;	/* onvif.h:2569 */
class _trt__GetAudioEncoderConfiguration;	/* onvif.h:2572 */
class _trt__GetAudioEncoderConfigurationResponse;	/* onvif.h:2575 */
class _trt__GetVideoAnalyticsConfiguration;	/* onvif.h:2578 */
class _trt__GetVideoAnalyticsConfigurationResponse;	/* onvif.h:2581 */
class _trt__GetMetadataConfiguration;	/* onvif.h:2584 */
class _trt__GetMetadataConfigurationResponse;	/* onvif.h:2587 */
class _trt__GetAudioOutputConfiguration;	/* onvif.h:2590 */
class _trt__GetAudioOutputConfigurationResponse;	/* onvif.h:2593 */
class _trt__GetAudioDecoderConfiguration;	/* onvif.h:2596 */
class _trt__GetAudioDecoderConfigurationResponse;	/* onvif.h:2599 */
class _trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:2602 */
class _trt__GetCompatibleVideoEncoderConfigurationsResponse;	/* onvif.h:2605 */
class _trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:2608 */
class _trt__GetCompatibleVideoSourceConfigurationsResponse;	/* onvif.h:2611 */
class _trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:2614 */
class _trt__GetCompatibleAudioEncoderConfigurationsResponse;	/* onvif.h:2617 */
class _trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:2620 */
class _trt__GetCompatibleAudioSourceConfigurationsResponse;	/* onvif.h:2623 */
class _trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:2626 */
class _trt__GetCompatibleVideoAnalyticsConfigurationsResponse;	/* onvif.h:2629 */
class _trt__GetCompatibleMetadataConfigurations;	/* onvif.h:2632 */
class _trt__GetCompatibleMetadataConfigurationsResponse;	/* onvif.h:2635 */
class _trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:2638 */
class _trt__GetCompatibleAudioOutputConfigurationsResponse;	/* onvif.h:2641 */
class _trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:2644 */
class _trt__GetCompatibleAudioDecoderConfigurationsResponse;	/* onvif.h:2647 */
class _trt__SetVideoEncoderConfiguration;	/* onvif.h:2650 */
class _trt__SetVideoEncoderConfigurationResponse;	/* onvif.h:2653 */
class _trt__SetVideoSourceConfiguration;	/* onvif.h:2656 */
class _trt__SetVideoSourceConfigurationResponse;	/* onvif.h:2659 */
class _trt__SetAudioEncoderConfiguration;	/* onvif.h:2662 */
class _trt__SetAudioEncoderConfigurationResponse;	/* onvif.h:2665 */
class _trt__SetAudioSourceConfiguration;	/* onvif.h:2668 */
class _trt__SetAudioSourceConfigurationResponse;	/* onvif.h:2671 */
class _trt__SetVideoAnalyticsConfiguration;	/* onvif.h:2674 */
class _trt__SetVideoAnalyticsConfigurationResponse;	/* onvif.h:2677 */
class _trt__SetMetadataConfiguration;	/* onvif.h:2680 */
class _trt__SetMetadataConfigurationResponse;	/* onvif.h:2683 */
class _trt__SetAudioOutputConfiguration;	/* onvif.h:2686 */
class _trt__SetAudioOutputConfigurationResponse;	/* onvif.h:2689 */
class _trt__SetAudioDecoderConfiguration;	/* onvif.h:2692 */
class _trt__SetAudioDecoderConfigurationResponse;	/* onvif.h:2695 */
class _trt__GetVideoSourceConfigurationOptions;	/* onvif.h:2698 */
class _trt__GetVideoSourceConfigurationOptionsResponse;	/* onvif.h:2701 */
class _trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:2704 */
class _trt__GetVideoEncoderConfigurationOptionsResponse;	/* onvif.h:2707 */
class _trt__GetAudioSourceConfigurationOptions;	/* onvif.h:2710 */
class _trt__GetAudioSourceConfigurationOptionsResponse;	/* onvif.h:2713 */
class _trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:2716 */
class _trt__GetAudioEncoderConfigurationOptionsResponse;	/* onvif.h:2719 */
class _trt__GetMetadataConfigurationOptions;	/* onvif.h:2722 */
class _trt__GetMetadataConfigurationOptionsResponse;	/* onvif.h:2725 */
class _trt__GetAudioOutputConfigurationOptions;	/* onvif.h:2728 */
class _trt__GetAudioOutputConfigurationOptionsResponse;	/* onvif.h:2731 */
class _trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:2734 */
class _trt__GetAudioDecoderConfigurationOptionsResponse;	/* onvif.h:2737 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:2740 */
class _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse;	/* onvif.h:2743 */
class _trt__GetStreamUri;	/* onvif.h:2746 */
class _trt__GetStreamUriResponse;	/* onvif.h:2749 */
class _trt__StartMulticastStreaming;	/* onvif.h:2752 */
class _trt__StartMulticastStreamingResponse;	/* onvif.h:2755 */
class _trt__StopMulticastStreaming;	/* onvif.h:2758 */
class _trt__StopMulticastStreamingResponse;	/* onvif.h:2761 */
class _trt__SetSynchronizationPoint;	/* onvif.h:2764 */
class _trt__SetSynchronizationPointResponse;	/* onvif.h:2767 */
class _trt__GetSnapshotUri;	/* onvif.h:2770 */
class _trt__GetSnapshotUriResponse;	/* onvif.h:2773 */
class _trt__GetVideoSourceModes;	/* onvif.h:2776 */
class _trt__GetVideoSourceModesResponse;	/* onvif.h:2779 */
class _trt__SetVideoSourceMode;	/* onvif.h:2782 */
class _trt__SetVideoSourceModeResponse;	/* onvif.h:2785 */
class _trt__GetOSDs;	/* onvif.h:2788 */
class _trt__GetOSDsResponse;	/* onvif.h:2791 */
class _trt__GetOSD;	/* onvif.h:2794 */
class _trt__GetOSDResponse;	/* onvif.h:2797 */
class _trt__SetOSD;	/* onvif.h:2800 */
class _trt__SetOSDResponse;	/* onvif.h:2803 */
class _trt__GetOSDOptions;	/* onvif.h:2806 */
class _trt__GetOSDOptionsResponse;	/* onvif.h:2809 */
class _trt__CreateOSD;	/* onvif.h:2812 */
class _trt__CreateOSDResponse;	/* onvif.h:2815 */
class _trt__DeleteOSD;	/* onvif.h:2818 */
class _trt__DeleteOSDResponse;	/* onvif.h:2821 */
class tptz__Capabilities;	/* onvif.h:2824 */
class _tptz__GetServiceCapabilities;	/* onvif.h:2827 */
class _tptz__GetServiceCapabilitiesResponse;	/* onvif.h:2830 */
class _tptz__GetNodes;	/* onvif.h:2833 */
class _tptz__GetNodesResponse;	/* onvif.h:2836 */
class _tptz__GetNode;	/* onvif.h:2839 */
class _tptz__GetNodeResponse;	/* onvif.h:2842 */
class _tptz__GetConfigurations;	/* onvif.h:2845 */
class _tptz__GetConfigurationsResponse;	/* onvif.h:2848 */
class _tptz__GetConfiguration;	/* onvif.h:2851 */
class _tptz__GetConfigurationResponse;	/* onvif.h:2854 */
class _tptz__SetConfiguration;	/* onvif.h:2857 */
class __tptz__SetConfigurationResponse_sequence;	/* onvif.h:27531 */
class _tptz__SetConfigurationResponse;	/* onvif.h:2860 */
class _tptz__GetConfigurationOptions;	/* onvif.h:2863 */
class _tptz__GetConfigurationOptionsResponse;	/* onvif.h:2866 */
class _tptz__SendAuxiliaryCommand;	/* onvif.h:2869 */
class _tptz__SendAuxiliaryCommandResponse;	/* onvif.h:2872 */
class _tptz__GetPresets;	/* onvif.h:2875 */
class _tptz__GetPresetsResponse;	/* onvif.h:2878 */
class _tptz__SetPreset;	/* onvif.h:2881 */
class _tptz__SetPresetResponse;	/* onvif.h:2884 */
class _tptz__RemovePreset;	/* onvif.h:2887 */
class _tptz__RemovePresetResponse;	/* onvif.h:2890 */
class _tptz__GotoPreset;	/* onvif.h:2893 */
class _tptz__GotoPresetResponse;	/* onvif.h:2896 */
class _tptz__GetStatus;	/* onvif.h:2899 */
class _tptz__GetStatusResponse;	/* onvif.h:2902 */
class _tptz__GotoHomePosition;	/* onvif.h:2905 */
class _tptz__GotoHomePositionResponse;	/* onvif.h:2908 */
class _tptz__SetHomePosition;	/* onvif.h:2911 */
class _tptz__SetHomePositionResponse;	/* onvif.h:2914 */
class _tptz__ContinuousMove;	/* onvif.h:2917 */
class _tptz__ContinuousMoveResponse;	/* onvif.h:2920 */
class _tptz__RelativeMove;	/* onvif.h:2923 */
class _tptz__RelativeMoveResponse;	/* onvif.h:2926 */
class _tptz__AbsoluteMove;	/* onvif.h:2929 */
class _tptz__AbsoluteMoveResponse;	/* onvif.h:2932 */
class _tptz__GeoMove;	/* onvif.h:2935 */
class _tptz__GeoMoveResponse;	/* onvif.h:2938 */
class _tptz__Stop;	/* onvif.h:2941 */
class _tptz__StopResponse;	/* onvif.h:2944 */
class _tptz__GetPresetTours;	/* onvif.h:2947 */
class _tptz__GetPresetToursResponse;	/* onvif.h:2950 */
class _tptz__GetPresetTour;	/* onvif.h:2953 */
class _tptz__GetPresetTourResponse;	/* onvif.h:2956 */
class _tptz__GetPresetTourOptions;	/* onvif.h:2959 */
class _tptz__GetPresetTourOptionsResponse;	/* onvif.h:2962 */
class _tptz__CreatePresetTour;	/* onvif.h:2965 */
class _tptz__CreatePresetTourResponse;	/* onvif.h:2968 */
class _tptz__ModifyPresetTour;	/* onvif.h:2971 */
class _tptz__ModifyPresetTourResponse;	/* onvif.h:2974 */
class _tptz__OperatePresetTour;	/* onvif.h:2977 */
class _tptz__OperatePresetTourResponse;	/* onvif.h:2980 */
class _tptz__RemovePresetTour;	/* onvif.h:2983 */
class _tptz__RemovePresetTourResponse;	/* onvif.h:2986 */
class _tptz__GetCompatibleConfigurations;	/* onvif.h:2989 */
class _tptz__GetCompatibleConfigurationsResponse;	/* onvif.h:2992 */
class _tas__KeyAttribute_Extension;	/* onvif.h:28643 */
class tas__KeyAttribute;	/* onvif.h:2995 */
class tas__DNAttributeTypeAndValue;	/* onvif.h:2998 */
class tas__MultiValuedRDN;	/* onvif.h:3001 */
class _tas__DistinguishedName_anyAttribute;	/* onvif.h:28842 */
class tas__DistinguishedName;	/* onvif.h:3004 */
class _tas__AlgorithmIdentifier_anyParameters;	/* onvif.h:28901 */
class tas__AlgorithmIdentifier;	/* onvif.h:3007 */
class tas__BasicRequestAttribute;	/* onvif.h:3010 */
class _tas__CSRAttribute_anyAttribute;	/* onvif.h:29001 */
union _tas__union_CSRAttribute;	/* onvif.h:29010 */
class tas__CSRAttribute;	/* onvif.h:3013 */
class tas__X509v3Extension;	/* onvif.h:3016 */
class tas__X509Certificate;	/* onvif.h:3019 */
class tas__CertificateIDs;	/* onvif.h:3022 */
class _tas__CertificationPath_anyElement;	/* onvif.h:29184 */
class tas__CertificationPath;	/* onvif.h:3025 */
class tas__PassphraseAttribute;	/* onvif.h:3028 */
class tas__Dot1XCapabilities;	/* onvif.h:3031 */
class tas__Dot1XStage;	/* onvif.h:3034 */
class tas__Dot1XStageExtension;	/* onvif.h:3037 */
class tas__Dot1XConfiguration;	/* onvif.h:3040 */
class tas__CRL;	/* onvif.h:3043 */
class _tas__CertPathValidationParameters_anyParameters;	/* onvif.h:29461 */
class tas__CertPathValidationParameters;	/* onvif.h:3046 */
class tas__TrustAnchor;	/* onvif.h:3049 */
class _tas__CertPathValidationPolicy_anyParameters;	/* onvif.h:29533 */
class tas__CertPathValidationPolicy;	/* onvif.h:3052 */
class _tas__KeystoreCapabilities_anyElement;	/* onvif.h:29577 */
class tas__KeystoreCapabilities;	/* onvif.h:3055 */
class tas__TLSServerCapabilities;	/* onvif.h:3058 */
class tas__Capabilities;	/* onvif.h:3061 */
class _tas__GetServiceCapabilities;	/* onvif.h:3064 */
class _tas__GetServiceCapabilitiesResponse;	/* onvif.h:3067 */
class _tas__CreateRSAKeyPair;	/* onvif.h:3070 */
class _tas__CreateRSAKeyPairResponse;	/* onvif.h:3073 */
class _tas__UploadKeyPairInPKCS8;	/* onvif.h:3076 */
class _tas__UploadKeyPairInPKCS8Response;	/* onvif.h:3079 */
class _tas__UploadCertificateWithPrivateKeyInPKCS12;	/* onvif.h:3082 */
class _tas__UploadCertificateWithPrivateKeyInPKCS12Response;	/* onvif.h:3085 */
class _tas__GetKeyStatus;	/* onvif.h:3088 */
class _tas__GetKeyStatusResponse;	/* onvif.h:3091 */
class _tas__GetPrivateKeyStatus;	/* onvif.h:3094 */
class _tas__GetPrivateKeyStatusResponse;	/* onvif.h:3097 */
class _tas__GetAllKeys;	/* onvif.h:3100 */
class _tas__GetAllKeysResponse;	/* onvif.h:3103 */
class _tas__DeleteKey;	/* onvif.h:3106 */
class _tas__DeleteKeyResponse;	/* onvif.h:3109 */
class _tas__CreatePKCS10CSR;	/* onvif.h:3112 */
class _tas__CreatePKCS10CSRResponse;	/* onvif.h:3115 */
class _tas__CreateSelfSignedCertificate;	/* onvif.h:3118 */
class _tas__CreateSelfSignedCertificateResponse;	/* onvif.h:3121 */
class _tas__UploadCertificate;	/* onvif.h:3124 */
class _tas__UploadCertificateResponse;	/* onvif.h:3127 */
class _tas__GetCertificate;	/* onvif.h:3130 */
class _tas__GetCertificateResponse;	/* onvif.h:3133 */
class _tas__GetAllCertificates;	/* onvif.h:3136 */
class _tas__GetAllCertificatesResponse;	/* onvif.h:3139 */
class _tas__DeleteCertificate;	/* onvif.h:3142 */
class _tas__DeleteCertificateResponse;	/* onvif.h:3145 */
class _tas__CreateCertificationPath;	/* onvif.h:3148 */
class _tas__CreateCertificationPathResponse;	/* onvif.h:3151 */
class _tas__GetCertificationPath;	/* onvif.h:3154 */
class _tas__GetCertificationPathResponse;	/* onvif.h:3157 */
class _tas__GetAllCertificationPaths;	/* onvif.h:3160 */
class _tas__GetAllCertificationPathsResponse;	/* onvif.h:3163 */
class _tas__DeleteCertificationPath;	/* onvif.h:3166 */
class _tas__DeleteCertificationPathResponse;	/* onvif.h:3169 */
class _tas__UploadPassphrase;	/* onvif.h:3172 */
class _tas__UploadPassphraseResponse;	/* onvif.h:3175 */
class _tas__GetAllPassphrases;	/* onvif.h:3178 */
class _tas__GetAllPassphrasesResponse;	/* onvif.h:3181 */
class _tas__DeletePassphrase;	/* onvif.h:3184 */
class _tas__DeletePassphraseResponse;	/* onvif.h:3187 */
class _tas__AddServerCertificateAssignment;	/* onvif.h:3190 */
class _tas__AddServerCertificateAssignmentResponse;	/* onvif.h:3193 */
class _tas__RemoveServerCertificateAssignment;	/* onvif.h:3196 */
class _tas__RemoveServerCertificateAssignmentResponse;	/* onvif.h:3199 */
class _tas__ReplaceServerCertificateAssignment;	/* onvif.h:3202 */
class _tas__ReplaceServerCertificateAssignmentResponse;	/* onvif.h:3205 */
class _tas__GetAssignedServerCertificates;	/* onvif.h:3208 */
class _tas__GetAssignedServerCertificatesResponse;	/* onvif.h:3211 */
class _tas__SetEnabledTLSVersions;	/* onvif.h:3214 */
class _tas__SetEnabledTLSVersionsResponse;	/* onvif.h:3217 */
class _tas__GetEnabledTLSVersions;	/* onvif.h:3220 */
class _tas__GetEnabledTLSVersionsResponse;	/* onvif.h:3223 */
class _tas__UploadCRL_anyParameters;	/* onvif.h:31122 */
class _tas__UploadCRL;	/* onvif.h:3226 */
class _tas__UploadCRLResponse;	/* onvif.h:3229 */
class _tas__GetCRL;	/* onvif.h:3232 */
class _tas__GetCRLResponse;	/* onvif.h:3235 */
class _tas__GetAllCRLs;	/* onvif.h:3238 */
class _tas__GetAllCRLsResponse;	/* onvif.h:3241 */
class _tas__DeleteCRL;	/* onvif.h:3244 */
class _tas__DeleteCRLResponse;	/* onvif.h:3247 */
class _tas__CreateCertPathValidationPolicy_anyParameters;	/* onvif.h:31325 */
class _tas__CreateCertPathValidationPolicy;	/* onvif.h:3250 */
class _tas__CreateCertPathValidationPolicyResponse;	/* onvif.h:3253 */
class _tas__GetCertPathValidationPolicy;	/* onvif.h:3256 */
class _tas__GetCertPathValidationPolicyResponse;	/* onvif.h:3259 */
class _tas__GetAllCertPathValidationPolicies;	/* onvif.h:3262 */
class _tas__GetAllCertPathValidationPoliciesResponse;	/* onvif.h:3265 */
class _tas__DeleteCertPathValidationPolicy;	/* onvif.h:3268 */
class _tas__DeleteCertPathValidationPolicyResponse;	/* onvif.h:3271 */
class _tas__SetClientAuthenticationRequired;	/* onvif.h:3274 */
class _tas__SetClientAuthenticationRequiredResponse;	/* onvif.h:3277 */
class _tas__GetClientAuthenticationRequired;	/* onvif.h:3280 */
class _tas__GetClientAuthenticationRequiredResponse;	/* onvif.h:3283 */
class _tas__AddCertPathValidationPolicyAssignment;	/* onvif.h:3286 */
class _tas__AddCertPathValidationPolicyAssignmentResponse;	/* onvif.h:3289 */
class _tas__RemoveCertPathValidationPolicyAssignment;	/* onvif.h:3292 */
class _tas__RemoveCertPathValidationPolicyAssignmentResponse;	/* onvif.h:3295 */
class _tas__ReplaceCertPathValidationPolicyAssignment;	/* onvif.h:3298 */
class _tas__ReplaceCertPathValidationPolicyAssignmentResponse;	/* onvif.h:3301 */
class _tas__GetAssignedCertPathValidationPolicies;	/* onvif.h:3304 */
class _tas__GetAssignedCertPathValidationPoliciesResponse;	/* onvif.h:3307 */
class _tas__AddDot1XConfiguration;	/* onvif.h:3310 */
class _tas__AddDot1XConfigurationResponse;	/* onvif.h:3313 */
class _tas__GetAllDot1XConfigurations;	/* onvif.h:3316 */
class _tas__GetAllDot1XConfigurationsResponse;	/* onvif.h:3319 */
class _tas__GetDot1XConfiguration;	/* onvif.h:3322 */
class _tas__GetDot1XConfigurationResponse;	/* onvif.h:3325 */
class _tas__DeleteDot1XConfiguration;	/* onvif.h:3328 */
class _tas__DeleteDot1XConfigurationResponse;	/* onvif.h:3331 */
class _tas__SetNetworkInterfaceDot1XConfiguration;	/* onvif.h:3334 */
class _tas__SetNetworkInterfaceDot1XConfigurationResponse;	/* onvif.h:3337 */
class _tas__GetNetworkInterfaceDot1XConfiguration;	/* onvif.h:3340 */
class _tas__GetNetworkInterfaceDot1XConfigurationResponse;	/* onvif.h:3343 */
class _tas__DeleteNetworkInterfaceDot1XConfiguration;	/* onvif.h:3346 */
class _tas__DeleteNetworkInterfaceDot1XConfigurationResponse;	/* onvif.h:3349 */
class tds__StorageConfiguration;	/* onvif.h:301 */
class tt__VideoSource;	/* onvif.h:865 */
class tt__AudioSource;	/* onvif.h:874 */
class tt__VideoSourceConfiguration;	/* onvif.h:889 */
class tt__VideoEncoderConfiguration;	/* onvif.h:931 */
class tt__JpegOptions2;	/* onvif.h:958 */
class tt__Mpeg4Options2;	/* onvif.h:964 */
class tt__H264Options2;	/* onvif.h:970 */
class tt__AudioSourceConfiguration;	/* onvif.h:973 */
class tt__AudioEncoderConfiguration;	/* onvif.h:982 */
class tt__VideoAnalyticsConfiguration;	/* onvif.h:991 */
class tt__MetadataConfiguration;	/* onvif.h:994 */
class tt__VideoOutput;	/* onvif.h:1021 */
class tt__VideoOutputConfiguration;	/* onvif.h:1027 */
class tt__AudioOutput;	/* onvif.h:1033 */
class tt__AudioOutputConfiguration;	/* onvif.h:1036 */
class tt__AudioDecoderConfiguration;	/* onvif.h:1042 */
class tt__NetworkInterface;	/* onvif.h:1075 */
class tt__CertificateUsage;	/* onvif.h:1381 */
class tt__RelayOutput;	/* onvif.h:1405 */
class tt__DigitalInput;	/* onvif.h:1408 */
class tt__PTZNode;	/* onvif.h:1411 */
class tt__PTZConfiguration;	/* onvif.h:1426 */
class tt__OSDConfiguration;	/* onvif.h:1807 */
class wsnt__SubscribeCreationFailedFaultType;	/* onvif.h:1888 */
class wsnt__InvalidFilterFaultType;	/* onvif.h:1891 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* onvif.h:1894 */
class wsnt__InvalidTopicExpressionFaultType;	/* onvif.h:1897 */
class wsnt__TopicNotSupportedFaultType;	/* onvif.h:1900 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* onvif.h:1903 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* onvif.h:1906 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* onvif.h:1909 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* onvif.h:1912 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* onvif.h:1915 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* onvif.h:1918 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* onvif.h:1921 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* onvif.h:1924 */
class wsnt__UnableToGetMessagesFaultType;	/* onvif.h:1927 */
class wsnt__UnableToDestroyPullPointFaultType;	/* onvif.h:1930 */
class wsnt__UnableToCreatePullPointFaultType;	/* onvif.h:1933 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* onvif.h:1936 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* onvif.h:1939 */
class wsnt__PauseFailedFaultType;	/* onvif.h:1942 */
class wsnt__ResumeFailedFaultType;	/* onvif.h:1945 */
class _wstop__TopicNamespaceType_Topic;	/* onvif.h:35240 */
class wstop__TopicNamespaceType;	/* onvif.h:2026 */
class wstop__TopicType;	/* onvif.h:2029 */
class wstop__TopicSetType;	/* onvif.h:2032 */
class wsrfr__ResourceUnknownFaultType;	/* onvif.h:2080 */
class wsrfr__ResourceUnavailableFaultType;	/* onvif.h:2083 */
class tmd__SerialPort;	/* onvif.h:2107 */
class tt__OSDReference;	/* onvif.h:1759 */
struct __tas__GetServiceCapabilities;	/* onvif.h:37203 */
struct __tas__CreateRSAKeyPair;	/* onvif.h:37295 */
struct __tas__UploadKeyPairInPKCS8;	/* onvif.h:37375 */
struct __tas__UploadCertificateWithPrivateKeyInPKCS12;	/* onvif.h:37475 */
struct __tas__GetKeyStatus;	/* onvif.h:37549 */
struct __tas__GetPrivateKeyStatus;	/* onvif.h:37626 */
struct __tas__GetAllKeys;	/* onvif.h:37701 */
struct __tas__DeleteKey;	/* onvif.h:37785 */
struct __tas__CreatePKCS10CSR;	/* onvif.h:37878 */
struct __tas__CreateSelfSignedCertificate;	/* onvif.h:37980 */
struct __tas__UploadCertificate;	/* onvif.h:38116 */
struct __tas__GetCertificate;	/* onvif.h:38192 */
struct __tas__GetAllCertificates;	/* onvif.h:38267 */
struct __tas__DeleteCertificate;	/* onvif.h:38350 */
struct __tas__CreateCertificationPath;	/* onvif.h:38439 */
struct __tas__GetCertificationPath;	/* onvif.h:38514 */
struct __tas__GetAllCertificationPaths;	/* onvif.h:38589 */
struct __tas__DeleteCertificationPath;	/* onvif.h:38675 */
struct __tas__UploadPassphrase;	/* onvif.h:38745 */
struct __tas__GetAllPassphrases;	/* onvif.h:38820 */
struct __tas__DeletePassphrase;	/* onvif.h:38890 */
struct __tas__UploadCRL;	/* onvif.h:38969 */
struct __tas__GetCRL;	/* onvif.h:39042 */
struct __tas__GetAllCRLs;	/* onvif.h:39115 */
struct __tas__DeleteCRL;	/* onvif.h:39192 */
struct __tas__CreateCertPathValidationPolicy;	/* onvif.h:39279 */
struct __tas__GetCertPathValidationPolicy;	/* onvif.h:39354 */
struct __tas__GetAllCertPathValidationPolicies;	/* onvif.h:39427 */
struct __tas__DeleteCertPathValidationPolicy;	/* onvif.h:39507 */
struct __tas__AddServerCertificateAssignment;	/* onvif.h:39613 */
struct __tas__RemoveServerCertificateAssignment;	/* onvif.h:39687 */
struct __tas__ReplaceServerCertificateAssignment;	/* onvif.h:39795 */
struct __tas__GetAssignedServerCertificates;	/* onvif.h:39871 */
struct __tas__SetEnabledTLSVersions;	/* onvif.h:39960 */
struct __tas__GetEnabledTLSVersions;	/* onvif.h:40031 */
struct __tas__SetClientAuthenticationRequired;	/* onvif.h:40109 */
struct __tas__GetClientAuthenticationRequired;	/* onvif.h:40179 */
struct __tas__AddCertPathValidationPolicyAssignment;	/* onvif.h:40262 */
struct __tas__RemoveCertPathValidationPolicyAssignment;	/* onvif.h:40336 */
struct __tas__ReplaceCertPathValidationPolicyAssignment;	/* onvif.h:40417 */
struct __tas__GetAssignedCertPathValidationPolicies;	/* onvif.h:40488 */
struct __tas__AddDot1XConfiguration;	/* onvif.h:40558 */
struct __tas__GetAllDot1XConfigurations;	/* onvif.h:40628 */
struct __tas__GetDot1XConfiguration;	/* onvif.h:40698 */
struct __tas__DeleteDot1XConfiguration;	/* onvif.h:40768 */
struct __tas__SetNetworkInterfaceDot1XConfiguration;	/* onvif.h:40838 */
struct __tas__GetNetworkInterfaceDot1XConfiguration;	/* onvif.h:40908 */
struct __tas__DeleteNetworkInterfaceDot1XConfiguration;	/* onvif.h:40978 */
struct __tdn__Hello;	/* onvif.h:41063 */
struct __tdn__Bye;	/* onvif.h:41130 */
struct __tdn__Probe;	/* onvif.h:41197 */
struct __tds__GetServices;	/* onvif.h:41283 */
struct __tds__GetServiceCapabilities;	/* onvif.h:41352 */
struct __tds__GetDeviceInformation;	/* onvif.h:41420 */
struct __tds__SetSystemDateAndTime;	/* onvif.h:41502 */
struct __tds__GetSystemDateAndTime;	/* onvif.h:41576 */
struct __tds__SetSystemFactoryDefault;	/* onvif.h:41644 */
struct __tds__UpgradeSystemFirmware;	/* onvif.h:41718 */
struct __tds__SystemReboot;	/* onvif.h:41786 */
struct __tds__RestoreSystem;	/* onvif.h:41862 */
struct __tds__GetSystemBackup;	/* onvif.h:41937 */
struct __tds__GetSystemLog;	/* onvif.h:42006 */
struct __tds__GetSystemSupportInformation;	/* onvif.h:42074 */
struct __tds__GetScopes;	/* onvif.h:42157 */
struct __tds__SetScopes;	/* onvif.h:42233 */
struct __tds__AddScopes;	/* onvif.h:42305 */
struct __tds__RemoveScopes;	/* onvif.h:42379 */
struct __tds__GetDiscoveryMode;	/* onvif.h:42451 */
struct __tds__SetDiscoveryMode;	/* onvif.h:42524 */
struct __tds__GetRemoteDiscoveryMode;	/* onvif.h:42598 */
struct __tds__SetRemoteDiscoveryMode;	/* onvif.h:42672 */
struct __tds__GetDPAddresses;	/* onvif.h:42744 */
struct __tds__GetEndpointReference;	/* onvif.h:42818 */
struct __tds__GetRemoteUser;	/* onvif.h:42892 */
struct __tds__SetRemoteUser;	/* onvif.h:42971 */
struct __tds__GetUsers;	/* onvif.h:43043 */
struct __tds__CreateUsers;	/* onvif.h:43123 */
struct __tds__DeleteUsers;	/* onvif.h:43198 */
struct __tds__SetUser;	/* onvif.h:43271 */
struct __tds__GetWsdlUrl;	/* onvif.h:43346 */
struct __tds__GetCapabilities;	/* onvif.h:43416 */
struct __tds__SetDPAddresses;	/* onvif.h:43489 */
struct __tds__GetHostname;	/* onvif.h:43560 */
struct __tds__SetHostname;	/* onvif.h:43635 */
struct __tds__SetHostnameFromDHCP;	/* onvif.h:43703 */
struct __tds__GetDNS;	/* onvif.h:43773 */
struct __tds__SetDNS;	/* onvif.h:43843 */
struct __tds__GetNTP;	/* onvif.h:43914 */
struct __tds__SetNTP;	/* onvif.h:43992 */
struct __tds__GetDynamicDNS;	/* onvif.h:44064 */
struct __tds__SetDynamicDNS;	/* onvif.h:44136 */
struct __tds__GetNetworkInterfaces;	/* onvif.h:44208 */
struct __tds__SetNetworkInterfaces;	/* onvif.h:44285 */
struct __tds__GetNetworkProtocols;	/* onvif.h:44356 */
struct __tds__SetNetworkProtocols;	/* onvif.h:44427 */
struct __tds__GetNetworkDefaultGateway;	/* onvif.h:44498 */
struct __tds__SetNetworkDefaultGateway;	/* onvif.h:44568 */
struct __tds__GetZeroConfiguration;	/* onvif.h:44643 */
struct __tds__SetZeroConfiguration;	/* onvif.h:44712 */
struct __tds__GetIPAddressFilter;	/* onvif.h:44784 */
struct __tds__SetIPAddressFilter;	/* onvif.h:44858 */
struct __tds__AddIPAddressFilter;	/* onvif.h:44931 */
struct __tds__RemoveIPAddressFilter;	/* onvif.h:45004 */
struct __tds__GetAccessPolicy;	/* onvif.h:45086 */
struct __tds__SetAccessPolicy;	/* onvif.h:45159 */
struct __tds__CreateCertificate;	/* onvif.h:45242 */
struct __tds__GetCertificates;	/* onvif.h:45322 */
struct __tds__GetCertificatesStatus;	/* onvif.h:45393 */
struct __tds__SetCertificatesStatus;	/* onvif.h:45466 */
struct __tds__DeleteCertificates;	/* onvif.h:45542 */
struct __tds__GetPkcs10Request;	/* onvif.h:45623 */
struct __tds__LoadCertificates;	/* onvif.h:45714 */
struct __tds__GetClientCertificateMode;	/* onvif.h:45785 */
struct __tds__SetClientCertificateMode;	/* onvif.h:45856 */
struct __tds__GetRelayOutputs;	/* onvif.h:45926 */
struct __tds__SetRelayOutputSettings;	/* onvif.h:45996 */
struct __tds__SetRelayOutputState;	/* onvif.h:46066 */
struct __tds__SendAuxiliaryCommand;	/* onvif.h:46165 */
struct __tds__GetCACertificates;	/* onvif.h:46244 */
struct __tds__LoadCertificateWithPrivateKey;	/* onvif.h:46335 */
struct __tds__GetCertificateInformation;	/* onvif.h:46413 */
struct __tds__LoadCACertificates;	/* onvif.h:46498 */
struct __tds__CreateDot1XConfiguration;	/* onvif.h:46574 */
struct __tds__SetDot1XConfiguration;	/* onvif.h:46646 */
struct __tds__GetDot1XConfiguration;	/* onvif.h:46722 */
struct __tds__GetDot1XConfigurations;	/* onvif.h:46801 */
struct __tds__DeleteDot1XConfiguration;	/* onvif.h:46874 */
struct __tds__GetDot11Capabilities;	/* onvif.h:46943 */
struct __tds__GetDot11Status;	/* onvif.h:47013 */
struct __tds__ScanAvailableDot11Networks;	/* onvif.h:47083 */
struct __tds__GetSystemUris;	/* onvif.h:47170 */
struct __tds__StartFirmwareUpgrade;	/* onvif.h:47266 */
struct __tds__StartSystemRestore;	/* onvif.h:47361 */
struct __tds__GetStorageConfigurations;	/* onvif.h:47432 */
struct __tds__CreateStorageConfiguration;	/* onvif.h:47504 */
struct __tds__GetStorageConfiguration;	/* onvif.h:47575 */
struct __tds__SetStorageConfiguration;	/* onvif.h:47645 */
struct __tds__DeleteStorageConfiguration;	/* onvif.h:47716 */
struct __tds__GetGeoLocation;	/* onvif.h:47787 */
struct __tds__SetGeoLocation;	/* onvif.h:47858 */
struct __tds__DeleteGeoLocation;	/* onvif.h:47928 */
struct __tds__GetServices_;	/* onvif.h:47996 */
struct __tds__GetServiceCapabilities_;	/* onvif.h:48065 */
struct __tds__GetDeviceInformation_;	/* onvif.h:48133 */
struct __tds__SetSystemDateAndTime_;	/* onvif.h:48215 */
struct __tds__GetSystemDateAndTime_;	/* onvif.h:48289 */
struct __tds__SetSystemFactoryDefault_;	/* onvif.h:48357 */
struct __tds__UpgradeSystemFirmware_;	/* onvif.h:48431 */
struct __tds__SystemReboot_;	/* onvif.h:48499 */
struct __tds__RestoreSystem_;	/* onvif.h:48575 */
struct __tds__GetSystemBackup_;	/* onvif.h:48650 */
struct __tds__GetSystemLog_;	/* onvif.h:48719 */
struct __tds__GetSystemSupportInformation_;	/* onvif.h:48787 */
struct __tds__GetScopes_;	/* onvif.h:48870 */
struct __tds__SetScopes_;	/* onvif.h:48946 */
struct __tds__AddScopes_;	/* onvif.h:49018 */
struct __tds__RemoveScopes_;	/* onvif.h:49092 */
struct __tds__GetDiscoveryMode_;	/* onvif.h:49164 */
struct __tds__SetDiscoveryMode_;	/* onvif.h:49237 */
struct __tds__GetRemoteDiscoveryMode_;	/* onvif.h:49311 */
struct __tds__SetRemoteDiscoveryMode_;	/* onvif.h:49385 */
struct __tds__GetDPAddresses_;	/* onvif.h:49457 */
struct __tds__GetEndpointReference_;	/* onvif.h:49531 */
struct __tds__GetRemoteUser_;	/* onvif.h:49605 */
struct __tds__SetRemoteUser_;	/* onvif.h:49684 */
struct __tds__GetUsers_;	/* onvif.h:49756 */
struct __tds__CreateUsers_;	/* onvif.h:49836 */
struct __tds__DeleteUsers_;	/* onvif.h:49911 */
struct __tds__SetUser_;	/* onvif.h:49984 */
struct __tds__GetWsdlUrl_;	/* onvif.h:50059 */
struct __tds__GetCapabilities_;	/* onvif.h:50129 */
struct __tds__SetDPAddresses_;	/* onvif.h:50202 */
struct __tds__GetHostname_;	/* onvif.h:50273 */
struct __tds__SetHostname_;	/* onvif.h:50348 */
struct __tds__SetHostnameFromDHCP_;	/* onvif.h:50416 */
struct __tds__GetDNS_;	/* onvif.h:50486 */
struct __tds__SetDNS_;	/* onvif.h:50556 */
struct __tds__GetNTP_;	/* onvif.h:50627 */
struct __tds__SetNTP_;	/* onvif.h:50705 */
struct __tds__GetDynamicDNS_;	/* onvif.h:50777 */
struct __tds__SetDynamicDNS_;	/* onvif.h:50849 */
struct __tds__GetNetworkInterfaces_;	/* onvif.h:50921 */
struct __tds__SetNetworkInterfaces_;	/* onvif.h:50998 */
struct __tds__GetNetworkProtocols_;	/* onvif.h:51069 */
struct __tds__SetNetworkProtocols_;	/* onvif.h:51140 */
struct __tds__GetNetworkDefaultGateway_;	/* onvif.h:51211 */
struct __tds__SetNetworkDefaultGateway_;	/* onvif.h:51281 */
struct __tds__GetZeroConfiguration_;	/* onvif.h:51356 */
struct __tds__SetZeroConfiguration_;	/* onvif.h:51425 */
struct __tds__GetIPAddressFilter_;	/* onvif.h:51497 */
struct __tds__SetIPAddressFilter_;	/* onvif.h:51571 */
struct __tds__AddIPAddressFilter_;	/* onvif.h:51644 */
struct __tds__RemoveIPAddressFilter_;	/* onvif.h:51717 */
struct __tds__GetAccessPolicy_;	/* onvif.h:51799 */
struct __tds__SetAccessPolicy_;	/* onvif.h:51872 */
struct __tds__CreateCertificate_;	/* onvif.h:51955 */
struct __tds__GetCertificates_;	/* onvif.h:52035 */
struct __tds__GetCertificatesStatus_;	/* onvif.h:52106 */
struct __tds__SetCertificatesStatus_;	/* onvif.h:52179 */
struct __tds__DeleteCertificates_;	/* onvif.h:52255 */
struct __tds__GetPkcs10Request_;	/* onvif.h:52336 */
struct __tds__LoadCertificates_;	/* onvif.h:52427 */
struct __tds__GetClientCertificateMode_;	/* onvif.h:52498 */
struct __tds__SetClientCertificateMode_;	/* onvif.h:52569 */
struct __tds__GetRelayOutputs_;	/* onvif.h:52639 */
struct __tds__SetRelayOutputSettings_;	/* onvif.h:52709 */
struct __tds__SetRelayOutputState_;	/* onvif.h:52779 */
struct __tds__SendAuxiliaryCommand_;	/* onvif.h:52878 */
struct __tds__GetCACertificates_;	/* onvif.h:52957 */
struct __tds__LoadCertificateWithPrivateKey_;	/* onvif.h:53048 */
struct __tds__GetCertificateInformation_;	/* onvif.h:53126 */
struct __tds__LoadCACertificates_;	/* onvif.h:53211 */
struct __tds__CreateDot1XConfiguration_;	/* onvif.h:53287 */
struct __tds__SetDot1XConfiguration_;	/* onvif.h:53359 */
struct __tds__GetDot1XConfiguration_;	/* onvif.h:53435 */
struct __tds__GetDot1XConfigurations_;	/* onvif.h:53514 */
struct __tds__DeleteDot1XConfiguration_;	/* onvif.h:53587 */
struct __tds__GetDot11Capabilities_;	/* onvif.h:53656 */
struct __tds__GetDot11Status_;	/* onvif.h:53726 */
struct __tds__ScanAvailableDot11Networks_;	/* onvif.h:53796 */
struct __tds__GetSystemUris_;	/* onvif.h:53883 */
struct __tds__StartFirmwareUpgrade_;	/* onvif.h:53979 */
struct __tds__StartSystemRestore_;	/* onvif.h:54074 */
struct __tds__GetStorageConfigurations_;	/* onvif.h:54145 */
struct __tds__CreateStorageConfiguration_;	/* onvif.h:54217 */
struct __tds__GetStorageConfiguration_;	/* onvif.h:54288 */
struct __tds__SetStorageConfiguration_;	/* onvif.h:54358 */
struct __tds__DeleteStorageConfiguration_;	/* onvif.h:54429 */
struct __tds__GetGeoLocation_;	/* onvif.h:54500 */
struct __tds__SetGeoLocation_;	/* onvif.h:54571 */
struct __tds__DeleteGeoLocation_;	/* onvif.h:54641 */
struct __tev__PullMessages;	/* onvif.h:54741 */
struct __tev__Seek;	/* onvif.h:54823 */
struct __tev__SetSynchronizationPoint;	/* onvif.h:54906 */
struct __tev__Unsubscribe;	/* onvif.h:54984 */
struct __tev__GetServiceCapabilities;	/* onvif.h:55053 */
struct __tev__CreatePullPointSubscription;	/* onvif.h:55163 */
struct __tev__GetEventProperties;	/* onvif.h:55238 */
struct __tev__Renew;	/* onvif.h:55311 */
struct __tev__Unsubscribe_;	/* onvif.h:55384 */
struct __tev__Subscribe;	/* onvif.h:55487 */
struct __tev__GetCurrentMessage;	/* onvif.h:55572 */
struct __tev__Notify;	/* onvif.h:55635 */
struct __tev__GetMessages;	/* onvif.h:55708 */
struct __tev__DestroyPullPoint;	/* onvif.h:55781 */
struct __tev__Notify_;	/* onvif.h:55844 */
struct __tev__CreatePullPoint;	/* onvif.h:55914 */
struct __tev__Renew_;	/* onvif.h:55987 */
struct __tev__Unsubscribe__;	/* onvif.h:56060 */
struct __tev__PauseSubscription;	/* onvif.h:56133 */
struct __tev__ResumeSubscription;	/* onvif.h:56206 */
struct __timg__GetServiceCapabilities;	/* onvif.h:56293 */
struct __timg__GetImagingSettings;	/* onvif.h:56361 */
struct __timg__SetImagingSettings;	/* onvif.h:56429 */
struct __timg__GetOptions;	/* onvif.h:56507 */
struct __timg__Move;	/* onvif.h:56597 */
struct __timg__Stop;	/* onvif.h:56668 */
struct __timg__GetStatus;	/* onvif.h:56738 */
struct __timg__GetMoveOptions;	/* onvif.h:56806 */
struct __timg__GetPresets;	/* onvif.h:56874 */
struct __timg__GetCurrentPreset;	/* onvif.h:56946 */
struct __timg__SetCurrentPreset;	/* onvif.h:57022 */
struct __tmd__GetServiceCapabilities;	/* onvif.h:57109 */
struct __tmd__GetRelayOutputOptions;	/* onvif.h:57202 */
struct __tmd__GetAudioSources;	/* onvif.h:57272 */
struct __tmd__GetAudioOutputs;	/* onvif.h:57342 */
struct __tmd__GetVideoSources;	/* onvif.h:57412 */
struct __tmd__GetVideoOutputs;	/* onvif.h:57482 */
struct __tmd__GetVideoSourceConfiguration;	/* onvif.h:57552 */
struct __tmd__GetVideoOutputConfiguration;	/* onvif.h:57621 */
struct __tmd__GetAudioSourceConfiguration;	/* onvif.h:57690 */
struct __tmd__GetAudioOutputConfiguration;	/* onvif.h:57760 */
struct __tmd__SetVideoSourceConfiguration;	/* onvif.h:57830 */
struct __tmd__SetVideoOutputConfiguration;	/* onvif.h:57899 */
struct __tmd__SetAudioSourceConfiguration;	/* onvif.h:57969 */
struct __tmd__SetAudioOutputConfiguration;	/* onvif.h:58039 */
struct __tmd__GetVideoSourceConfigurationOptions;	/* onvif.h:58108 */
struct __tmd__GetVideoOutputConfigurationOptions;	/* onvif.h:58178 */
struct __tmd__GetAudioSourceConfigurationOptions;	/* onvif.h:58247 */
struct __tmd__GetAudioOutputConfigurationOptions;	/* onvif.h:58317 */
struct __tmd__GetRelayOutputs;	/* onvif.h:58385 */
struct __tmd__SetRelayOutputSettings;	/* onvif.h:58475 */
struct __tmd__SetRelayOutputState;	/* onvif.h:58543 */
struct __tmd__GetDigitalInputs;	/* onvif.h:58611 */
struct __tmd__GetDigitalInputConfigurationOptions;	/* onvif.h:58679 */
struct __tmd__SetDigitalInputConfigurations;	/* onvif.h:58747 */
struct __tmd__GetSerialPorts;	/* onvif.h:58814 */
struct __tmd__GetSerialPortConfiguration;	/* onvif.h:58881 */
struct __tmd__SetSerialPortConfiguration;	/* onvif.h:58948 */
struct __tmd__GetSerialPortConfigurationOptions;	/* onvif.h:59015 */
struct __tmd__SendReceiveSerialCommand;	/* onvif.h:59082 */
struct __tptz__GetServiceCapabilities;	/* onvif.h:59168 */
struct __tptz__GetConfigurations;	/* onvif.h:59265 */
struct __tptz__GetPresets;	/* onvif.h:59336 */
struct __tptz__SetPreset;	/* onvif.h:59422 */
struct __tptz__RemovePreset;	/* onvif.h:59497 */
struct __tptz__GotoPreset;	/* onvif.h:59568 */
struct __tptz__GetStatus;	/* onvif.h:59639 */
struct __tptz__GetConfiguration;	/* onvif.h:59736 */
struct __tptz__GetNodes;	/* onvif.h:59815 */
struct __tptz__GetNode;	/* onvif.h:59885 */
struct __tptz__SetConfiguration;	/* onvif.h:59955 */
struct __tptz__GetConfigurationOptions;	/* onvif.h:60035 */
struct __tptz__GotoHomePosition;	/* onvif.h:60105 */
struct __tptz__SetHomePosition;	/* onvif.h:60178 */
struct __tptz__ContinuousMove;	/* onvif.h:60249 */
struct __tptz__RelativeMove;	/* onvif.h:60325 */
struct __tptz__SendAuxiliaryCommand;	/* onvif.h:60398 */
struct __tptz__AbsoluteMove;	/* onvif.h:60473 */
struct __tptz__GeoMove;	/* onvif.h:60553 */
struct __tptz__Stop;	/* onvif.h:60624 */
struct __tptz__GetPresetTours;	/* onvif.h:60692 */
struct __tptz__GetPresetTour;	/* onvif.h:60760 */
struct __tptz__GetPresetTourOptions;	/* onvif.h:60828 */
struct __tptz__CreatePresetTour;	/* onvif.h:60896 */
struct __tptz__ModifyPresetTour;	/* onvif.h:60964 */
struct __tptz__OperatePresetTour;	/* onvif.h:61032 */
struct __tptz__RemovePresetTour;	/* onvif.h:61100 */
struct __tptz__GetCompatibleConfigurations;	/* onvif.h:61176 */
struct __trt__GetServiceCapabilities;	/* onvif.h:61263 */
struct __trt__GetVideoSources;	/* onvif.h:61331 */
struct __trt__GetAudioSources;	/* onvif.h:61399 */
struct __trt__GetAudioOutputs;	/* onvif.h:61467 */
struct __trt__CreateProfile;	/* onvif.h:61539 */
struct __trt__GetProfile;	/* onvif.h:61608 */
struct __trt__GetProfiles;	/* onvif.h:61681 */
struct __trt__AddVideoEncoderConfiguration;	/* onvif.h:61756 */
struct __trt__AddVideoSourceConfiguration;	/* onvif.h:61827 */
struct __trt__AddAudioEncoderConfiguration;	/* onvif.h:61902 */
struct __trt__AddAudioSourceConfiguration;	/* onvif.h:61973 */
struct __trt__AddPTZConfiguration;	/* onvif.h:62048 */
struct __trt__AddVideoAnalyticsConfiguration;	/* onvif.h:62126 */
struct __trt__AddMetadataConfiguration;	/* onvif.h:62198 */
struct __trt__AddAudioOutputConfiguration;	/* onvif.h:62268 */
struct __trt__AddAudioDecoderConfiguration;	/* onvif.h:62338 */
struct __trt__RemoveVideoEncoderConfiguration;	/* onvif.h:62409 */
struct __trt__RemoveVideoSourceConfiguration;	/* onvif.h:62482 */
struct __trt__RemoveAudioEncoderConfiguration;	/* onvif.h:62554 */
struct __trt__RemoveAudioSourceConfiguration;	/* onvif.h:62628 */
struct __trt__RemovePTZConfiguration;	/* onvif.h:62699 */
struct __trt__RemoveVideoAnalyticsConfiguration;	/* onvif.h:62770 */
struct __trt__RemoveMetadataConfiguration;	/* onvif.h:62840 */
struct __trt__RemoveAudioOutputConfiguration;	/* onvif.h:62910 */
struct __trt__RemoveAudioDecoderConfiguration;	/* onvif.h:62980 */
struct __trt__DeleteProfile;	/* onvif.h:63049 */
struct __trt__GetVideoSourceConfigurations;	/* onvif.h:63119 */
struct __trt__GetVideoEncoderConfigurations;	/* onvif.h:63190 */
struct __trt__GetAudioSourceConfigurations;	/* onvif.h:63261 */
struct __trt__GetAudioEncoderConfigurations;	/* onvif.h:63331 */
struct __trt__GetVideoAnalyticsConfigurations;	/* onvif.h:63401 */
struct __trt__GetMetadataConfigurations;	/* onvif.h:63470 */
struct __trt__GetAudioOutputConfigurations;	/* onvif.h:63539 */
struct __trt__GetAudioDecoderConfigurations;	/* onvif.h:63610 */
struct __trt__GetVideoSourceConfiguration;	/* onvif.h:63679 */
struct __trt__GetVideoEncoderConfiguration;	/* onvif.h:63748 */
struct __trt__GetAudioSourceConfiguration;	/* onvif.h:63817 */
struct __trt__GetAudioEncoderConfiguration;	/* onvif.h:63886 */
struct __trt__GetVideoAnalyticsConfiguration;	/* onvif.h:63955 */
struct __trt__GetMetadataConfiguration;	/* onvif.h:64024 */
struct __trt__GetAudioOutputConfiguration;	/* onvif.h:64093 */
struct __trt__GetAudioDecoderConfiguration;	/* onvif.h:64162 */
struct __trt__GetCompatibleVideoEncoderConfigurations;	/* onvif.h:64234 */
struct __trt__GetCompatibleVideoSourceConfigurations;	/* onvif.h:64308 */
struct __trt__GetCompatibleAudioEncoderConfigurations;	/* onvif.h:64380 */
struct __trt__GetCompatibleAudioSourceConfigurations;	/* onvif.h:64452 */
struct __trt__GetCompatibleVideoAnalyticsConfigurations;	/* onvif.h:64524 */
struct __trt__GetCompatibleMetadataConfigurations;	/* onvif.h:64596 */
struct __trt__GetCompatibleAudioOutputConfigurations;	/* onvif.h:64667 */
struct __trt__GetCompatibleAudioDecoderConfigurations;	/* onvif.h:64738 */
struct __trt__SetVideoSourceConfiguration;	/* onvif.h:64811 */
struct __trt__SetVideoEncoderConfiguration;	/* onvif.h:64888 */
struct __trt__SetAudioSourceConfiguration;	/* onvif.h:64963 */
struct __trt__SetAudioEncoderConfiguration;	/* onvif.h:65039 */
struct __trt__SetVideoAnalyticsConfiguration;	/* onvif.h:65117 */
struct __trt__SetMetadataConfiguration;	/* onvif.h:65194 */
struct __trt__SetAudioOutputConfiguration;	/* onvif.h:65264 */
struct __trt__SetAudioDecoderConfiguration;	/* onvif.h:65334 */
struct __trt__GetVideoSourceConfigurationOptions;	/* onvif.h:65408 */
struct __trt__GetVideoEncoderConfigurationOptions;	/* onvif.h:65490 */
struct __trt__GetAudioSourceConfigurationOptions;	/* onvif.h:65564 */
struct __trt__GetAudioEncoderConfigurationOptions;	/* onvif.h:65634 */
struct __trt__GetMetadataConfigurationOptions;	/* onvif.h:65703 */
struct __trt__GetAudioOutputConfigurationOptions;	/* onvif.h:65772 */
struct __trt__GetAudioDecoderConfigurationOptions;	/* onvif.h:65842 */
struct __trt__GetGuaranteedNumberOfVideoEncoderInstances;	/* onvif.h:65912 */
struct __trt__GetStreamUri;	/* onvif.h:66003 */
struct __trt__StartMulticastStreaming;	/* onvif.h:66078 */
struct __trt__StopMulticastStreaming;	/* onvif.h:66146 */
struct __trt__SetSynchronizationPoint;	/* onvif.h:66231 */
struct __trt__GetSnapshotUri;	/* onvif.h:66309 */
struct __trt__GetVideoSourceModes;	/* onvif.h:66379 */
struct __trt__SetVideoSourceMode;	/* onvif.h:66450 */
struct __trt__GetOSDs;	/* onvif.h:66518 */
struct __trt__GetOSD;	/* onvif.h:66586 */
struct __trt__GetOSDOptions;	/* onvif.h:66654 */
struct __trt__SetOSD;	/* onvif.h:66722 */
struct __trt__CreateOSD;	/* onvif.h:66790 */
struct __trt__DeleteOSD;	/* onvif.h:66858 */
struct _wsu__Timestamp;	/* wsu.h:76 */
struct wsse__EncodedString;	/* wsse.h:57 */
struct _wsse__UsernameToken;	/* wsse.h:128 */
struct _wsse__BinarySecurityToken;	/* wsse.h:139 */
struct _wsse__Reference;	/* wsse.h:149 */
struct _wsse__Embedded;	/* wsse.h:157 */
struct _wsse__KeyIdentifier;	/* wsse.h:166 */
struct _wsse__SecurityTokenReference;	/* wsse.h:176 */
struct ds__SignatureType;	/* ds.h:46 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:73 */
struct ds__KeyInfoType;	/* ds.h:48 */
struct ds__SignedInfoType;	/* ds.h:46 */
struct ds__CanonicalizationMethodType;	/* ds.h:59 */
struct ds__SignatureMethodType;	/* ds.h:62 */
struct ds__ReferenceType;	/* ds.h:65 */
struct ds__TransformsType;	/* ds.h:68 */
struct ds__DigestMethodType;	/* ds.h:79 */
struct ds__KeyValueType;	/* ds.h:84 */
struct ds__RetrievalMethodType;	/* ds.h:85 */
struct ds__X509DataType;	/* wsse.h:179 */
struct ds__X509IssuerSerialType;	/* ds.h:102 */
struct ds__DSAKeyValueType;	/* ds.h:123 */
struct ds__RSAKeyValueType;	/* ds.h:126 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct __saml1__union_AssertionType;	/* saml1.h:147 */
struct saml1__AssertionType;	/* saml1.h:62 */
struct __saml1__union_ConditionsType;	/* saml1.h:190 */
struct saml1__ConditionsType;	/* saml1.h:64 */
struct saml1__ConditionAbstractType;	/* saml1.h:66 */
struct __saml1__union_AdviceType;	/* saml1.h:232 */
struct saml1__AdviceType;	/* saml1.h:72 */
struct saml1__StatementAbstractType;	/* saml1.h:74 */
struct saml1__SubjectType;	/* saml1.h:78 */
struct saml1__SubjectConfirmationType;	/* saml1.h:82 */
struct saml1__SubjectLocalityType;	/* saml1.h:86 */
struct saml1__AuthorityBindingType;	/* saml1.h:88 */
struct __saml1__union_EvidenceType;	/* saml1.h:354 */
struct saml1__EvidenceType;	/* saml1.h:94 */
struct saml1__AttributeDesignatorType;	/* saml1.h:98 */
struct saml1__AudienceRestrictionConditionType;	/* saml1.h:68 */
struct saml1__DoNotCacheConditionType;	/* saml1.h:70 */
struct saml1__SubjectStatementAbstractType;	/* saml1.h:76 */
struct saml1__NameIdentifierType;	/* saml1.h:80 */
struct saml1__ActionType;	/* saml1.h:92 */
struct saml1__AttributeType;	/* saml1.h:100 */
struct saml1__AuthenticationStatementType;	/* saml1.h:84 */
struct saml1__AuthorizationDecisionStatementType;	/* saml1.h:90 */
struct saml1__AttributeStatementType;	/* saml1.h:96 */
struct saml2__BaseIDAbstractType;	/* saml2.h:62 */
struct saml2__EncryptedElementType;	/* saml2.h:66 */
struct __saml2__union_AssertionType;	/* saml2.h:197 */
struct saml2__AssertionType;	/* saml2.h:68 */
struct saml2__SubjectType;	/* saml2.h:70 */
struct saml2__SubjectConfirmationType;	/* saml2.h:72 */
struct __saml2__union_ConditionsType;	/* saml2.h:290 */
struct saml2__ConditionsType;	/* saml2.h:78 */
struct saml2__ConditionAbstractType;	/* saml2.h:80 */
struct __saml2__union_AdviceType;	/* saml2.h:334 */
struct saml2__AdviceType;	/* saml2.h:88 */
struct saml2__StatementAbstractType;	/* saml2.h:90 */
struct saml2__SubjectLocalityType;	/* saml2.h:94 */
struct saml2__AuthnContextType;	/* saml2.h:96 */
struct __saml2__union_EvidenceType;	/* saml2.h:432 */
struct saml2__EvidenceType;	/* saml2.h:102 */
struct saml2__AttributeType;	/* saml2.h:106 */
struct saml2__NameIDType;	/* saml2.h:64 */
struct saml2__SubjectConfirmationDataType;	/* saml2.h:74 */
struct saml2__AudienceRestrictionType;	/* saml2.h:82 */
struct saml2__OneTimeUseType;	/* saml2.h:84 */
struct saml2__ProxyRestrictionType;	/* saml2.h:86 */
struct saml2__AuthnStatementType;	/* saml2.h:92 */
struct saml2__AuthzDecisionStatementType;	/* saml2.h:98 */
struct saml2__ActionType;	/* saml2.h:100 */
struct __saml2__union_AttributeStatementType;	/* saml2.h:674 */
struct saml2__AttributeStatementType;	/* saml2.h:104 */
struct saml2__KeyInfoConfirmationDataType;	/* saml2.h:76 */
struct _wsse__Security;	/* wsse.h:193 */
struct _wsse__Password;	/* wsse.h:129 */

/* wsa5.h:63 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (8)
/* complex XSD type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XSD type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XSD type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XSD type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:66 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (9)
/* complex XSD type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XSD type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:69 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (10)
/* complex XSD type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XSD type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:84 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (12)
/* complex XSD type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XSD type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XSD type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:72 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (11)
/* simple XSD type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XSD type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XSD type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:258 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (37)
/* simple XSD type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XSD type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XSD type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	 /**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:264 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (38)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa5:MessageID' of XSD type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XSD type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XSD type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XSD type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
        /** Optional element 'wsdd:AppSequence' of XSD type 'wsdd:AppSequenceType' */
        struct wsdd__AppSequenceType *wsdd__AppSequence;
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance(), wsdd__AppSequence(), wsse__Security() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:282 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (46)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (48)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:288 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (52)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsdd5.h:55 */
#ifndef SOAP_TYPE_wsdd__HelloType
#define SOAP_TYPE_wsdd__HelloType (53)
/* complex XSD type 'wsdd:HelloType': */
struct SOAP_CMAC wsdd__HelloType {
      public:
        /** Required element 'wsa5:EndpointReference' of XSD type 'wsa5:EndpointReference' */
        struct wsa5__EndpointReferenceType wsa5__EndpointReference;
        /** Optional element 'wsdd:Types' of XSD type 'xsd:QName' */
        char *Types;
        /** Optional element 'wsdd:Scopes' of XSD type 'wsdd:ScopesType' */
        struct wsdd__ScopesType *Scopes;
        /** Optional element 'wsdd:XAddrs' of XSD type 'wsdd:UriListType' */
        char *XAddrs;
        /** Required element 'wsdd:MetadataVersion' of XSD type 'xsd:unsignedInt' */
        unsigned int MetadataVersion;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__HelloType */
        long soap_type() const { return SOAP_TYPE_wsdd__HelloType; }
        /** Constructor with member initializations */
        wsdd__HelloType() : wsa5__EndpointReference(), Types(), Scopes(), XAddrs(), MetadataVersion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__HelloType * SOAP_FMAC2 soap_instantiate_wsdd__HelloType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:57 */
#ifndef SOAP_TYPE_wsdd__ByeType
#define SOAP_TYPE_wsdd__ByeType (54)
/* complex XSD type 'wsdd:ByeType': */
struct SOAP_CMAC wsdd__ByeType {
      public:
        /** Required element 'wsa5:EndpointReference' of XSD type 'wsa5:EndpointReference' */
        struct wsa5__EndpointReferenceType wsa5__EndpointReference;
        /** Optional element 'wsdd:Types' of XSD type 'xsd:QName' */
        char *Types;
        /** Optional element 'wsdd:Scopes' of XSD type 'wsdd:ScopesType' */
        struct wsdd__ScopesType *Scopes;
        /** Optional element 'wsdd:XAddrs' of XSD type 'wsdd:UriListType' */
        char *XAddrs;
        /** Optional element 'wsdd:MetadataVersion' of XSD type 'xsd:unsignedInt' */
        unsigned int *MetadataVersion;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ByeType */
        long soap_type() const { return SOAP_TYPE_wsdd__ByeType; }
        /** Constructor with member initializations */
        wsdd__ByeType() : wsa5__EndpointReference(), Types(), Scopes(), XAddrs(), MetadataVersion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ByeType * SOAP_FMAC2 soap_instantiate_wsdd__ByeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:59 */
#ifndef SOAP_TYPE_wsdd__ProbeType
#define SOAP_TYPE_wsdd__ProbeType (55)
/* complex XSD type 'wsdd:ProbeType': */
struct SOAP_CMAC wsdd__ProbeType {
      public:
        /** Optional element 'wsdd:Types' of XSD type 'xsd:QName' */
        char *Types;
        /** Optional element 'wsdd:Scopes' of XSD type 'wsdd:ScopesType' */
        struct wsdd__ScopesType *Scopes;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ProbeType */
        long soap_type() const { return SOAP_TYPE_wsdd__ProbeType; }
        /** Constructor with member initializations */
        wsdd__ProbeType() : Types(), Scopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ProbeType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:61 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchesType
#define SOAP_TYPE_wsdd__ProbeMatchesType (56)
/* complex XSD type 'wsdd:ProbeMatchesType': */
struct SOAP_CMAC wsdd__ProbeMatchesType {
      public:
        /** Sequence of elements 'wsdd:ProbeMatch' of XSD type 'wsdd:ProbeMatchType' stored in dynamic array ProbeMatch of length __sizeProbeMatch */
        int __sizeProbeMatch;
        struct wsdd__ProbeMatchType *ProbeMatch;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ProbeMatchesType */
        long soap_type() const { return SOAP_TYPE_wsdd__ProbeMatchesType; }
        /** Constructor with member initializations */
        wsdd__ProbeMatchesType() : __sizeProbeMatch(), ProbeMatch() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ProbeMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:63 */
#ifndef SOAP_TYPE_wsdd__ProbeMatchType
#define SOAP_TYPE_wsdd__ProbeMatchType (57)
/* complex XSD type 'wsdd:ProbeMatchType': */
struct SOAP_CMAC wsdd__ProbeMatchType {
      public:
        /** Required element 'wsa5:EndpointReference' of XSD type 'wsa5:EndpointReference' */
        struct wsa5__EndpointReferenceType wsa5__EndpointReference;
        /** Optional element 'wsdd:Types' of XSD type 'xsd:QName' */
        char *Types;
        /** Optional element 'wsdd:Scopes' of XSD type 'wsdd:ScopesType' */
        struct wsdd__ScopesType *Scopes;
        /** Optional element 'wsdd:XAddrs' of XSD type 'wsdd:UriListType' */
        char *XAddrs;
        /** Required element 'wsdd:MetadataVersion' of XSD type 'xsd:unsignedInt' */
        unsigned int MetadataVersion;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ProbeMatchType */
        long soap_type() const { return SOAP_TYPE_wsdd__ProbeMatchType; }
        /** Constructor with member initializations */
        wsdd__ProbeMatchType() : wsa5__EndpointReference(), Types(), Scopes(), XAddrs(), MetadataVersion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:65 */
#ifndef SOAP_TYPE_wsdd__ResolveType
#define SOAP_TYPE_wsdd__ResolveType (58)
/* complex XSD type 'wsdd:ResolveType': */
struct SOAP_CMAC wsdd__ResolveType {
      public:
        /** Required element 'wsa5:EndpointReference' of XSD type 'wsa5:EndpointReference' */
        struct wsa5__EndpointReferenceType wsa5__EndpointReference;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ResolveType */
        long soap_type() const { return SOAP_TYPE_wsdd__ResolveType; }
        /** Constructor with member initializations */
        wsdd__ResolveType() : wsa5__EndpointReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ResolveType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:67 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchesType
#define SOAP_TYPE_wsdd__ResolveMatchesType (59)
/* complex XSD type 'wsdd:ResolveMatchesType': */
struct SOAP_CMAC wsdd__ResolveMatchesType {
      public:
        /** Optional element 'wsdd:ResolveMatch' of XSD type 'wsdd:ResolveMatchType' */
        struct wsdd__ResolveMatchType *ResolveMatch;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ResolveMatchesType */
        long soap_type() const { return SOAP_TYPE_wsdd__ResolveMatchesType; }
        /** Constructor with member initializations */
        wsdd__ResolveMatchesType() : ResolveMatch() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:69 */
#ifndef SOAP_TYPE_wsdd__ResolveMatchType
#define SOAP_TYPE_wsdd__ResolveMatchType (60)
/* complex XSD type 'wsdd:ResolveMatchType': */
struct SOAP_CMAC wsdd__ResolveMatchType {
      public:
        /** Required element 'wsa5:EndpointReference' of XSD type 'wsa5:EndpointReference' */
        struct wsa5__EndpointReferenceType wsa5__EndpointReference;
        /** Optional element 'wsdd:Types' of XSD type 'xsd:QName' */
        char *Types;
        /** Optional element 'wsdd:Scopes' of XSD type 'wsdd:ScopesType' */
        struct wsdd__ScopesType *Scopes;
        /** Optional element 'wsdd:XAddrs' of XSD type 'wsdd:UriListType' */
        char *XAddrs;
        /** Required element 'wsdd:MetadataVersion' of XSD type 'xsd:unsignedInt' */
        unsigned int MetadataVersion;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ResolveMatchType */
        long soap_type() const { return SOAP_TYPE_wsdd__ResolveMatchType; }
        /** Constructor with member initializations */
        wsdd__ResolveMatchType() : wsa5__EndpointReference(), Types(), Scopes(), XAddrs(), MetadataVersion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:73 */
#ifndef SOAP_TYPE_wsdd__SecurityType
#define SOAP_TYPE_wsdd__SecurityType (62)
/* complex XSD type 'wsdd:SecurityType': */
struct SOAP_CMAC wsdd__SecurityType {
      public:
        /** Optional element 'wsdd:Sig' of XSD type 'wsdd:SigType' */
        struct wsdd__SigType *Sig;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__SecurityType */
        long soap_type() const { return SOAP_TYPE_wsdd__SecurityType; }
        /** Constructor with member initializations */
        wsdd__SecurityType() : Sig() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__SecurityType * SOAP_FMAC2 soap_instantiate_wsdd__SecurityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:75 */
#ifndef SOAP_TYPE_wsdd__SigType
#define SOAP_TYPE_wsdd__SigType (63)
/* complex XSD type 'wsdd:SigType': */
struct SOAP_CMAC wsdd__SigType {
      public:
        /** Required attribute 'Scheme' of XSD type 'xsd:string' */
        char *Scheme;
        /** Optional attribute 'KeyId' of XSD type 'xsd:string' */
        char *KeyId;
        /** Required attribute 'Refs' of XSD type 'xsd:string' */
        char *Refs;
        /** Required attribute 'Sig' of XSD type 'xsd:string' */
        char *Sig;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__SigType */
        long soap_type() const { return SOAP_TYPE_wsdd__SigType; }
        /** Constructor with member initializations */
        wsdd__SigType() : Scheme(), KeyId(), Refs(), Sig() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__SigType * SOAP_FMAC2 soap_instantiate_wsdd__SigType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:71 */
#ifndef SOAP_TYPE_wsdd__ScopesType
#define SOAP_TYPE_wsdd__ScopesType (61)
/* simple XSD type 'wsdd:ScopesType': */
struct SOAP_CMAC wsdd__ScopesType {
      public:
        /** Simple content of XSD type 'wsdd:UriListType' wrapped by this struct */
        char *__item;
        /** Optional attribute 'MatchBy' of XSD type 'xsd:string' */
        char *MatchBy;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__ScopesType */
        long soap_type() const { return SOAP_TYPE_wsdd__ScopesType; }
        /** Constructor with member initializations */
        wsdd__ScopesType() : __item(), MatchBy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__ScopesType * SOAP_FMAC2 soap_instantiate_wsdd__ScopesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdd5.h:77 */
#ifndef SOAP_TYPE_wsdd__AppSequenceType
#define SOAP_TYPE_wsdd__AppSequenceType (64)
/* complex XSD type 'wsdd:AppSequenceType': */
struct SOAP_CMAC wsdd__AppSequenceType {
      public:
        /** Required attribute 'InstanceId' of XSD type 'xsd:unsignedInt' */
        unsigned int InstanceId;
        /** Optional attribute 'SequenceId' of XSD type 'xsd:string' */
        char *SequenceId;
        /** Required attribute 'MessageNumber' of XSD type 'xsd:unsignedInt' */
        unsigned int MessageNumber;
      public:
        /** Return unique type id SOAP_TYPE_wsdd__AppSequenceType */
        long soap_type() const { return SOAP_TYPE_wsdd__AppSequenceType; }
        /** Constructor with member initializations */
        wsdd__AppSequenceType() : InstanceId(), SequenceId(), MessageNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsdd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsdd__AppSequenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:67 */
#ifndef SOAP_TYPE___wsdd__Hello
#define SOAP_TYPE___wsdd__Hello (93)
/* Wrapper: */
struct SOAP_CMAC __wsdd__Hello {
      public:
        /** Optional element 'wsdd:Hello' of XSD type 'wsdd:HelloType' */
        struct wsdd__HelloType *wsdd__Hello;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__Hello */
        long soap_type() const { return SOAP_TYPE___wsdd__Hello; }
        /** Constructor with member initializations */
        __wsdd__Hello() : wsdd__Hello() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__Hello * SOAP_FMAC2 soap_instantiate___wsdd__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:76 */
#ifndef SOAP_TYPE___wsdd__Bye
#define SOAP_TYPE___wsdd__Bye (96)
/* Wrapper: */
struct SOAP_CMAC __wsdd__Bye {
      public:
        /** Optional element 'wsdd:Bye' of XSD type 'wsdd:ByeType' */
        struct wsdd__ByeType *wsdd__Bye;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__Bye */
        long soap_type() const { return SOAP_TYPE___wsdd__Bye; }
        /** Constructor with member initializations */
        __wsdd__Bye() : wsdd__Bye() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__Bye * SOAP_FMAC2 soap_instantiate___wsdd__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:85 */
#ifndef SOAP_TYPE___wsdd__Probe
#define SOAP_TYPE___wsdd__Probe (99)
/* Wrapper: */
struct SOAP_CMAC __wsdd__Probe {
      public:
        /** Optional element 'wsdd:Probe' of XSD type 'wsdd:ProbeType' */
        struct wsdd__ProbeType *wsdd__Probe;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__Probe */
        long soap_type() const { return SOAP_TYPE___wsdd__Probe; }
        /** Constructor with member initializations */
        __wsdd__Probe() : wsdd__Probe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__Probe * SOAP_FMAC2 soap_instantiate___wsdd__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:94 */
#ifndef SOAP_TYPE___wsdd__ProbeMatches
#define SOAP_TYPE___wsdd__ProbeMatches (102)
/* Wrapper: */
struct SOAP_CMAC __wsdd__ProbeMatches {
      public:
        /** Optional element 'wsdd:ProbeMatches' of XSD type 'wsdd:ProbeMatchesType' */
        struct wsdd__ProbeMatchesType *wsdd__ProbeMatches;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__ProbeMatches */
        long soap_type() const { return SOAP_TYPE___wsdd__ProbeMatches; }
        /** Constructor with member initializations */
        __wsdd__ProbeMatches() : wsdd__ProbeMatches() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__ProbeMatches * SOAP_FMAC2 soap_instantiate___wsdd__ProbeMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:103 */
#ifndef SOAP_TYPE___wsdd__Resolve
#define SOAP_TYPE___wsdd__Resolve (105)
/* Wrapper: */
struct SOAP_CMAC __wsdd__Resolve {
      public:
        /** Optional element 'wsdd:Resolve' of XSD type 'wsdd:ResolveType' */
        struct wsdd__ResolveType *wsdd__Resolve;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__Resolve */
        long soap_type() const { return SOAP_TYPE___wsdd__Resolve; }
        /** Constructor with member initializations */
        __wsdd__Resolve() : wsdd__Resolve() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__Resolve * SOAP_FMAC2 soap_instantiate___wsdd__Resolve(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsdx.h:112 */
#ifndef SOAP_TYPE___wsdd__ResolveMatches
#define SOAP_TYPE___wsdd__ResolveMatches (108)
/* Wrapper: */
struct SOAP_CMAC __wsdd__ResolveMatches {
      public:
        /** Optional element 'wsdd:ResolveMatches' of XSD type 'wsdd:ResolveMatchesType' */
        struct wsdd__ResolveMatchesType *wsdd__ResolveMatches;
      public:
        /** Return unique type id SOAP_TYPE___wsdd__ResolveMatches */
        long soap_type() const { return SOAP_TYPE___wsdd__ResolveMatches; }
        /** Constructor with member initializations */
        __wsdd__ResolveMatches() : wsdd__ResolveMatches() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsdd__ResolveMatches * SOAP_FMAC2 soap_instantiate___wsdd__ResolveMatches(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xop.h:58 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (109)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
struct SOAP_CMAC _xop__Include {
      public:
        unsigned char *__ptr;
        int __size;
        /** Optional element 'id' of XSD type 'xsd:string' */
        char *id;
        /** Optional element 'type' of XSD type 'xsd:string' */
        char *type;
        /** Optional element 'options' of XSD type 'xsd:string' */
        char *options;
      public:
        /** Return unique type id SOAP_TYPE__xop__Include */
        long soap_type() const { return SOAP_TYPE__xop__Include; }
        /** Constructor with member initializations */
        _xop__Include() : __ptr(), __size(), id(), type(), options() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:221 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (112)
/* simple XSD type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XSD type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:224 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (114)
/* complex XSD type 'SOAP-ENV:Envelope': */
struct SOAP_CMAC SOAP_ENV__Envelope {
      public:
        /** Optional element 'SOAP-ENV:Header' of XSD type 'SOAP-ENV:Header' */
        struct SOAP_ENV__Header *SOAP_ENV__Header;
        /** Optional element 'SOAP-ENV:Body' of XSD type 'xsd:anyType' */
        char *SOAP_ENV__Body;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Envelope */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Envelope; }
        /** Constructor with member initializations */
        SOAP_ENV__Envelope() : SOAP_ENV__Header(), SOAP_ENV__Body() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:230 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (118)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XSD type 'xsd:string'
        char *id;
        /// Optional element 'type' of XSD type 'xsd:string'
        char *type;
        /// Optional element 'options' of XSD type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:237 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (119)
/* hexBinary XSD type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary); }
      public:
        /// Constructor with initializations
        xsd__hexBinary() : __ptr(), __size() { }
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4579 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1240)
/* complex XSD type 'tds:Service-Capabilities': */
class SOAP_CMAC _tds__Service_Capabilities {
      public:
        /// Return unique type id SOAP_TYPE__tds__Service_Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__Service_Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
        virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__Service_Capabilities); }
      public:
        /// Constructor with initializations
        _tds__Service_Capabilities() { }
        virtual ~_tds__Service_Capabilities() { }
        /// Friend allocator used by soap_new__tds__Service_Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:277 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (129)
/* complex XSD type 'tds:Service': */
class SOAP_CMAC tds__Service {
      public:
        /// Required element 'tds:Namespace' of XSD type 'xsd:anyURI'
        std::string Namespace;
        /// Required element 'tds:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tds:Capabilities' of XSD type 'tds:Service-Capabilities'
        _tds__Service_Capabilities *Capabilities;
        /// Required element 'tds:Version' of XSD type 'tt:OnvifVersion'
        tt__OnvifVersion *Version;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__Service
        virtual long soap_type(void) const { return SOAP_TYPE_tds__Service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__Service, default initialized and not managed by a soap context
        virtual tds__Service *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__Service); }
      public:
        /// Constructor with initializations
        tds__Service() : Namespace(), XAddr(), Capabilities(), Version(), soap() { }
        virtual ~tds__Service() { }
        /// Friend allocator used by soap_new_tds__Service(struct soap*, int)
        friend SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:280 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (130)
/* complex XSD type 'tds:DeviceServiceCapabilities': */
class SOAP_CMAC tds__DeviceServiceCapabilities {
      public:
        /// Required element 'tds:Network' of XSD type 'tds:NetworkCapabilities'
        tds__NetworkCapabilities *Network;
        /// Required element 'tds:Security' of XSD type 'tds:SecurityCapabilities'
        tds__SecurityCapabilities *Security;
        /// Required element 'tds:System' of XSD type 'tds:SystemCapabilities'
        tds__SystemCapabilities *System;
        /// Optional element 'tds:Misc' of XSD type 'tds:MiscCapabilities'
        tds__MiscCapabilities *Misc;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__DeviceServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__DeviceServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
        virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__DeviceServiceCapabilities); }
      public:
        /// Constructor with initializations
        tds__DeviceServiceCapabilities() : Network(), Security(), System(), Misc(), soap() { }
        virtual ~tds__DeviceServiceCapabilities() { }
        /// Friend allocator used by soap_new_tds__DeviceServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:283 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (131)
/* complex XSD type 'tds:NetworkCapabilities': */
class SOAP_CMAC tds__NetworkCapabilities {
      public:
        /// optional attribute 'IPFilter' of XSD type 'xsd:boolean'
        bool *IPFilter;
        /// optional attribute 'ZeroConfiguration' of XSD type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// optional attribute 'IPVersion6' of XSD type 'xsd:boolean'
        bool *IPVersion6;
        /// optional attribute 'DynDNS' of XSD type 'xsd:boolean'
        bool *DynDNS;
        /// optional attribute 'Dot11Configuration' of XSD type 'xsd:boolean'
        bool *Dot11Configuration;
        /// optional attribute 'Dot1XConfigurations' of XSD type 'xsd:int'
        int *Dot1XConfigurations;
        /// optional attribute 'HostnameFromDHCP' of XSD type 'xsd:boolean'
        bool *HostnameFromDHCP;
        /// optional attribute 'NTP' of XSD type 'xsd:int'
        int *NTP;
        /// optional attribute 'DHCPv6' of XSD type 'xsd:boolean'
        bool *DHCPv6;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__NetworkCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
        virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__NetworkCapabilities); }
      public:
        /// Constructor with initializations
        tds__NetworkCapabilities() : IPFilter(), ZeroConfiguration(), IPVersion6(), DynDNS(), Dot11Configuration(), Dot1XConfigurations(), HostnameFromDHCP(), NTP(), DHCPv6(), soap() { }
        virtual ~tds__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_tds__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:286 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (132)
/* complex XSD type 'tds:SecurityCapabilities': */
class SOAP_CMAC tds__SecurityCapabilities {
      public:
        /// optional attribute 'TLS1.0' of XSD type 'xsd:boolean'
        bool *TLS1_x002e0;
        /// optional attribute 'TLS1.1' of XSD type 'xsd:boolean'
        bool *TLS1_x002e1;
        /// optional attribute 'TLS1.2' of XSD type 'xsd:boolean'
        bool *TLS1_x002e2;
        /// optional attribute 'OnboardKeyGeneration' of XSD type 'xsd:boolean'
        bool *OnboardKeyGeneration;
        /// optional attribute 'AccessPolicyConfig' of XSD type 'xsd:boolean'
        bool *AccessPolicyConfig;
        /// optional attribute 'DefaultAccessPolicy' of XSD type 'xsd:boolean'
        bool *DefaultAccessPolicy;
        /// optional attribute 'Dot1X' of XSD type 'xsd:boolean'
        bool *Dot1X;
        /// optional attribute 'RemoteUserHandling' of XSD type 'xsd:boolean'
        bool *RemoteUserHandling;
        /// optional attribute 'X.509Token' of XSD type 'xsd:boolean'
        bool *X_x002e509Token;
        /// optional attribute 'SAMLToken' of XSD type 'xsd:boolean'
        bool *SAMLToken;
        /// optional attribute 'KerberosToken' of XSD type 'xsd:boolean'
        bool *KerberosToken;
        /// optional attribute 'UsernameToken' of XSD type 'xsd:boolean'
        bool *UsernameToken;
        /// optional attribute 'HttpDigest' of XSD type 'xsd:boolean'
        bool *HttpDigest;
        /// optional attribute 'RELToken' of XSD type 'xsd:boolean'
        bool *RELToken;
        /// optional attribute 'SupportedEAPMethods' of XSD type 'tds:EAPMethodTypes'
        std::string *SupportedEAPMethods;
        /// optional attribute 'MaxUsers' of XSD type 'xsd:int'
        int *MaxUsers;
        /// optional attribute 'MaxUserNameLength' of XSD type 'xsd:int'
        int *MaxUserNameLength;
        /// optional attribute 'MaxPasswordLength' of XSD type 'xsd:int'
        int *MaxPasswordLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__SecurityCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
        virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__SecurityCapabilities); }
      public:
        /// Constructor with initializations
        tds__SecurityCapabilities() : TLS1_x002e0(), TLS1_x002e1(), TLS1_x002e2(), OnboardKeyGeneration(), AccessPolicyConfig(), DefaultAccessPolicy(), Dot1X(), RemoteUserHandling(), X_x002e509Token(), SAMLToken(), KerberosToken(), UsernameToken(), HttpDigest(), RELToken(), SupportedEAPMethods(), MaxUsers(), MaxUserNameLength(), MaxPasswordLength(), soap() { }
        virtual ~tds__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_tds__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:289 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (133)
/* complex XSD type 'tds:SystemCapabilities': */
class SOAP_CMAC tds__SystemCapabilities {
      public:
        /// optional attribute 'DiscoveryResolve' of XSD type 'xsd:boolean'
        bool *DiscoveryResolve;
        /// optional attribute 'DiscoveryBye' of XSD type 'xsd:boolean'
        bool *DiscoveryBye;
        /// optional attribute 'RemoteDiscovery' of XSD type 'xsd:boolean'
        bool *RemoteDiscovery;
        /// optional attribute 'SystemBackup' of XSD type 'xsd:boolean'
        bool *SystemBackup;
        /// optional attribute 'SystemLogging' of XSD type 'xsd:boolean'
        bool *SystemLogging;
        /// optional attribute 'FirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *FirmwareUpgrade;
        /// optional attribute 'HttpFirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// optional attribute 'HttpSystemBackup' of XSD type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// optional attribute 'HttpSystemLogging' of XSD type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// optional attribute 'HttpSupportInformation' of XSD type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// optional attribute 'StorageConfiguration' of XSD type 'xsd:boolean'
        bool *StorageConfiguration;
        /// optional attribute 'MaxStorageConfigurations' of XSD type 'xsd:int'
        int *MaxStorageConfigurations;
        /// optional attribute 'GeoLocationEntries' of XSD type 'xsd:int'
        int *GeoLocationEntries;
        /// optional attribute 'AutoGeo' of XSD type 'tt:StringAttrList'
        std::string *AutoGeo;
        /// optional attribute 'StorageTypesSupported' of XSD type 'tt:StringAttrList'
        std::string *StorageTypesSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__SystemCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
        virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__SystemCapabilities); }
      public:
        /// Constructor with initializations
        tds__SystemCapabilities() : DiscoveryResolve(), DiscoveryBye(), RemoteDiscovery(), SystemBackup(), SystemLogging(), FirmwareUpgrade(), HttpFirmwareUpgrade(), HttpSystemBackup(), HttpSystemLogging(), HttpSupportInformation(), StorageConfiguration(), MaxStorageConfigurations(), GeoLocationEntries(), AutoGeo(), StorageTypesSupported(), soap() { }
        virtual ~tds__SystemCapabilities() { }
        /// Friend allocator used by soap_new_tds__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:292 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (134)
/* complex XSD type 'tds:MiscCapabilities': */
class SOAP_CMAC tds__MiscCapabilities {
      public:
        /// optional attribute 'AuxiliaryCommands' of XSD type 'tt:StringAttrList'
        std::string *AuxiliaryCommands;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__MiscCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__MiscCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
        virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__MiscCapabilities); }
      public:
        /// Constructor with initializations
        tds__MiscCapabilities() : AuxiliaryCommands(), soap() { }
        virtual ~tds__MiscCapabilities() { }
        /// Friend allocator used by soap_new_tds__MiscCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4981 */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1252)
/* complex XSD type 'tds:UserCredential-Extension': */
class SOAP_CMAC _tds__UserCredential_Extension {
      public:
        /// Return unique type id SOAP_TYPE__tds__UserCredential_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UserCredential_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UserCredential_Extension, default initialized and not managed by a soap context
        virtual _tds__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UserCredential_Extension); }
      public:
        /// Constructor with initializations
        _tds__UserCredential_Extension() { }
        virtual ~_tds__UserCredential_Extension() { }
        /// Friend allocator used by soap_new__tds__UserCredential_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__tds__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:295 */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (135)
/* complex XSD type 'tds:UserCredential': */
class SOAP_CMAC tds__UserCredential {
      public:
        /// Required element 'tds:UserName' of XSD type 'xsd:string'
        std::string UserName;
        /// Optional element 'tds:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'tds:Extension' of XSD type 'tds:UserCredential-Extension'
        _tds__UserCredential_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__UserCredential
        virtual long soap_type(void) const { return SOAP_TYPE_tds__UserCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__UserCredential, default initialized and not managed by a soap context
        virtual tds__UserCredential *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__UserCredential); }
      public:
        /// Constructor with initializations
        tds__UserCredential() : UserName(), Password(), Extension(), soap() { }
        virtual ~tds__UserCredential() { }
        /// Friend allocator used by soap_new_tds__UserCredential(struct soap*, int)
        friend SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:5032 */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1256)
/* complex XSD type 'tds:StorageConfigurationData-Extension': */
class SOAP_CMAC _tds__StorageConfigurationData_Extension {
      public:
        /// Return unique type id SOAP_TYPE__tds__StorageConfigurationData_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StorageConfigurationData_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StorageConfigurationData_Extension, default initialized and not managed by a soap context
        virtual _tds__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StorageConfigurationData_Extension); }
      public:
        /// Constructor with initializations
        _tds__StorageConfigurationData_Extension() { }
        virtual ~_tds__StorageConfigurationData_Extension() { }
        /// Friend allocator used by soap_new__tds__StorageConfigurationData_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__tds__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:298 */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (136)
/* complex XSD type 'tds:StorageConfigurationData': */
class SOAP_CMAC tds__StorageConfigurationData {
      public:
        /// Optional element 'tds:LocalPath' of XSD type 'xsd:anyURI'
        std::string *LocalPath;
        /// Optional element 'tds:StorageUri' of XSD type 'xsd:anyURI'
        std::string *StorageUri;
        /// Optional element 'tds:User' of XSD type 'tds:UserCredential'
        tds__UserCredential *User;
        /// Optional element 'tds:Extension' of XSD type 'tds:StorageConfigurationData-Extension'
        _tds__StorageConfigurationData_Extension *Extension;
        /// required attribute 'type' of XSD type 'xsd:string'
        std::string type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tds__StorageConfigurationData
        virtual long soap_type(void) const { return SOAP_TYPE_tds__StorageConfigurationData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__StorageConfigurationData, default initialized and not managed by a soap context
        virtual tds__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__StorageConfigurationData); }
      public:
        /// Constructor with initializations
        tds__StorageConfigurationData() : LocalPath(), StorageUri(), User(), Extension(), type(), soap() { }
        virtual ~tds__StorageConfigurationData() { }
        /// Friend allocator used by soap_new_tds__StorageConfigurationData(struct soap*, int)
        friend SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:304 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (138)
/* complex XSD type 'tds:GetServices': */
class SOAP_CMAC _tds__GetServices {
      public:
        /// Required element 'tds:IncludeCapability' of XSD type 'xsd:boolean'
        bool IncludeCapability;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServices
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
        virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServices); }
      public:
        /// Constructor with initializations
        _tds__GetServices() : IncludeCapability(), soap() { }
        virtual ~_tds__GetServices() { }
        /// Friend allocator used by soap_new__tds__GetServices(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:307 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (139)
/* complex XSD type 'tds:GetServicesResponse': */
class SOAP_CMAC _tds__GetServicesResponse {
      public:
        /// Required element 'tds:Service' of XSD type 'tds:Service'
        std::vector<tds__Service *> Service;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServicesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServicesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
        virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServicesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetServicesResponse() : Service(), soap() { }
        virtual ~_tds__GetServicesResponse() { }
        /// Friend allocator used by soap_new__tds__GetServicesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:310 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (140)
/* complex XSD type 'tds:GetServiceCapabilities': */
class SOAP_CMAC _tds__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _tds__GetServiceCapabilities() : soap() { }
        virtual ~_tds__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tds__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:313 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (141)
/* complex XSD type 'tds:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XSD type 'tds:DeviceServiceCapabilities'
        tds__DeviceServiceCapabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tds__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:316 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (142)
/* complex XSD type 'tds:GetDeviceInformation': */
class SOAP_CMAC _tds__GetDeviceInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDeviceInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDeviceInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
        virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDeviceInformation); }
      public:
        /// Constructor with initializations
        _tds__GetDeviceInformation() : soap() { }
        virtual ~_tds__GetDeviceInformation() { }
        /// Friend allocator used by soap_new__tds__GetDeviceInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:319 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (143)
/* complex XSD type 'tds:GetDeviceInformationResponse': */
class SOAP_CMAC _tds__GetDeviceInformationResponse {
      public:
        /// Required element 'tds:Manufacturer' of XSD type 'xsd:string'
        std::string Manufacturer;
        /// Required element 'tds:Model' of XSD type 'xsd:string'
        std::string Model;
        /// Required element 'tds:FirmwareVersion' of XSD type 'xsd:string'
        std::string FirmwareVersion;
        /// Required element 'tds:SerialNumber' of XSD type 'xsd:string'
        std::string SerialNumber;
        /// Required element 'tds:HardwareId' of XSD type 'xsd:string'
        std::string HardwareId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDeviceInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDeviceInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDeviceInformationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDeviceInformationResponse() : Manufacturer(), Model(), FirmwareVersion(), SerialNumber(), HardwareId(), soap() { }
        virtual ~_tds__GetDeviceInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetDeviceInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:322 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (144)
/* complex XSD type 'tds:SetSystemDateAndTime': */
class SOAP_CMAC _tds__SetSystemDateAndTime {
      public:
        /// Required element 'tds:DateTimeType' of XSD type 'tt:SetDateTimeType'
        enum tt__SetDateTimeType DateTimeType;
        /// Required element 'tds:DaylightSavings' of XSD type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'tds:TimeZone' of XSD type 'tt:TimeZone'
        tt__TimeZone *TimeZone;
        /// Optional element 'tds:UTCDateTime' of XSD type 'tt:DateTime'
        tt__DateTime *UTCDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemDateAndTime
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemDateAndTime); }
      public:
        /// Constructor with initializations
        _tds__SetSystemDateAndTime() : DateTimeType(), DaylightSavings(), TimeZone(), UTCDateTime(), soap() { }
        virtual ~_tds__SetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__tds__SetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:325 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (145)
/* complex XSD type 'tds:SetSystemDateAndTimeResponse': */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemDateAndTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemDateAndTimeResponse); }
      public:
        /// Constructor with initializations
        _tds__SetSystemDateAndTimeResponse() : soap() { }
        virtual ~_tds__SetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__tds__SetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:328 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (146)
/* complex XSD type 'tds:GetSystemDateAndTime': */
class SOAP_CMAC _tds__GetSystemDateAndTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemDateAndTime
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemDateAndTime); }
      public:
        /// Constructor with initializations
        _tds__GetSystemDateAndTime() : soap() { }
        virtual ~_tds__GetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__tds__GetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:331 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (147)
/* complex XSD type 'tds:GetSystemDateAndTimeResponse': */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse {
      public:
        /// Required element 'tds:SystemDateAndTime' of XSD type 'tt:SystemDateTime'
        tt__SystemDateTime *SystemDateAndTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemDateAndTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemDateAndTimeResponse); }
      public:
        /// Constructor with initializations
        _tds__GetSystemDateAndTimeResponse() : SystemDateAndTime(), soap() { }
        virtual ~_tds__GetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:334 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (148)
/* complex XSD type 'tds:SetSystemFactoryDefault': */
class SOAP_CMAC _tds__SetSystemFactoryDefault {
      public:
        /// Required element 'tds:FactoryDefault' of XSD type 'tt:FactoryDefaultType'
        enum tt__FactoryDefaultType FactoryDefault;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemFactoryDefault
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemFactoryDefault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
        virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemFactoryDefault); }
      public:
        /// Constructor with initializations
        _tds__SetSystemFactoryDefault() : FactoryDefault(), soap() { }
        virtual ~_tds__SetSystemFactoryDefault() { }
        /// Friend allocator used by soap_new__tds__SetSystemFactoryDefault(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:337 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (149)
/* complex XSD type 'tds:SetSystemFactoryDefaultResponse': */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemFactoryDefaultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
        virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemFactoryDefaultResponse); }
      public:
        /// Constructor with initializations
        _tds__SetSystemFactoryDefaultResponse() : soap() { }
        virtual ~_tds__SetSystemFactoryDefaultResponse() { }
        /// Friend allocator used by soap_new__tds__SetSystemFactoryDefaultResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:340 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (150)
/* complex XSD type 'tds:UpgradeSystemFirmware': */
class SOAP_CMAC _tds__UpgradeSystemFirmware {
      public:
        /// Required element 'tds:Firmware' of XSD type 'tt:AttachmentData'
        tt__AttachmentData *Firmware;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__UpgradeSystemFirmware
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UpgradeSystemFirmware; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
        virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UpgradeSystemFirmware); }
      public:
        /// Constructor with initializations
        _tds__UpgradeSystemFirmware() : Firmware(), soap() { }
        virtual ~_tds__UpgradeSystemFirmware() { }
        /// Friend allocator used by soap_new__tds__UpgradeSystemFirmware(struct soap*, int)
        friend SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:343 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (151)
/* complex XSD type 'tds:UpgradeSystemFirmwareResponse': */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse {
      public:
        /// Optional element 'tds:Message' of XSD type 'xsd:string'
        std::string *Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UpgradeSystemFirmwareResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
        virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UpgradeSystemFirmwareResponse); }
      public:
        /// Constructor with initializations
        _tds__UpgradeSystemFirmwareResponse() : Message(), soap() { }
        virtual ~_tds__UpgradeSystemFirmwareResponse() { }
        /// Friend allocator used by soap_new__tds__UpgradeSystemFirmwareResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:346 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (152)
/* complex XSD type 'tds:SystemReboot': */
class SOAP_CMAC _tds__SystemReboot {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SystemReboot
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SystemReboot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
        virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SystemReboot); }
      public:
        /// Constructor with initializations
        _tds__SystemReboot() : soap() { }
        virtual ~_tds__SystemReboot() { }
        /// Friend allocator used by soap_new__tds__SystemReboot(struct soap*, int)
        friend SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:349 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (153)
/* complex XSD type 'tds:SystemRebootResponse': */
class SOAP_CMAC _tds__SystemRebootResponse {
      public:
        /// Required element 'tds:Message' of XSD type 'xsd:string'
        std::string Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SystemRebootResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SystemRebootResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
        virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SystemRebootResponse); }
      public:
        /// Constructor with initializations
        _tds__SystemRebootResponse() : Message(), soap() { }
        virtual ~_tds__SystemRebootResponse() { }
        /// Friend allocator used by soap_new__tds__SystemRebootResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:352 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (154)
/* complex XSD type 'tds:RestoreSystem': */
class SOAP_CMAC _tds__RestoreSystem {
      public:
        /// Required element 'tds:BackupFiles' of XSD type 'tt:BackupFile'
        std::vector<tt__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RestoreSystem
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RestoreSystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
        virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RestoreSystem); }
      public:
        /// Constructor with initializations
        _tds__RestoreSystem() : BackupFiles(), soap() { }
        virtual ~_tds__RestoreSystem() { }
        /// Friend allocator used by soap_new__tds__RestoreSystem(struct soap*, int)
        friend SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:355 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (155)
/* complex XSD type 'tds:RestoreSystemResponse': */
class SOAP_CMAC _tds__RestoreSystemResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RestoreSystemResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RestoreSystemResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
        virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RestoreSystemResponse); }
      public:
        /// Constructor with initializations
        _tds__RestoreSystemResponse() : soap() { }
        virtual ~_tds__RestoreSystemResponse() { }
        /// Friend allocator used by soap_new__tds__RestoreSystemResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:358 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (156)
/* complex XSD type 'tds:GetSystemBackup': */
class SOAP_CMAC _tds__GetSystemBackup {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemBackup
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemBackup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
        virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemBackup); }
      public:
        /// Constructor with initializations
        _tds__GetSystemBackup() : soap() { }
        virtual ~_tds__GetSystemBackup() { }
        /// Friend allocator used by soap_new__tds__GetSystemBackup(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:361 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (157)
/* complex XSD type 'tds:GetSystemBackupResponse': */
class SOAP_CMAC _tds__GetSystemBackupResponse {
      public:
        /// Required element 'tds:BackupFiles' of XSD type 'tt:BackupFile'
        std::vector<tt__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemBackupResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemBackupResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemBackupResponse); }
      public:
        /// Constructor with initializations
        _tds__GetSystemBackupResponse() : BackupFiles(), soap() { }
        virtual ~_tds__GetSystemBackupResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemBackupResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:364 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (158)
/* complex XSD type 'tds:GetSystemSupportInformation': */
class SOAP_CMAC _tds__GetSystemSupportInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemSupportInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemSupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
        virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemSupportInformation); }
      public:
        /// Constructor with initializations
        _tds__GetSystemSupportInformation() : soap() { }
        virtual ~_tds__GetSystemSupportInformation() { }
        /// Friend allocator used by soap_new__tds__GetSystemSupportInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:367 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (159)
/* complex XSD type 'tds:GetSystemSupportInformationResponse': */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse {
      public:
        /// Required element 'tds:SupportInformation' of XSD type 'tt:SupportInformation'
        tt__SupportInformation *SupportInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemSupportInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemSupportInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemSupportInformationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetSystemSupportInformationResponse() : SupportInformation(), soap() { }
        virtual ~_tds__GetSystemSupportInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemSupportInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:370 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (160)
/* complex XSD type 'tds:GetSystemLog': */
class SOAP_CMAC _tds__GetSystemLog {
      public:
        /// Required element 'tds:LogType' of XSD type 'tt:SystemLogType'
        enum tt__SystemLogType LogType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemLog
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
        virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemLog); }
      public:
        /// Constructor with initializations
        _tds__GetSystemLog() : LogType(), soap() { }
        virtual ~_tds__GetSystemLog() { }
        /// Friend allocator used by soap_new__tds__GetSystemLog(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:373 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (161)
/* complex XSD type 'tds:GetSystemLogResponse': */
class SOAP_CMAC _tds__GetSystemLogResponse {
      public:
        /// Required element 'tds:SystemLog' of XSD type 'tt:SystemLog'
        tt__SystemLog *SystemLog;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemLogResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemLogResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemLogResponse); }
      public:
        /// Constructor with initializations
        _tds__GetSystemLogResponse() : SystemLog(), soap() { }
        virtual ~_tds__GetSystemLogResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemLogResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:376 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (162)
/* complex XSD type 'tds:GetScopes': */
class SOAP_CMAC _tds__GetScopes {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
        virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetScopes); }
      public:
        /// Constructor with initializations
        _tds__GetScopes() : soap() { }
        virtual ~_tds__GetScopes() { }
        /// Friend allocator used by soap_new__tds__GetScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:379 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (163)
/* complex XSD type 'tds:GetScopesResponse': */
class SOAP_CMAC _tds__GetScopesResponse {
      public:
        /// Required element 'tds:Scopes' of XSD type 'tt:Scope'
        std::vector<tt__Scope *> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
        virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetScopesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetScopesResponse() : Scopes(), soap() { }
        virtual ~_tds__GetScopesResponse() { }
        /// Friend allocator used by soap_new__tds__GetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:382 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (164)
/* complex XSD type 'tds:SetScopes': */
class SOAP_CMAC _tds__SetScopes {
      public:
        /// Required element 'tds:Scopes' of XSD type 'xsd:anyURI'
        std::vector<std::string> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
        virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetScopes); }
      public:
        /// Constructor with initializations
        _tds__SetScopes() : Scopes(), soap() { }
        virtual ~_tds__SetScopes() { }
        /// Friend allocator used by soap_new__tds__SetScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:385 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (165)
/* complex XSD type 'tds:SetScopesResponse': */
class SOAP_CMAC _tds__SetScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
        virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetScopesResponse); }
      public:
        /// Constructor with initializations
        _tds__SetScopesResponse() : soap() { }
        virtual ~_tds__SetScopesResponse() { }
        /// Friend allocator used by soap_new__tds__SetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:388 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (166)
/* complex XSD type 'tds:AddScopes': */
class SOAP_CMAC _tds__AddScopes {
      public:
        /// Required element 'tds:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
        virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddScopes); }
      public:
        /// Constructor with initializations
        _tds__AddScopes() : ScopeItem(), soap() { }
        virtual ~_tds__AddScopes() { }
        /// Friend allocator used by soap_new__tds__AddScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:391 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (167)
/* complex XSD type 'tds:AddScopesResponse': */
class SOAP_CMAC _tds__AddScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
        virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddScopesResponse); }
      public:
        /// Constructor with initializations
        _tds__AddScopesResponse() : soap() { }
        virtual ~_tds__AddScopesResponse() { }
        /// Friend allocator used by soap_new__tds__AddScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:394 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (168)
/* complex XSD type 'tds:RemoveScopes': */
class SOAP_CMAC _tds__RemoveScopes {
      public:
        /// Required element 'tds:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
        virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveScopes); }
      public:
        /// Constructor with initializations
        _tds__RemoveScopes() : ScopeItem(), soap() { }
        virtual ~_tds__RemoveScopes() { }
        /// Friend allocator used by soap_new__tds__RemoveScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:397 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (169)
/* complex XSD type 'tds:RemoveScopesResponse': */
class SOAP_CMAC _tds__RemoveScopesResponse {
      public:
        /// Optional element 'tds:ScopeItem' of XSD type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
        virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveScopesResponse); }
      public:
        /// Constructor with initializations
        _tds__RemoveScopesResponse() : ScopeItem(), soap() { }
        virtual ~_tds__RemoveScopesResponse() { }
        /// Friend allocator used by soap_new__tds__RemoveScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:400 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (170)
/* complex XSD type 'tds:GetDiscoveryMode': */
class SOAP_CMAC _tds__GetDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDiscoveryMode); }
      public:
        /// Constructor with initializations
        _tds__GetDiscoveryMode() : soap() { }
        virtual ~_tds__GetDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__GetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:403 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (171)
/* complex XSD type 'tds:GetDiscoveryModeResponse': */
class SOAP_CMAC _tds__GetDiscoveryModeResponse {
      public:
        /// Required element 'tds:DiscoveryMode' of XSD type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDiscoveryModeResponse() : DiscoveryMode(), soap() { }
        virtual ~_tds__GetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:406 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (172)
/* complex XSD type 'tds:SetDiscoveryMode': */
class SOAP_CMAC _tds__SetDiscoveryMode {
      public:
        /// Required element 'tds:DiscoveryMode' of XSD type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDiscoveryMode); }
      public:
        /// Constructor with initializations
        _tds__SetDiscoveryMode() : DiscoveryMode(), soap() { }
        virtual ~_tds__SetDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__SetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:409 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (173)
/* complex XSD type 'tds:SetDiscoveryModeResponse': */
class SOAP_CMAC _tds__SetDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _tds__SetDiscoveryModeResponse() : soap() { }
        virtual ~_tds__SetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:412 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (174)
/* complex XSD type 'tds:GetRemoteDiscoveryMode': */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteDiscoveryMode); }
      public:
        /// Constructor with initializations
        _tds__GetRemoteDiscoveryMode() : soap() { }
        virtual ~_tds__GetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__GetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:415 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (175)
/* complex XSD type 'tds:GetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse {
      public:
        /// Required element 'tds:RemoteDiscoveryMode' of XSD type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _tds__GetRemoteDiscoveryModeResponse() : RemoteDiscoveryMode(), soap() { }
        virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:418 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (176)
/* complex XSD type 'tds:SetRemoteDiscoveryMode': */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode {
      public:
        /// Required element 'tds:RemoteDiscoveryMode' of XSD type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteDiscoveryMode); }
      public:
        /// Constructor with initializations
        _tds__SetRemoteDiscoveryMode() : RemoteDiscoveryMode(), soap() { }
        virtual ~_tds__SetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__SetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:421 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (177)
/* complex XSD type 'tds:SetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with initializations
        _tds__SetRemoteDiscoveryModeResponse() : soap() { }
        virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:424 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (178)
/* complex XSD type 'tds:GetDPAddresses': */
class SOAP_CMAC _tds__GetDPAddresses {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDPAddresses
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
        virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDPAddresses); }
      public:
        /// Constructor with initializations
        _tds__GetDPAddresses() : soap() { }
        virtual ~_tds__GetDPAddresses() { }
        /// Friend allocator used by soap_new__tds__GetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:427 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (179)
/* complex XSD type 'tds:GetDPAddressesResponse': */
class SOAP_CMAC _tds__GetDPAddressesResponse {
      public:
        /// Optional element 'tds:DPAddress' of XSD type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDPAddressesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDPAddressesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDPAddressesResponse() : DPAddress(), soap() { }
        virtual ~_tds__GetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__tds__GetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:430 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (180)
/* complex XSD type 'tds:SetDPAddresses': */
class SOAP_CMAC _tds__SetDPAddresses {
      public:
        /// Optional element 'tds:DPAddress' of XSD type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDPAddresses
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
        virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDPAddresses); }
      public:
        /// Constructor with initializations
        _tds__SetDPAddresses() : DPAddress(), soap() { }
        virtual ~_tds__SetDPAddresses() { }
        /// Friend allocator used by soap_new__tds__SetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:433 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (181)
/* complex XSD type 'tds:SetDPAddressesResponse': */
class SOAP_CMAC _tds__SetDPAddressesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDPAddressesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDPAddressesResponse); }
      public:
        /// Constructor with initializations
        _tds__SetDPAddressesResponse() : soap() { }
        virtual ~_tds__SetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__tds__SetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:436 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (182)
/* complex XSD type 'tds:GetEndpointReference': */
class SOAP_CMAC _tds__GetEndpointReference {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetEndpointReference
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetEndpointReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
        virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetEndpointReference); }
      public:
        /// Constructor with initializations
        _tds__GetEndpointReference() : soap() { }
        virtual ~_tds__GetEndpointReference() { }
        /// Friend allocator used by soap_new__tds__GetEndpointReference(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:439 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (183)
/* complex XSD type 'tds:GetEndpointReferenceResponse': */
class SOAP_CMAC _tds__GetEndpointReferenceResponse {
      public:
        /// Required element 'tds:GUID' of XSD type 'xsd:string'
        std::string GUID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetEndpointReferenceResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetEndpointReferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
        virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetEndpointReferenceResponse); }
      public:
        /// Constructor with initializations
        _tds__GetEndpointReferenceResponse() : GUID(), soap() { }
        virtual ~_tds__GetEndpointReferenceResponse() { }
        /// Friend allocator used by soap_new__tds__GetEndpointReferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:442 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (184)
/* complex XSD type 'tds:GetRemoteUser': */
class SOAP_CMAC _tds__GetRemoteUser {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
        virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteUser); }
      public:
        /// Constructor with initializations
        _tds__GetRemoteUser() : soap() { }
        virtual ~_tds__GetRemoteUser() { }
        /// Friend allocator used by soap_new__tds__GetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:445 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (185)
/* complex XSD type 'tds:GetRemoteUserResponse': */
class SOAP_CMAC _tds__GetRemoteUserResponse {
      public:
        /// Optional element 'tds:RemoteUser' of XSD type 'tt:RemoteUser'
        tt__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteUserResponse); }
      public:
        /// Constructor with initializations
        _tds__GetRemoteUserResponse() : RemoteUser(), soap() { }
        virtual ~_tds__GetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__tds__GetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:448 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (186)
/* complex XSD type 'tds:SetRemoteUser': */
class SOAP_CMAC _tds__SetRemoteUser {
      public:
        /// Optional element 'tds:RemoteUser' of XSD type 'tt:RemoteUser'
        tt__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
        virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteUser); }
      public:
        /// Constructor with initializations
        _tds__SetRemoteUser() : RemoteUser(), soap() { }
        virtual ~_tds__SetRemoteUser() { }
        /// Friend allocator used by soap_new__tds__SetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:451 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (187)
/* complex XSD type 'tds:SetRemoteUserResponse': */
class SOAP_CMAC _tds__SetRemoteUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteUserResponse); }
      public:
        /// Constructor with initializations
        _tds__SetRemoteUserResponse() : soap() { }
        virtual ~_tds__SetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__tds__SetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:454 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (188)
/* complex XSD type 'tds:GetUsers': */
class SOAP_CMAC _tds__GetUsers {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
        virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetUsers); }
      public:
        /// Constructor with initializations
        _tds__GetUsers() : soap() { }
        virtual ~_tds__GetUsers() { }
        /// Friend allocator used by soap_new__tds__GetUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:457 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (189)
/* complex XSD type 'tds:GetUsersResponse': */
class SOAP_CMAC _tds__GetUsersResponse {
      public:
        /// Optional element 'tds:User' of XSD type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
        virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetUsersResponse); }
      public:
        /// Constructor with initializations
        _tds__GetUsersResponse() : User(), soap() { }
        virtual ~_tds__GetUsersResponse() { }
        /// Friend allocator used by soap_new__tds__GetUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:460 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (190)
/* complex XSD type 'tds:CreateUsers': */
class SOAP_CMAC _tds__CreateUsers {
      public:
        /// Required element 'tds:User' of XSD type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
        virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateUsers); }
      public:
        /// Constructor with initializations
        _tds__CreateUsers() : User(), soap() { }
        virtual ~_tds__CreateUsers() { }
        /// Friend allocator used by soap_new__tds__CreateUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:463 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (191)
/* complex XSD type 'tds:CreateUsersResponse': */
class SOAP_CMAC _tds__CreateUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
        virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateUsersResponse); }
      public:
        /// Constructor with initializations
        _tds__CreateUsersResponse() : soap() { }
        virtual ~_tds__CreateUsersResponse() { }
        /// Friend allocator used by soap_new__tds__CreateUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:466 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (192)
/* complex XSD type 'tds:DeleteUsers': */
class SOAP_CMAC _tds__DeleteUsers {
      public:
        /// Required element 'tds:Username' of XSD type 'xsd:string'
        std::vector<std::string> Username;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
        virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteUsers); }
      public:
        /// Constructor with initializations
        _tds__DeleteUsers() : Username(), soap() { }
        virtual ~_tds__DeleteUsers() { }
        /// Friend allocator used by soap_new__tds__DeleteUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:469 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (193)
/* complex XSD type 'tds:DeleteUsersResponse': */
class SOAP_CMAC _tds__DeleteUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteUsersResponse); }
      public:
        /// Constructor with initializations
        _tds__DeleteUsersResponse() : soap() { }
        virtual ~_tds__DeleteUsersResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:472 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (194)
/* complex XSD type 'tds:SetUser': */
class SOAP_CMAC _tds__SetUser {
      public:
        /// Required element 'tds:User' of XSD type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
        virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetUser); }
      public:
        /// Constructor with initializations
        _tds__SetUser() : User(), soap() { }
        virtual ~_tds__SetUser() { }
        /// Friend allocator used by soap_new__tds__SetUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:475 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (195)
/* complex XSD type 'tds:SetUserResponse': */
class SOAP_CMAC _tds__SetUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
        virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetUserResponse); }
      public:
        /// Constructor with initializations
        _tds__SetUserResponse() : soap() { }
        virtual ~_tds__SetUserResponse() { }
        /// Friend allocator used by soap_new__tds__SetUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:478 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (196)
/* complex XSD type 'tds:GetWsdlUrl': */
class SOAP_CMAC _tds__GetWsdlUrl {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetWsdlUrl
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetWsdlUrl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
        virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetWsdlUrl); }
      public:
        /// Constructor with initializations
        _tds__GetWsdlUrl() : soap() { }
        virtual ~_tds__GetWsdlUrl() { }
        /// Friend allocator used by soap_new__tds__GetWsdlUrl(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:481 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (197)
/* complex XSD type 'tds:GetWsdlUrlResponse': */
class SOAP_CMAC _tds__GetWsdlUrlResponse {
      public:
        /// Required element 'tds:WsdlUrl' of XSD type 'xsd:anyURI'
        std::string WsdlUrl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetWsdlUrlResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetWsdlUrlResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
        virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetWsdlUrlResponse); }
      public:
        /// Constructor with initializations
        _tds__GetWsdlUrlResponse() : WsdlUrl(), soap() { }
        virtual ~_tds__GetWsdlUrlResponse() { }
        /// Friend allocator used by soap_new__tds__GetWsdlUrlResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:484 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (198)
/* complex XSD type 'tds:GetCapabilities': */
class SOAP_CMAC _tds__GetCapabilities {
      public:
        /// Optional element 'tds:Category' of XSD type 'tt:CapabilityCategory'
        std::vector<enum tt__CapabilityCategory> Category;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
        virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCapabilities); }
      public:
        /// Constructor with initializations
        _tds__GetCapabilities() : Category(), soap() { }
        virtual ~_tds__GetCapabilities() { }
        /// Friend allocator used by soap_new__tds__GetCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:487 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (199)
/* complex XSD type 'tds:GetCapabilitiesResponse': */
class SOAP_CMAC _tds__GetCapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XSD type 'tt:Capabilities'
        tt__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tds__GetCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:490 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (200)
/* complex XSD type 'tds:GetHostname': */
class SOAP_CMAC _tds__GetHostname {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetHostname
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
        virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetHostname); }
      public:
        /// Constructor with initializations
        _tds__GetHostname() : soap() { }
        virtual ~_tds__GetHostname() { }
        /// Friend allocator used by soap_new__tds__GetHostname(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:493 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (201)
/* complex XSD type 'tds:GetHostnameResponse': */
class SOAP_CMAC _tds__GetHostnameResponse {
      public:
        /// Required element 'tds:HostnameInformation' of XSD type 'tt:HostnameInformation'
        tt__HostnameInformation *HostnameInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetHostnameResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
        virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetHostnameResponse); }
      public:
        /// Constructor with initializations
        _tds__GetHostnameResponse() : HostnameInformation(), soap() { }
        virtual ~_tds__GetHostnameResponse() { }
        /// Friend allocator used by soap_new__tds__GetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:496 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (202)
/* complex XSD type 'tds:SetHostname': */
class SOAP_CMAC _tds__SetHostname {
      public:
        /// Required element 'tds:Name' of XSD type 'xsd:token'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostname
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
        virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostname); }
      public:
        /// Constructor with initializations
        _tds__SetHostname() : Name(), soap() { }
        virtual ~_tds__SetHostname() { }
        /// Friend allocator used by soap_new__tds__SetHostname(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:499 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (203)
/* complex XSD type 'tds:SetHostnameResponse': */
class SOAP_CMAC _tds__SetHostnameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
        virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameResponse); }
      public:
        /// Constructor with initializations
        _tds__SetHostnameResponse() : soap() { }
        virtual ~_tds__SetHostnameResponse() { }
        /// Friend allocator used by soap_new__tds__SetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:502 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (204)
/* complex XSD type 'tds:SetHostnameFromDHCP': */
class SOAP_CMAC _tds__SetHostnameFromDHCP {
      public:
        /// Required element 'tds:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameFromDHCP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameFromDHCP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
        virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameFromDHCP); }
      public:
        /// Constructor with initializations
        _tds__SetHostnameFromDHCP() : FromDHCP(), soap() { }
        virtual ~_tds__SetHostnameFromDHCP() { }
        /// Friend allocator used by soap_new__tds__SetHostnameFromDHCP(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:505 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (205)
/* complex XSD type 'tds:SetHostnameFromDHCPResponse': */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse {
      public:
        /// Required element 'tds:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameFromDHCPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameFromDHCPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
        virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameFromDHCPResponse); }
      public:
        /// Constructor with initializations
        _tds__SetHostnameFromDHCPResponse() : RebootNeeded(), soap() { }
        virtual ~_tds__SetHostnameFromDHCPResponse() { }
        /// Friend allocator used by soap_new__tds__SetHostnameFromDHCPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:508 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (206)
/* complex XSD type 'tds:GetDNS': */
class SOAP_CMAC _tds__GetDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
        virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDNS); }
      public:
        /// Constructor with initializations
        _tds__GetDNS() : soap() { }
        virtual ~_tds__GetDNS() { }
        /// Friend allocator used by soap_new__tds__GetDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:511 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (207)
/* complex XSD type 'tds:GetDNSResponse': */
class SOAP_CMAC _tds__GetDNSResponse {
      public:
        /// Required element 'tds:DNSInformation' of XSD type 'tt:DNSInformation'
        tt__DNSInformation *DNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
        virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDNSResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDNSResponse() : DNSInformation(), soap() { }
        virtual ~_tds__GetDNSResponse() { }
        /// Friend allocator used by soap_new__tds__GetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:514 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (208)
/* complex XSD type 'tds:SetDNS': */
class SOAP_CMAC _tds__SetDNS {
      public:
        /// Required element 'tds:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tds:SearchDomain' of XSD type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'tds:DNSManual' of XSD type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
        virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDNS); }
      public:
        /// Constructor with initializations
        _tds__SetDNS() : FromDHCP(), SearchDomain(), DNSManual(), soap() { }
        virtual ~_tds__SetDNS() { }
        /// Friend allocator used by soap_new__tds__SetDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:517 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (209)
/* complex XSD type 'tds:SetDNSResponse': */
class SOAP_CMAC _tds__SetDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
        virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDNSResponse); }
      public:
        /// Constructor with initializations
        _tds__SetDNSResponse() : soap() { }
        virtual ~_tds__SetDNSResponse() { }
        /// Friend allocator used by soap_new__tds__SetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:520 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (210)
/* complex XSD type 'tds:GetNTP': */
class SOAP_CMAC _tds__GetNTP {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNTP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
        virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNTP); }
      public:
        /// Constructor with initializations
        _tds__GetNTP() : soap() { }
        virtual ~_tds__GetNTP() { }
        /// Friend allocator used by soap_new__tds__GetNTP(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:523 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (211)
/* complex XSD type 'tds:GetNTPResponse': */
class SOAP_CMAC _tds__GetNTPResponse {
      public:
        /// Required element 'tds:NTPInformation' of XSD type 'tt:NTPInformation'
        tt__NTPInformation *NTPInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNTPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
        virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNTPResponse); }
      public:
        /// Constructor with initializations
        _tds__GetNTPResponse() : NTPInformation(), soap() { }
        virtual ~_tds__GetNTPResponse() { }
        /// Friend allocator used by soap_new__tds__GetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:526 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (212)
/* complex XSD type 'tds:SetNTP': */
class SOAP_CMAC _tds__SetNTP {
      public:
        /// Required element 'tds:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tds:NTPManual' of XSD type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNTP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
        virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNTP); }
      public:
        /// Constructor with initializations
        _tds__SetNTP() : FromDHCP(), NTPManual(), soap() { }
        virtual ~_tds__SetNTP() { }
        /// Friend allocator used by soap_new__tds__SetNTP(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:529 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (213)
/* complex XSD type 'tds:SetNTPResponse': */
class SOAP_CMAC _tds__SetNTPResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNTPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
        virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNTPResponse); }
      public:
        /// Constructor with initializations
        _tds__SetNTPResponse() : soap() { }
        virtual ~_tds__SetNTPResponse() { }
        /// Friend allocator used by soap_new__tds__SetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:532 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (214)
/* complex XSD type 'tds:GetDynamicDNS': */
class SOAP_CMAC _tds__GetDynamicDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDynamicDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
        virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDynamicDNS); }
      public:
        /// Constructor with initializations
        _tds__GetDynamicDNS() : soap() { }
        virtual ~_tds__GetDynamicDNS() { }
        /// Friend allocator used by soap_new__tds__GetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:535 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (215)
/* complex XSD type 'tds:GetDynamicDNSResponse': */
class SOAP_CMAC _tds__GetDynamicDNSResponse {
      public:
        /// Required element 'tds:DynamicDNSInformation' of XSD type 'tt:DynamicDNSInformation'
        tt__DynamicDNSInformation *DynamicDNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDynamicDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDynamicDNSResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDynamicDNSResponse() : DynamicDNSInformation(), soap() { }
        virtual ~_tds__GetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__tds__GetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:538 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (216)
/* complex XSD type 'tds:SetDynamicDNS': */
class SOAP_CMAC _tds__SetDynamicDNS {
      public:
        /// Required element 'tds:Type' of XSD type 'tt:DynamicDNSType'
        enum tt__DynamicDNSType Type;
        /// Optional element 'tds:Name' of XSD type 'tt:DNSName'
        std::string *Name;
        /// Optional element 'tds:TTL' of XSD type 'xsd:duration'
        std::string *TTL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDynamicDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
        virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDynamicDNS); }
      public:
        /// Constructor with initializations
        _tds__SetDynamicDNS() : Type(), Name(), TTL(), soap() { }
        virtual ~_tds__SetDynamicDNS() { }
        /// Friend allocator used by soap_new__tds__SetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:541 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (217)
/* complex XSD type 'tds:SetDynamicDNSResponse': */
class SOAP_CMAC _tds__SetDynamicDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDynamicDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDynamicDNSResponse); }
      public:
        /// Constructor with initializations
        _tds__SetDynamicDNSResponse() : soap() { }
        virtual ~_tds__SetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__tds__SetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:544 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (218)
/* complex XSD type 'tds:GetNetworkInterfaces': */
class SOAP_CMAC _tds__GetNetworkInterfaces {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkInterfaces
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkInterfaces); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkInterfaces() : soap() { }
        virtual ~_tds__GetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__tds__GetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:547 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (219)
/* complex XSD type 'tds:GetNetworkInterfacesResponse': */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse {
      public:
        /// Required element 'tds:NetworkInterfaces' of XSD type 'tt:NetworkInterface'
        std::vector<tt__NetworkInterface *> NetworkInterfaces;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkInterfacesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkInterfacesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkInterfacesResponse() : NetworkInterfaces(), soap() { }
        virtual ~_tds__GetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:550 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (220)
/* complex XSD type 'tds:SetNetworkInterfaces': */
class SOAP_CMAC _tds__SetNetworkInterfaces {
      public:
        /// Required element 'tds:InterfaceToken' of XSD type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tds:NetworkInterface' of XSD type 'tt:NetworkInterfaceSetConfiguration'
        tt__NetworkInterfaceSetConfiguration *NetworkInterface;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkInterfaces
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkInterfaces); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkInterfaces() : InterfaceToken(), NetworkInterface(), soap() { }
        virtual ~_tds__SetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__tds__SetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:553 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (221)
/* complex XSD type 'tds:SetNetworkInterfacesResponse': */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse {
      public:
        /// Required element 'tds:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkInterfacesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkInterfacesResponse); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkInterfacesResponse() : RebootNeeded(), soap() { }
        virtual ~_tds__SetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:556 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (222)
/* complex XSD type 'tds:GetNetworkProtocols': */
class SOAP_CMAC _tds__GetNetworkProtocols {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkProtocols
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
        virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkProtocols); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkProtocols() : soap() { }
        virtual ~_tds__GetNetworkProtocols() { }
        /// Friend allocator used by soap_new__tds__GetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:559 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (223)
/* complex XSD type 'tds:GetNetworkProtocolsResponse': */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse {
      public:
        /// Optional element 'tds:NetworkProtocols' of XSD type 'tt:NetworkProtocol'
        std::vector<tt__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkProtocolsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkProtocolsResponse); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkProtocolsResponse() : NetworkProtocols(), soap() { }
        virtual ~_tds__GetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:562 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (224)
/* complex XSD type 'tds:SetNetworkProtocols': */
class SOAP_CMAC _tds__SetNetworkProtocols {
      public:
        /// Required element 'tds:NetworkProtocols' of XSD type 'tt:NetworkProtocol'
        std::vector<tt__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkProtocols
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
        virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkProtocols); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkProtocols() : NetworkProtocols(), soap() { }
        virtual ~_tds__SetNetworkProtocols() { }
        /// Friend allocator used by soap_new__tds__SetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:565 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (225)
/* complex XSD type 'tds:SetNetworkProtocolsResponse': */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkProtocolsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkProtocolsResponse); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkProtocolsResponse() : soap() { }
        virtual ~_tds__SetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:568 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (226)
/* complex XSD type 'tds:GetNetworkDefaultGateway': */
class SOAP_CMAC _tds__GetNetworkDefaultGateway {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkDefaultGateway
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkDefaultGateway); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkDefaultGateway() : soap() { }
        virtual ~_tds__GetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__tds__GetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:571 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (227)
/* complex XSD type 'tds:GetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse {
      public:
        /// Required element 'tds:NetworkGateway' of XSD type 'tt:NetworkGateway'
        tt__NetworkGateway *NetworkGateway;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with initializations
        _tds__GetNetworkDefaultGatewayResponse() : NetworkGateway(), soap() { }
        virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:574 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (228)
/* complex XSD type 'tds:SetNetworkDefaultGateway': */
class SOAP_CMAC _tds__SetNetworkDefaultGateway {
      public:
        /// Optional element 'tds:IPv4Address' of XSD type 'tt:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'tds:IPv6Address' of XSD type 'tt:IPv6Address'
        std::vector<std::string> IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkDefaultGateway
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkDefaultGateway); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkDefaultGateway() : IPv4Address(), IPv6Address(), soap() { }
        virtual ~_tds__SetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__tds__SetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:577 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (229)
/* complex XSD type 'tds:SetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with initializations
        _tds__SetNetworkDefaultGatewayResponse() : soap() { }
        virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:580 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (230)
/* complex XSD type 'tds:GetZeroConfiguration': */
class SOAP_CMAC _tds__GetZeroConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetZeroConfiguration); }
      public:
        /// Constructor with initializations
        _tds__GetZeroConfiguration() : soap() { }
        virtual ~_tds__GetZeroConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:583 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (231)
/* complex XSD type 'tds:GetZeroConfigurationResponse': */
class SOAP_CMAC _tds__GetZeroConfigurationResponse {
      public:
        /// Required element 'tds:ZeroConfiguration' of XSD type 'tt:NetworkZeroConfiguration'
        tt__NetworkZeroConfiguration *ZeroConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetZeroConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetZeroConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetZeroConfigurationResponse() : ZeroConfiguration(), soap() { }
        virtual ~_tds__GetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:586 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (232)
/* complex XSD type 'tds:SetZeroConfiguration': */
class SOAP_CMAC _tds__SetZeroConfiguration {
      public:
        /// Required element 'tds:InterfaceToken' of XSD type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tds:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetZeroConfiguration); }
      public:
        /// Constructor with initializations
        _tds__SetZeroConfiguration() : InterfaceToken(), Enabled(), soap() { }
        virtual ~_tds__SetZeroConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:589 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (233)
/* complex XSD type 'tds:SetZeroConfigurationResponse': */
class SOAP_CMAC _tds__SetZeroConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetZeroConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetZeroConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__SetZeroConfigurationResponse() : soap() { }
        virtual ~_tds__SetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:592 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (234)
/* complex XSD type 'tds:GetIPAddressFilter': */
class SOAP_CMAC _tds__GetIPAddressFilter {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetIPAddressFilter); }
      public:
        /// Constructor with initializations
        _tds__GetIPAddressFilter() : soap() { }
        virtual ~_tds__GetIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__GetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:595 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (235)
/* complex XSD type 'tds:GetIPAddressFilterResponse': */
class SOAP_CMAC _tds__GetIPAddressFilterResponse {
      public:
        /// Required element 'tds:IPAddressFilter' of XSD type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _tds__GetIPAddressFilterResponse() : IPAddressFilter(), soap() { }
        virtual ~_tds__GetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__GetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:598 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (236)
/* complex XSD type 'tds:SetIPAddressFilter': */
class SOAP_CMAC _tds__SetIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XSD type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetIPAddressFilter); }
      public:
        /// Constructor with initializations
        _tds__SetIPAddressFilter() : IPAddressFilter(), soap() { }
        virtual ~_tds__SetIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__SetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:601 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (237)
/* complex XSD type 'tds:SetIPAddressFilterResponse': */
class SOAP_CMAC _tds__SetIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _tds__SetIPAddressFilterResponse() : soap() { }
        virtual ~_tds__SetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__SetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:604 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (238)
/* complex XSD type 'tds:AddIPAddressFilter': */
class SOAP_CMAC _tds__AddIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XSD type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddIPAddressFilter); }
      public:
        /// Constructor with initializations
        _tds__AddIPAddressFilter() : IPAddressFilter(), soap() { }
        virtual ~_tds__AddIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__AddIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:607 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (239)
/* complex XSD type 'tds:AddIPAddressFilterResponse': */
class SOAP_CMAC _tds__AddIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _tds__AddIPAddressFilterResponse() : soap() { }
        virtual ~_tds__AddIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__AddIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:610 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (240)
/* complex XSD type 'tds:RemoveIPAddressFilter': */
class SOAP_CMAC _tds__RemoveIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XSD type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveIPAddressFilter); }
      public:
        /// Constructor with initializations
        _tds__RemoveIPAddressFilter() : IPAddressFilter(), soap() { }
        virtual ~_tds__RemoveIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__RemoveIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:613 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (241)
/* complex XSD type 'tds:RemoveIPAddressFilterResponse': */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveIPAddressFilterResponse); }
      public:
        /// Constructor with initializations
        _tds__RemoveIPAddressFilterResponse() : soap() { }
        virtual ~_tds__RemoveIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__RemoveIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:616 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (242)
/* complex XSD type 'tds:GetAccessPolicy': */
class SOAP_CMAC _tds__GetAccessPolicy {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAccessPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
        virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAccessPolicy); }
      public:
        /// Constructor with initializations
        _tds__GetAccessPolicy() : soap() { }
        virtual ~_tds__GetAccessPolicy() { }
        /// Friend allocator used by soap_new__tds__GetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:619 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (243)
/* complex XSD type 'tds:GetAccessPolicyResponse': */
class SOAP_CMAC _tds__GetAccessPolicyResponse {
      public:
        /// Required element 'tds:PolicyFile' of XSD type 'tt:BinaryData'
        tt__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAccessPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAccessPolicyResponse); }
      public:
        /// Constructor with initializations
        _tds__GetAccessPolicyResponse() : PolicyFile(), soap() { }
        virtual ~_tds__GetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__tds__GetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:622 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (244)
/* complex XSD type 'tds:SetAccessPolicy': */
class SOAP_CMAC _tds__SetAccessPolicy {
      public:
        /// Required element 'tds:PolicyFile' of XSD type 'tt:BinaryData'
        tt__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAccessPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
        virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAccessPolicy); }
      public:
        /// Constructor with initializations
        _tds__SetAccessPolicy() : PolicyFile(), soap() { }
        virtual ~_tds__SetAccessPolicy() { }
        /// Friend allocator used by soap_new__tds__SetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:625 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (245)
/* complex XSD type 'tds:SetAccessPolicyResponse': */
class SOAP_CMAC _tds__SetAccessPolicyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAccessPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAccessPolicyResponse); }
      public:
        /// Constructor with initializations
        _tds__SetAccessPolicyResponse() : soap() { }
        virtual ~_tds__SetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__tds__SetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:628 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (246)
/* complex XSD type 'tds:CreateCertificate': */
class SOAP_CMAC _tds__CreateCertificate {
      public:
        /// Optional element 'tds:CertificateID' of XSD type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'tds:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'tds:ValidNotBefore' of XSD type 'xsd:dateTime'
        time_t *ValidNotBefore;
        /// Optional element 'tds:ValidNotAfter' of XSD type 'xsd:dateTime'
        time_t *ValidNotAfter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
        virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateCertificate); }
      public:
        /// Constructor with initializations
        _tds__CreateCertificate() : CertificateID(), Subject(), ValidNotBefore(), ValidNotAfter(), soap() { }
        virtual ~_tds__CreateCertificate() { }
        /// Friend allocator used by soap_new__tds__CreateCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:631 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (247)
/* complex XSD type 'tds:CreateCertificateResponse': */
class SOAP_CMAC _tds__CreateCertificateResponse {
      public:
        /// Required element 'tds:NvtCertificate' of XSD type 'tt:Certificate'
        tt__Certificate *NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
        virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateCertificateResponse); }
      public:
        /// Constructor with initializations
        _tds__CreateCertificateResponse() : NvtCertificate(), soap() { }
        virtual ~_tds__CreateCertificateResponse() { }
        /// Friend allocator used by soap_new__tds__CreateCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:634 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (248)
/* complex XSD type 'tds:GetCertificates': */
class SOAP_CMAC _tds__GetCertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
        virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificates); }
      public:
        /// Constructor with initializations
        _tds__GetCertificates() : soap() { }
        virtual ~_tds__GetCertificates() { }
        /// Friend allocator used by soap_new__tds__GetCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:637 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (249)
/* complex XSD type 'tds:GetCertificatesResponse': */
class SOAP_CMAC _tds__GetCertificatesResponse {
      public:
        /// Optional element 'tds:NvtCertificate' of XSD type 'tt:Certificate'
        std::vector<tt__Certificate *> NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetCertificatesResponse() : NvtCertificate(), soap() { }
        virtual ~_tds__GetCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:640 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (250)
/* complex XSD type 'tds:GetCertificatesStatus': */
class SOAP_CMAC _tds__GetCertificatesStatus {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesStatus); }
      public:
        /// Constructor with initializations
        _tds__GetCertificatesStatus() : soap() { }
        virtual ~_tds__GetCertificatesStatus() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:643 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (251)
/* complex XSD type 'tds:GetCertificatesStatusResponse': */
class SOAP_CMAC _tds__GetCertificatesStatusResponse {
      public:
        /// Optional element 'tds:CertificateStatus' of XSD type 'tt:CertificateStatus'
        std::vector<tt__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesStatusResponse); }
      public:
        /// Constructor with initializations
        _tds__GetCertificatesStatusResponse() : CertificateStatus(), soap() { }
        virtual ~_tds__GetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:646 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (252)
/* complex XSD type 'tds:SetCertificatesStatus': */
class SOAP_CMAC _tds__SetCertificatesStatus {
      public:
        /// Optional element 'tds:CertificateStatus' of XSD type 'tt:CertificateStatus'
        std::vector<tt__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetCertificatesStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
        virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetCertificatesStatus); }
      public:
        /// Constructor with initializations
        _tds__SetCertificatesStatus() : CertificateStatus(), soap() { }
        virtual ~_tds__SetCertificatesStatus() { }
        /// Friend allocator used by soap_new__tds__SetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:649 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (253)
/* complex XSD type 'tds:SetCertificatesStatusResponse': */
class SOAP_CMAC _tds__SetCertificatesStatusResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetCertificatesStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetCertificatesStatusResponse); }
      public:
        /// Constructor with initializations
        _tds__SetCertificatesStatusResponse() : soap() { }
        virtual ~_tds__SetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__tds__SetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:652 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (254)
/* complex XSD type 'tds:DeleteCertificates': */
class SOAP_CMAC _tds__DeleteCertificates {
      public:
        /// Required element 'tds:CertificateID' of XSD type 'xsd:token'
        std::vector<std::string> CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
        virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteCertificates); }
      public:
        /// Constructor with initializations
        _tds__DeleteCertificates() : CertificateID(), soap() { }
        virtual ~_tds__DeleteCertificates() { }
        /// Friend allocator used by soap_new__tds__DeleteCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:655 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (255)
/* complex XSD type 'tds:DeleteCertificatesResponse': */
class SOAP_CMAC _tds__DeleteCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteCertificatesResponse); }
      public:
        /// Constructor with initializations
        _tds__DeleteCertificatesResponse() : soap() { }
        virtual ~_tds__DeleteCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:658 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (256)
/* complex XSD type 'tds:GetPkcs10Request': */
class SOAP_CMAC _tds__GetPkcs10Request {
      public:
        /// Required element 'tds:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'tds:Subject' of XSD type 'xsd:string'
        std::string *Subject;
        /// Optional element 'tds:Attributes' of XSD type 'tt:BinaryData'
        tt__BinaryData *Attributes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPkcs10Request
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPkcs10Request; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
        virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPkcs10Request); }
      public:
        /// Constructor with initializations
        _tds__GetPkcs10Request() : CertificateID(), Subject(), Attributes(), soap() { }
        virtual ~_tds__GetPkcs10Request() { }
        /// Friend allocator used by soap_new__tds__GetPkcs10Request(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:661 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (257)
/* complex XSD type 'tds:GetPkcs10RequestResponse': */
class SOAP_CMAC _tds__GetPkcs10RequestResponse {
      public:
        /// Required element 'tds:Pkcs10Request' of XSD type 'tt:BinaryData'
        tt__BinaryData *Pkcs10Request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPkcs10RequestResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPkcs10RequestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
        virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPkcs10RequestResponse); }
      public:
        /// Constructor with initializations
        _tds__GetPkcs10RequestResponse() : Pkcs10Request(), soap() { }
        virtual ~_tds__GetPkcs10RequestResponse() { }
        /// Friend allocator used by soap_new__tds__GetPkcs10RequestResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:664 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (258)
/* complex XSD type 'tds:LoadCertificates': */
class SOAP_CMAC _tds__LoadCertificates {
      public:
        /// Required element 'tds:NVTCertificate' of XSD type 'tt:Certificate'
        std::vector<tt__Certificate *> NVTCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
        virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificates); }
      public:
        /// Constructor with initializations
        _tds__LoadCertificates() : NVTCertificate(), soap() { }
        virtual ~_tds__LoadCertificates() { }
        /// Friend allocator used by soap_new__tds__LoadCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:667 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (259)
/* complex XSD type 'tds:LoadCertificatesResponse': */
class SOAP_CMAC _tds__LoadCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificatesResponse); }
      public:
        /// Constructor with initializations
        _tds__LoadCertificatesResponse() : soap() { }
        virtual ~_tds__LoadCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:670 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (260)
/* complex XSD type 'tds:GetClientCertificateMode': */
class SOAP_CMAC _tds__GetClientCertificateMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetClientCertificateMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
        virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetClientCertificateMode); }
      public:
        /// Constructor with initializations
        _tds__GetClientCertificateMode() : soap() { }
        virtual ~_tds__GetClientCertificateMode() { }
        /// Friend allocator used by soap_new__tds__GetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:673 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (261)
/* complex XSD type 'tds:GetClientCertificateModeResponse': */
class SOAP_CMAC _tds__GetClientCertificateModeResponse {
      public:
        /// Required element 'tds:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetClientCertificateModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetClientCertificateModeResponse); }
      public:
        /// Constructor with initializations
        _tds__GetClientCertificateModeResponse() : Enabled(), soap() { }
        virtual ~_tds__GetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:676 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (262)
/* complex XSD type 'tds:SetClientCertificateMode': */
class SOAP_CMAC _tds__SetClientCertificateMode {
      public:
        /// Required element 'tds:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetClientCertificateMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
        virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetClientCertificateMode); }
      public:
        /// Constructor with initializations
        _tds__SetClientCertificateMode() : Enabled(), soap() { }
        virtual ~_tds__SetClientCertificateMode() { }
        /// Friend allocator used by soap_new__tds__SetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:679 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (263)
/* complex XSD type 'tds:SetClientCertificateModeResponse': */
class SOAP_CMAC _tds__SetClientCertificateModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetClientCertificateModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetClientCertificateModeResponse); }
      public:
        /// Constructor with initializations
        _tds__SetClientCertificateModeResponse() : soap() { }
        virtual ~_tds__SetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:682 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (264)
/* complex XSD type 'tds:GetCACertificates': */
class SOAP_CMAC _tds__GetCACertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCACertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
        virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCACertificates); }
      public:
        /// Constructor with initializations
        _tds__GetCACertificates() : soap() { }
        virtual ~_tds__GetCACertificates() { }
        /// Friend allocator used by soap_new__tds__GetCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:685 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (265)
/* complex XSD type 'tds:GetCACertificatesResponse': */
class SOAP_CMAC _tds__GetCACertificatesResponse {
      public:
        /// Optional element 'tds:CACertificate' of XSD type 'tt:Certificate'
        std::vector<tt__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCACertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCACertificatesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetCACertificatesResponse() : CACertificate(), soap() { }
        virtual ~_tds__GetCACertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:688 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (266)
/* complex XSD type 'tds:LoadCertificateWithPrivateKey': */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey {
      public:
        /// Required element 'tds:CertificateWithPrivateKey' of XSD type 'tt:CertificateWithPrivateKey'
        std::vector<tt__CertificateWithPrivateKey *> CertificateWithPrivateKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificateWithPrivateKey
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificateWithPrivateKey); }
      public:
        /// Constructor with initializations
        _tds__LoadCertificateWithPrivateKey() : CertificateWithPrivateKey(), soap() { }
        virtual ~_tds__LoadCertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new__tds__LoadCertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:691 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (267)
/* complex XSD type 'tds:LoadCertificateWithPrivateKeyResponse': */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificateWithPrivateKeyResponse); }
      public:
        /// Constructor with initializations
        _tds__LoadCertificateWithPrivateKeyResponse() : soap() { }
        virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:694 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (268)
/* complex XSD type 'tds:GetCertificateInformation': */
class SOAP_CMAC _tds__GetCertificateInformation {
      public:
        /// Required element 'tds:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificateInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
        virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificateInformation); }
      public:
        /// Constructor with initializations
        _tds__GetCertificateInformation() : CertificateID(), soap() { }
        virtual ~_tds__GetCertificateInformation() { }
        /// Friend allocator used by soap_new__tds__GetCertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:697 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (269)
/* complex XSD type 'tds:GetCertificateInformationResponse': */
class SOAP_CMAC _tds__GetCertificateInformationResponse {
      public:
        /// Required element 'tds:CertificateInformation' of XSD type 'tt:CertificateInformation'
        tt__CertificateInformation *CertificateInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificateInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificateInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificateInformationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetCertificateInformationResponse() : CertificateInformation(), soap() { }
        virtual ~_tds__GetCertificateInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificateInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:700 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (270)
/* complex XSD type 'tds:LoadCACertificates': */
class SOAP_CMAC _tds__LoadCACertificates {
      public:
        /// Required element 'tds:CACertificate' of XSD type 'tt:Certificate'
        std::vector<tt__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCACertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
        virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCACertificates); }
      public:
        /// Constructor with initializations
        _tds__LoadCACertificates() : CACertificate(), soap() { }
        virtual ~_tds__LoadCACertificates() { }
        /// Friend allocator used by soap_new__tds__LoadCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:703 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (271)
/* complex XSD type 'tds:LoadCACertificatesResponse': */
class SOAP_CMAC _tds__LoadCACertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCACertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCACertificatesResponse); }
      public:
        /// Constructor with initializations
        _tds__LoadCACertificatesResponse() : soap() { }
        virtual ~_tds__LoadCACertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:706 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (272)
/* complex XSD type 'tds:CreateDot1XConfiguration': */
class SOAP_CMAC _tds__CreateDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XSD type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tds__CreateDot1XConfiguration() : Dot1XConfiguration(), soap() { }
        virtual ~_tds__CreateDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__CreateDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:709 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (273)
/* complex XSD type 'tds:CreateDot1XConfigurationResponse': */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__CreateDot1XConfigurationResponse() : soap() { }
        virtual ~_tds__CreateDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__CreateDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:712 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (274)
/* complex XSD type 'tds:SetDot1XConfiguration': */
class SOAP_CMAC _tds__SetDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XSD type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tds__SetDot1XConfiguration() : Dot1XConfiguration(), soap() { }
        virtual ~_tds__SetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:715 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (275)
/* complex XSD type 'tds:SetDot1XConfigurationResponse': */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__SetDot1XConfigurationResponse() : soap() { }
        virtual ~_tds__SetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:718 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (276)
/* complex XSD type 'tds:GetDot1XConfiguration': */
class SOAP_CMAC _tds__GetDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tds__GetDot1XConfiguration() : Dot1XConfigurationToken(), soap() { }
        virtual ~_tds__GetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:721 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (277)
/* complex XSD type 'tds:GetDot1XConfigurationResponse': */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XSD type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDot1XConfigurationResponse() : Dot1XConfiguration(), soap() { }
        virtual ~_tds__GetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:724 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (278)
/* complex XSD type 'tds:GetDot1XConfigurations': */
class SOAP_CMAC _tds__GetDot1XConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurations); }
      public:
        /// Constructor with initializations
        _tds__GetDot1XConfigurations() : soap() { }
        virtual ~_tds__GetDot1XConfigurations() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:727 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (279)
/* complex XSD type 'tds:GetDot1XConfigurationsResponse': */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse {
      public:
        /// Optional element 'tds:Dot1XConfiguration' of XSD type 'tt:Dot1XConfiguration'
        std::vector<tt__Dot1XConfiguration *> Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDot1XConfigurationsResponse() : Dot1XConfiguration(), soap() { }
        virtual ~_tds__GetDot1XConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:730 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (280)
/* complex XSD type 'tds:DeleteDot1XConfiguration': */
class SOAP_CMAC _tds__DeleteDot1XConfiguration {
      public:
        /// Optional element 'tds:Dot1XConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tds__DeleteDot1XConfiguration() : Dot1XConfigurationToken(), soap() { }
        virtual ~_tds__DeleteDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__DeleteDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:733 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (281)
/* complex XSD type 'tds:DeleteDot1XConfigurationResponse': */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__DeleteDot1XConfigurationResponse() : soap() { }
        virtual ~_tds__DeleteDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:736 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (282)
/* complex XSD type 'tds:GetRelayOutputs': */
class SOAP_CMAC _tds__GetRelayOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRelayOutputs
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRelayOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
        virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRelayOutputs); }
      public:
        /// Constructor with initializations
        _tds__GetRelayOutputs() : soap() { }
        virtual ~_tds__GetRelayOutputs() { }
        /// Friend allocator used by soap_new__tds__GetRelayOutputs(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:739 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (283)
/* complex XSD type 'tds:GetRelayOutputsResponse': */
class SOAP_CMAC _tds__GetRelayOutputsResponse {
      public:
        /// Optional element 'tds:RelayOutputs' of XSD type 'tt:RelayOutput'
        std::vector<tt__RelayOutput *> RelayOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRelayOutputsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRelayOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
        virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRelayOutputsResponse); }
      public:
        /// Constructor with initializations
        _tds__GetRelayOutputsResponse() : RelayOutputs(), soap() { }
        virtual ~_tds__GetRelayOutputsResponse() { }
        /// Friend allocator used by soap_new__tds__GetRelayOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:742 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (284)
/* complex XSD type 'tds:SetRelayOutputSettings': */
class SOAP_CMAC _tds__SetRelayOutputSettings {
      public:
        /// Required element 'tds:RelayOutputToken' of XSD type 'tt:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'tds:Properties' of XSD type 'tt:RelayOutputSettings'
        tt__RelayOutputSettings *Properties;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputSettings
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputSettings); }
      public:
        /// Constructor with initializations
        _tds__SetRelayOutputSettings() : RelayOutputToken(), Properties(), soap() { }
        virtual ~_tds__SetRelayOutputSettings() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:745 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (285)
/* complex XSD type 'tds:SetRelayOutputSettingsResponse': */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputSettingsResponse); }
      public:
        /// Constructor with initializations
        _tds__SetRelayOutputSettingsResponse() : soap() { }
        virtual ~_tds__SetRelayOutputSettingsResponse() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:748 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (286)
/* complex XSD type 'tds:SetRelayOutputState': */
class SOAP_CMAC _tds__SetRelayOutputState {
      public:
        /// Required element 'tds:RelayOutputToken' of XSD type 'tt:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'tds:LogicalState' of XSD type 'tt:RelayLogicalState'
        enum tt__RelayLogicalState LogicalState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputState
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputState); }
      public:
        /// Constructor with initializations
        _tds__SetRelayOutputState() : RelayOutputToken(), LogicalState(), soap() { }
        virtual ~_tds__SetRelayOutputState() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputState(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:751 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (287)
/* complex XSD type 'tds:SetRelayOutputStateResponse': */
class SOAP_CMAC _tds__SetRelayOutputStateResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputStateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputStateResponse); }
      public:
        /// Constructor with initializations
        _tds__SetRelayOutputStateResponse() : soap() { }
        virtual ~_tds__SetRelayOutputStateResponse() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:754 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (288)
/* complex XSD type 'tds:SendAuxiliaryCommand': */
class SOAP_CMAC _tds__SendAuxiliaryCommand {
      public:
        /// Required element 'tds:AuxiliaryCommand' of XSD type 'tt:AuxiliaryData'
        std::string AuxiliaryCommand;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SendAuxiliaryCommand
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SendAuxiliaryCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
        virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SendAuxiliaryCommand); }
      public:
        /// Constructor with initializations
        _tds__SendAuxiliaryCommand() : AuxiliaryCommand(), soap() { }
        virtual ~_tds__SendAuxiliaryCommand() { }
        /// Friend allocator used by soap_new__tds__SendAuxiliaryCommand(struct soap*, int)
        friend SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:757 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (289)
/* complex XSD type 'tds:SendAuxiliaryCommandResponse': */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse {
      public:
        /// Optional element 'tds:AuxiliaryCommandResponse' of XSD type 'tt:AuxiliaryData'
        std::string *AuxiliaryCommandResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SendAuxiliaryCommandResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SendAuxiliaryCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
        virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SendAuxiliaryCommandResponse); }
      public:
        /// Constructor with initializations
        _tds__SendAuxiliaryCommandResponse() : AuxiliaryCommandResponse(), soap() { }
        virtual ~_tds__SendAuxiliaryCommandResponse() { }
        /// Friend allocator used by soap_new__tds__SendAuxiliaryCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:760 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (290)
/* complex XSD type 'tds:GetDot11Capabilities': */
class SOAP_CMAC _tds__GetDot11Capabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
        virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11Capabilities); }
      public:
        /// Constructor with initializations
        _tds__GetDot11Capabilities() : soap() { }
        virtual ~_tds__GetDot11Capabilities() { }
        /// Friend allocator used by soap_new__tds__GetDot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:763 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (291)
/* complex XSD type 'tds:GetDot11CapabilitiesResponse': */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XSD type 'tt:Dot11Capabilities'
        tt__Dot11Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11CapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11CapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11CapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDot11CapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tds__GetDot11CapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot11CapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:766 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (292)
/* complex XSD type 'tds:GetDot11Status': */
class SOAP_CMAC _tds__GetDot11Status {
      public:
        /// Required element 'tds:InterfaceToken' of XSD type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11Status
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
        virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11Status); }
      public:
        /// Constructor with initializations
        _tds__GetDot11Status() : InterfaceToken(), soap() { }
        virtual ~_tds__GetDot11Status() { }
        /// Friend allocator used by soap_new__tds__GetDot11Status(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:769 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (293)
/* complex XSD type 'tds:GetDot11StatusResponse': */
class SOAP_CMAC _tds__GetDot11StatusResponse {
      public:
        /// Required element 'tds:Status' of XSD type 'tt:Dot11Status'
        tt__Dot11Status *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11StatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11StatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11StatusResponse); }
      public:
        /// Constructor with initializations
        _tds__GetDot11StatusResponse() : Status(), soap() { }
        virtual ~_tds__GetDot11StatusResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot11StatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:772 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (294)
/* complex XSD type 'tds:ScanAvailableDot11Networks': */
class SOAP_CMAC _tds__ScanAvailableDot11Networks {
      public:
        /// Required element 'tds:InterfaceToken' of XSD type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__ScanAvailableDot11Networks
        virtual long soap_type(void) const { return SOAP_TYPE__tds__ScanAvailableDot11Networks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
        virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__ScanAvailableDot11Networks); }
      public:
        /// Constructor with initializations
        _tds__ScanAvailableDot11Networks() : InterfaceToken(), soap() { }
        virtual ~_tds__ScanAvailableDot11Networks() { }
        /// Friend allocator used by soap_new__tds__ScanAvailableDot11Networks(struct soap*, int)
        friend SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:775 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (295)
/* complex XSD type 'tds:ScanAvailableDot11NetworksResponse': */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse {
      public:
        /// Optional element 'tds:Networks' of XSD type 'tt:Dot11AvailableNetworks'
        std::vector<tt__Dot11AvailableNetworks *> Networks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
        virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__ScanAvailableDot11NetworksResponse); }
      public:
        /// Constructor with initializations
        _tds__ScanAvailableDot11NetworksResponse() : Networks(), soap() { }
        virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
        /// Friend allocator used by soap_new__tds__ScanAvailableDot11NetworksResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:778 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (296)
/* complex XSD type 'tds:GetSystemUris': */
class SOAP_CMAC _tds__GetSystemUris {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUris
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUris; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
        virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUris); }
      public:
        /// Constructor with initializations
        _tds__GetSystemUris() : soap() { }
        virtual ~_tds__GetSystemUris() { }
        /// Friend allocator used by soap_new__tds__GetSystemUris(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:8425 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1322)
/* complex XSD type 'tds:GetSystemUrisResponse-Extension': */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension {
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUrisResponse_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUrisResponse_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
        virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUrisResponse_Extension); }
      public:
        /// Constructor with initializations
        _tds__GetSystemUrisResponse_Extension() { }
        virtual ~_tds__GetSystemUrisResponse_Extension() { }
        /// Friend allocator used by soap_new__tds__GetSystemUrisResponse_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:781 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (297)
/* complex XSD type 'tds:GetSystemUrisResponse': */
class SOAP_CMAC _tds__GetSystemUrisResponse {
      public:
        /// Optional element 'tds:SystemLogUris' of XSD type 'tt:SystemLogUriList'
        tt__SystemLogUriList *SystemLogUris;
        /// Optional element 'tds:SupportInfoUri' of XSD type 'xsd:anyURI'
        std::string *SupportInfoUri;
        /// Optional element 'tds:SystemBackupUri' of XSD type 'xsd:anyURI'
        std::string *SystemBackupUri;
        /// Optional element 'tds:Extension' of XSD type 'tds:GetSystemUrisResponse-Extension'
        _tds__GetSystemUrisResponse_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUrisResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUrisResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUrisResponse); }
      public:
        /// Constructor with initializations
        _tds__GetSystemUrisResponse() : SystemLogUris(), SupportInfoUri(), SystemBackupUri(), Extension(), soap() { }
        virtual ~_tds__GetSystemUrisResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemUrisResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:784 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (298)
/* complex XSD type 'tds:StartFirmwareUpgrade': */
class SOAP_CMAC _tds__StartFirmwareUpgrade {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartFirmwareUpgrade
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartFirmwareUpgrade; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
        virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartFirmwareUpgrade); }
      public:
        /// Constructor with initializations
        _tds__StartFirmwareUpgrade() : soap() { }
        virtual ~_tds__StartFirmwareUpgrade() { }
        /// Friend allocator used by soap_new__tds__StartFirmwareUpgrade(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:787 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (299)
/* complex XSD type 'tds:StartFirmwareUpgradeResponse': */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse {
      public:
        /// Required element 'tds:UploadUri' of XSD type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'tds:UploadDelay' of XSD type 'xsd:duration'
        std::string UploadDelay;
        /// Required element 'tds:ExpectedDownTime' of XSD type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartFirmwareUpgradeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartFirmwareUpgradeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
        virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartFirmwareUpgradeResponse); }
      public:
        /// Constructor with initializations
        _tds__StartFirmwareUpgradeResponse() : UploadUri(), UploadDelay(), ExpectedDownTime(), soap() { }
        virtual ~_tds__StartFirmwareUpgradeResponse() { }
        /// Friend allocator used by soap_new__tds__StartFirmwareUpgradeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:790 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (300)
/* complex XSD type 'tds:StartSystemRestore': */
class SOAP_CMAC _tds__StartSystemRestore {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartSystemRestore
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartSystemRestore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
        virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartSystemRestore); }
      public:
        /// Constructor with initializations
        _tds__StartSystemRestore() : soap() { }
        virtual ~_tds__StartSystemRestore() { }
        /// Friend allocator used by soap_new__tds__StartSystemRestore(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:793 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (301)
/* complex XSD type 'tds:StartSystemRestoreResponse': */
class SOAP_CMAC _tds__StartSystemRestoreResponse {
      public:
        /// Required element 'tds:UploadUri' of XSD type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'tds:ExpectedDownTime' of XSD type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartSystemRestoreResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartSystemRestoreResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
        virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartSystemRestoreResponse); }
      public:
        /// Constructor with initializations
        _tds__StartSystemRestoreResponse() : UploadUri(), ExpectedDownTime(), soap() { }
        virtual ~_tds__StartSystemRestoreResponse() { }
        /// Friend allocator used by soap_new__tds__StartSystemRestoreResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:796 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (302)
/* complex XSD type 'tds:GetStorageConfigurations': */
class SOAP_CMAC _tds__GetStorageConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurations, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurations); }
      public:
        /// Constructor with initializations
        _tds__GetStorageConfigurations() : soap() { }
        virtual ~_tds__GetStorageConfigurations() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:799 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (303)
/* complex XSD type 'tds:GetStorageConfigurationsResponse': */
class SOAP_CMAC _tds__GetStorageConfigurationsResponse {
      public:
        /// Optional element 'tds:StorageConfigurations' of XSD type 'tds:StorageConfiguration'
        std::vector<tds__StorageConfiguration *> StorageConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tds__GetStorageConfigurationsResponse() : StorageConfigurations(), soap() { }
        virtual ~_tds__GetStorageConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:802 */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (304)
/* complex XSD type 'tds:CreateStorageConfiguration': */
class SOAP_CMAC _tds__CreateStorageConfiguration {
      public:
        /// Required element 'tds:StorageConfiguration' of XSD type 'tds:StorageConfigurationData'
        tds__StorageConfigurationData *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateStorageConfiguration); }
      public:
        /// Constructor with initializations
        _tds__CreateStorageConfiguration() : StorageConfiguration(), soap() { }
        virtual ~_tds__CreateStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__CreateStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:805 */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (305)
/* complex XSD type 'tds:CreateStorageConfigurationResponse': */
class SOAP_CMAC _tds__CreateStorageConfigurationResponse {
      public:
        /// Required element 'tds:Token' of XSD type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__CreateStorageConfigurationResponse() : Token(), soap() { }
        virtual ~_tds__CreateStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__CreateStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:808 */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (306)
/* complex XSD type 'tds:GetStorageConfiguration': */
class SOAP_CMAC _tds__GetStorageConfiguration {
      public:
        /// Required element 'tds:Token' of XSD type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfiguration); }
      public:
        /// Constructor with initializations
        _tds__GetStorageConfiguration() : Token(), soap() { }
        virtual ~_tds__GetStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:811 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (307)
/* complex XSD type 'tds:GetStorageConfigurationResponse': */
class SOAP_CMAC _tds__GetStorageConfigurationResponse {
      public:
        /// Required element 'tds:StorageConfiguration' of XSD type 'tds:StorageConfiguration'
        tds__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetStorageConfigurationResponse() : StorageConfiguration(), soap() { }
        virtual ~_tds__GetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:814 */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (308)
/* complex XSD type 'tds:SetStorageConfiguration': */
class SOAP_CMAC _tds__SetStorageConfiguration {
      public:
        /// Required element 'tds:StorageConfiguration' of XSD type 'tds:StorageConfiguration'
        tds__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetStorageConfiguration); }
      public:
        /// Constructor with initializations
        _tds__SetStorageConfiguration() : StorageConfiguration(), soap() { }
        virtual ~_tds__SetStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:817 */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (309)
/* complex XSD type 'tds:SetStorageConfigurationResponse': */
class SOAP_CMAC _tds__SetStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__SetStorageConfigurationResponse() : soap() { }
        virtual ~_tds__SetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:820 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (310)
/* complex XSD type 'tds:DeleteStorageConfiguration': */
class SOAP_CMAC _tds__DeleteStorageConfiguration {
      public:
        /// Required element 'tds:Token' of XSD type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteStorageConfiguration); }
      public:
        /// Constructor with initializations
        _tds__DeleteStorageConfiguration() : Token(), soap() { }
        virtual ~_tds__DeleteStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__DeleteStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:823 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (311)
/* complex XSD type 'tds:DeleteStorageConfigurationResponse': */
class SOAP_CMAC _tds__DeleteStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteStorageConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tds__DeleteStorageConfigurationResponse() : soap() { }
        virtual ~_tds__DeleteStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:826 */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (312)
/* complex XSD type 'tds:GetGeoLocation': */
class SOAP_CMAC _tds__GetGeoLocation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetGeoLocation, default initialized and not managed by a soap context
        virtual _tds__GetGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetGeoLocation); }
      public:
        /// Constructor with initializations
        _tds__GetGeoLocation() : soap() { }
        virtual ~_tds__GetGeoLocation() { }
        /// Friend allocator used by soap_new__tds__GetGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:829 */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (313)
/* complex XSD type 'tds:GetGeoLocationResponse': */
class SOAP_CMAC _tds__GetGeoLocationResponse {
      public:
        /// Optional element 'tds:Location' of XSD type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__GetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetGeoLocationResponse); }
      public:
        /// Constructor with initializations
        _tds__GetGeoLocationResponse() : Location(), soap() { }
        virtual ~_tds__GetGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__GetGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:832 */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (314)
/* complex XSD type 'tds:SetGeoLocation': */
class SOAP_CMAC _tds__SetGeoLocation {
      public:
        /// Required element 'tds:Location' of XSD type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetGeoLocation, default initialized and not managed by a soap context
        virtual _tds__SetGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetGeoLocation); }
      public:
        /// Constructor with initializations
        _tds__SetGeoLocation() : Location(), soap() { }
        virtual ~_tds__SetGeoLocation() { }
        /// Friend allocator used by soap_new__tds__SetGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:835 */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (315)
/* complex XSD type 'tds:SetGeoLocationResponse': */
class SOAP_CMAC _tds__SetGeoLocationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__SetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetGeoLocationResponse); }
      public:
        /// Constructor with initializations
        _tds__SetGeoLocationResponse() : soap() { }
        virtual ~_tds__SetGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__SetGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:838 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (316)
/* complex XSD type 'tds:DeleteGeoLocation': */
class SOAP_CMAC _tds__DeleteGeoLocation {
      public:
        /// Required element 'tds:Location' of XSD type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteGeoLocation, default initialized and not managed by a soap context
        virtual _tds__DeleteGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteGeoLocation); }
      public:
        /// Constructor with initializations
        _tds__DeleteGeoLocation() : Location(), soap() { }
        virtual ~_tds__DeleteGeoLocation() { }
        /// Friend allocator used by soap_new__tds__DeleteGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:841 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (317)
/* complex XSD type 'tds:DeleteGeoLocationResponse': */
class SOAP_CMAC _tds__DeleteGeoLocationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteGeoLocationResponse); }
      public:
        /// Constructor with initializations
        _tds__DeleteGeoLocationResponse() : soap() { }
        virtual ~_tds__DeleteGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:844 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (318)
/* Type tt__DeviceEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:DeviceEntity': */
class SOAP_CMAC tt__DeviceEntity {
      public:
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
        virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceEntity); }
      public:
        /// Constructor with initializations
        tt__DeviceEntity() : token(), soap() { }
        virtual ~tt__DeviceEntity() { }
        /// Friend allocator used by soap_new_tt__DeviceEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:847 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (319)
/* complex XSD type 'tt:IntRectangle': */
class SOAP_CMAC tt__IntRectangle {
      public:
        /// required attribute 'x' of XSD type 'xsd:int'
        int x;
        /// required attribute 'y' of XSD type 'xsd:int'
        int y;
        /// required attribute 'width' of XSD type 'xsd:int'
        int width;
        /// required attribute 'height' of XSD type 'xsd:int'
        int height;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
        virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangle); }
      public:
        /// Constructor with initializations
        tt__IntRectangle() : x(), y(), width(), height(), soap() { }
        virtual ~tt__IntRectangle() { }
        /// Friend allocator used by soap_new_tt__IntRectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:850 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (320)
/* complex XSD type 'tt:IntRectangleRange': */
class SOAP_CMAC tt__IntRectangleRange {
      public:
        /// Required element 'tt:XRange' of XSD type 'tt:IntRange'
        tt__IntRange *XRange;
        /// Required element 'tt:YRange' of XSD type 'tt:IntRange'
        tt__IntRange *YRange;
        /// Required element 'tt:WidthRange' of XSD type 'tt:IntRange'
        tt__IntRange *WidthRange;
        /// Required element 'tt:HeightRange' of XSD type 'tt:IntRange'
        tt__IntRange *HeightRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangleRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangleRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
        virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangleRange); }
      public:
        /// Constructor with initializations
        tt__IntRectangleRange() : XRange(), YRange(), WidthRange(), HeightRange(), soap() { }
        virtual ~tt__IntRectangleRange() { }
        /// Friend allocator used by soap_new_tt__IntRectangleRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:853 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (321)
/* complex XSD type 'tt:FloatRange': */
class SOAP_CMAC tt__FloatRange {
      public:
        /// Required element 'tt:Min' of XSD type 'xsd:float'
        float Min;
        /// Required element 'tt:Max' of XSD type 'xsd:float'
        float Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FloatRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FloatRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
        virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FloatRange); }
      public:
        /// Constructor with initializations
        tt__FloatRange() : Min(), Max(), soap() { }
        virtual ~tt__FloatRange() { }
        /// Friend allocator used by soap_new_tt__FloatRange(struct soap*, int)
        friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:856 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (322)
/* complex XSD type 'tt:DurationRange': */
class SOAP_CMAC tt__DurationRange {
      public:
        /// Required element 'tt:Min' of XSD type 'xsd:duration'
        std::string Min;
        /// Required element 'tt:Max' of XSD type 'xsd:duration'
        std::string Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DurationRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DurationRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
        virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DurationRange); }
      public:
        /// Constructor with initializations
        tt__DurationRange() : Min(), Max(), soap() { }
        virtual ~tt__DurationRange() { }
        /// Friend allocator used by soap_new_tt__DurationRange(struct soap*, int)
        friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:859 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (323)
/* complex XSD type 'tt:IntList': */
class SOAP_CMAC tt__IntList {
      public:
        /// Optional element 'tt:Items' of XSD type 'xsd:int'
        std::vector<int> Items;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntList, default initialized and not managed by a soap context
        virtual tt__IntList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntList); }
      public:
        /// Constructor with initializations
        tt__IntList() : Items(), soap() { }
        virtual ~tt__IntList() { }
        /// Friend allocator used by soap_new_tt__IntList(struct soap*, int)
        friend SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:862 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (324)
/* complex XSD type 'tt:FloatList': */
class SOAP_CMAC tt__FloatList {
      public:
        /// Optional element 'tt:Items' of XSD type 'xsd:float'
        std::vector<float> Items;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FloatList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FloatList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FloatList, default initialized and not managed by a soap context
        virtual tt__FloatList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FloatList); }
      public:
        /// Constructor with initializations
        tt__FloatList() : Items(), soap() { }
        virtual ~tt__FloatList() { }
        /// Friend allocator used by soap_new_tt__FloatList(struct soap*, int)
        friend SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:868 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (326)
/* complex XSD type 'tt:VideoSourceExtension': */
class SOAP_CMAC tt__VideoSourceExtension {
      public:
        /// Optional element 'tt:Imaging' of XSD type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *Imaging;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceExtension2'
        tt__VideoSourceExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceExtension); }
      public:
        /// Constructor with initializations
        tt__VideoSourceExtension() : Imaging(), Extension(), soap() { }
        virtual ~tt__VideoSourceExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:871 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (327)
/* complex XSD type 'tt:VideoSourceExtension2': */
class SOAP_CMAC tt__VideoSourceExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceExtension2); }
      public:
        /// Constructor with initializations
        tt__VideoSourceExtension2() : soap() { }
        virtual ~tt__VideoSourceExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:877 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (329)
/* complex XSD type 'tt:Profile': */
class SOAP_CMAC tt__Profile {
      public:
        /// Required element 'tt:Name' of XSD type 'tt:Name'
        std::string Name;
        /// Optional element 'tt:VideoSourceConfiguration' of XSD type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *VideoSourceConfiguration;
        /// Optional element 'tt:AudioSourceConfiguration' of XSD type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *AudioSourceConfiguration;
        /// Optional element 'tt:VideoEncoderConfiguration' of XSD type 'tt:VideoEncoderConfiguration'
        tt__VideoEncoderConfiguration *VideoEncoderConfiguration;
        /// Optional element 'tt:AudioEncoderConfiguration' of XSD type 'tt:AudioEncoderConfiguration'
        tt__AudioEncoderConfiguration *AudioEncoderConfiguration;
        /// Optional element 'tt:VideoAnalyticsConfiguration' of XSD type 'tt:VideoAnalyticsConfiguration'
        tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;
        /// Optional element 'tt:PTZConfiguration' of XSD type 'tt:PTZConfiguration'
        tt__PTZConfiguration *PTZConfiguration;
        /// Optional element 'tt:MetadataConfiguration' of XSD type 'tt:MetadataConfiguration'
        tt__MetadataConfiguration *MetadataConfiguration;
        /// Optional element 'tt:Extension' of XSD type 'tt:ProfileExtension'
        tt__ProfileExtension *Extension;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// optional attribute 'fixed' of XSD type 'xsd:boolean'
        bool *fixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Profile
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Profile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Profile, default initialized and not managed by a soap context
        virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Profile); }
      public:
        /// Constructor with initializations
        tt__Profile() : Name(), VideoSourceConfiguration(), AudioSourceConfiguration(), VideoEncoderConfiguration(), AudioEncoderConfiguration(), VideoAnalyticsConfiguration(), PTZConfiguration(), MetadataConfiguration(), Extension(), token(), fixed(), soap() { }
        virtual ~tt__Profile() { }
        /// Friend allocator used by soap_new_tt__Profile(struct soap*, int)
        friend SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:880 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (330)
/* complex XSD type 'tt:ProfileExtension': */
class SOAP_CMAC tt__ProfileExtension {
      public:
        /// Optional element 'tt:AudioOutputConfiguration' of XSD type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *AudioOutputConfiguration;
        /// Optional element 'tt:AudioDecoderConfiguration' of XSD type 'tt:AudioDecoderConfiguration'
        tt__AudioDecoderConfiguration *AudioDecoderConfiguration;
        /// Optional element 'tt:Extension' of XSD type 'tt:ProfileExtension2'
        tt__ProfileExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
        virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileExtension); }
      public:
        /// Constructor with initializations
        tt__ProfileExtension() : AudioOutputConfiguration(), AudioDecoderConfiguration(), Extension(), soap() { }
        virtual ~tt__ProfileExtension() { }
        /// Friend allocator used by soap_new_tt__ProfileExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:883 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (331)
/* complex XSD type 'tt:ProfileExtension2': */
class SOAP_CMAC tt__ProfileExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
        virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileExtension2); }
      public:
        /// Constructor with initializations
        tt__ProfileExtension2() : soap() { }
        virtual ~tt__ProfileExtension2() { }
        /// Friend allocator used by soap_new_tt__ProfileExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:886 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (332)
/* Type tt__ConfigurationEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:ConfigurationEntity': */
class SOAP_CMAC tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Name' of XSD type 'tt:Name'
        std::string Name;
        /// Required element 'tt:UseCount' of XSD type 'xsd:int'
        int UseCount;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ConfigurationEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ConfigurationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
        virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ConfigurationEntity); }
      public:
        /// Constructor with initializations
        tt__ConfigurationEntity() : Name(), UseCount(), token(), soap() { }
        virtual ~tt__ConfigurationEntity() { }
        /// Friend allocator used by soap_new_tt__ConfigurationEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:892 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (334)
/* complex XSD type 'tt:VideoSourceConfigurationExtension': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension {
      public:
        /// Optional element 'tt:Rotate' of XSD type 'tt:Rotate'
        tt__Rotate *Rotate;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceConfigurationExtension2'
        tt__VideoSourceConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfigurationExtension() : Rotate(), Extension(), soap() { }
        virtual ~tt__VideoSourceConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:895 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (335)
/* complex XSD type 'tt:VideoSourceConfigurationExtension2': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 {
      public:
        /// Optional element 'tt:LensDescription' of XSD type 'tt:LensDescription'
        std::vector<tt__LensDescription *> LensDescription;
        /// Optional element 'tt:SceneOrientation' of XSD type 'tt:SceneOrientation'
        tt__SceneOrientation *SceneOrientation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension2); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfigurationExtension2() : LensDescription(), SceneOrientation(), soap() { }
        virtual ~tt__VideoSourceConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:898 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (336)
/* complex XSD type 'tt:Rotate': */
class SOAP_CMAC tt__Rotate {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:RotateMode'
        enum tt__RotateMode Mode;
        /// Optional element 'tt:Degree' of XSD type 'xsd:int'
        int *Degree;
        /// Optional element 'tt:Extension' of XSD type 'tt:RotateExtension'
        tt__RotateExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rotate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rotate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
        virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rotate); }
      public:
        /// Constructor with initializations
        tt__Rotate() : Mode(), Degree(), Extension(), soap() { }
        virtual ~tt__Rotate() { }
        /// Friend allocator used by soap_new_tt__Rotate(struct soap*, int)
        friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:901 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (337)
/* complex XSD type 'tt:RotateExtension': */
class SOAP_CMAC tt__RotateExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
        virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateExtension); }
      public:
        /// Constructor with initializations
        tt__RotateExtension() : soap() { }
        virtual ~tt__RotateExtension() { }
        /// Friend allocator used by soap_new_tt__RotateExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:904 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (338)
/* complex XSD type 'tt:LensProjection': */
class SOAP_CMAC tt__LensProjection {
      public:
        /// Required element 'tt:Angle' of XSD type 'xsd:float'
        float Angle;
        /// Required element 'tt:Radius' of XSD type 'xsd:float'
        float Radius;
        /// Optional element 'tt:Transmittance' of XSD type 'xsd:float'
        float *Transmittance;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensProjection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensProjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
        virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensProjection); }
      public:
        /// Constructor with initializations
        tt__LensProjection() : Angle(), Radius(), Transmittance(), soap() { }
        virtual ~tt__LensProjection() { }
        /// Friend allocator used by soap_new_tt__LensProjection(struct soap*, int)
        friend SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:907 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (339)
/* complex XSD type 'tt:LensOffset': */
class SOAP_CMAC tt__LensOffset {
      public:
        /// optional attribute 'x' of XSD type 'xsd:float'
        float *x;
        /// optional attribute 'y' of XSD type 'xsd:float'
        float *y;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensOffset
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensOffset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
        virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensOffset); }
      public:
        /// Constructor with initializations
        tt__LensOffset() : x(), y(), soap() { }
        virtual ~tt__LensOffset() { }
        /// Friend allocator used by soap_new_tt__LensOffset(struct soap*, int)
        friend SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:910 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (340)
/* complex XSD type 'tt:LensDescription': */
class SOAP_CMAC tt__LensDescription {
      public:
        /// Required element 'tt:Offset' of XSD type 'tt:LensOffset'
        tt__LensOffset *Offset;
        /// Required element 'tt:Projection' of XSD type 'tt:LensProjection'
        std::vector<tt__LensProjection *> Projection;
        /// Required element 'tt:XFactor' of XSD type 'xsd:float'
        float XFactor;
        /// optional attribute 'FocalLength' of XSD type 'xsd:float'
        float *FocalLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
        virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensDescription); }
      public:
        /// Constructor with initializations
        tt__LensDescription() : Offset(), Projection(), XFactor(), FocalLength(), soap() { }
        virtual ~tt__LensDescription() { }
        /// Friend allocator used by soap_new_tt__LensDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:913 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (341)
/* complex XSD type 'tt:VideoSourceConfigurationOptions': */
class SOAP_CMAC tt__VideoSourceConfigurationOptions {
      public:
        /// Required element 'tt:BoundsRange' of XSD type 'tt:IntRectangleRange'
        tt__IntRectangleRange *BoundsRange;
        /// Required element 'tt:VideoSourceTokensAvailable' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> VideoSourceTokensAvailable;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceConfigurationOptionsExtension'
        tt__VideoSourceConfigurationOptionsExtension *Extension;
        /// optional attribute 'MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int *MaximumNumberOfProfiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfigurationOptions() : BoundsRange(), VideoSourceTokensAvailable(), Extension(), MaximumNumberOfProfiles(), soap() { }
        virtual ~tt__VideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:916 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (342)
/* complex XSD type 'tt:VideoSourceConfigurationOptionsExtension': */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension {
      public:
        /// Optional element 'tt:Rotate' of XSD type 'tt:RotateOptions'
        tt__RotateOptions *Rotate;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceConfigurationOptionsExtension2'
        tt__VideoSourceConfigurationOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfigurationOptionsExtension() : Rotate(), Extension(), soap() { }
        virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:919 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (343)
/* complex XSD type 'tt:VideoSourceConfigurationOptionsExtension2': */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2 {
      public:
        /// Optional element 'tt:SceneOrientationMode' of XSD type 'tt:SceneOrientationMode'
        std::vector<enum tt__SceneOrientationMode> SceneOrientationMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptionsExtension2); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfigurationOptionsExtension2() : SceneOrientationMode(), soap() { }
        virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:922 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (344)
/* complex XSD type 'tt:RotateOptions': */
class SOAP_CMAC tt__RotateOptions {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:RotateMode'
        std::vector<enum tt__RotateMode> Mode;
        /// Optional element 'tt:DegreeList' of XSD type 'tt:IntList'
        tt__IntList *DegreeList;
        /// Optional element 'tt:Extension' of XSD type 'tt:RotateOptionsExtension'
        tt__RotateOptionsExtension *Extension;
        /// optional attribute 'Reboot' of XSD type 'xsd:boolean'
        bool *Reboot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
        virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateOptions); }
      public:
        /// Constructor with initializations
        tt__RotateOptions() : Mode(), DegreeList(), Extension(), Reboot(), soap() { }
        virtual ~tt__RotateOptions() { }
        /// Friend allocator used by soap_new_tt__RotateOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:925 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (345)
/* complex XSD type 'tt:RotateOptionsExtension': */
class SOAP_CMAC tt__RotateOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
        virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__RotateOptionsExtension() : soap() { }
        virtual ~tt__RotateOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__RotateOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:928 */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (346)
/* complex XSD type 'tt:SceneOrientation': */
class SOAP_CMAC tt__SceneOrientation {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:SceneOrientationMode'
        enum tt__SceneOrientationMode Mode;
        /// Optional element 'tt:Orientation' of XSD type 'xsd:string'
        std::string *Orientation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientation, default initialized and not managed by a soap context
        virtual tt__SceneOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientation); }
      public:
        /// Constructor with initializations
        tt__SceneOrientation() : Mode(), Orientation(), soap() { }
        virtual ~tt__SceneOrientation() { }
        /// Friend allocator used by soap_new_tt__SceneOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:934 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (348)
/* complex XSD type 'tt:VideoResolution': */
class SOAP_CMAC tt__VideoResolution {
      public:
        /// Required element 'tt:Width' of XSD type 'xsd:int'
        int Width;
        /// Required element 'tt:Height' of XSD type 'xsd:int'
        int Height;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoResolution
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoResolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
        virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoResolution); }
      public:
        /// Constructor with initializations
        tt__VideoResolution() : Width(), Height(), soap() { }
        virtual ~tt__VideoResolution() { }
        /// Friend allocator used by soap_new_tt__VideoResolution(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:937 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (349)
/* complex XSD type 'tt:VideoRateControl': */
class SOAP_CMAC tt__VideoRateControl {
      public:
        /// Required element 'tt:FrameRateLimit' of XSD type 'xsd:int'
        int FrameRateLimit;
        /// Required element 'tt:EncodingInterval' of XSD type 'xsd:int'
        int EncodingInterval;
        /// Required element 'tt:BitrateLimit' of XSD type 'xsd:int'
        int BitrateLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoRateControl
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoRateControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
        virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoRateControl); }
      public:
        /// Constructor with initializations
        tt__VideoRateControl() : FrameRateLimit(), EncodingInterval(), BitrateLimit(), soap() { }
        virtual ~tt__VideoRateControl() { }
        /// Friend allocator used by soap_new_tt__VideoRateControl(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:940 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (350)
/* complex XSD type 'tt:Mpeg4Configuration': */
class SOAP_CMAC tt__Mpeg4Configuration {
      public:
        /// Required element 'tt:GovLength' of XSD type 'xsd:int'
        int GovLength;
        /// Required element 'tt:Mpeg4Profile' of XSD type 'tt:Mpeg4Profile'
        enum tt__Mpeg4Profile Mpeg4Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
        virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Configuration); }
      public:
        /// Constructor with initializations
        tt__Mpeg4Configuration() : GovLength(), Mpeg4Profile(), soap() { }
        virtual ~tt__Mpeg4Configuration() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:943 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (351)
/* complex XSD type 'tt:H264Configuration': */
class SOAP_CMAC tt__H264Configuration {
      public:
        /// Required element 'tt:GovLength' of XSD type 'xsd:int'
        int GovLength;
        /// Required element 'tt:H264Profile' of XSD type 'tt:H264Profile'
        enum tt__H264Profile H264Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
        virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Configuration); }
      public:
        /// Constructor with initializations
        tt__H264Configuration() : GovLength(), H264Profile(), soap() { }
        virtual ~tt__H264Configuration() { }
        /// Friend allocator used by soap_new_tt__H264Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:946 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (352)
/* complex XSD type 'tt:VideoEncoderConfigurationOptions': */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions {
      public:
        /// Required element 'tt:QualityRange' of XSD type 'tt:IntRange'
        tt__IntRange *QualityRange;
        /// Optional element 'tt:JPEG' of XSD type 'tt:JpegOptions'
        tt__JpegOptions *JPEG;
        /// Optional element 'tt:MPEG4' of XSD type 'tt:Mpeg4Options'
        tt__Mpeg4Options *MPEG4;
        /// Optional element 'tt:H264' of XSD type 'tt:H264Options'
        tt__H264Options *H264;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoEncoderOptionsExtension'
        tt__VideoEncoderOptionsExtension *Extension;
        /// optional attribute 'GuaranteedFrameRateSupported' of XSD type 'xsd:boolean'
        bool *GuaranteedFrameRateSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__VideoEncoderConfigurationOptions() : QualityRange(), JPEG(), MPEG4(), H264(), Extension(), GuaranteedFrameRateSupported(), soap() { }
        virtual ~tt__VideoEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:949 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (353)
/* complex XSD type 'tt:VideoEncoderOptionsExtension': */
class SOAP_CMAC tt__VideoEncoderOptionsExtension {
      public:
        /// Optional element 'tt:JPEG' of XSD type 'tt:JpegOptions2'
        tt__JpegOptions2 *JPEG;
        /// Optional element 'tt:MPEG4' of XSD type 'tt:Mpeg4Options2'
        tt__Mpeg4Options2 *MPEG4;
        /// Optional element 'tt:H264' of XSD type 'tt:H264Options2'
        tt__H264Options2 *H264;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoEncoderOptionsExtension2'
        tt__VideoEncoderOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
        virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__VideoEncoderOptionsExtension() : JPEG(), MPEG4(), H264(), Extension(), soap() { }
        virtual ~tt__VideoEncoderOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:952 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (354)
/* complex XSD type 'tt:VideoEncoderOptionsExtension2': */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderOptionsExtension2); }
      public:
        /// Constructor with initializations
        tt__VideoEncoderOptionsExtension2() : soap() { }
        virtual ~tt__VideoEncoderOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:955 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (355)
/* Type tt__JpegOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:JpegOptions': */
class SOAP_CMAC tt__JpegOptions {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XSD type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:FrameRateRange' of XSD type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XSD type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__JpegOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JpegOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
        virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JpegOptions); }
      public:
        /// Constructor with initializations
        tt__JpegOptions() : ResolutionsAvailable(), FrameRateRange(), EncodingIntervalRange(), soap() { }
        virtual ~tt__JpegOptions() { }
        /// Friend allocator used by soap_new_tt__JpegOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:961 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (357)
/* Type tt__Mpeg4Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:Mpeg4Options': */
class SOAP_CMAC tt__Mpeg4Options {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XSD type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:GovLengthRange' of XSD type 'tt:IntRange'
        tt__IntRange *GovLengthRange;
        /// Required element 'tt:FrameRateRange' of XSD type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XSD type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
        /// Required element 'tt:Mpeg4ProfilesSupported' of XSD type 'tt:Mpeg4Profile'
        std::vector<enum tt__Mpeg4Profile> Mpeg4ProfilesSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Options
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
        virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Options); }
      public:
        /// Constructor with initializations
        tt__Mpeg4Options() : ResolutionsAvailable(), GovLengthRange(), FrameRateRange(), EncodingIntervalRange(), Mpeg4ProfilesSupported(), soap() { }
        virtual ~tt__Mpeg4Options() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Options(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:967 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (359)
/* Type tt__H264Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:H264Options': */
class SOAP_CMAC tt__H264Options {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XSD type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:GovLengthRange' of XSD type 'tt:IntRange'
        tt__IntRange *GovLengthRange;
        /// Required element 'tt:FrameRateRange' of XSD type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XSD type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
        /// Required element 'tt:H264ProfilesSupported' of XSD type 'tt:H264Profile'
        std::vector<enum tt__H264Profile> H264ProfilesSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Options
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
        virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Options); }
      public:
        /// Constructor with initializations
        tt__H264Options() : ResolutionsAvailable(), GovLengthRange(), FrameRateRange(), EncodingIntervalRange(), H264ProfilesSupported(), soap() { }
        virtual ~tt__H264Options() { }
        /// Friend allocator used by soap_new_tt__H264Options(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:976 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (362)
/* complex XSD type 'tt:AudioSourceConfigurationOptions': */
class SOAP_CMAC tt__AudioSourceConfigurationOptions {
      public:
        /// Required element 'tt:InputTokensAvailable' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> InputTokensAvailable;
        /// Optional element 'tt:Extension' of XSD type 'tt:AudioSourceOptionsExtension'
        tt__AudioSourceOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__AudioSourceConfigurationOptions() : InputTokensAvailable(), Extension(), soap() { }
        virtual ~tt__AudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:979 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (363)
/* complex XSD type 'tt:AudioSourceOptionsExtension': */
class SOAP_CMAC tt__AudioSourceOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
        virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__AudioSourceOptionsExtension() : soap() { }
        virtual ~tt__AudioSourceOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__AudioSourceOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:985 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (365)
/* complex XSD type 'tt:AudioEncoderConfigurationOptions': */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions {
      public:
        /// Optional element 'tt:Options' of XSD type 'tt:AudioEncoderConfigurationOption'
        std::vector<tt__AudioEncoderConfigurationOption *> Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__AudioEncoderConfigurationOptions() : Options(), soap() { }
        virtual ~tt__AudioEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:988 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (366)
/* complex XSD type 'tt:AudioEncoderConfigurationOption': */
class SOAP_CMAC tt__AudioEncoderConfigurationOption {
      public:
        /// Required element 'tt:Encoding' of XSD type 'tt:AudioEncoding'
        enum tt__AudioEncoding Encoding;
        /// Required element 'tt:BitrateList' of XSD type 'tt:IntList'
        tt__IntList *BitrateList;
        /// Required element 'tt:SampleRateList' of XSD type 'tt:IntList'
        tt__IntList *SampleRateList;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOption
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfigurationOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfigurationOption); }
      public:
        /// Constructor with initializations
        tt__AudioEncoderConfigurationOption() : Encoding(), BitrateList(), SampleRateList(), soap() { }
        virtual ~tt__AudioEncoderConfigurationOption() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfigurationOption(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:997 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (369)
/* complex XSD type 'tt:MetadataConfigurationExtension': */
class SOAP_CMAC tt__MetadataConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__MetadataConfigurationExtension() : soap() { }
        virtual ~tt__MetadataConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1000 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (370)
/* complex XSD type 'tt:PTZFilter': */
class SOAP_CMAC tt__PTZFilter {
      public:
        /// Required element 'tt:Status' of XSD type 'xsd:boolean'
        bool Status;
        /// Required element 'tt:Position' of XSD type 'xsd:boolean'
        bool Position;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
        virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZFilter); }
      public:
        /// Constructor with initializations
        tt__PTZFilter() : Status(), Position(), soap() { }
        virtual ~tt__PTZFilter() { }
        /// Friend allocator used by soap_new_tt__PTZFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:10241 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1380)
/* complex XSD type 'tt:EventSubscription-SubscriptionPolicy': */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy {
      public:
        /// Return unique type id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__EventSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _tt__EventSubscription_SubscriptionPolicy() { }
        virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__tt__EventSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1003 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (371)
/* complex XSD type 'tt:EventSubscription': */
class SOAP_CMAC tt__EventSubscription {
      public:
        /// Optional element 'tt:Filter' of XSD type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'tt:SubscriptionPolicy' of XSD type 'tt:EventSubscription-SubscriptionPolicy'
        _tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventSubscription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
        virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventSubscription); }
      public:
        /// Constructor with initializations
        tt__EventSubscription() : Filter(), SubscriptionPolicy(), soap() { }
        virtual ~tt__EventSubscription() { }
        /// Friend allocator used by soap_new_tt__EventSubscription(struct soap*, int)
        friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1006 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (372)
/* complex XSD type 'tt:MetadataConfigurationOptions': */
class SOAP_CMAC tt__MetadataConfigurationOptions {
      public:
        /// Required element 'tt:PTZStatusFilterOptions' of XSD type 'tt:PTZStatusFilterOptions'
        tt__PTZStatusFilterOptions *PTZStatusFilterOptions;
        /// Optional element 'tt:Extension' of XSD type 'tt:MetadataConfigurationOptionsExtension'
        tt__MetadataConfigurationOptionsExtension *Extension;
        /// optional attribute 'GeoLocation' of XSD type 'xsd:boolean'
        bool *GeoLocation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__MetadataConfigurationOptions() : PTZStatusFilterOptions(), Extension(), GeoLocation(), soap() { }
        virtual ~tt__MetadataConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1009 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (373)
/* complex XSD type 'tt:MetadataConfigurationOptionsExtension': */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension {
      public:
        /// Optional element 'tt:CompressionType' of XSD type 'xsd:string'
        std::vector<std::string> CompressionType;
        /// Optional element 'tt:Extension' of XSD type 'tt:MetadataConfigurationOptionsExtension2'
        tt__MetadataConfigurationOptionsExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__MetadataConfigurationOptionsExtension() : CompressionType(), Extension(), soap() { }
        virtual ~tt__MetadataConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1012 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (374)
/* complex XSD type 'tt:MetadataConfigurationOptionsExtension2': */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptionsExtension2); }
      public:
        /// Constructor with initializations
        tt__MetadataConfigurationOptionsExtension2() : soap() { }
        virtual ~tt__MetadataConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1015 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (375)
/* complex XSD type 'tt:PTZStatusFilterOptions': */
class SOAP_CMAC tt__PTZStatusFilterOptions {
      public:
        /// Required element 'tt:PanTiltStatusSupported' of XSD type 'xsd:boolean'
        bool PanTiltStatusSupported;
        /// Required element 'tt:ZoomStatusSupported' of XSD type 'xsd:boolean'
        bool ZoomStatusSupported;
        /// Optional element 'tt:PanTiltPositionSupported' of XSD type 'xsd:boolean'
        bool *PanTiltPositionSupported;
        /// Optional element 'tt:ZoomPositionSupported' of XSD type 'xsd:boolean'
        bool *ZoomPositionSupported;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZStatusFilterOptionsExtension'
        tt__PTZStatusFilterOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatusFilterOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatusFilterOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
        virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatusFilterOptions); }
      public:
        /// Constructor with initializations
        tt__PTZStatusFilterOptions() : PanTiltStatusSupported(), ZoomStatusSupported(), PanTiltPositionSupported(), ZoomPositionSupported(), Extension(), soap() { }
        virtual ~tt__PTZStatusFilterOptions() { }
        /// Friend allocator used by soap_new_tt__PTZStatusFilterOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1018 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (376)
/* complex XSD type 'tt:PTZStatusFilterOptionsExtension': */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatusFilterOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatusFilterOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__PTZStatusFilterOptionsExtension() : soap() { }
        virtual ~tt__PTZStatusFilterOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZStatusFilterOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1024 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (378)
/* complex XSD type 'tt:VideoOutputExtension': */
class SOAP_CMAC tt__VideoOutputExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
        virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputExtension); }
      public:
        /// Constructor with initializations
        tt__VideoOutputExtension() : soap() { }
        virtual ~tt__VideoOutputExtension() { }
        /// Friend allocator used by soap_new_tt__VideoOutputExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1030 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (380)
/* complex XSD type 'tt:VideoOutputConfigurationOptions': */
class SOAP_CMAC tt__VideoOutputConfigurationOptions {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__VideoOutputConfigurationOptions() : soap() { }
        virtual ~tt__VideoOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1039 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (383)
/* complex XSD type 'tt:AudioOutputConfigurationOptions': */
class SOAP_CMAC tt__AudioOutputConfigurationOptions {
      public:
        /// Required element 'tt:OutputTokensAvailable' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> OutputTokensAvailable;
        /// Optional element 'tt:SendPrimacyOptions' of XSD type 'xsd:anyURI'
        std::vector<std::string> SendPrimacyOptions;
        /// Required element 'tt:OutputLevelRange' of XSD type 'tt:IntRange'
        tt__IntRange *OutputLevelRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__AudioOutputConfigurationOptions() : OutputTokensAvailable(), SendPrimacyOptions(), OutputLevelRange(), soap() { }
        virtual ~tt__AudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1045 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (385)
/* complex XSD type 'tt:AudioDecoderConfigurationOptions': */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions {
      public:
        /// Optional element 'tt:AACDecOptions' of XSD type 'tt:AACDecOptions'
        tt__AACDecOptions *AACDecOptions;
        /// Optional element 'tt:G711DecOptions' of XSD type 'tt:G711DecOptions'
        tt__G711DecOptions *G711DecOptions;
        /// Optional element 'tt:G726DecOptions' of XSD type 'tt:G726DecOptions'
        tt__G726DecOptions *G726DecOptions;
        /// Optional element 'tt:Extension' of XSD type 'tt:AudioDecoderConfigurationOptionsExtension'
        tt__AudioDecoderConfigurationOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__AudioDecoderConfigurationOptions() : AACDecOptions(), G711DecOptions(), G726DecOptions(), Extension(), soap() { }
        virtual ~tt__AudioDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1048 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (386)
/* complex XSD type 'tt:G711DecOptions': */
class SOAP_CMAC tt__G711DecOptions {
      public:
        /// Required element 'tt:Bitrate' of XSD type 'tt:IntList'
        tt__IntList *Bitrate;
        /// Required element 'tt:SampleRateRange' of XSD type 'tt:IntList'
        tt__IntList *SampleRateRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__G711DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__G711DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
        virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__G711DecOptions); }
      public:
        /// Constructor with initializations
        tt__G711DecOptions() : Bitrate(), SampleRateRange(), soap() { }
        virtual ~tt__G711DecOptions() { }
        /// Friend allocator used by soap_new_tt__G711DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1051 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (387)
/* complex XSD type 'tt:AACDecOptions': */
class SOAP_CMAC tt__AACDecOptions {
      public:
        /// Required element 'tt:Bitrate' of XSD type 'tt:IntList'
        tt__IntList *Bitrate;
        /// Required element 'tt:SampleRateRange' of XSD type 'tt:IntList'
        tt__IntList *SampleRateRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AACDecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AACDecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
        virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AACDecOptions); }
      public:
        /// Constructor with initializations
        tt__AACDecOptions() : Bitrate(), SampleRateRange(), soap() { }
        virtual ~tt__AACDecOptions() { }
        /// Friend allocator used by soap_new_tt__AACDecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1054 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (388)
/* complex XSD type 'tt:G726DecOptions': */
class SOAP_CMAC tt__G726DecOptions {
      public:
        /// Required element 'tt:Bitrate' of XSD type 'tt:IntList'
        tt__IntList *Bitrate;
        /// Required element 'tt:SampleRateRange' of XSD type 'tt:IntList'
        tt__IntList *SampleRateRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__G726DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__G726DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
        virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__G726DecOptions); }
      public:
        /// Constructor with initializations
        tt__G726DecOptions() : Bitrate(), SampleRateRange(), soap() { }
        virtual ~tt__G726DecOptions() { }
        /// Friend allocator used by soap_new_tt__G726DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1057 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (389)
/* complex XSD type 'tt:AudioDecoderConfigurationOptionsExtension': */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__AudioDecoderConfigurationOptionsExtension() : soap() { }
        virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1060 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (390)
/* complex XSD type 'tt:MulticastConfiguration': */
class SOAP_CMAC tt__MulticastConfiguration {
      public:
        /// Required element 'tt:Address' of XSD type 'tt:IPAddress'
        tt__IPAddress *Address;
        /// Required element 'tt:Port' of XSD type 'xsd:int'
        int Port;
        /// Required element 'tt:TTL' of XSD type 'xsd:int'
        int TTL;
        /// Required element 'tt:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MulticastConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MulticastConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
        virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MulticastConfiguration); }
      public:
        /// Constructor with initializations
        tt__MulticastConfiguration() : Address(), Port(), TTL(), AutoStart(), soap() { }
        virtual ~tt__MulticastConfiguration() { }
        /// Friend allocator used by soap_new_tt__MulticastConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1063 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (391)
/* complex XSD type 'tt:StreamSetup': */
class SOAP_CMAC tt__StreamSetup {
      public:
        /// Required element 'tt:Stream' of XSD type 'tt:StreamType'
        enum tt__StreamType Stream;
        /// Required element 'tt:Transport' of XSD type 'tt:Transport'
        tt__Transport *Transport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__StreamSetup
        virtual long soap_type(void) const { return SOAP_TYPE_tt__StreamSetup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
        virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__StreamSetup); }
      public:
        /// Constructor with initializations
        tt__StreamSetup() : Stream(), Transport(), soap() { }
        virtual ~tt__StreamSetup() { }
        /// Friend allocator used by soap_new_tt__StreamSetup(struct soap*, int)
        friend SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1066 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (392)
/* Type tt__Transport is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:Transport': */
class SOAP_CMAC tt__Transport {
      public:
        /// Required element 'tt:Protocol' of XSD type 'tt:TransportProtocol'
        enum tt__TransportProtocol Protocol;
        /// Optional element 'tt:Tunnel' of XSD type 'tt:Transport'
        tt__Transport *Tunnel;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Transport
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Transport; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Transport, default initialized and not managed by a soap context
        virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Transport); }
      public:
        /// Constructor with initializations
        tt__Transport() : Protocol(), Tunnel(), soap() { }
        virtual ~tt__Transport() { }
        /// Friend allocator used by soap_new_tt__Transport(struct soap*, int)
        friend SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1069 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (393)
/* complex XSD type 'tt:MediaUri': */
class SOAP_CMAC tt__MediaUri {
      public:
        /// Required element 'tt:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// Required element 'tt:InvalidAfterConnect' of XSD type 'xsd:boolean'
        bool InvalidAfterConnect;
        /// Required element 'tt:InvalidAfterReboot' of XSD type 'xsd:boolean'
        bool InvalidAfterReboot;
        /// Required element 'tt:Timeout' of XSD type 'xsd:duration'
        std::string Timeout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaUri
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
        virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaUri); }
      public:
        /// Constructor with initializations
        tt__MediaUri() : Uri(), InvalidAfterConnect(), InvalidAfterReboot(), Timeout(), soap() { }
        virtual ~tt__MediaUri() { }
        /// Friend allocator used by soap_new_tt__MediaUri(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1072 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (394)
/* complex XSD type 'tt:Scope': */
class SOAP_CMAC tt__Scope {
      public:
        /// Required element 'tt:ScopeDef' of XSD type 'tt:ScopeDefinition'
        enum tt__ScopeDefinition ScopeDef;
        /// Required element 'tt:ScopeItem' of XSD type 'xsd:anyURI'
        std::string ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Scope
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Scope; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Scope, default initialized and not managed by a soap context
        virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Scope); }
      public:
        /// Constructor with initializations
        tt__Scope() : ScopeDef(), ScopeItem(), soap() { }
        virtual ~tt__Scope() { }
        /// Friend allocator used by soap_new_tt__Scope(struct soap*, int)
        friend SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1078 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (396)
/* complex XSD type 'tt:NetworkInterfaceExtension': */
class SOAP_CMAC tt__NetworkInterfaceExtension {
      public:
        /// Required element 'tt:InterfaceType' of XSD type 'tt:IANA-IfTypes'
        int InterfaceType;
        /// Optional element 'tt:Dot3' of XSD type 'tt:Dot3Configuration'
        std::vector<tt__Dot3Configuration *> Dot3;
        /// Optional element 'tt:Dot11' of XSD type 'tt:Dot11Configuration'
        std::vector<tt__Dot11Configuration *> Dot11;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkInterfaceExtension2'
        tt__NetworkInterfaceExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceExtension() : InterfaceType(), Dot3(), Dot11(), Extension(), soap() { }
        virtual ~tt__NetworkInterfaceExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1081 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (397)
/* complex XSD type 'tt:Dot3Configuration': */
class SOAP_CMAC tt__Dot3Configuration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot3Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot3Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
        virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot3Configuration); }
      public:
        /// Constructor with initializations
        tt__Dot3Configuration() : soap() { }
        virtual ~tt__Dot3Configuration() { }
        /// Friend allocator used by soap_new_tt__Dot3Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1084 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (398)
/* complex XSD type 'tt:NetworkInterfaceExtension2': */
class SOAP_CMAC tt__NetworkInterfaceExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceExtension2); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceExtension2() : soap() { }
        virtual ~tt__NetworkInterfaceExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1087 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (399)
/* complex XSD type 'tt:NetworkInterfaceLink': */
class SOAP_CMAC tt__NetworkInterfaceLink {
      public:
        /// Required element 'tt:AdminSettings' of XSD type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *AdminSettings;
        /// Required element 'tt:OperSettings' of XSD type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *OperSettings;
        /// Required element 'tt:InterfaceType' of XSD type 'tt:IANA-IfTypes'
        int InterfaceType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceLink
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceLink); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceLink() : AdminSettings(), OperSettings(), InterfaceType(), soap() { }
        virtual ~tt__NetworkInterfaceLink() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceLink(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1090 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (400)
/* complex XSD type 'tt:NetworkInterfaceConnectionSetting': */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting {
      public:
        /// Required element 'tt:AutoNegotiation' of XSD type 'xsd:boolean'
        bool AutoNegotiation;
        /// Required element 'tt:Speed' of XSD type 'xsd:int'
        int Speed;
        /// Required element 'tt:Duplex' of XSD type 'tt:Duplex'
        enum tt__Duplex Duplex;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceConnectionSetting; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceConnectionSetting); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceConnectionSetting() : AutoNegotiation(), Speed(), Duplex(), soap() { }
        virtual ~tt__NetworkInterfaceConnectionSetting() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceConnectionSetting(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1093 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (401)
/* complex XSD type 'tt:NetworkInterfaceInfo': */
class SOAP_CMAC tt__NetworkInterfaceInfo {
      public:
        /// Optional element 'tt:Name' of XSD type 'xsd:string'
        std::string *Name;
        /// Required element 'tt:HwAddress' of XSD type 'tt:HwAddress'
        std::string HwAddress;
        /// Optional element 'tt:MTU' of XSD type 'xsd:int'
        int *MTU;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceInfo
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceInfo); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceInfo() : Name(), HwAddress(), MTU(), soap() { }
        virtual ~tt__NetworkInterfaceInfo() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceInfo(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1096 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (402)
/* complex XSD type 'tt:IPv6NetworkInterface': */
class SOAP_CMAC tt__IPv6NetworkInterface {
      public:
        /// Required element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Config' of XSD type 'tt:IPv6Configuration'
        tt__IPv6Configuration *Config;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
        virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6NetworkInterface); }
      public:
        /// Constructor with initializations
        tt__IPv6NetworkInterface() : Enabled(), Config(), soap() { }
        virtual ~tt__IPv6NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__IPv6NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1099 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (403)
/* complex XSD type 'tt:IPv4NetworkInterface': */
class SOAP_CMAC tt__IPv4NetworkInterface {
      public:
        /// Required element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tt:Config' of XSD type 'tt:IPv4Configuration'
        tt__IPv4Configuration *Config;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
        virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4NetworkInterface); }
      public:
        /// Constructor with initializations
        tt__IPv4NetworkInterface() : Enabled(), Config(), soap() { }
        virtual ~tt__IPv4NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__IPv4NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1102 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (404)
/* complex XSD type 'tt:IPv4Configuration': */
class SOAP_CMAC tt__IPv4Configuration {
      public:
        /// Optional element 'tt:Manual' of XSD type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> Manual;
        /// Optional element 'tt:LinkLocal' of XSD type 'tt:PrefixedIPv4Address'
        tt__PrefixedIPv4Address *LinkLocal;
        /// Optional element 'tt:FromDHCP' of XSD type 'tt:PrefixedIPv4Address'
        tt__PrefixedIPv4Address *FromDHCP;
        /// Required element 'tt:DHCP' of XSD type 'xsd:boolean'
        bool DHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
        virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4Configuration); }
      public:
        /// Constructor with initializations
        tt__IPv4Configuration() : Manual(), LinkLocal(), FromDHCP(), DHCP(), soap() { }
        virtual ~tt__IPv4Configuration() { }
        /// Friend allocator used by soap_new_tt__IPv4Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1105 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (405)
/* complex XSD type 'tt:IPv6Configuration': */
class SOAP_CMAC tt__IPv6Configuration {
      public:
        /// Optional element 'tt:AcceptRouterAdvert' of XSD type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Required element 'tt:DHCP' of XSD type 'tt:IPv6DHCPConfiguration'
        enum tt__IPv6DHCPConfiguration DHCP;
        /// Optional element 'tt:Manual' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> Manual;
        /// Optional element 'tt:LinkLocal' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> LinkLocal;
        /// Optional element 'tt:FromDHCP' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> FromDHCP;
        /// Optional element 'tt:FromRA' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> FromRA;
        /// Optional element 'tt:Extension' of XSD type 'tt:IPv6ConfigurationExtension'
        tt__IPv6ConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
        virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6Configuration); }
      public:
        /// Constructor with initializations
        tt__IPv6Configuration() : AcceptRouterAdvert(), DHCP(), Manual(), LinkLocal(), FromDHCP(), FromRA(), Extension(), soap() { }
        virtual ~tt__IPv6Configuration() { }
        /// Friend allocator used by soap_new_tt__IPv6Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1108 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (406)
/* complex XSD type 'tt:IPv6ConfigurationExtension': */
class SOAP_CMAC tt__IPv6ConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6ConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6ConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6ConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__IPv6ConfigurationExtension() : soap() { }
        virtual ~tt__IPv6ConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__IPv6ConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1111 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (407)
/* complex XSD type 'tt:NetworkProtocol': */
class SOAP_CMAC tt__NetworkProtocol {
      public:
        /// Required element 'tt:Name' of XSD type 'tt:NetworkProtocolType'
        enum tt__NetworkProtocolType Name;
        /// Required element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tt:Port' of XSD type 'xsd:int'
        std::vector<int> Port;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkProtocolExtension'
        tt__NetworkProtocolExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkProtocol
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkProtocol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
        virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkProtocol); }
      public:
        /// Constructor with initializations
        tt__NetworkProtocol() : Name(), Enabled(), Port(), Extension(), soap() { }
        virtual ~tt__NetworkProtocol() { }
        /// Friend allocator used by soap_new_tt__NetworkProtocol(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1114 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (408)
/* complex XSD type 'tt:NetworkProtocolExtension': */
class SOAP_CMAC tt__NetworkProtocolExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkProtocolExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkProtocolExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
        virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkProtocolExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkProtocolExtension() : soap() { }
        virtual ~tt__NetworkProtocolExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkProtocolExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1117 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (409)
/* complex XSD type 'tt:NetworkHost': */
class SOAP_CMAC tt__NetworkHost {
      public:
        /// Required element 'tt:Type' of XSD type 'tt:NetworkHostType'
        enum tt__NetworkHostType Type;
        /// Optional element 'tt:IPv4Address' of XSD type 'tt:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'tt:IPv6Address' of XSD type 'tt:IPv6Address'
        std::string *IPv6Address;
        /// Optional element 'tt:DNSname' of XSD type 'tt:DNSName'
        std::string *DNSname;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkHostExtension'
        tt__NetworkHostExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkHost
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkHost; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
        virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkHost); }
      public:
        /// Constructor with initializations
        tt__NetworkHost() : Type(), IPv4Address(), IPv6Address(), DNSname(), Extension(), soap() { }
        virtual ~tt__NetworkHost() { }
        /// Friend allocator used by soap_new_tt__NetworkHost(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1120 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (410)
/* complex XSD type 'tt:NetworkHostExtension': */
class SOAP_CMAC tt__NetworkHostExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkHostExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkHostExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
        virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkHostExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkHostExtension() : soap() { }
        virtual ~tt__NetworkHostExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkHostExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1123 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (411)
/* complex XSD type 'tt:IPAddress': */
class SOAP_CMAC tt__IPAddress {
      public:
        /// Required element 'tt:Type' of XSD type 'tt:IPType'
        enum tt__IPType Type;
        /// Optional element 'tt:IPv4Address' of XSD type 'tt:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'tt:IPv6Address' of XSD type 'tt:IPv6Address'
        std::string *IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddress
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
        virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddress); }
      public:
        /// Constructor with initializations
        tt__IPAddress() : Type(), IPv4Address(), IPv6Address(), soap() { }
        virtual ~tt__IPAddress() { }
        /// Friend allocator used by soap_new_tt__IPAddress(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1126 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (412)
/* complex XSD type 'tt:PrefixedIPv4Address': */
class SOAP_CMAC tt__PrefixedIPv4Address {
      public:
        /// Required element 'tt:Address' of XSD type 'tt:IPv4Address'
        std::string Address;
        /// Required element 'tt:PrefixLength' of XSD type 'xsd:int'
        int PrefixLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PrefixedIPv4Address
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PrefixedIPv4Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
        virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PrefixedIPv4Address); }
      public:
        /// Constructor with initializations
        tt__PrefixedIPv4Address() : Address(), PrefixLength(), soap() { }
        virtual ~tt__PrefixedIPv4Address() { }
        /// Friend allocator used by soap_new_tt__PrefixedIPv4Address(struct soap*, int)
        friend SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1129 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (413)
/* complex XSD type 'tt:PrefixedIPv6Address': */
class SOAP_CMAC tt__PrefixedIPv6Address {
      public:
        /// Required element 'tt:Address' of XSD type 'tt:IPv6Address'
        std::string Address;
        /// Required element 'tt:PrefixLength' of XSD type 'xsd:int'
        int PrefixLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PrefixedIPv6Address
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PrefixedIPv6Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
        virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PrefixedIPv6Address); }
      public:
        /// Constructor with initializations
        tt__PrefixedIPv6Address() : Address(), PrefixLength(), soap() { }
        virtual ~tt__PrefixedIPv6Address() { }
        /// Friend allocator used by soap_new_tt__PrefixedIPv6Address(struct soap*, int)
        friend SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1132 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (414)
/* complex XSD type 'tt:HostnameInformation': */
class SOAP_CMAC tt__HostnameInformation {
      public:
        /// Required element 'tt:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:Name' of XSD type 'xsd:token'
        std::string *Name;
        /// Optional element 'tt:Extension' of XSD type 'tt:HostnameInformationExtension'
        tt__HostnameInformationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__HostnameInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__HostnameInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
        virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__HostnameInformation); }
      public:
        /// Constructor with initializations
        tt__HostnameInformation() : FromDHCP(), Name(), Extension(), soap() { }
        virtual ~tt__HostnameInformation() { }
        /// Friend allocator used by soap_new_tt__HostnameInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1135 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (415)
/* complex XSD type 'tt:HostnameInformationExtension': */
class SOAP_CMAC tt__HostnameInformationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__HostnameInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__HostnameInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
        virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__HostnameInformationExtension); }
      public:
        /// Constructor with initializations
        tt__HostnameInformationExtension() : soap() { }
        virtual ~tt__HostnameInformationExtension() { }
        /// Friend allocator used by soap_new_tt__HostnameInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1138 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (416)
/* complex XSD type 'tt:DNSInformation': */
class SOAP_CMAC tt__DNSInformation {
      public:
        /// Required element 'tt:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:SearchDomain' of XSD type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'tt:DNSFromDHCP' of XSD type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSFromDHCP;
        /// Optional element 'tt:DNSManual' of XSD type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSManual;
        /// Optional element 'tt:Extension' of XSD type 'tt:DNSInformationExtension'
        tt__DNSInformationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DNSInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
        virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DNSInformation); }
      public:
        /// Constructor with initializations
        tt__DNSInformation() : FromDHCP(), SearchDomain(), DNSFromDHCP(), DNSManual(), Extension(), soap() { }
        virtual ~tt__DNSInformation() { }
        /// Friend allocator used by soap_new_tt__DNSInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1141 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (417)
/* complex XSD type 'tt:DNSInformationExtension': */
class SOAP_CMAC tt__DNSInformationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DNSInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
        virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DNSInformationExtension); }
      public:
        /// Constructor with initializations
        tt__DNSInformationExtension() : soap() { }
        virtual ~tt__DNSInformationExtension() { }
        /// Friend allocator used by soap_new_tt__DNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1144 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (418)
/* complex XSD type 'tt:NTPInformation': */
class SOAP_CMAC tt__NTPInformation {
      public:
        /// Required element 'tt:FromDHCP' of XSD type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:NTPFromDHCP' of XSD type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPFromDHCP;
        /// Optional element 'tt:NTPManual' of XSD type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPManual;
        /// Optional element 'tt:Extension' of XSD type 'tt:NTPInformationExtension'
        tt__NTPInformationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NTPInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NTPInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
        virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NTPInformation); }
      public:
        /// Constructor with initializations
        tt__NTPInformation() : FromDHCP(), NTPFromDHCP(), NTPManual(), Extension(), soap() { }
        virtual ~tt__NTPInformation() { }
        /// Friend allocator used by soap_new_tt__NTPInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1147 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (419)
/* complex XSD type 'tt:NTPInformationExtension': */
class SOAP_CMAC tt__NTPInformationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NTPInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NTPInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
        virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NTPInformationExtension); }
      public:
        /// Constructor with initializations
        tt__NTPInformationExtension() : soap() { }
        virtual ~tt__NTPInformationExtension() { }
        /// Friend allocator used by soap_new_tt__NTPInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1150 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (420)
/* complex XSD type 'tt:DynamicDNSInformation': */
class SOAP_CMAC tt__DynamicDNSInformation {
      public:
        /// Required element 'tt:Type' of XSD type 'tt:DynamicDNSType'
        enum tt__DynamicDNSType Type;
        /// Optional element 'tt:Name' of XSD type 'tt:DNSName'
        std::string *Name;
        /// Optional element 'tt:TTL' of XSD type 'xsd:duration'
        std::string *TTL;
        /// Optional element 'tt:Extension' of XSD type 'tt:DynamicDNSInformationExtension'
        tt__DynamicDNSInformationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DynamicDNSInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DynamicDNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
        virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DynamicDNSInformation); }
      public:
        /// Constructor with initializations
        tt__DynamicDNSInformation() : Type(), Name(), TTL(), Extension(), soap() { }
        virtual ~tt__DynamicDNSInformation() { }
        /// Friend allocator used by soap_new_tt__DynamicDNSInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1153 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (421)
/* complex XSD type 'tt:DynamicDNSInformationExtension': */
class SOAP_CMAC tt__DynamicDNSInformationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DynamicDNSInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DynamicDNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
        virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DynamicDNSInformationExtension); }
      public:
        /// Constructor with initializations
        tt__DynamicDNSInformationExtension() : soap() { }
        virtual ~tt__DynamicDNSInformationExtension() { }
        /// Friend allocator used by soap_new_tt__DynamicDNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1156 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (422)
/* complex XSD type 'tt:NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:Link' of XSD type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *Link;
        /// Optional element 'tt:MTU' of XSD type 'xsd:int'
        int *MTU;
        /// Optional element 'tt:IPv4' of XSD type 'tt:IPv4NetworkInterfaceSetConfiguration'
        tt__IPv4NetworkInterfaceSetConfiguration *IPv4;
        /// Optional element 'tt:IPv6' of XSD type 'tt:IPv6NetworkInterfaceSetConfiguration'
        tt__IPv6NetworkInterfaceSetConfiguration *IPv6;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkInterfaceSetConfigurationExtension'
        tt__NetworkInterfaceSetConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceSetConfiguration() : Enabled(), Link(), MTU(), IPv4(), IPv6(), Extension(), soap() { }
        virtual ~tt__NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1159 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (423)
/* complex XSD type 'tt:NetworkInterfaceSetConfigurationExtension': */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension {
      public:
        /// Optional element 'tt:Dot3' of XSD type 'tt:Dot3Configuration'
        std::vector<tt__Dot3Configuration *> Dot3;
        /// Optional element 'tt:Dot11' of XSD type 'tt:Dot11Configuration'
        std::vector<tt__Dot11Configuration *> Dot11;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkInterfaceSetConfigurationExtension2'
        tt__NetworkInterfaceSetConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceSetConfigurationExtension() : Dot3(), Dot11(), Extension(), soap() { }
        virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1162 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (424)
/* complex XSD type 'tt:IPv6NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:AcceptRouterAdvert' of XSD type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Optional element 'tt:Manual' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> Manual;
        /// Optional element 'tt:DHCP' of XSD type 'tt:IPv6DHCPConfiguration'
        enum tt__IPv6DHCPConfiguration *DHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        tt__IPv6NetworkInterfaceSetConfiguration() : Enabled(), AcceptRouterAdvert(), Manual(), DHCP(), soap() { }
        virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1165 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (425)
/* complex XSD type 'tt:IPv4NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration {
      public:
        /// Optional element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:Manual' of XSD type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> Manual;
        /// Optional element 'tt:DHCP' of XSD type 'xsd:boolean'
        bool *DHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with initializations
        tt__IPv4NetworkInterfaceSetConfiguration() : Enabled(), Manual(), DHCP(), soap() { }
        virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1168 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (426)
/* complex XSD type 'tt:NetworkGateway': */
class SOAP_CMAC tt__NetworkGateway {
      public:
        /// Optional element 'tt:IPv4Address' of XSD type 'tt:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'tt:IPv6Address' of XSD type 'tt:IPv6Address'
        std::vector<std::string> IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkGateway
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
        virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkGateway); }
      public:
        /// Constructor with initializations
        tt__NetworkGateway() : IPv4Address(), IPv6Address(), soap() { }
        virtual ~tt__NetworkGateway() { }
        /// Friend allocator used by soap_new_tt__NetworkGateway(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1171 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (427)
/* complex XSD type 'tt:NetworkZeroConfiguration': */
class SOAP_CMAC tt__NetworkZeroConfiguration {
      public:
        /// Required element 'tt:InterfaceToken' of XSD type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Addresses' of XSD type 'tt:IPv4Address'
        std::vector<std::string> Addresses;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkZeroConfigurationExtension'
        tt__NetworkZeroConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfiguration); }
      public:
        /// Constructor with initializations
        tt__NetworkZeroConfiguration() : InterfaceToken(), Enabled(), Addresses(), Extension(), soap() { }
        virtual ~tt__NetworkZeroConfiguration() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1174 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (428)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:NetworkZeroConfigurationExtension': */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension {
      public:
        /// Optional element 'tt:Additional' of XSD type 'tt:NetworkZeroConfiguration'
        std::vector<tt__NetworkZeroConfiguration *> Additional;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkZeroConfigurationExtension2'
        tt__NetworkZeroConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkZeroConfigurationExtension() : Additional(), Extension(), soap() { }
        virtual ~tt__NetworkZeroConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1177 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (429)
/* complex XSD type 'tt:NetworkZeroConfigurationExtension2': */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfigurationExtension2); }
      public:
        /// Constructor with initializations
        tt__NetworkZeroConfigurationExtension2() : soap() { }
        virtual ~tt__NetworkZeroConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1180 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (430)
/* complex XSD type 'tt:IPAddressFilter': */
class SOAP_CMAC tt__IPAddressFilter {
      public:
        /// Required element 'tt:Type' of XSD type 'tt:IPAddressFilterType'
        enum tt__IPAddressFilterType Type;
        /// Optional element 'tt:IPv4Address' of XSD type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> IPv4Address;
        /// Optional element 'tt:IPv6Address' of XSD type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> IPv6Address;
        /// Optional element 'tt:Extension' of XSD type 'tt:IPAddressFilterExtension'
        tt__IPAddressFilterExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
        virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddressFilter); }
      public:
        /// Constructor with initializations
        tt__IPAddressFilter() : Type(), IPv4Address(), IPv6Address(), Extension(), soap() { }
        virtual ~tt__IPAddressFilter() { }
        /// Friend allocator used by soap_new_tt__IPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1183 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (431)
/* complex XSD type 'tt:IPAddressFilterExtension': */
class SOAP_CMAC tt__IPAddressFilterExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddressFilterExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddressFilterExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
        virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddressFilterExtension); }
      public:
        /// Constructor with initializations
        tt__IPAddressFilterExtension() : soap() { }
        virtual ~tt__IPAddressFilterExtension() { }
        /// Friend allocator used by soap_new_tt__IPAddressFilterExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1186 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (432)
/* complex XSD type 'tt:Dot11Configuration': */
class SOAP_CMAC tt__Dot11Configuration {
      public:
        /// Required element 'tt:SSID' of XSD type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Required element 'tt:Mode' of XSD type 'tt:Dot11StationMode'
        enum tt__Dot11StationMode Mode;
        /// Required element 'tt:Alias' of XSD type 'tt:Name'
        std::string Alias;
        /// Required element 'tt:Priority' of XSD type 'tt:NetworkInterfaceConfigPriority'
        std::string Priority;
        /// Required element 'tt:Security' of XSD type 'tt:Dot11SecurityConfiguration'
        tt__Dot11SecurityConfiguration *Security;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
        virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Configuration); }
      public:
        /// Constructor with initializations
        tt__Dot11Configuration() : SSID(), Mode(), Alias(), Priority(), Security(), soap() { }
        virtual ~tt__Dot11Configuration() { }
        /// Friend allocator used by soap_new_tt__Dot11Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1189 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (433)
/* complex XSD type 'tt:Dot11SecurityConfiguration': */
class SOAP_CMAC tt__Dot11SecurityConfiguration {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:Dot11SecurityMode'
        enum tt__Dot11SecurityMode Mode;
        /// Optional element 'tt:Algorithm' of XSD type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *Algorithm;
        /// Optional element 'tt:PSK' of XSD type 'tt:Dot11PSKSet'
        tt__Dot11PSKSet *PSK;
        /// Optional element 'tt:Dot1X' of XSD type 'tt:ReferenceToken'
        std::string *Dot1X;
        /// Optional element 'tt:Extension' of XSD type 'tt:Dot11SecurityConfigurationExtension'
        tt__Dot11SecurityConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SecurityConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SecurityConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
        virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SecurityConfiguration); }
      public:
        /// Constructor with initializations
        tt__Dot11SecurityConfiguration() : Mode(), Algorithm(), PSK(), Dot1X(), Extension(), soap() { }
        virtual ~tt__Dot11SecurityConfiguration() { }
        /// Friend allocator used by soap_new_tt__Dot11SecurityConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1192 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (434)
/* complex XSD type 'tt:Dot11SecurityConfigurationExtension': */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SecurityConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SecurityConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__Dot11SecurityConfigurationExtension() : soap() { }
        virtual ~tt__Dot11SecurityConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11SecurityConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1195 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (435)
/* complex XSD type 'tt:Dot11PSKSet': */
class SOAP_CMAC tt__Dot11PSKSet {
      public:
        /// Optional element 'tt:Key' of XSD type 'tt:Dot11PSK'
        xsd__hexBinary *Key;
        /// Optional element 'tt:Passphrase' of XSD type 'tt:Dot11PSKPassphrase'
        std::string *Passphrase;
        /// Optional element 'tt:Extension' of XSD type 'tt:Dot11PSKSetExtension'
        tt__Dot11PSKSetExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSKSet
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSKSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
        virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSKSet); }
      public:
        /// Constructor with initializations
        tt__Dot11PSKSet() : Key(), Passphrase(), Extension(), soap() { }
        virtual ~tt__Dot11PSKSet() { }
        /// Friend allocator used by soap_new_tt__Dot11PSKSet(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1198 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (436)
/* complex XSD type 'tt:Dot11PSKSetExtension': */
class SOAP_CMAC tt__Dot11PSKSetExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSKSetExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSKSetExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
        virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSKSetExtension); }
      public:
        /// Constructor with initializations
        tt__Dot11PSKSetExtension() : soap() { }
        virtual ~tt__Dot11PSKSetExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11PSKSetExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1201 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (437)
/* complex XSD type 'tt:NetworkInterfaceSetConfigurationExtension2': */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfigurationExtension2); }
      public:
        /// Constructor with initializations
        tt__NetworkInterfaceSetConfigurationExtension2() : soap() { }
        virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1204 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (438)
/* complex XSD type 'tt:Dot11Capabilities': */
class SOAP_CMAC tt__Dot11Capabilities {
      public:
        /// Required element 'tt:TKIP' of XSD type 'xsd:boolean'
        bool TKIP;
        /// Required element 'tt:ScanAvailableNetworks' of XSD type 'xsd:boolean'
        bool ScanAvailableNetworks;
        /// Required element 'tt:MultipleConfiguration' of XSD type 'xsd:boolean'
        bool MultipleConfiguration;
        /// Required element 'tt:AdHocStationMode' of XSD type 'xsd:boolean'
        bool AdHocStationMode;
        /// Required element 'tt:WEP' of XSD type 'xsd:boolean'
        bool WEP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
        virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Capabilities); }
      public:
        /// Constructor with initializations
        tt__Dot11Capabilities() : TKIP(), ScanAvailableNetworks(), MultipleConfiguration(), AdHocStationMode(), WEP(), soap() { }
        virtual ~tt__Dot11Capabilities() { }
        /// Friend allocator used by soap_new_tt__Dot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1207 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (439)
/* complex XSD type 'tt:Dot11Status': */
class SOAP_CMAC tt__Dot11Status {
      public:
        /// Required element 'tt:SSID' of XSD type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'tt:BSSID' of XSD type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'tt:PairCipher' of XSD type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *PairCipher;
        /// Optional element 'tt:GroupCipher' of XSD type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *GroupCipher;
        /// Optional element 'tt:SignalStrength' of XSD type 'tt:Dot11SignalStrength'
        enum tt__Dot11SignalStrength *SignalStrength;
        /// Required element 'tt:ActiveConfigAlias' of XSD type 'tt:ReferenceToken'
        std::string ActiveConfigAlias;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Status
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
        virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Status); }
      public:
        /// Constructor with initializations
        tt__Dot11Status() : SSID(), BSSID(), PairCipher(), GroupCipher(), SignalStrength(), ActiveConfigAlias(), soap() { }
        virtual ~tt__Dot11Status() { }
        /// Friend allocator used by soap_new_tt__Dot11Status(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1210 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (440)
/* complex XSD type 'tt:Dot11AvailableNetworks': */
class SOAP_CMAC tt__Dot11AvailableNetworks {
      public:
        /// Required element 'tt:SSID' of XSD type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'tt:BSSID' of XSD type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'tt:AuthAndMangementSuite' of XSD type 'tt:Dot11AuthAndMangementSuite'
        std::vector<enum tt__Dot11AuthAndMangementSuite> AuthAndMangementSuite;
        /// Optional element 'tt:PairCipher' of XSD type 'tt:Dot11Cipher'
        std::vector<enum tt__Dot11Cipher> PairCipher;
        /// Optional element 'tt:GroupCipher' of XSD type 'tt:Dot11Cipher'
        std::vector<enum tt__Dot11Cipher> GroupCipher;
        /// Optional element 'tt:SignalStrength' of XSD type 'tt:Dot11SignalStrength'
        enum tt__Dot11SignalStrength *SignalStrength;
        /// Optional element 'tt:Extension' of XSD type 'tt:Dot11AvailableNetworksExtension'
        tt__Dot11AvailableNetworksExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11AvailableNetworks
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11AvailableNetworks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
        virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11AvailableNetworks); }
      public:
        /// Constructor with initializations
        tt__Dot11AvailableNetworks() : SSID(), BSSID(), AuthAndMangementSuite(), PairCipher(), GroupCipher(), SignalStrength(), Extension(), soap() { }
        virtual ~tt__Dot11AvailableNetworks() { }
        /// Friend allocator used by soap_new_tt__Dot11AvailableNetworks(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1213 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (441)
/* complex XSD type 'tt:Dot11AvailableNetworksExtension': */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11AvailableNetworksExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11AvailableNetworksExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
        virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11AvailableNetworksExtension); }
      public:
        /// Constructor with initializations
        tt__Dot11AvailableNetworksExtension() : soap() { }
        virtual ~tt__Dot11AvailableNetworksExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11AvailableNetworksExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1216 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (442)
/* complex XSD type 'tt:Capabilities': */
class SOAP_CMAC tt__Capabilities {
      public:
        /// Optional element 'tt:Analytics' of XSD type 'tt:AnalyticsCapabilities'
        tt__AnalyticsCapabilities *Analytics;
        /// Optional element 'tt:Device' of XSD type 'tt:DeviceCapabilities'
        tt__DeviceCapabilities *Device;
        /// Optional element 'tt:Events' of XSD type 'tt:EventCapabilities'
        tt__EventCapabilities *Events;
        /// Optional element 'tt:Imaging' of XSD type 'tt:ImagingCapabilities'
        tt__ImagingCapabilities *Imaging;
        /// Optional element 'tt:Media' of XSD type 'tt:MediaCapabilities'
        tt__MediaCapabilities *Media;
        /// Optional element 'tt:PTZ' of XSD type 'tt:PTZCapabilities'
        tt__PTZCapabilities *PTZ;
        /// Optional element 'tt:Extension' of XSD type 'tt:CapabilitiesExtension'
        tt__CapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
        virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Capabilities); }
      public:
        /// Constructor with initializations
        tt__Capabilities() : Analytics(), Device(), Events(), Imaging(), Media(), PTZ(), Extension(), soap() { }
        virtual ~tt__Capabilities() { }
        /// Friend allocator used by soap_new_tt__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1219 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (443)
/* complex XSD type 'tt:CapabilitiesExtension': */
class SOAP_CMAC tt__CapabilitiesExtension {
      public:
        /// Optional element 'tt:DeviceIO' of XSD type 'tt:DeviceIOCapabilities'
        tt__DeviceIOCapabilities *DeviceIO;
        /// Optional element 'tt:Display' of XSD type 'tt:DisplayCapabilities'
        tt__DisplayCapabilities *Display;
        /// Optional element 'tt:Recording' of XSD type 'tt:RecordingCapabilities'
        tt__RecordingCapabilities *Recording;
        /// Optional element 'tt:Search' of XSD type 'tt:SearchCapabilities'
        tt__SearchCapabilities *Search;
        /// Optional element 'tt:Replay' of XSD type 'tt:ReplayCapabilities'
        tt__ReplayCapabilities *Replay;
        /// Optional element 'tt:Receiver' of XSD type 'tt:ReceiverCapabilities'
        tt__ReceiverCapabilities *Receiver;
        /// Optional element 'tt:AnalyticsDevice' of XSD type 'tt:AnalyticsDeviceCapabilities'
        tt__AnalyticsDeviceCapabilities *AnalyticsDevice;
        /// Optional element 'tt:Extensions' of XSD type 'tt:CapabilitiesExtension2'
        tt__CapabilitiesExtension2 *Extensions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__CapabilitiesExtension() : DeviceIO(), Display(), Recording(), Search(), Replay(), Receiver(), AnalyticsDevice(), Extensions(), soap() { }
        virtual ~tt__CapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__CapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1222 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (444)
/* complex XSD type 'tt:CapabilitiesExtension2': */
class SOAP_CMAC tt__CapabilitiesExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        tt__CapabilitiesExtension2() : soap() { }
        virtual ~tt__CapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__CapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1225 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (445)
/* complex XSD type 'tt:AnalyticsCapabilities': */
class SOAP_CMAC tt__AnalyticsCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:RuleSupport' of XSD type 'xsd:boolean'
        bool RuleSupport;
        /// Required element 'tt:AnalyticsModuleSupport' of XSD type 'xsd:boolean'
        bool AnalyticsModuleSupport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
        virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsCapabilities); }
      public:
        /// Constructor with initializations
        tt__AnalyticsCapabilities() : XAddr(), RuleSupport(), AnalyticsModuleSupport(), soap() { }
        virtual ~tt__AnalyticsCapabilities() { }
        /// Friend allocator used by soap_new_tt__AnalyticsCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1228 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (446)
/* complex XSD type 'tt:DeviceCapabilities': */
class SOAP_CMAC tt__DeviceCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tt:Network' of XSD type 'tt:NetworkCapabilities'
        tt__NetworkCapabilities *Network;
        /// Optional element 'tt:System' of XSD type 'tt:SystemCapabilities'
        tt__SystemCapabilities *System;
        /// Optional element 'tt:IO' of XSD type 'tt:IOCapabilities'
        tt__IOCapabilities *IO;
        /// Optional element 'tt:Security' of XSD type 'tt:SecurityCapabilities'
        tt__SecurityCapabilities *Security;
        /// Optional element 'tt:Extension' of XSD type 'tt:DeviceCapabilitiesExtension'
        tt__DeviceCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
        virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceCapabilities); }
      public:
        /// Constructor with initializations
        tt__DeviceCapabilities() : XAddr(), Network(), System(), IO(), Security(), Extension(), soap() { }
        virtual ~tt__DeviceCapabilities() { }
        /// Friend allocator used by soap_new_tt__DeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1231 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (447)
/* complex XSD type 'tt:DeviceCapabilitiesExtension': */
class SOAP_CMAC tt__DeviceCapabilitiesExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__DeviceCapabilitiesExtension() : soap() { }
        virtual ~tt__DeviceCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__DeviceCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1234 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (448)
/* complex XSD type 'tt:EventCapabilities': */
class SOAP_CMAC tt__EventCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:WSSubscriptionPolicySupport' of XSD type 'xsd:boolean'
        bool WSSubscriptionPolicySupport;
        /// Required element 'tt:WSPullPointSupport' of XSD type 'xsd:boolean'
        bool WSPullPointSupport;
        /// Required element 'tt:WSPausableSubscriptionManagerInterfaceSupport' of XSD type 'xsd:boolean'
        bool WSPausableSubscriptionManagerInterfaceSupport;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
        virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventCapabilities); }
      public:
        /// Constructor with initializations
        tt__EventCapabilities() : XAddr(), WSSubscriptionPolicySupport(), WSPullPointSupport(), WSPausableSubscriptionManagerInterfaceSupport(), soap() { }
        virtual ~tt__EventCapabilities() { }
        /// Friend allocator used by soap_new_tt__EventCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1237 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (449)
/* complex XSD type 'tt:IOCapabilities': */
class SOAP_CMAC tt__IOCapabilities {
      public:
        /// Optional element 'tt:InputConnectors' of XSD type 'xsd:int'
        int *InputConnectors;
        /// Optional element 'tt:RelayOutputs' of XSD type 'xsd:int'
        int *RelayOutputs;
        /// Optional element 'tt:Extension' of XSD type 'tt:IOCapabilitiesExtension'
        tt__IOCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
        virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilities); }
      public:
        /// Constructor with initializations
        tt__IOCapabilities() : InputConnectors(), RelayOutputs(), Extension(), soap() { }
        virtual ~tt__IOCapabilities() { }
        /// Friend allocator used by soap_new_tt__IOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1240 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (450)
/* complex XSD type 'tt:IOCapabilitiesExtension': */
class SOAP_CMAC tt__IOCapabilitiesExtension {
      public:
        /// Optional element 'tt:Auxiliary' of XSD type 'xsd:boolean'
        bool *Auxiliary;
        /// Optional element 'tt:AuxiliaryCommands' of XSD type 'tt:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Required element 'tt:Extension' of XSD type 'tt:IOCapabilitiesExtension2'
        tt__IOCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__IOCapabilitiesExtension() : Auxiliary(), AuxiliaryCommands(), Extension(), soap() { }
        virtual ~tt__IOCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__IOCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1243 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (451)
/* complex XSD type 'tt:IOCapabilitiesExtension2': */
class SOAP_CMAC tt__IOCapabilitiesExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        tt__IOCapabilitiesExtension2() : soap() { }
        virtual ~tt__IOCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__IOCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1246 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (452)
/* complex XSD type 'tt:MediaCapabilities': */
class SOAP_CMAC tt__MediaCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:StreamingCapabilities' of XSD type 'tt:RealTimeStreamingCapabilities'
        tt__RealTimeStreamingCapabilities *StreamingCapabilities;
        /// Optional element 'tt:Extension' of XSD type 'tt:MediaCapabilitiesExtension'
        tt__MediaCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
        virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaCapabilities); }
      public:
        /// Constructor with initializations
        tt__MediaCapabilities() : XAddr(), StreamingCapabilities(), Extension(), soap() { }
        virtual ~tt__MediaCapabilities() { }
        /// Friend allocator used by soap_new_tt__MediaCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1249 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (453)
/* complex XSD type 'tt:MediaCapabilitiesExtension': */
class SOAP_CMAC tt__MediaCapabilitiesExtension {
      public:
        /// Required element 'tt:ProfileCapabilities' of XSD type 'tt:ProfileCapabilities'
        tt__ProfileCapabilities *ProfileCapabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__MediaCapabilitiesExtension() : ProfileCapabilities(), soap() { }
        virtual ~tt__MediaCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__MediaCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1252 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (454)
/* complex XSD type 'tt:RealTimeStreamingCapabilities': */
class SOAP_CMAC tt__RealTimeStreamingCapabilities {
      public:
        /// Optional element 'tt:RTPMulticast' of XSD type 'xsd:boolean'
        bool *RTPMulticast;
        /// Optional element 'tt:RTP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORETCP;
        /// Optional element 'tt:RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// Optional element 'tt:Extension' of XSD type 'tt:RealTimeStreamingCapabilitiesExtension'
        tt__RealTimeStreamingCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RealTimeStreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
        virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RealTimeStreamingCapabilities); }
      public:
        /// Constructor with initializations
        tt__RealTimeStreamingCapabilities() : RTPMulticast(), RTP_USCORETCP(), RTP_USCORERTSP_USCORETCP(), Extension(), soap() { }
        virtual ~tt__RealTimeStreamingCapabilities() { }
        /// Friend allocator used by soap_new_tt__RealTimeStreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1255 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (455)
/* complex XSD type 'tt:RealTimeStreamingCapabilitiesExtension': */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RealTimeStreamingCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__RealTimeStreamingCapabilitiesExtension() : soap() { }
        virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1258 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (456)
/* complex XSD type 'tt:ProfileCapabilities': */
class SOAP_CMAC tt__ProfileCapabilities {
      public:
        /// Required element 'tt:MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int MaximumNumberOfProfiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
        virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileCapabilities); }
      public:
        /// Constructor with initializations
        tt__ProfileCapabilities() : MaximumNumberOfProfiles(), soap() { }
        virtual ~tt__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_tt__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1261 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (457)
/* complex XSD type 'tt:NetworkCapabilities': */
class SOAP_CMAC tt__NetworkCapabilities {
      public:
        /// Optional element 'tt:IPFilter' of XSD type 'xsd:boolean'
        bool *IPFilter;
        /// Optional element 'tt:ZeroConfiguration' of XSD type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// Optional element 'tt:IPVersion6' of XSD type 'xsd:boolean'
        bool *IPVersion6;
        /// Optional element 'tt:DynDNS' of XSD type 'xsd:boolean'
        bool *DynDNS;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkCapabilitiesExtension'
        tt__NetworkCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilities); }
      public:
        /// Constructor with initializations
        tt__NetworkCapabilities() : IPFilter(), ZeroConfiguration(), IPVersion6(), DynDNS(), Extension(), soap() { }
        virtual ~tt__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1264 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (458)
/* complex XSD type 'tt:NetworkCapabilitiesExtension': */
class SOAP_CMAC tt__NetworkCapabilitiesExtension {
      public:
        /// Optional element 'tt:Dot11Configuration' of XSD type 'xsd:boolean'
        bool *Dot11Configuration;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkCapabilitiesExtension2'
        tt__NetworkCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__NetworkCapabilitiesExtension() : Dot11Configuration(), Extension(), soap() { }
        virtual ~tt__NetworkCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1267 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (459)
/* complex XSD type 'tt:NetworkCapabilitiesExtension2': */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        tt__NetworkCapabilitiesExtension2() : soap() { }
        virtual ~tt__NetworkCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1270 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (460)
/* complex XSD type 'tt:SecurityCapabilities': */
class SOAP_CMAC tt__SecurityCapabilities {
      public:
        /// Required element 'tt:TLS1.1' of XSD type 'xsd:boolean'
        bool TLS1_x002e1;
        /// Required element 'tt:TLS1.2' of XSD type 'xsd:boolean'
        bool TLS1_x002e2;
        /// Required element 'tt:OnboardKeyGeneration' of XSD type 'xsd:boolean'
        bool OnboardKeyGeneration;
        /// Required element 'tt:AccessPolicyConfig' of XSD type 'xsd:boolean'
        bool AccessPolicyConfig;
        /// Required element 'tt:X.509Token' of XSD type 'xsd:boolean'
        bool X_x002e509Token;
        /// Required element 'tt:SAMLToken' of XSD type 'xsd:boolean'
        bool SAMLToken;
        /// Required element 'tt:KerberosToken' of XSD type 'xsd:boolean'
        bool KerberosToken;
        /// Required element 'tt:RELToken' of XSD type 'xsd:boolean'
        bool RELToken;
        /// Optional element 'tt:Extension' of XSD type 'tt:SecurityCapabilitiesExtension'
        tt__SecurityCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilities); }
      public:
        /// Constructor with initializations
        tt__SecurityCapabilities() : TLS1_x002e1(), TLS1_x002e2(), OnboardKeyGeneration(), AccessPolicyConfig(), X_x002e509Token(), SAMLToken(), KerberosToken(), RELToken(), Extension(), soap() { }
        virtual ~tt__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1273 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (461)
/* complex XSD type 'tt:SecurityCapabilitiesExtension': */
class SOAP_CMAC tt__SecurityCapabilitiesExtension {
      public:
        /// Required element 'tt:TLS1.0' of XSD type 'xsd:boolean'
        bool TLS1_x002e0;
        /// Optional element 'tt:Extension' of XSD type 'tt:SecurityCapabilitiesExtension2'
        tt__SecurityCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__SecurityCapabilitiesExtension() : TLS1_x002e0(), Extension(), soap() { }
        virtual ~tt__SecurityCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1276 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (462)
/* complex XSD type 'tt:SecurityCapabilitiesExtension2': */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2 {
      public:
        /// Required element 'tt:Dot1X' of XSD type 'xsd:boolean'
        bool Dot1X;
        /// Optional element 'tt:SupportedEAPMethod' of XSD type 'xsd:int'
        std::vector<int> SupportedEAPMethod;
        /// Required element 'tt:RemoteUserHandling' of XSD type 'xsd:boolean'
        bool RemoteUserHandling;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        tt__SecurityCapabilitiesExtension2() : Dot1X(), SupportedEAPMethod(), RemoteUserHandling(), soap() { }
        virtual ~tt__SecurityCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1279 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (463)
/* complex XSD type 'tt:SystemCapabilities': */
class SOAP_CMAC tt__SystemCapabilities {
      public:
        /// Required element 'tt:DiscoveryResolve' of XSD type 'xsd:boolean'
        bool DiscoveryResolve;
        /// Required element 'tt:DiscoveryBye' of XSD type 'xsd:boolean'
        bool DiscoveryBye;
        /// Required element 'tt:RemoteDiscovery' of XSD type 'xsd:boolean'
        bool RemoteDiscovery;
        /// Required element 'tt:SystemBackup' of XSD type 'xsd:boolean'
        bool SystemBackup;
        /// Required element 'tt:SystemLogging' of XSD type 'xsd:boolean'
        bool SystemLogging;
        /// Required element 'tt:FirmwareUpgrade' of XSD type 'xsd:boolean'
        bool FirmwareUpgrade;
        /// Required element 'tt:SupportedVersions' of XSD type 'tt:OnvifVersion'
        std::vector<tt__OnvifVersion *> SupportedVersions;
        /// Optional element 'tt:Extension' of XSD type 'tt:SystemCapabilitiesExtension'
        tt__SystemCapabilitiesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
        virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilities); }
      public:
        /// Constructor with initializations
        tt__SystemCapabilities() : DiscoveryResolve(), DiscoveryBye(), RemoteDiscovery(), SystemBackup(), SystemLogging(), FirmwareUpgrade(), SupportedVersions(), Extension(), soap() { }
        virtual ~tt__SystemCapabilities() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1282 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (464)
/* complex XSD type 'tt:SystemCapabilitiesExtension': */
class SOAP_CMAC tt__SystemCapabilitiesExtension {
      public:
        /// Optional element 'tt:HttpFirmwareUpgrade' of XSD type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// Optional element 'tt:HttpSystemBackup' of XSD type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// Optional element 'tt:HttpSystemLogging' of XSD type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// Optional element 'tt:HttpSupportInformation' of XSD type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// Optional element 'tt:Extension' of XSD type 'tt:SystemCapabilitiesExtension2'
        tt__SystemCapabilitiesExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilitiesExtension); }
      public:
        /// Constructor with initializations
        tt__SystemCapabilitiesExtension() : HttpFirmwareUpgrade(), HttpSystemBackup(), HttpSystemLogging(), HttpSupportInformation(), Extension(), soap() { }
        virtual ~tt__SystemCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1285 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (465)
/* complex XSD type 'tt:SystemCapabilitiesExtension2': */
class SOAP_CMAC tt__SystemCapabilitiesExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilitiesExtension2); }
      public:
        /// Constructor with initializations
        tt__SystemCapabilitiesExtension2() : soap() { }
        virtual ~tt__SystemCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1288 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (466)
/* complex XSD type 'tt:OnvifVersion': */
class SOAP_CMAC tt__OnvifVersion {
      public:
        /// Required element 'tt:Major' of XSD type 'xsd:int'
        int Major;
        /// Required element 'tt:Minor' of XSD type 'xsd:int'
        int Minor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OnvifVersion
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OnvifVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
        virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OnvifVersion); }
      public:
        /// Constructor with initializations
        tt__OnvifVersion() : Major(), Minor(), soap() { }
        virtual ~tt__OnvifVersion() { }
        /// Friend allocator used by soap_new_tt__OnvifVersion(struct soap*, int)
        friend SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1291 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (467)
/* complex XSD type 'tt:ImagingCapabilities': */
class SOAP_CMAC tt__ImagingCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
        virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingCapabilities); }
      public:
        /// Constructor with initializations
        tt__ImagingCapabilities() : XAddr(), soap() { }
        virtual ~tt__ImagingCapabilities() { }
        /// Friend allocator used by soap_new_tt__ImagingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1294 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (468)
/* complex XSD type 'tt:PTZCapabilities': */
class SOAP_CMAC tt__PTZCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
        virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZCapabilities); }
      public:
        /// Constructor with initializations
        tt__PTZCapabilities() : XAddr(), soap() { }
        virtual ~tt__PTZCapabilities() { }
        /// Friend allocator used by soap_new_tt__PTZCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1297 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (469)
/* complex XSD type 'tt:DeviceIOCapabilities': */
class SOAP_CMAC tt__DeviceIOCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:VideoSources' of XSD type 'xsd:int'
        int VideoSources;
        /// Required element 'tt:VideoOutputs' of XSD type 'xsd:int'
        int VideoOutputs;
        /// Required element 'tt:AudioSources' of XSD type 'xsd:int'
        int AudioSources;
        /// Required element 'tt:AudioOutputs' of XSD type 'xsd:int'
        int AudioOutputs;
        /// Required element 'tt:RelayOutputs' of XSD type 'xsd:int'
        int RelayOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceIOCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceIOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
        virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceIOCapabilities); }
      public:
        /// Constructor with initializations
        tt__DeviceIOCapabilities() : XAddr(), VideoSources(), VideoOutputs(), AudioSources(), AudioOutputs(), RelayOutputs(), soap() { }
        virtual ~tt__DeviceIOCapabilities() { }
        /// Friend allocator used by soap_new_tt__DeviceIOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1300 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (470)
/* complex XSD type 'tt:DisplayCapabilities': */
class SOAP_CMAC tt__DisplayCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:FixedLayout' of XSD type 'xsd:boolean'
        bool FixedLayout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DisplayCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DisplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
        virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DisplayCapabilities); }
      public:
        /// Constructor with initializations
        tt__DisplayCapabilities() : XAddr(), FixedLayout(), soap() { }
        virtual ~tt__DisplayCapabilities() { }
        /// Friend allocator used by soap_new_tt__DisplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1303 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (471)
/* complex XSD type 'tt:RecordingCapabilities': */
class SOAP_CMAC tt__RecordingCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:ReceiverSource' of XSD type 'xsd:boolean'
        bool ReceiverSource;
        /// Required element 'tt:MediaProfileSource' of XSD type 'xsd:boolean'
        bool MediaProfileSource;
        /// Required element 'tt:DynamicRecordings' of XSD type 'xsd:boolean'
        bool DynamicRecordings;
        /// Required element 'tt:DynamicTracks' of XSD type 'xsd:boolean'
        bool DynamicTracks;
        /// Required element 'tt:MaxStringLength' of XSD type 'xsd:int'
        int MaxStringLength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
        virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingCapabilities); }
      public:
        /// Constructor with initializations
        tt__RecordingCapabilities() : XAddr(), ReceiverSource(), MediaProfileSource(), DynamicRecordings(), DynamicTracks(), MaxStringLength(), soap() { }
        virtual ~tt__RecordingCapabilities() { }
        /// Friend allocator used by soap_new_tt__RecordingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1306 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (472)
/* complex XSD type 'tt:SearchCapabilities': */
class SOAP_CMAC tt__SearchCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:MetadataSearch' of XSD type 'xsd:boolean'
        bool MetadataSearch;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SearchCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SearchCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
        virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SearchCapabilities); }
      public:
        /// Constructor with initializations
        tt__SearchCapabilities() : XAddr(), MetadataSearch(), soap() { }
        virtual ~tt__SearchCapabilities() { }
        /// Friend allocator used by soap_new_tt__SearchCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1309 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (473)
/* complex XSD type 'tt:ReplayCapabilities': */
class SOAP_CMAC tt__ReplayCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReplayCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
        virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReplayCapabilities); }
      public:
        /// Constructor with initializations
        tt__ReplayCapabilities() : XAddr(), soap() { }
        virtual ~tt__ReplayCapabilities() { }
        /// Friend allocator used by soap_new_tt__ReplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1312 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (474)
/* complex XSD type 'tt:ReceiverCapabilities': */
class SOAP_CMAC tt__ReceiverCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:RTP_Multicast' of XSD type 'xsd:boolean'
        bool RTP_USCOREMulticast;
        /// Required element 'tt:RTP_TCP' of XSD type 'xsd:boolean'
        bool RTP_USCORETCP;
        /// Required element 'tt:RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool RTP_USCORERTSP_USCORETCP;
        /// Required element 'tt:SupportedReceivers' of XSD type 'xsd:int'
        int SupportedReceivers;
        /// Required element 'tt:MaximumRTSPURILength' of XSD type 'xsd:int'
        int MaximumRTSPURILength;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
        virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverCapabilities); }
      public:
        /// Constructor with initializations
        tt__ReceiverCapabilities() : XAddr(), RTP_USCOREMulticast(), RTP_USCORETCP(), RTP_USCORERTSP_USCORETCP(), SupportedReceivers(), MaximumRTSPURILength(), soap() { }
        virtual ~tt__ReceiverCapabilities() { }
        /// Friend allocator used by soap_new_tt__ReceiverCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1315 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (475)
/* complex XSD type 'tt:AnalyticsDeviceCapabilities': */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities {
      public:
        /// Required element 'tt:XAddr' of XSD type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tt:RuleSupport' of XSD type 'xsd:boolean'
        bool *RuleSupport;
        /// Optional element 'tt:Extension' of XSD type 'tt:AnalyticsDeviceExtension'
        tt__AnalyticsDeviceExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceCapabilities); }
      public:
        /// Constructor with initializations
        tt__AnalyticsDeviceCapabilities() : XAddr(), RuleSupport(), Extension(), soap() { }
        virtual ~tt__AnalyticsDeviceCapabilities() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1318 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (476)
/* complex XSD type 'tt:AnalyticsDeviceExtension': */
class SOAP_CMAC tt__AnalyticsDeviceExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceExtension); }
      public:
        /// Constructor with initializations
        tt__AnalyticsDeviceExtension() : soap() { }
        virtual ~tt__AnalyticsDeviceExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1321 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (477)
/* complex XSD type 'tt:SystemLog': */
class SOAP_CMAC tt__SystemLog {
      public:
        /// Optional element 'tt:Binary' of XSD type 'tt:AttachmentData'
        tt__AttachmentData *Binary;
        /// Optional element 'tt:String' of XSD type 'xsd:string'
        std::string *String;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLog
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
        virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLog); }
      public:
        /// Constructor with initializations
        tt__SystemLog() : Binary(), String(), soap() { }
        virtual ~tt__SystemLog() { }
        /// Friend allocator used by soap_new_tt__SystemLog(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1324 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (478)
/* complex XSD type 'tt:SupportInformation': */
class SOAP_CMAC tt__SupportInformation {
      public:
        /// Optional element 'tt:Binary' of XSD type 'tt:AttachmentData'
        tt__AttachmentData *Binary;
        /// Optional element 'tt:String' of XSD type 'xsd:string'
        std::string *String;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
        virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportInformation); }
      public:
        /// Constructor with initializations
        tt__SupportInformation() : Binary(), String(), soap() { }
        virtual ~tt__SupportInformation() { }
        /// Friend allocator used by soap_new_tt__SupportInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1327 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (479)
/* complex XSD type 'tt:BinaryData': */
class SOAP_CMAC tt__BinaryData {
      public:
        /// Required element 'tt:Data' of XSD type 'xsd:base64Binary'
        xsd__base64Binary Data;
        /// optional attribute 'xmime:contentType' of XSD type 'xsd:string'
        char *xmime__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__BinaryData
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BinaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
        virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BinaryData); }
      public:
        /// Constructor with initializations
        tt__BinaryData() : Data(), xmime__contentType(), soap() { }
        virtual ~tt__BinaryData() { }
        /// Friend allocator used by soap_new_tt__BinaryData(struct soap*, int)
        friend SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1330 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (480)
/* complex XSD type 'tt:AttachmentData': */
class SOAP_CMAC tt__AttachmentData {
      public:
        /// Required element 'xop:Include' of XSD type 'xop:Include'
        struct _xop__Include xop__Include;
        /// optional attribute 'xmime:contentType' of XSD type 'xsd:string'
        char *xmime__contentType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AttachmentData
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AttachmentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
        virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AttachmentData); }
      public:
        /// Constructor with initializations
        tt__AttachmentData() : xop__Include(), xmime__contentType(), soap() { }
        virtual ~tt__AttachmentData() { }
        /// Friend allocator used by soap_new_tt__AttachmentData(struct soap*, int)
        friend SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1333 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (481)
/* complex XSD type 'tt:BackupFile': */
class SOAP_CMAC tt__BackupFile {
      public:
        /// Required element 'tt:Name' of XSD type 'xsd:string'
        std::string Name;
        /// Required element 'tt:Data' of XSD type 'tt:AttachmentData'
        tt__AttachmentData *Data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__BackupFile
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BackupFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
        virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BackupFile); }
      public:
        /// Constructor with initializations
        tt__BackupFile() : Name(), Data(), soap() { }
        virtual ~tt__BackupFile() { }
        /// Friend allocator used by soap_new_tt__BackupFile(struct soap*, int)
        friend SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1336 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (482)
/* complex XSD type 'tt:SystemLogUriList': */
class SOAP_CMAC tt__SystemLogUriList {
      public:
        /// Optional element 'tt:SystemLog' of XSD type 'tt:SystemLogUri'
        std::vector<tt__SystemLogUri *> SystemLog;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLogUriList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLogUriList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
        virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLogUriList); }
      public:
        /// Constructor with initializations
        tt__SystemLogUriList() : SystemLog(), soap() { }
        virtual ~tt__SystemLogUriList() { }
        /// Friend allocator used by soap_new_tt__SystemLogUriList(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1339 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (483)
/* complex XSD type 'tt:SystemLogUri': */
class SOAP_CMAC tt__SystemLogUri {
      public:
        /// Required element 'tt:Type' of XSD type 'tt:SystemLogType'
        enum tt__SystemLogType Type;
        /// Required element 'tt:Uri' of XSD type 'xsd:anyURI'
        std::string Uri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLogUri
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLogUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
        virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLogUri); }
      public:
        /// Constructor with initializations
        tt__SystemLogUri() : Type(), Uri(), soap() { }
        virtual ~tt__SystemLogUri() { }
        /// Friend allocator used by soap_new_tt__SystemLogUri(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1342 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (484)
/* complex XSD type 'tt:SystemDateTime': */
class SOAP_CMAC tt__SystemDateTime {
      public:
        /// Required element 'tt:DateTimeType' of XSD type 'tt:SetDateTimeType'
        enum tt__SetDateTimeType DateTimeType;
        /// Required element 'tt:DaylightSavings' of XSD type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'tt:TimeZone' of XSD type 'tt:TimeZone'
        tt__TimeZone *TimeZone;
        /// Optional element 'tt:UTCDateTime' of XSD type 'tt:DateTime'
        tt__DateTime *UTCDateTime;
        /// Optional element 'tt:LocalDateTime' of XSD type 'tt:DateTime'
        tt__DateTime *LocalDateTime;
        /// Optional element 'tt:Extension' of XSD type 'tt:SystemDateTimeExtension'
        tt__SystemDateTimeExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemDateTime
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemDateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
        virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemDateTime); }
      public:
        /// Constructor with initializations
        tt__SystemDateTime() : DateTimeType(), DaylightSavings(), TimeZone(), UTCDateTime(), LocalDateTime(), Extension(), soap() { }
        virtual ~tt__SystemDateTime() { }
        /// Friend allocator used by soap_new_tt__SystemDateTime(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1345 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (485)
/* complex XSD type 'tt:SystemDateTimeExtension': */
class SOAP_CMAC tt__SystemDateTimeExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemDateTimeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemDateTimeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
        virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemDateTimeExtension); }
      public:
        /// Constructor with initializations
        tt__SystemDateTimeExtension() : soap() { }
        virtual ~tt__SystemDateTimeExtension() { }
        /// Friend allocator used by soap_new_tt__SystemDateTimeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1348 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (486)
/* complex XSD type 'tt:DateTime': */
class SOAP_CMAC tt__DateTime {
      public:
        /// Required element 'tt:Time' of XSD type 'tt:Time'
        tt__Time *Time;
        /// Required element 'tt:Date' of XSD type 'tt:Date'
        tt__Date *Date;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DateTime
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
        virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DateTime); }
      public:
        /// Constructor with initializations
        tt__DateTime() : Time(), Date(), soap() { }
        virtual ~tt__DateTime() { }
        /// Friend allocator used by soap_new_tt__DateTime(struct soap*, int)
        friend SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1351 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (487)
/* complex XSD type 'tt:Date': */
class SOAP_CMAC tt__Date {
      public:
        /// Required element 'tt:Year' of XSD type 'xsd:int'
        int Year;
        /// Required element 'tt:Month' of XSD type 'xsd:int'
        int Month;
        /// Required element 'tt:Day' of XSD type 'xsd:int'
        int Day;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Date
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Date; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Date, default initialized and not managed by a soap context
        virtual tt__Date *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Date); }
      public:
        /// Constructor with initializations
        tt__Date() : Year(), Month(), Day(), soap() { }
        virtual ~tt__Date() { }
        /// Friend allocator used by soap_new_tt__Date(struct soap*, int)
        friend SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1354 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (488)
/* complex XSD type 'tt:Time': */
class SOAP_CMAC tt__Time {
      public:
        /// Required element 'tt:Hour' of XSD type 'xsd:int'
        int Hour;
        /// Required element 'tt:Minute' of XSD type 'xsd:int'
        int Minute;
        /// Required element 'tt:Second' of XSD type 'xsd:int'
        int Second;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Time
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Time; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Time, default initialized and not managed by a soap context
        virtual tt__Time *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Time); }
      public:
        /// Constructor with initializations
        tt__Time() : Hour(), Minute(), Second(), soap() { }
        virtual ~tt__Time() { }
        /// Friend allocator used by soap_new_tt__Time(struct soap*, int)
        friend SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1357 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (489)
/* complex XSD type 'tt:TimeZone': */
class SOAP_CMAC tt__TimeZone {
      public:
        /// Required element 'tt:TZ' of XSD type 'xsd:token'
        std::string TZ;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__TimeZone
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TimeZone; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
        virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TimeZone); }
      public:
        /// Constructor with initializations
        tt__TimeZone() : TZ(), soap() { }
        virtual ~tt__TimeZone() { }
        /// Friend allocator used by soap_new_tt__TimeZone(struct soap*, int)
        friend SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1360 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (490)
/* complex XSD type 'tt:RemoteUser': */
class SOAP_CMAC tt__RemoteUser {
      public:
        /// Required element 'tt:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Optional element 'tt:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Required element 'tt:UseDerivedPassword' of XSD type 'xsd:boolean'
        bool UseDerivedPassword;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
        virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RemoteUser); }
      public:
        /// Constructor with initializations
        tt__RemoteUser() : Username(), Password(), UseDerivedPassword(), soap() { }
        virtual ~tt__RemoteUser() { }
        /// Friend allocator used by soap_new_tt__RemoteUser(struct soap*, int)
        friend SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1363 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (491)
/* complex XSD type 'tt:User': */
class SOAP_CMAC tt__User {
      public:
        /// Required element 'tt:Username' of XSD type 'xsd:string'
        std::string Username;
        /// Optional element 'tt:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Required element 'tt:UserLevel' of XSD type 'tt:UserLevel'
        enum tt__UserLevel UserLevel;
        /// Optional element 'tt:Extension' of XSD type 'tt:UserExtension'
        tt__UserExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__User
        virtual long soap_type(void) const { return SOAP_TYPE_tt__User; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__User, default initialized and not managed by a soap context
        virtual tt__User *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__User); }
      public:
        /// Constructor with initializations
        tt__User() : Username(), Password(), UserLevel(), Extension(), soap() { }
        virtual ~tt__User() { }
        /// Friend allocator used by soap_new_tt__User(struct soap*, int)
        friend SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1366 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (492)
/* complex XSD type 'tt:UserExtension': */
class SOAP_CMAC tt__UserExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__UserExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__UserExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
        virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__UserExtension); }
      public:
        /// Constructor with initializations
        tt__UserExtension() : soap() { }
        virtual ~tt__UserExtension() { }
        /// Friend allocator used by soap_new_tt__UserExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1369 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (493)
/* complex XSD type 'tt:Certificate': */
class SOAP_CMAC tt__Certificate {
      public:
        /// Required element 'tt:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Required element 'tt:Certificate' of XSD type 'tt:BinaryData'
        tt__BinaryData *Certificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Certificate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Certificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
        virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Certificate); }
      public:
        /// Constructor with initializations
        tt__Certificate() : CertificateID(), Certificate(), soap() { }
        virtual ~tt__Certificate() { }
        /// Friend allocator used by soap_new_tt__Certificate(struct soap*, int)
        friend SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1372 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (494)
/* complex XSD type 'tt:CertificateStatus': */
class SOAP_CMAC tt__CertificateStatus {
      public:
        /// Required element 'tt:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Required element 'tt:Status' of XSD type 'xsd:boolean'
        bool Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
        virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateStatus); }
      public:
        /// Constructor with initializations
        tt__CertificateStatus() : CertificateID(), Status(), soap() { }
        virtual ~tt__CertificateStatus() { }
        /// Friend allocator used by soap_new_tt__CertificateStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1375 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (495)
/* complex XSD type 'tt:CertificateWithPrivateKey': */
class SOAP_CMAC tt__CertificateWithPrivateKey {
      public:
        /// Optional element 'tt:CertificateID' of XSD type 'xsd:token'
        std::string *CertificateID;
        /// Required element 'tt:Certificate' of XSD type 'tt:BinaryData'
        tt__BinaryData *Certificate;
        /// Required element 'tt:PrivateKey' of XSD type 'tt:BinaryData'
        tt__BinaryData *PrivateKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateWithPrivateKey
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateWithPrivateKey); }
      public:
        /// Constructor with initializations
        tt__CertificateWithPrivateKey() : CertificateID(), Certificate(), PrivateKey(), soap() { }
        virtual ~tt__CertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new_tt__CertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1378 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (496)
/* complex XSD type 'tt:CertificateInformation': */
class SOAP_CMAC tt__CertificateInformation {
      public:
        /// Required element 'tt:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'tt:IssuerDN' of XSD type 'xsd:string'
        std::string *IssuerDN;
        /// Optional element 'tt:SubjectDN' of XSD type 'xsd:string'
        std::string *SubjectDN;
        /// Optional element 'tt:KeyUsage' of XSD type 'tt:CertificateUsage'
        tt__CertificateUsage *KeyUsage;
        /// Optional element 'tt:ExtendedKeyUsage' of XSD type 'tt:CertificateUsage'
        tt__CertificateUsage *ExtendedKeyUsage;
        /// Optional element 'tt:KeyLength' of XSD type 'xsd:int'
        int *KeyLength;
        /// Optional element 'tt:Version' of XSD type 'xsd:string'
        std::string *Version;
        /// Optional element 'tt:SerialNum' of XSD type 'xsd:string'
        std::string *SerialNum;
        /// Optional element 'tt:SignatureAlgorithm' of XSD type 'xsd:string'
        std::string *SignatureAlgorithm;
        /// Optional element 'tt:Validity' of XSD type 'tt:DateTimeRange'
        tt__DateTimeRange *Validity;
        /// Optional element 'tt:Extension' of XSD type 'tt:CertificateInformationExtension'
        tt__CertificateInformationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
        virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateInformation); }
      public:
        /// Constructor with initializations
        tt__CertificateInformation() : CertificateID(), IssuerDN(), SubjectDN(), KeyUsage(), ExtendedKeyUsage(), KeyLength(), Version(), SerialNum(), SignatureAlgorithm(), Validity(), Extension(), soap() { }
        virtual ~tt__CertificateInformation() { }
        /// Friend allocator used by soap_new_tt__CertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1384 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (498)
/* complex XSD type 'tt:CertificateInformationExtension': */
class SOAP_CMAC tt__CertificateInformationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
        virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateInformationExtension); }
      public:
        /// Constructor with initializations
        tt__CertificateInformationExtension() : soap() { }
        virtual ~tt__CertificateInformationExtension() { }
        /// Friend allocator used by soap_new_tt__CertificateInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1387 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (499)
/* complex XSD type 'tt:Dot1XConfiguration': */
class SOAP_CMAC tt__Dot1XConfiguration {
      public:
        /// Required element 'tt:Dot1XConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Required element 'tt:Identity' of XSD type 'xsd:string'
        std::string Identity;
        /// Optional element 'tt:AnonymousID' of XSD type 'xsd:string'
        std::string *AnonymousID;
        /// Required element 'tt:EAPMethod' of XSD type 'xsd:int'
        int EAPMethod;
        /// Optional element 'tt:CACertificateID' of XSD type 'xsd:token'
        std::vector<std::string> CACertificateID;
        /// Optional element 'tt:EAPMethodConfiguration' of XSD type 'tt:EAPMethodConfiguration'
        tt__EAPMethodConfiguration *EAPMethodConfiguration;
        /// Optional element 'tt:Extension' of XSD type 'tt:Dot1XConfigurationExtension'
        tt__Dot1XConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
        virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot1XConfiguration); }
      public:
        /// Constructor with initializations
        tt__Dot1XConfiguration() : Dot1XConfigurationToken(), Identity(), AnonymousID(), EAPMethod(), CACertificateID(), EAPMethodConfiguration(), Extension(), soap() { }
        virtual ~tt__Dot1XConfiguration() { }
        /// Friend allocator used by soap_new_tt__Dot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1390 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (500)
/* complex XSD type 'tt:Dot1XConfigurationExtension': */
class SOAP_CMAC tt__Dot1XConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot1XConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot1XConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot1XConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__Dot1XConfigurationExtension() : soap() { }
        virtual ~tt__Dot1XConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__Dot1XConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1393 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (501)
/* complex XSD type 'tt:EAPMethodConfiguration': */
class SOAP_CMAC tt__EAPMethodConfiguration {
      public:
        /// Optional element 'tt:TLSConfiguration' of XSD type 'tt:TLSConfiguration'
        tt__TLSConfiguration *TLSConfiguration;
        /// Optional element 'tt:Password' of XSD type 'xsd:string'
        std::string *Password;
        /// Optional element 'tt:Extension' of XSD type 'tt:EapMethodExtension'
        tt__EapMethodExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EAPMethodConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EAPMethodConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
        virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EAPMethodConfiguration); }
      public:
        /// Constructor with initializations
        tt__EAPMethodConfiguration() : TLSConfiguration(), Password(), Extension(), soap() { }
        virtual ~tt__EAPMethodConfiguration() { }
        /// Friend allocator used by soap_new_tt__EAPMethodConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1396 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (502)
/* complex XSD type 'tt:EapMethodExtension': */
class SOAP_CMAC tt__EapMethodExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EapMethodExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EapMethodExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
        virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EapMethodExtension); }
      public:
        /// Constructor with initializations
        tt__EapMethodExtension() : soap() { }
        virtual ~tt__EapMethodExtension() { }
        /// Friend allocator used by soap_new_tt__EapMethodExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1399 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (503)
/* complex XSD type 'tt:TLSConfiguration': */
class SOAP_CMAC tt__TLSConfiguration {
      public:
        /// Required element 'tt:CertificateID' of XSD type 'xsd:token'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__TLSConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TLSConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
        virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TLSConfiguration); }
      public:
        /// Constructor with initializations
        tt__TLSConfiguration() : CertificateID(), soap() { }
        virtual ~tt__TLSConfiguration() { }
        /// Friend allocator used by soap_new_tt__TLSConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1402 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (504)
/* complex XSD type 'tt:RelayOutputSettings': */
class SOAP_CMAC tt__RelayOutputSettings {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:RelayMode'
        enum tt__RelayMode Mode;
        /// Required element 'tt:DelayTime' of XSD type 'xsd:duration'
        std::string DelayTime;
        /// Required element 'tt:IdleState' of XSD type 'tt:RelayIdleState'
        enum tt__RelayIdleState IdleState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayOutputSettings
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
        virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayOutputSettings); }
      public:
        /// Constructor with initializations
        tt__RelayOutputSettings() : Mode(), DelayTime(), IdleState(), soap() { }
        virtual ~tt__RelayOutputSettings() { }
        /// Friend allocator used by soap_new_tt__RelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1414 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (508)
/* complex XSD type 'tt:PTZNodeExtension': */
class SOAP_CMAC tt__PTZNodeExtension {
      public:
        /// Optional element 'tt:SupportedPresetTour' of XSD type 'tt:PTZPresetTourSupported'
        tt__PTZPresetTourSupported *SupportedPresetTour;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZNodeExtension2'
        tt__PTZNodeExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNodeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNodeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
        virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNodeExtension); }
      public:
        /// Constructor with initializations
        tt__PTZNodeExtension() : SupportedPresetTour(), Extension(), soap() { }
        virtual ~tt__PTZNodeExtension() { }
        /// Friend allocator used by soap_new_tt__PTZNodeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1417 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (509)
/* complex XSD type 'tt:PTZNodeExtension2': */
class SOAP_CMAC tt__PTZNodeExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNodeExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNodeExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
        virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNodeExtension2); }
      public:
        /// Constructor with initializations
        tt__PTZNodeExtension2() : soap() { }
        virtual ~tt__PTZNodeExtension2() { }
        /// Friend allocator used by soap_new_tt__PTZNodeExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1420 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (510)
/* complex XSD type 'tt:PTZPresetTourSupported': */
class SOAP_CMAC tt__PTZPresetTourSupported {
      public:
        /// Required element 'tt:MaximumNumberOfPresetTours' of XSD type 'xsd:int'
        int MaximumNumberOfPresetTours;
        /// Optional element 'tt:PTZPresetTourOperation' of XSD type 'tt:PTZPresetTourOperation'
        std::vector<enum tt__PTZPresetTourOperation> PTZPresetTourOperation;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourSupportedExtension'
        tt__PTZPresetTourSupportedExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSupported
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSupported; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSupported); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourSupported() : MaximumNumberOfPresetTours(), PTZPresetTourOperation(), Extension(), soap() { }
        virtual ~tt__PTZPresetTourSupported() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSupported(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1423 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (511)
/* complex XSD type 'tt:PTZPresetTourSupportedExtension': */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSupportedExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSupportedExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSupportedExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourSupportedExtension() : soap() { }
        virtual ~tt__PTZPresetTourSupportedExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSupportedExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1429 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (513)
/* complex XSD type 'tt:PTZConfigurationExtension': */
class SOAP_CMAC tt__PTZConfigurationExtension {
      public:
        /// Optional element 'tt:PTControlDirection' of XSD type 'tt:PTControlDirection'
        tt__PTControlDirection *PTControlDirection;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZConfigurationExtension2'
        tt__PTZConfigurationExtension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__PTZConfigurationExtension() : PTControlDirection(), Extension(), soap() { }
        virtual ~tt__PTZConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1432 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (514)
/* complex XSD type 'tt:PTZConfigurationExtension2': */
class SOAP_CMAC tt__PTZConfigurationExtension2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension2); }
      public:
        /// Constructor with initializations
        tt__PTZConfigurationExtension2() : soap() { }
        virtual ~tt__PTZConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1435 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (515)
/* complex XSD type 'tt:PTControlDirection': */
class SOAP_CMAC tt__PTControlDirection {
      public:
        /// Optional element 'tt:EFlip' of XSD type 'tt:EFlip'
        tt__EFlip *EFlip;
        /// Optional element 'tt:Reverse' of XSD type 'tt:Reverse'
        tt__Reverse *Reverse;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTControlDirectionExtension'
        tt__PTControlDirectionExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
        virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirection); }
      public:
        /// Constructor with initializations
        tt__PTControlDirection() : EFlip(), Reverse(), Extension(), soap() { }
        virtual ~tt__PTControlDirection() { }
        /// Friend allocator used by soap_new_tt__PTControlDirection(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1438 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (516)
/* complex XSD type 'tt:PTControlDirectionExtension': */
class SOAP_CMAC tt__PTControlDirectionExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionExtension); }
      public:
        /// Constructor with initializations
        tt__PTControlDirectionExtension() : soap() { }
        virtual ~tt__PTControlDirectionExtension() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1441 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (517)
/* complex XSD type 'tt:EFlip': */
class SOAP_CMAC tt__EFlip {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:EFlipMode'
        enum tt__EFlipMode Mode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlip
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlip; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
        virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlip); }
      public:
        /// Constructor with initializations
        tt__EFlip() : Mode(), soap() { }
        virtual ~tt__EFlip() { }
        /// Friend allocator used by soap_new_tt__EFlip(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1444 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (518)
/* complex XSD type 'tt:Reverse': */
class SOAP_CMAC tt__Reverse {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ReverseMode'
        enum tt__ReverseMode Mode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Reverse
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Reverse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
        virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Reverse); }
      public:
        /// Constructor with initializations
        tt__Reverse() : Mode(), soap() { }
        virtual ~tt__Reverse() { }
        /// Friend allocator used by soap_new_tt__Reverse(struct soap*, int)
        friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1447 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (519)
/* complex XSD type 'tt:PTZConfigurationOptions': */
class SOAP_CMAC tt__PTZConfigurationOptions {
      public:
        /// Required element 'tt:Spaces' of XSD type 'tt:PTZSpaces'
        tt__PTZSpaces *Spaces;
        /// Required element 'tt:PTZTimeout' of XSD type 'tt:DurationRange'
        tt__DurationRange *PTZTimeout;
        /// Optional element 'tt:PTControlDirection' of XSD type 'tt:PTControlDirectionOptions'
        tt__PTControlDirectionOptions *PTControlDirection;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZConfigurationOptions2'
        tt__PTZConfigurationOptions2 *Extension;
        /// optional attribute 'PTZRamps' of XSD type 'tt:IntAttrList'
        std::string *PTZRamps;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__PTZConfigurationOptions() : Spaces(), PTZTimeout(), PTControlDirection(), Extension(), PTZRamps(), soap() { }
        virtual ~tt__PTZConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1450 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (520)
/* complex XSD type 'tt:PTZConfigurationOptions2': */
class SOAP_CMAC tt__PTZConfigurationOptions2 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationOptions2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationOptions2); }
      public:
        /// Constructor with initializations
        tt__PTZConfigurationOptions2() : soap() { }
        virtual ~tt__PTZConfigurationOptions2() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationOptions2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1453 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (521)
/* complex XSD type 'tt:PTControlDirectionOptions': */
class SOAP_CMAC tt__PTControlDirectionOptions {
      public:
        /// Optional element 'tt:EFlip' of XSD type 'tt:EFlipOptions'
        tt__EFlipOptions *EFlip;
        /// Optional element 'tt:Reverse' of XSD type 'tt:ReverseOptions'
        tt__ReverseOptions *Reverse;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTControlDirectionOptionsExtension'
        tt__PTControlDirectionOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionOptions); }
      public:
        /// Constructor with initializations
        tt__PTControlDirectionOptions() : EFlip(), Reverse(), Extension(), soap() { }
        virtual ~tt__PTControlDirectionOptions() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1456 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (522)
/* complex XSD type 'tt:PTControlDirectionOptionsExtension': */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__PTControlDirectionOptionsExtension() : soap() { }
        virtual ~tt__PTControlDirectionOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1459 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (523)
/* complex XSD type 'tt:EFlipOptions': */
class SOAP_CMAC tt__EFlipOptions {
      public:
        /// Optional element 'tt:Mode' of XSD type 'tt:EFlipMode'
        std::vector<enum tt__EFlipMode> Mode;
        /// Optional element 'tt:Extension' of XSD type 'tt:EFlipOptionsExtension'
        tt__EFlipOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
        virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipOptions); }
      public:
        /// Constructor with initializations
        tt__EFlipOptions() : Mode(), Extension(), soap() { }
        virtual ~tt__EFlipOptions() { }
        /// Friend allocator used by soap_new_tt__EFlipOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1462 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (524)
/* complex XSD type 'tt:EFlipOptionsExtension': */
class SOAP_CMAC tt__EFlipOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
        virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__EFlipOptionsExtension() : soap() { }
        virtual ~tt__EFlipOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__EFlipOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1465 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (525)
/* complex XSD type 'tt:ReverseOptions': */
class SOAP_CMAC tt__ReverseOptions {
      public:
        /// Optional element 'tt:Mode' of XSD type 'tt:ReverseMode'
        std::vector<enum tt__ReverseMode> Mode;
        /// Optional element 'tt:Extension' of XSD type 'tt:ReverseOptionsExtension'
        tt__ReverseOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
        virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseOptions); }
      public:
        /// Constructor with initializations
        tt__ReverseOptions() : Mode(), Extension(), soap() { }
        virtual ~tt__ReverseOptions() { }
        /// Friend allocator used by soap_new_tt__ReverseOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1468 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (526)
/* complex XSD type 'tt:ReverseOptionsExtension': */
class SOAP_CMAC tt__ReverseOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
        virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__ReverseOptionsExtension() : soap() { }
        virtual ~tt__ReverseOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__ReverseOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1471 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (527)
/* complex XSD type 'tt:PanTiltLimits': */
class SOAP_CMAC tt__PanTiltLimits {
      public:
        /// Required element 'tt:Range' of XSD type 'tt:Space2DDescription'
        tt__Space2DDescription *Range;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PanTiltLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PanTiltLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
        virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PanTiltLimits); }
      public:
        /// Constructor with initializations
        tt__PanTiltLimits() : Range(), soap() { }
        virtual ~tt__PanTiltLimits() { }
        /// Friend allocator used by soap_new_tt__PanTiltLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1474 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (528)
/* complex XSD type 'tt:ZoomLimits': */
class SOAP_CMAC tt__ZoomLimits {
      public:
        /// Required element 'tt:Range' of XSD type 'tt:Space1DDescription'
        tt__Space1DDescription *Range;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ZoomLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ZoomLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
        virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ZoomLimits); }
      public:
        /// Constructor with initializations
        tt__ZoomLimits() : Range(), soap() { }
        virtual ~tt__ZoomLimits() { }
        /// Friend allocator used by soap_new_tt__ZoomLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1477 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (529)
/* complex XSD type 'tt:PTZSpaces': */
class SOAP_CMAC tt__PTZSpaces {
      public:
        /// Optional element 'tt:AbsolutePanTiltPositionSpace' of XSD type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> AbsolutePanTiltPositionSpace;
        /// Optional element 'tt:AbsoluteZoomPositionSpace' of XSD type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> AbsoluteZoomPositionSpace;
        /// Optional element 'tt:RelativePanTiltTranslationSpace' of XSD type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> RelativePanTiltTranslationSpace;
        /// Optional element 'tt:RelativeZoomTranslationSpace' of XSD type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> RelativeZoomTranslationSpace;
        /// Optional element 'tt:ContinuousPanTiltVelocitySpace' of XSD type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> ContinuousPanTiltVelocitySpace;
        /// Optional element 'tt:ContinuousZoomVelocitySpace' of XSD type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> ContinuousZoomVelocitySpace;
        /// Optional element 'tt:PanTiltSpeedSpace' of XSD type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> PanTiltSpeedSpace;
        /// Optional element 'tt:ZoomSpeedSpace' of XSD type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> ZoomSpeedSpace;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZSpacesExtension'
        tt__PTZSpacesExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpaces
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
        virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpaces); }
      public:
        /// Constructor with initializations
        tt__PTZSpaces() : AbsolutePanTiltPositionSpace(), AbsoluteZoomPositionSpace(), RelativePanTiltTranslationSpace(), RelativeZoomTranslationSpace(), ContinuousPanTiltVelocitySpace(), ContinuousZoomVelocitySpace(), PanTiltSpeedSpace(), ZoomSpeedSpace(), Extension(), soap() { }
        virtual ~tt__PTZSpaces() { }
        /// Friend allocator used by soap_new_tt__PTZSpaces(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1480 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (530)
/* complex XSD type 'tt:PTZSpacesExtension': */
class SOAP_CMAC tt__PTZSpacesExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpacesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpacesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
        virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpacesExtension); }
      public:
        /// Constructor with initializations
        tt__PTZSpacesExtension() : soap() { }
        virtual ~tt__PTZSpacesExtension() { }
        /// Friend allocator used by soap_new_tt__PTZSpacesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1483 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (531)
/* complex XSD type 'tt:Space2DDescription': */
class SOAP_CMAC tt__Space2DDescription {
      public:
        /// Required element 'tt:URI' of XSD type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XSD type 'tt:FloatRange'
        tt__FloatRange *XRange;
        /// Required element 'tt:YRange' of XSD type 'tt:FloatRange'
        tt__FloatRange *YRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space2DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space2DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
        virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space2DDescription); }
      public:
        /// Constructor with initializations
        tt__Space2DDescription() : URI(), XRange(), YRange(), soap() { }
        virtual ~tt__Space2DDescription() { }
        /// Friend allocator used by soap_new_tt__Space2DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1486 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (532)
/* complex XSD type 'tt:Space1DDescription': */
class SOAP_CMAC tt__Space1DDescription {
      public:
        /// Required element 'tt:URI' of XSD type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XSD type 'tt:FloatRange'
        tt__FloatRange *XRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space1DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space1DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
        virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space1DDescription); }
      public:
        /// Constructor with initializations
        tt__Space1DDescription() : URI(), XRange(), soap() { }
        virtual ~tt__Space1DDescription() { }
        /// Friend allocator used by soap_new_tt__Space1DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1489 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (533)
/* complex XSD type 'tt:PTZSpeed': */
class SOAP_CMAC tt__PTZSpeed {
      public:
        /// Optional element 'tt:PanTilt' of XSD type 'tt:Vector2D'
        tt__Vector2D *PanTilt;
        /// Optional element 'tt:Zoom' of XSD type 'tt:Vector1D'
        tt__Vector1D *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
        virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpeed); }
      public:
        /// Constructor with initializations
        tt__PTZSpeed() : PanTilt(), Zoom(), soap() { }
        virtual ~tt__PTZSpeed() { }
        /// Friend allocator used by soap_new_tt__PTZSpeed(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1492 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (534)
/* complex XSD type 'tt:PTZPreset': */
class SOAP_CMAC tt__PTZPreset {
      public:
        /// Optional element 'tt:Name' of XSD type 'tt:Name'
        std::string *Name;
        /// Optional element 'tt:PTZPosition' of XSD type 'tt:PTZVector'
        tt__PTZVector *PTZPosition;
        /// optional attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string *token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPreset
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
        virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPreset); }
      public:
        /// Constructor with initializations
        tt__PTZPreset() : Name(), PTZPosition(), token(), soap() { }
        virtual ~tt__PTZPreset() { }
        /// Friend allocator used by soap_new_tt__PTZPreset(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1495 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (535)
/* complex XSD type 'tt:PresetTour': */
class SOAP_CMAC tt__PresetTour {
      public:
        /// Optional element 'tt:Name' of XSD type 'tt:Name'
        std::string *Name;
        /// Required element 'tt:Status' of XSD type 'tt:PTZPresetTourStatus'
        tt__PTZPresetTourStatus *Status;
        /// Required element 'tt:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'tt:StartingCondition' of XSD type 'tt:PTZPresetTourStartingCondition'
        tt__PTZPresetTourStartingCondition *StartingCondition;
        /// Optional element 'tt:TourSpot' of XSD type 'tt:PTZPresetTourSpot'
        std::vector<tt__PTZPresetTourSpot *> TourSpot;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourExtension'
        tt__PTZPresetTourExtension *Extension;
        /// optional attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string *token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PresetTour
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
        virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PresetTour); }
      public:
        /// Constructor with initializations
        tt__PresetTour() : Name(), Status(), AutoStart(), StartingCondition(), TourSpot(), Extension(), token(), soap() { }
        virtual ~tt__PresetTour() { }
        /// Friend allocator used by soap_new_tt__PresetTour(struct soap*, int)
        friend SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1498 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (536)
/* complex XSD type 'tt:PTZPresetTourExtension': */
class SOAP_CMAC tt__PTZPresetTourExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourExtension() : soap() { }
        virtual ~tt__PTZPresetTourExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1501 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (537)
/* complex XSD type 'tt:PTZPresetTourSpot': */
class SOAP_CMAC tt__PTZPresetTourSpot {
      public:
        /// Required element 'tt:PresetDetail' of XSD type 'tt:PTZPresetTourPresetDetail'
        tt__PTZPresetTourPresetDetail *PresetDetail;
        /// Optional element 'tt:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Optional element 'tt:StayTime' of XSD type 'xsd:duration'
        std::string *StayTime;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourSpotExtension'
        tt__PTZPresetTourSpotExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpot
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpot); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourSpot() : PresetDetail(), Speed(), StayTime(), Extension(), soap() { }
        virtual ~tt__PTZPresetTourSpot() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpot(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1504 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (538)
/* complex XSD type 'tt:PTZPresetTourSpotExtension': */
class SOAP_CMAC tt__PTZPresetTourSpotExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpotExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpotExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpotExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourSpotExtension() : soap() { }
        virtual ~tt__PTZPresetTourSpotExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpotExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:15389 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1521)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tt__union_PTZPresetTourPresetDetail
{
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)	/**< union variant selector value for member PresetToken */
        std::string *PresetToken;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)	/**< union variant selector value for member Home */
        bool Home;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)	/**< union variant selector value for member PTZPosition */
        tt__PTZVector *PTZPosition;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)	/**< union variant selector value for member TypeExtension */
        tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvif.h:1507 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (539)
/* Choice: */
class SOAP_CMAC tt__PTZPresetTourPresetDetail {
      public:
        /// Union with union _tt__union_PTZPresetTourPresetDetail variant selector __union_PTZPresetTourPresetDetail set to one of: SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension
        int __union_PTZPresetTourPresetDetail;
        union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetail
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetail); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourPresetDetail() : __union_PTZPresetTourPresetDetail(), soap() { }
        virtual ~tt__PTZPresetTourPresetDetail() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetail(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1510 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (540)
/* complex XSD type 'tt:PTZPresetTourTypeExtension': */
class SOAP_CMAC tt__PTZPresetTourTypeExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourTypeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourTypeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourTypeExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourTypeExtension() : soap() { }
        virtual ~tt__PTZPresetTourTypeExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourTypeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1513 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (541)
/* complex XSD type 'tt:PTZPresetTourStatus': */
class SOAP_CMAC tt__PTZPresetTourStatus {
      public:
        /// Required element 'tt:State' of XSD type 'tt:PTZPresetTourState'
        enum tt__PTZPresetTourState State;
        /// Optional element 'tt:CurrentTourSpot' of XSD type 'tt:PTZPresetTourSpot'
        tt__PTZPresetTourSpot *CurrentTourSpot;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourStatusExtension'
        tt__PTZPresetTourStatusExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStatus); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStatus() : State(), CurrentTourSpot(), Extension(), soap() { }
        virtual ~tt__PTZPresetTourStatus() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1516 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (542)
/* complex XSD type 'tt:PTZPresetTourStatusExtension': */
class SOAP_CMAC tt__PTZPresetTourStatusExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStatusExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStatusExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStatusExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStatusExtension() : soap() { }
        virtual ~tt__PTZPresetTourStatusExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStatusExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1519 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (543)
/* complex XSD type 'tt:PTZPresetTourStartingCondition': */
class SOAP_CMAC tt__PTZPresetTourStartingCondition {
      public:
        /// Optional element 'tt:RecurringTime' of XSD type 'xsd:int'
        int *RecurringTime;
        /// Optional element 'tt:RecurringDuration' of XSD type 'xsd:duration'
        std::string *RecurringDuration;
        /// Optional element 'tt:Direction' of XSD type 'tt:PTZPresetTourDirection'
        enum tt__PTZPresetTourDirection *Direction;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourStartingConditionExtension'
        tt__PTZPresetTourStartingConditionExtension *Extension;
        /// optional attribute 'RandomPresetOrder' of XSD type 'xsd:boolean'
        bool *RandomPresetOrder;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingCondition
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingCondition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingCondition); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStartingCondition() : RecurringTime(), RecurringDuration(), Direction(), Extension(), RandomPresetOrder(), soap() { }
        virtual ~tt__PTZPresetTourStartingCondition() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingCondition(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1522 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (544)
/* complex XSD type 'tt:PTZPresetTourStartingConditionExtension': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStartingConditionExtension() : soap() { }
        virtual ~tt__PTZPresetTourStartingConditionExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1525 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (545)
/* complex XSD type 'tt:PTZPresetTourOptions': */
class SOAP_CMAC tt__PTZPresetTourOptions {
      public:
        /// Required element 'tt:AutoStart' of XSD type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'tt:StartingCondition' of XSD type 'tt:PTZPresetTourStartingConditionOptions'
        tt__PTZPresetTourStartingConditionOptions *StartingCondition;
        /// Required element 'tt:TourSpot' of XSD type 'tt:PTZPresetTourSpotOptions'
        tt__PTZPresetTourSpotOptions *TourSpot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourOptions); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourOptions() : AutoStart(), StartingCondition(), TourSpot(), soap() { }
        virtual ~tt__PTZPresetTourOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1528 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (546)
/* complex XSD type 'tt:PTZPresetTourSpotOptions': */
class SOAP_CMAC tt__PTZPresetTourSpotOptions {
      public:
        /// Required element 'tt:PresetDetail' of XSD type 'tt:PTZPresetTourPresetDetailOptions'
        tt__PTZPresetTourPresetDetailOptions *PresetDetail;
        /// Required element 'tt:StayTime' of XSD type 'tt:DurationRange'
        tt__DurationRange *StayTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpotOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpotOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpotOptions); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourSpotOptions() : PresetDetail(), StayTime(), soap() { }
        virtual ~tt__PTZPresetTourSpotOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpotOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1531 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (547)
/* complex XSD type 'tt:PTZPresetTourPresetDetailOptions': */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions {
      public:
        /// Optional element 'tt:PresetToken' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> PresetToken;
        /// Optional element 'tt:Home' of XSD type 'xsd:boolean'
        bool *Home;
        /// Optional element 'tt:PanTiltPositionSpace' of XSD type 'tt:Space2DDescription'
        tt__Space2DDescription *PanTiltPositionSpace;
        /// Optional element 'tt:ZoomPositionSpace' of XSD type 'tt:Space1DDescription'
        tt__Space1DDescription *ZoomPositionSpace;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourPresetDetailOptionsExtension'
        tt__PTZPresetTourPresetDetailOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetailOptions); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourPresetDetailOptions() : PresetToken(), Home(), PanTiltPositionSpace(), ZoomPositionSpace(), Extension(), soap() { }
        virtual ~tt__PTZPresetTourPresetDetailOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetailOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1534 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (548)
/* complex XSD type 'tt:PTZPresetTourPresetDetailOptionsExtension': */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetailOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourPresetDetailOptionsExtension() : soap() { }
        virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1537 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (549)
/* complex XSD type 'tt:PTZPresetTourStartingConditionOptions': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions {
      public:
        /// Optional element 'tt:RecurringTime' of XSD type 'tt:IntRange'
        tt__IntRange *RecurringTime;
        /// Optional element 'tt:RecurringDuration' of XSD type 'tt:DurationRange'
        tt__DurationRange *RecurringDuration;
        /// Optional element 'tt:Direction' of XSD type 'tt:PTZPresetTourDirection'
        std::vector<enum tt__PTZPresetTourDirection> Direction;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZPresetTourStartingConditionOptionsExtension'
        tt__PTZPresetTourStartingConditionOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionOptions); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStartingConditionOptions() : RecurringTime(), RecurringDuration(), Direction(), Extension(), soap() { }
        virtual ~tt__PTZPresetTourStartingConditionOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1540 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (550)
/* complex XSD type 'tt:PTZPresetTourStartingConditionOptionsExtension': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__PTZPresetTourStartingConditionOptionsExtension() : soap() { }
        virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1543 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (551)
/* complex XSD type 'tt:FocusConfiguration': */
class SOAP_CMAC tt__FocusConfiguration {
      public:
        /// Required element 'tt:AutoFocusMode' of XSD type 'tt:AutoFocusMode'
        enum tt__AutoFocusMode AutoFocusMode;
        /// Required element 'tt:DefaultSpeed' of XSD type 'xsd:float'
        float DefaultSpeed;
        /// Required element 'tt:NearLimit' of XSD type 'xsd:float'
        float NearLimit;
        /// Required element 'tt:FarLimit' of XSD type 'xsd:float'
        float FarLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration); }
      public:
        /// Constructor with initializations
        tt__FocusConfiguration() : AutoFocusMode(), DefaultSpeed(), NearLimit(), FarLimit(), soap() { }
        virtual ~tt__FocusConfiguration() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1546 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (552)
/* complex XSD type 'tt:ImagingSettings': */
class SOAP_CMAC tt__ImagingSettings {
      public:
        /// Optional element 'tt:BacklightCompensation' of XSD type 'tt:BacklightCompensation'
        tt__BacklightCompensation *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XSD type 'xsd:float'
        float *Brightness;
        /// Optional element 'tt:ColorSaturation' of XSD type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'tt:Contrast' of XSD type 'xsd:float'
        float *Contrast;
        /// Optional element 'tt:Exposure' of XSD type 'tt:Exposure'
        tt__Exposure *Exposure;
        /// Optional element 'tt:Focus' of XSD type 'tt:FocusConfiguration'
        tt__FocusConfiguration *Focus;
        /// Optional element 'tt:IrCutFilter' of XSD type 'tt:IrCutFilterMode'
        enum tt__IrCutFilterMode *IrCutFilter;
        /// Optional element 'tt:Sharpness' of XSD type 'xsd:float'
        float *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XSD type 'tt:WideDynamicRange'
        tt__WideDynamicRange *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XSD type 'tt:WhiteBalance'
        tt__WhiteBalance *WhiteBalance;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingSettingsExtension'
        tt__ImagingSettingsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
        virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettings); }
      public:
        /// Constructor with initializations
        tt__ImagingSettings() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilter(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), soap() { }
        virtual ~tt__ImagingSettings() { }
        /// Friend allocator used by soap_new_tt__ImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1549 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (553)
/* complex XSD type 'tt:ImagingSettingsExtension': */
class SOAP_CMAC tt__ImagingSettingsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension); }
      public:
        /// Constructor with initializations
        tt__ImagingSettingsExtension() : soap() { }
        virtual ~tt__ImagingSettingsExtension() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1552 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (554)
/* complex XSD type 'tt:Exposure': */
class SOAP_CMAC tt__Exposure {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ExposureMode'
        enum tt__ExposureMode Mode;
        /// Required element 'tt:Priority' of XSD type 'tt:ExposurePriority'
        enum tt__ExposurePriority Priority;
        /// Required element 'tt:Window' of XSD type 'tt:Rectangle'
        tt__Rectangle *Window;
        /// Required element 'tt:MinExposureTime' of XSD type 'xsd:float'
        float MinExposureTime;
        /// Required element 'tt:MaxExposureTime' of XSD type 'xsd:float'
        float MaxExposureTime;
        /// Required element 'tt:MinGain' of XSD type 'xsd:float'
        float MinGain;
        /// Required element 'tt:MaxGain' of XSD type 'xsd:float'
        float MaxGain;
        /// Required element 'tt:MinIris' of XSD type 'xsd:float'
        float MinIris;
        /// Required element 'tt:MaxIris' of XSD type 'xsd:float'
        float MaxIris;
        /// Required element 'tt:ExposureTime' of XSD type 'xsd:float'
        float ExposureTime;
        /// Required element 'tt:Gain' of XSD type 'xsd:float'
        float Gain;
        /// Required element 'tt:Iris' of XSD type 'xsd:float'
        float Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Exposure
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Exposure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
        virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Exposure); }
      public:
        /// Constructor with initializations
        tt__Exposure() : Mode(), Priority(), Window(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris(), soap() { }
        virtual ~tt__Exposure() { }
        /// Friend allocator used by soap_new_tt__Exposure(struct soap*, int)
        friend SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1555 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (555)
/* complex XSD type 'tt:WideDynamicRange': */
class SOAP_CMAC tt__WideDynamicRange {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WideDynamicMode'
        enum tt__WideDynamicMode Mode;
        /// Required element 'tt:Level' of XSD type 'xsd:float'
        float Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
        virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRange); }
      public:
        /// Constructor with initializations
        tt__WideDynamicRange() : Mode(), Level(), soap() { }
        virtual ~tt__WideDynamicRange() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRange(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1558 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (556)
/* complex XSD type 'tt:BacklightCompensation': */
class SOAP_CMAC tt__BacklightCompensation {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:BacklightCompensationMode'
        enum tt__BacklightCompensationMode Mode;
        /// Required element 'tt:Level' of XSD type 'xsd:float'
        float Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
        virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensation); }
      public:
        /// Constructor with initializations
        tt__BacklightCompensation() : Mode(), Level(), soap() { }
        virtual ~tt__BacklightCompensation() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensation(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1561 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (557)
/* complex XSD type 'tt:FocusMove': */
class SOAP_CMAC tt__FocusMove {
      public:
        /// Optional element 'tt:Absolute' of XSD type 'tt:AbsoluteFocus'
        tt__AbsoluteFocus *Absolute;
        /// Optional element 'tt:Relative' of XSD type 'tt:RelativeFocus'
        tt__RelativeFocus *Relative;
        /// Optional element 'tt:Continuous' of XSD type 'tt:ContinuousFocus'
        tt__ContinuousFocus *Continuous;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusMove
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
        virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusMove); }
      public:
        /// Constructor with initializations
        tt__FocusMove() : Absolute(), Relative(), Continuous(), soap() { }
        virtual ~tt__FocusMove() { }
        /// Friend allocator used by soap_new_tt__FocusMove(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1564 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (558)
/* complex XSD type 'tt:AbsoluteFocus': */
class SOAP_CMAC tt__AbsoluteFocus {
      public:
        /// Required element 'tt:Position' of XSD type 'xsd:float'
        float Position;
        /// Optional element 'tt:Speed' of XSD type 'xsd:float'
        float *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocus); }
      public:
        /// Constructor with initializations
        tt__AbsoluteFocus() : Position(), Speed(), soap() { }
        virtual ~tt__AbsoluteFocus() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1567 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (559)
/* complex XSD type 'tt:RelativeFocus': */
class SOAP_CMAC tt__RelativeFocus {
      public:
        /// Required element 'tt:Distance' of XSD type 'xsd:float'
        float Distance;
        /// Optional element 'tt:Speed' of XSD type 'xsd:float'
        float *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
        virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocus); }
      public:
        /// Constructor with initializations
        tt__RelativeFocus() : Distance(), Speed(), soap() { }
        virtual ~tt__RelativeFocus() { }
        /// Friend allocator used by soap_new_tt__RelativeFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1570 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (560)
/* complex XSD type 'tt:ContinuousFocus': */
class SOAP_CMAC tt__ContinuousFocus {
      public:
        /// Required element 'tt:Speed' of XSD type 'xsd:float'
        float Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
        virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocus); }
      public:
        /// Constructor with initializations
        tt__ContinuousFocus() : Speed(), soap() { }
        virtual ~tt__ContinuousFocus() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1573 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (561)
/* complex XSD type 'tt:AbsoluteFocusOptions': */
class SOAP_CMAC tt__AbsoluteFocusOptions {
      public:
        /// Required element 'tt:Position' of XSD type 'tt:FloatRange'
        tt__FloatRange *Position;
        /// Optional element 'tt:Speed' of XSD type 'tt:FloatRange'
        tt__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocusOptions); }
      public:
        /// Constructor with initializations
        tt__AbsoluteFocusOptions() : Position(), Speed(), soap() { }
        virtual ~tt__AbsoluteFocusOptions() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1576 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (562)
/* complex XSD type 'tt:ContinuousFocusOptions': */
class SOAP_CMAC tt__ContinuousFocusOptions {
      public:
        /// Required element 'tt:Speed' of XSD type 'tt:FloatRange'
        tt__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
        virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocusOptions); }
      public:
        /// Constructor with initializations
        tt__ContinuousFocusOptions() : Speed(), soap() { }
        virtual ~tt__ContinuousFocusOptions() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1579 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (563)
/* complex XSD type 'tt:WhiteBalance': */
class SOAP_CMAC tt__WhiteBalance {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WhiteBalanceMode'
        enum tt__WhiteBalanceMode Mode;
        /// Required element 'tt:CrGain' of XSD type 'xsd:float'
        float CrGain;
        /// Required element 'tt:CbGain' of XSD type 'xsd:float'
        float CbGain;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
        virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance); }
      public:
        /// Constructor with initializations
        tt__WhiteBalance() : Mode(), CrGain(), CbGain(), soap() { }
        virtual ~tt__WhiteBalance() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1582 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (564)
/* complex XSD type 'tt:ImagingStatus20': */
class SOAP_CMAC tt__ImagingStatus20 {
      public:
        /// Optional element 'tt:FocusStatus20' of XSD type 'tt:FocusStatus20'
        tt__FocusStatus20 *FocusStatus20;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingStatus20Extension'
        tt__ImagingStatus20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20); }
      public:
        /// Constructor with initializations
        tt__ImagingStatus20() : FocusStatus20(), Extension(), soap() { }
        virtual ~tt__ImagingStatus20() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1585 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (565)
/* complex XSD type 'tt:ImagingStatus20Extension': */
class SOAP_CMAC tt__ImagingStatus20Extension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20Extension); }
      public:
        /// Constructor with initializations
        tt__ImagingStatus20Extension() : soap() { }
        virtual ~tt__ImagingStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1588 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (566)
/* complex XSD type 'tt:FocusStatus20': */
class SOAP_CMAC tt__FocusStatus20 {
      public:
        /// Required element 'tt:Position' of XSD type 'xsd:float'
        float Position;
        /// Required element 'tt:MoveStatus' of XSD type 'tt:MoveStatus'
        enum tt__MoveStatus MoveStatus;
        /// Optional element 'tt:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Optional element 'tt:Extension' of XSD type 'tt:FocusStatus20Extension'
        tt__FocusStatus20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
        virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20); }
      public:
        /// Constructor with initializations
        tt__FocusStatus20() : Position(), MoveStatus(), Error(), Extension(), soap() { }
        virtual ~tt__FocusStatus20() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1591 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (567)
/* complex XSD type 'tt:FocusStatus20Extension': */
class SOAP_CMAC tt__FocusStatus20Extension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
        virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20Extension); }
      public:
        /// Constructor with initializations
        tt__FocusStatus20Extension() : soap() { }
        virtual ~tt__FocusStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1594 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (568)
/* complex XSD type 'tt:ImagingSettings20': */
class SOAP_CMAC tt__ImagingSettings20 {
      public:
        /// Optional element 'tt:BacklightCompensation' of XSD type 'tt:BacklightCompensation20'
        tt__BacklightCompensation20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XSD type 'xsd:float'
        float *Brightness;
        /// Optional element 'tt:ColorSaturation' of XSD type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'tt:Contrast' of XSD type 'xsd:float'
        float *Contrast;
        /// Optional element 'tt:Exposure' of XSD type 'tt:Exposure20'
        tt__Exposure20 *Exposure;
        /// Optional element 'tt:Focus' of XSD type 'tt:FocusConfiguration20'
        tt__FocusConfiguration20 *Focus;
        /// Optional element 'tt:IrCutFilter' of XSD type 'tt:IrCutFilterMode'
        enum tt__IrCutFilterMode *IrCutFilter;
        /// Optional element 'tt:Sharpness' of XSD type 'xsd:float'
        float *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XSD type 'tt:WideDynamicRange20'
        tt__WideDynamicRange20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XSD type 'tt:WhiteBalance20'
        tt__WhiteBalance20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingSettingsExtension20'
        tt__ImagingSettingsExtension20 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettings20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettings20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
        virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettings20); }
      public:
        /// Constructor with initializations
        tt__ImagingSettings20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilter(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), soap() { }
        virtual ~tt__ImagingSettings20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettings20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1597 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (569)
/* complex XSD type 'tt:ImagingSettingsExtension20': */
class SOAP_CMAC tt__ImagingSettingsExtension20 {
      public:
        /// Optional element 'tt:ImageStabilization' of XSD type 'tt:ImageStabilization'
        tt__ImageStabilization *ImageStabilization;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingSettingsExtension202'
        tt__ImagingSettingsExtension202 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension20); }
      public:
        /// Constructor with initializations
        tt__ImagingSettingsExtension20() : ImageStabilization(), Extension(), soap() { }
        virtual ~tt__ImagingSettingsExtension20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1600 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (570)
/* complex XSD type 'tt:ImagingSettingsExtension202': */
class SOAP_CMAC tt__ImagingSettingsExtension202 {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XSD type 'tt:IrCutFilterAutoAdjustment'
        std::vector<tt__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingSettingsExtension203'
        tt__ImagingSettingsExtension203 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension202
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension202; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension202); }
      public:
        /// Constructor with initializations
        tt__ImagingSettingsExtension202() : IrCutFilterAutoAdjustment(), Extension(), soap() { }
        virtual ~tt__ImagingSettingsExtension202() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension202(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1603 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (571)
/* complex XSD type 'tt:ImagingSettingsExtension203': */
class SOAP_CMAC tt__ImagingSettingsExtension203 {
      public:
        /// Optional element 'tt:ToneCompensation' of XSD type 'tt:ToneCompensation'
        tt__ToneCompensation *ToneCompensation;
        /// Optional element 'tt:Defogging' of XSD type 'tt:Defogging'
        tt__Defogging *Defogging;
        /// Optional element 'tt:NoiseReduction' of XSD type 'tt:NoiseReduction'
        tt__NoiseReduction *NoiseReduction;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingSettingsExtension204'
        tt__ImagingSettingsExtension204 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension203
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension203; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension203); }
      public:
        /// Constructor with initializations
        tt__ImagingSettingsExtension203() : ToneCompensation(), Defogging(), NoiseReduction(), Extension(), soap() { }
        virtual ~tt__ImagingSettingsExtension203() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension203(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1606 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (572)
/* complex XSD type 'tt:ImagingSettingsExtension204': */
class SOAP_CMAC tt__ImagingSettingsExtension204 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension204
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension204; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension204); }
      public:
        /// Constructor with initializations
        tt__ImagingSettingsExtension204() : soap() { }
        virtual ~tt__ImagingSettingsExtension204() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension204(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1609 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (573)
/* complex XSD type 'tt:ImageStabilization': */
class SOAP_CMAC tt__ImageStabilization {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ImageStabilizationMode'
        enum tt__ImageStabilizationMode Mode;
        /// Optional element 'tt:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImageStabilizationExtension'
        tt__ImageStabilizationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilization
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilization; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
        virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilization); }
      public:
        /// Constructor with initializations
        tt__ImageStabilization() : Mode(), Level(), Extension(), soap() { }
        virtual ~tt__ImageStabilization() { }
        /// Friend allocator used by soap_new_tt__ImageStabilization(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1612 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (574)
/* complex XSD type 'tt:ImageStabilizationExtension': */
class SOAP_CMAC tt__ImageStabilizationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationExtension); }
      public:
        /// Constructor with initializations
        tt__ImageStabilizationExtension() : soap() { }
        virtual ~tt__ImageStabilizationExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1615 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (575)
/* complex XSD type 'tt:IrCutFilterAutoAdjustment': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment {
      public:
        /// Required element 'tt:BoundaryType' of XSD type 'xsd:string'
        std::string BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XSD type 'xsd:float'
        float *BoundaryOffset;
        /// Optional element 'tt:ResponseTime' of XSD type 'xsd:duration'
        std::string *ResponseTime;
        /// Optional element 'tt:Extension' of XSD type 'tt:IrCutFilterAutoAdjustmentExtension'
        tt__IrCutFilterAutoAdjustmentExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustment
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustment); }
      public:
        /// Constructor with initializations
        tt__IrCutFilterAutoAdjustment() : BoundaryType(), BoundaryOffset(), ResponseTime(), Extension(), soap() { }
        virtual ~tt__IrCutFilterAutoAdjustment() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustment(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1618 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (576)
/* complex XSD type 'tt:IrCutFilterAutoAdjustmentExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentExtension); }
      public:
        /// Constructor with initializations
        tt__IrCutFilterAutoAdjustmentExtension() : soap() { }
        virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1621 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (577)
/* complex XSD type 'tt:WideDynamicRange20': */
class SOAP_CMAC tt__WideDynamicRange20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WideDynamicMode'
        enum tt__WideDynamicMode Mode;
        /// Optional element 'tt:Level' of XSD type 'xsd:float'
        float *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRange20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRange20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRange20); }
      public:
        /// Constructor with initializations
        tt__WideDynamicRange20() : Mode(), Level(), soap() { }
        virtual ~tt__WideDynamicRange20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRange20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1624 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (578)
/* complex XSD type 'tt:BacklightCompensation20': */
class SOAP_CMAC tt__BacklightCompensation20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:BacklightCompensationMode'
        enum tt__BacklightCompensationMode Mode;
        /// Optional element 'tt:Level' of XSD type 'xsd:float'
        float *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensation20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensation20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensation20); }
      public:
        /// Constructor with initializations
        tt__BacklightCompensation20() : Mode(), Level(), soap() { }
        virtual ~tt__BacklightCompensation20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensation20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1627 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (579)
/* complex XSD type 'tt:Exposure20': */
class SOAP_CMAC tt__Exposure20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ExposureMode'
        enum tt__ExposureMode Mode;
        /// Optional element 'tt:Priority' of XSD type 'tt:ExposurePriority'
        enum tt__ExposurePriority *Priority;
        /// Optional element 'tt:Window' of XSD type 'tt:Rectangle'
        tt__Rectangle *Window;
        /// Optional element 'tt:MinExposureTime' of XSD type 'xsd:float'
        float *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XSD type 'xsd:float'
        float *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XSD type 'xsd:float'
        float *MinGain;
        /// Optional element 'tt:MaxGain' of XSD type 'xsd:float'
        float *MaxGain;
        /// Optional element 'tt:MinIris' of XSD type 'xsd:float'
        float *MinIris;
        /// Optional element 'tt:MaxIris' of XSD type 'xsd:float'
        float *MaxIris;
        /// Optional element 'tt:ExposureTime' of XSD type 'xsd:float'
        float *ExposureTime;
        /// Optional element 'tt:Gain' of XSD type 'xsd:float'
        float *Gain;
        /// Optional element 'tt:Iris' of XSD type 'xsd:float'
        float *Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Exposure20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Exposure20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
        virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Exposure20); }
      public:
        /// Constructor with initializations
        tt__Exposure20() : Mode(), Priority(), Window(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris(), soap() { }
        virtual ~tt__Exposure20() { }
        /// Friend allocator used by soap_new_tt__Exposure20(struct soap*, int)
        friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1630 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (580)
/* complex XSD type 'tt:ToneCompensation': */
class SOAP_CMAC tt__ToneCompensation {
      public:
        /// Required element 'tt:Mode' of XSD type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XSD type 'tt:ToneCompensationExtension'
        tt__ToneCompensationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
        virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensation); }
      public:
        /// Constructor with initializations
        tt__ToneCompensation() : Mode(), Level(), Extension(), soap() { }
        virtual ~tt__ToneCompensation() { }
        /// Friend allocator used by soap_new_tt__ToneCompensation(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1633 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (581)
/* complex XSD type 'tt:ToneCompensationExtension': */
class SOAP_CMAC tt__ToneCompensationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
        virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationExtension); }
      public:
        /// Constructor with initializations
        tt__ToneCompensationExtension() : soap() { }
        virtual ~tt__ToneCompensationExtension() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1636 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (582)
/* complex XSD type 'tt:Defogging': */
class SOAP_CMAC tt__Defogging {
      public:
        /// Required element 'tt:Mode' of XSD type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XSD type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XSD type 'tt:DefoggingExtension'
        tt__DefoggingExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Defogging
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Defogging; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
        virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Defogging); }
      public:
        /// Constructor with initializations
        tt__Defogging() : Mode(), Level(), Extension(), soap() { }
        virtual ~tt__Defogging() { }
        /// Friend allocator used by soap_new_tt__Defogging(struct soap*, int)
        friend SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1639 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (583)
/* complex XSD type 'tt:DefoggingExtension': */
class SOAP_CMAC tt__DefoggingExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
        virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingExtension); }
      public:
        /// Constructor with initializations
        tt__DefoggingExtension() : soap() { }
        virtual ~tt__DefoggingExtension() { }
        /// Friend allocator used by soap_new_tt__DefoggingExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1642 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (584)
/* complex XSD type 'tt:NoiseReduction': */
class SOAP_CMAC tt__NoiseReduction {
      public:
        /// Required element 'tt:Level' of XSD type 'xsd:float'
        float Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReduction
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReduction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
        virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReduction); }
      public:
        /// Constructor with initializations
        tt__NoiseReduction() : Level(), soap() { }
        virtual ~tt__NoiseReduction() { }
        /// Friend allocator used by soap_new_tt__NoiseReduction(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1645 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (585)
/* complex XSD type 'tt:ImagingOptions20': */
class SOAP_CMAC tt__ImagingOptions20 {
      public:
        /// Optional element 'tt:BacklightCompensation' of XSD type 'tt:BacklightCompensationOptions20'
        tt__BacklightCompensationOptions20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XSD type 'tt:FloatRange'
        tt__FloatRange *Brightness;
        /// Optional element 'tt:ColorSaturation' of XSD type 'tt:FloatRange'
        tt__FloatRange *ColorSaturation;
        /// Optional element 'tt:Contrast' of XSD type 'tt:FloatRange'
        tt__FloatRange *Contrast;
        /// Optional element 'tt:Exposure' of XSD type 'tt:ExposureOptions20'
        tt__ExposureOptions20 *Exposure;
        /// Optional element 'tt:Focus' of XSD type 'tt:FocusOptions20'
        tt__FocusOptions20 *Focus;
        /// Optional element 'tt:IrCutFilterModes' of XSD type 'tt:IrCutFilterMode'
        std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;
        /// Optional element 'tt:Sharpness' of XSD type 'tt:FloatRange'
        tt__FloatRange *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XSD type 'tt:WideDynamicRangeOptions20'
        tt__WideDynamicRangeOptions20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XSD type 'tt:WhiteBalanceOptions20'
        tt__WhiteBalanceOptions20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingOptions20Extension'
        tt__ImagingOptions20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20); }
      public:
        /// Constructor with initializations
        tt__ImagingOptions20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilterModes(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), soap() { }
        virtual ~tt__ImagingOptions20() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1648 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (586)
/* complex XSD type 'tt:ImagingOptions20Extension': */
class SOAP_CMAC tt__ImagingOptions20Extension {
      public:
        /// Optional element 'tt:ImageStabilization' of XSD type 'tt:ImageStabilizationOptions'
        tt__ImageStabilizationOptions *ImageStabilization;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingOptions20Extension2'
        tt__ImagingOptions20Extension2 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension); }
      public:
        /// Constructor with initializations
        tt__ImagingOptions20Extension() : ImageStabilization(), Extension(), soap() { }
        virtual ~tt__ImagingOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1651 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (587)
/* complex XSD type 'tt:ImagingOptions20Extension2': */
class SOAP_CMAC tt__ImagingOptions20Extension2 {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XSD type 'tt:IrCutFilterAutoAdjustmentOptions'
        tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingOptions20Extension3'
        tt__ImagingOptions20Extension3 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension2); }
      public:
        /// Constructor with initializations
        tt__ImagingOptions20Extension2() : IrCutFilterAutoAdjustment(), Extension(), soap() { }
        virtual ~tt__ImagingOptions20Extension2() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension2(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1654 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (588)
/* complex XSD type 'tt:ImagingOptions20Extension3': */
class SOAP_CMAC tt__ImagingOptions20Extension3 {
      public:
        /// Optional element 'tt:ToneCompensationOptions' of XSD type 'tt:ToneCompensationOptions'
        tt__ToneCompensationOptions *ToneCompensationOptions;
        /// Optional element 'tt:DefoggingOptions' of XSD type 'tt:DefoggingOptions'
        tt__DefoggingOptions *DefoggingOptions;
        /// Optional element 'tt:NoiseReductionOptions' of XSD type 'tt:NoiseReductionOptions'
        tt__NoiseReductionOptions *NoiseReductionOptions;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImagingOptions20Extension4'
        tt__ImagingOptions20Extension4 *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension3
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension3); }
      public:
        /// Constructor with initializations
        tt__ImagingOptions20Extension3() : ToneCompensationOptions(), DefoggingOptions(), NoiseReductionOptions(), Extension(), soap() { }
        virtual ~tt__ImagingOptions20Extension3() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension3(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1657 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (589)
/* complex XSD type 'tt:ImagingOptions20Extension4': */
class SOAP_CMAC tt__ImagingOptions20Extension4 {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension4
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension4); }
      public:
        /// Constructor with initializations
        tt__ImagingOptions20Extension4() : soap() { }
        virtual ~tt__ImagingOptions20Extension4() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension4(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1660 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (590)
/* complex XSD type 'tt:ImageStabilizationOptions': */
class SOAP_CMAC tt__ImageStabilizationOptions {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ImageStabilizationMode'
        std::vector<enum tt__ImageStabilizationMode> Mode;
        /// Optional element 'tt:Level' of XSD type 'tt:FloatRange'
        tt__FloatRange *Level;
        /// Optional element 'tt:Extension' of XSD type 'tt:ImageStabilizationOptionsExtension'
        tt__ImageStabilizationOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptions); }
      public:
        /// Constructor with initializations
        tt__ImageStabilizationOptions() : Mode(), Level(), Extension(), soap() { }
        virtual ~tt__ImageStabilizationOptions() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1663 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (591)
/* complex XSD type 'tt:ImageStabilizationOptionsExtension': */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__ImageStabilizationOptionsExtension() : soap() { }
        virtual ~tt__ImageStabilizationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1666 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (592)
/* complex XSD type 'tt:IrCutFilterAutoAdjustmentOptions': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions {
      public:
        /// Required element 'tt:BoundaryType' of XSD type 'xsd:string'
        std::vector<std::string> BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XSD type 'xsd:boolean'
        bool *BoundaryOffset;
        /// Optional element 'tt:ResponseTimeRange' of XSD type 'tt:DurationRange'
        tt__DurationRange *ResponseTimeRange;
        /// Optional element 'tt:Extension' of XSD type 'tt:IrCutFilterAutoAdjustmentOptionsExtension'
        tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptions); }
      public:
        /// Constructor with initializations
        tt__IrCutFilterAutoAdjustmentOptions() : BoundaryType(), BoundaryOffset(), ResponseTimeRange(), Extension(), soap() { }
        virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1669 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (593)
/* complex XSD type 'tt:IrCutFilterAutoAdjustmentOptionsExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__IrCutFilterAutoAdjustmentOptionsExtension() : soap() { }
        virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1672 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (594)
/* complex XSD type 'tt:WideDynamicRangeOptions20': */
class SOAP_CMAC tt__WideDynamicRangeOptions20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WideDynamicMode'
        std::vector<enum tt__WideDynamicMode> Mode;
        /// Optional element 'tt:Level' of XSD type 'tt:FloatRange'
        tt__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRangeOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRangeOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRangeOptions20); }
      public:
        /// Constructor with initializations
        tt__WideDynamicRangeOptions20() : Mode(), Level(), soap() { }
        virtual ~tt__WideDynamicRangeOptions20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRangeOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1675 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (595)
/* complex XSD type 'tt:BacklightCompensationOptions20': */
class SOAP_CMAC tt__BacklightCompensationOptions20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:BacklightCompensationMode'
        std::vector<enum tt__BacklightCompensationMode> Mode;
        /// Optional element 'tt:Level' of XSD type 'tt:FloatRange'
        tt__FloatRange *Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationOptions20); }
      public:
        /// Constructor with initializations
        tt__BacklightCompensationOptions20() : Mode(), Level(), soap() { }
        virtual ~tt__BacklightCompensationOptions20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1678 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (596)
/* complex XSD type 'tt:ExposureOptions20': */
class SOAP_CMAC tt__ExposureOptions20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:ExposureMode'
        std::vector<enum tt__ExposureMode> Mode;
        /// Optional element 'tt:Priority' of XSD type 'tt:ExposurePriority'
        std::vector<enum tt__ExposurePriority> Priority;
        /// Optional element 'tt:MinExposureTime' of XSD type 'tt:FloatRange'
        tt__FloatRange *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XSD type 'tt:FloatRange'
        tt__FloatRange *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XSD type 'tt:FloatRange'
        tt__FloatRange *MinGain;
        /// Optional element 'tt:MaxGain' of XSD type 'tt:FloatRange'
        tt__FloatRange *MaxGain;
        /// Optional element 'tt:MinIris' of XSD type 'tt:FloatRange'
        tt__FloatRange *MinIris;
        /// Optional element 'tt:MaxIris' of XSD type 'tt:FloatRange'
        tt__FloatRange *MaxIris;
        /// Optional element 'tt:ExposureTime' of XSD type 'tt:FloatRange'
        tt__FloatRange *ExposureTime;
        /// Optional element 'tt:Gain' of XSD type 'tt:FloatRange'
        tt__FloatRange *Gain;
        /// Optional element 'tt:Iris' of XSD type 'tt:FloatRange'
        tt__FloatRange *Iris;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
        virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureOptions20); }
      public:
        /// Constructor with initializations
        tt__ExposureOptions20() : Mode(), Priority(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris(), soap() { }
        virtual ~tt__ExposureOptions20() { }
        /// Friend allocator used by soap_new_tt__ExposureOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1681 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (597)
/* complex XSD type 'tt:MoveOptions20': */
class SOAP_CMAC tt__MoveOptions20 {
      public:
        /// Optional element 'tt:Absolute' of XSD type 'tt:AbsoluteFocusOptions'
        tt__AbsoluteFocusOptions *Absolute;
        /// Optional element 'tt:Relative' of XSD type 'tt:RelativeFocusOptions20'
        tt__RelativeFocusOptions20 *Relative;
        /// Optional element 'tt:Continuous' of XSD type 'tt:ContinuousFocusOptions'
        tt__ContinuousFocusOptions *Continuous;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
        virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveOptions20); }
      public:
        /// Constructor with initializations
        tt__MoveOptions20() : Absolute(), Relative(), Continuous(), soap() { }
        virtual ~tt__MoveOptions20() { }
        /// Friend allocator used by soap_new_tt__MoveOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1684 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (598)
/* complex XSD type 'tt:RelativeFocusOptions20': */
class SOAP_CMAC tt__RelativeFocusOptions20 {
      public:
        /// Required element 'tt:Distance' of XSD type 'tt:FloatRange'
        tt__FloatRange *Distance;
        /// Optional element 'tt:Speed' of XSD type 'tt:FloatRange'
        tt__FloatRange *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
        virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocusOptions20); }
      public:
        /// Constructor with initializations
        tt__RelativeFocusOptions20() : Distance(), Speed(), soap() { }
        virtual ~tt__RelativeFocusOptions20() { }
        /// Friend allocator used by soap_new_tt__RelativeFocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1687 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (599)
/* complex XSD type 'tt:WhiteBalance20': */
class SOAP_CMAC tt__WhiteBalance20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WhiteBalanceMode'
        enum tt__WhiteBalanceMode Mode;
        /// Optional element 'tt:CrGain' of XSD type 'xsd:float'
        float *CrGain;
        /// Optional element 'tt:CbGain' of XSD type 'xsd:float'
        float *CbGain;
        /// Optional element 'tt:Extension' of XSD type 'tt:WhiteBalance20Extension'
        tt__WhiteBalance20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20); }
      public:
        /// Constructor with initializations
        tt__WhiteBalance20() : Mode(), CrGain(), CbGain(), Extension(), soap() { }
        virtual ~tt__WhiteBalance20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1690 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (600)
/* complex XSD type 'tt:WhiteBalance20Extension': */
class SOAP_CMAC tt__WhiteBalance20Extension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20Extension); }
      public:
        /// Constructor with initializations
        tt__WhiteBalance20Extension() : soap() { }
        virtual ~tt__WhiteBalance20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1693 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (601)
/* complex XSD type 'tt:FocusConfiguration20': */
class SOAP_CMAC tt__FocusConfiguration20 {
      public:
        /// Required element 'tt:AutoFocusMode' of XSD type 'tt:AutoFocusMode'
        enum tt__AutoFocusMode AutoFocusMode;
        /// Optional element 'tt:DefaultSpeed' of XSD type 'xsd:float'
        float *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XSD type 'xsd:float'
        float *NearLimit;
        /// Optional element 'tt:FarLimit' of XSD type 'xsd:float'
        float *FarLimit;
        /// Optional element 'tt:Extension' of XSD type 'tt:FocusConfiguration20Extension'
        tt__FocusConfiguration20Extension *Extension;
        /// optional attribute 'AFMode' of XSD type 'tt:StringAttrList'
        std::string *AFMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20); }
      public:
        /// Constructor with initializations
        tt__FocusConfiguration20() : AutoFocusMode(), DefaultSpeed(), NearLimit(), FarLimit(), Extension(), AFMode(), soap() { }
        virtual ~tt__FocusConfiguration20() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1696 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (602)
/* complex XSD type 'tt:FocusConfiguration20Extension': */
class SOAP_CMAC tt__FocusConfiguration20Extension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20Extension); }
      public:
        /// Constructor with initializations
        tt__FocusConfiguration20Extension() : soap() { }
        virtual ~tt__FocusConfiguration20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1699 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (603)
/* complex XSD type 'tt:WhiteBalanceOptions20': */
class SOAP_CMAC tt__WhiteBalanceOptions20 {
      public:
        /// Required element 'tt:Mode' of XSD type 'tt:WhiteBalanceMode'
        std::vector<enum tt__WhiteBalanceMode> Mode;
        /// Optional element 'tt:YrGain' of XSD type 'tt:FloatRange'
        tt__FloatRange *YrGain;
        /// Optional element 'tt:YbGain' of XSD type 'tt:FloatRange'
        tt__FloatRange *YbGain;
        /// Optional element 'tt:Extension' of XSD type 'tt:WhiteBalanceOptions20Extension'
        tt__WhiteBalanceOptions20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20); }
      public:
        /// Constructor with initializations
        tt__WhiteBalanceOptions20() : Mode(), YrGain(), YbGain(), Extension(), soap() { }
        virtual ~tt__WhiteBalanceOptions20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1702 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (604)
/* complex XSD type 'tt:WhiteBalanceOptions20Extension': */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20Extension); }
      public:
        /// Constructor with initializations
        tt__WhiteBalanceOptions20Extension() : soap() { }
        virtual ~tt__WhiteBalanceOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1705 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (605)
/* complex XSD type 'tt:FocusOptions20': */
class SOAP_CMAC tt__FocusOptions20 {
      public:
        /// Optional element 'tt:AutoFocusModes' of XSD type 'tt:AutoFocusMode'
        std::vector<enum tt__AutoFocusMode> AutoFocusModes;
        /// Optional element 'tt:DefaultSpeed' of XSD type 'tt:FloatRange'
        tt__FloatRange *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XSD type 'tt:FloatRange'
        tt__FloatRange *NearLimit;
        /// Optional element 'tt:FarLimit' of XSD type 'tt:FloatRange'
        tt__FloatRange *FarLimit;
        /// Optional element 'tt:Extension' of XSD type 'tt:FocusOptions20Extension'
        tt__FocusOptions20Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
        virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20); }
      public:
        /// Constructor with initializations
        tt__FocusOptions20() : AutoFocusModes(), DefaultSpeed(), NearLimit(), FarLimit(), Extension(), soap() { }
        virtual ~tt__FocusOptions20() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1708 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (606)
/* complex XSD type 'tt:FocusOptions20Extension': */
class SOAP_CMAC tt__FocusOptions20Extension {
      public:
        /// Optional element 'tt:AFModes' of XSD type 'tt:StringAttrList'
        std::string *AFModes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
        virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20Extension); }
      public:
        /// Constructor with initializations
        tt__FocusOptions20Extension() : AFModes(), soap() { }
        virtual ~tt__FocusOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1711 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (607)
/* complex XSD type 'tt:ToneCompensationOptions': */
class SOAP_CMAC tt__ToneCompensationOptions {
      public:
        /// Required element 'tt:Mode' of XSD type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
        virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationOptions); }
      public:
        /// Constructor with initializations
        tt__ToneCompensationOptions() : Mode(), Level(), soap() { }
        virtual ~tt__ToneCompensationOptions() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1714 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (608)
/* complex XSD type 'tt:DefoggingOptions': */
class SOAP_CMAC tt__DefoggingOptions {
      public:
        /// Required element 'tt:Mode' of XSD type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
        virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingOptions); }
      public:
        /// Constructor with initializations
        tt__DefoggingOptions() : Mode(), Level(), soap() { }
        virtual ~tt__DefoggingOptions() { }
        /// Friend allocator used by soap_new_tt__DefoggingOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1717 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (609)
/* complex XSD type 'tt:NoiseReductionOptions': */
class SOAP_CMAC tt__NoiseReductionOptions {
      public:
        /// Required element 'tt:Level' of XSD type 'xsd:boolean'
        bool Level;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReductionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReductionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
        virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReductionOptions); }
      public:
        /// Constructor with initializations
        tt__NoiseReductionOptions() : Level(), soap() { }
        virtual ~tt__NoiseReductionOptions() { }
        /// Friend allocator used by soap_new_tt__NoiseReductionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1720 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (610)
/* complex XSD type 'tt:MessageExtension': */
class SOAP_CMAC tt__MessageExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MessageExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MessageExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
        virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MessageExtension); }
      public:
        /// Constructor with initializations
        tt__MessageExtension() : soap() { }
        virtual ~tt__MessageExtension() { }
        /// Friend allocator used by soap_new_tt__MessageExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:17883 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1596)
/* complex XSD type 'tt:ItemList-SimpleItem': */
class SOAP_CMAC _tt__ItemList_SimpleItem {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Value' of XSD type 'xsd:anySimpleType'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_SimpleItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_SimpleItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_SimpleItem); }
      public:
        /// Constructor with initializations
        _tt__ItemList_SimpleItem() : Name(), Value() { }
        virtual ~_tt__ItemList_SimpleItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_SimpleItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:17911 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1598)
/* complex XSD type 'tt:ItemList-ElementItem': */
class SOAP_CMAC _tt__ItemList_ElementItem {
      public:
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_ElementItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_ElementItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_ElementItem); }
      public:
        /// Constructor with initializations
        _tt__ItemList_ElementItem() : Name() { }
        virtual ~_tt__ItemList_ElementItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_ElementItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1723 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (611)
/* complex XSD type 'tt:ItemList': */
class SOAP_CMAC tt__ItemList {
      public:
        /// Optional element 'tt:SimpleItem' of XSD type 'tt:ItemList-SimpleItem'
        std::vector<_tt__ItemList_SimpleItem> SimpleItem;
        /// Optional element 'tt:ElementItem' of XSD type 'tt:ItemList-ElementItem'
        std::vector<_tt__ItemList_ElementItem> ElementItem;
        /// Optional element 'tt:Extension' of XSD type 'tt:ItemListExtension'
        tt__ItemListExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
        virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemList); }
      public:
        /// Constructor with initializations
        tt__ItemList() : SimpleItem(), ElementItem(), Extension(), soap() { }
        virtual ~tt__ItemList() { }
        /// Friend allocator used by soap_new_tt__ItemList(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1726 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (612)
/* complex XSD type 'tt:ItemListExtension': */
class SOAP_CMAC tt__ItemListExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemListExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemListExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
        virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemListExtension); }
      public:
        /// Constructor with initializations
        tt__ItemListExtension() : soap() { }
        virtual ~tt__ItemListExtension() { }
        /// Friend allocator used by soap_new_tt__ItemListExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1729 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (613)
/* complex XSD type 'tt:Polyline': */
class SOAP_CMAC tt__Polyline {
      public:
        /// Required element 'tt:Point' of XSD type 'tt:Vector'
        std::vector<tt__Vector *> Point;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polyline
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polyline; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
        virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polyline); }
      public:
        /// Constructor with initializations
        tt__Polyline() : Point(), soap() { }
        virtual ~tt__Polyline() { }
        /// Friend allocator used by soap_new_tt__Polyline(struct soap*, int)
        friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1732 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (614)
/* complex XSD type 'tt:AnalyticsEngineConfiguration': */
class SOAP_CMAC tt__AnalyticsEngineConfiguration {
      public:
        /// Optional element 'tt:AnalyticsModule' of XSD type 'tt:Config'
        std::vector<tt__Config *> AnalyticsModule;
        /// Optional element 'tt:Extension' of XSD type 'tt:AnalyticsEngineConfigurationExtension'
        tt__AnalyticsEngineConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfiguration); }
      public:
        /// Constructor with initializations
        tt__AnalyticsEngineConfiguration() : AnalyticsModule(), Extension(), soap() { }
        virtual ~tt__AnalyticsEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1735 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (615)
/* complex XSD type 'tt:AnalyticsEngineConfigurationExtension': */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__AnalyticsEngineConfigurationExtension() : soap() { }
        virtual ~tt__AnalyticsEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1738 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (616)
/* complex XSD type 'tt:RuleEngineConfiguration': */
class SOAP_CMAC tt__RuleEngineConfiguration {
      public:
        /// Optional element 'tt:Rule' of XSD type 'tt:Config'
        std::vector<tt__Config *> Rule;
        /// Optional element 'tt:Extension' of XSD type 'tt:RuleEngineConfigurationExtension'
        tt__RuleEngineConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfiguration); }
      public:
        /// Constructor with initializations
        tt__RuleEngineConfiguration() : Rule(), Extension(), soap() { }
        virtual ~tt__RuleEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1741 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (617)
/* complex XSD type 'tt:RuleEngineConfigurationExtension': */
class SOAP_CMAC tt__RuleEngineConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__RuleEngineConfigurationExtension() : soap() { }
        virtual ~tt__RuleEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1744 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (618)
/* complex XSD type 'tt:Config': */
class SOAP_CMAC tt__Config {
      public:
        /// Required element 'tt:Parameters' of XSD type 'tt:ItemList'
        tt__ItemList *Parameters;
        /// required attribute 'Name' of XSD type 'xsd:string'
        std::string Name;
        /// required attribute 'Type' of XSD type 'xsd:QName'
        std::string Type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Config
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Config; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Config, default initialized and not managed by a soap context
        virtual tt__Config *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Config); }
      public:
        /// Constructor with initializations
        tt__Config() : Parameters(), Name(), Type(), soap() { }
        virtual ~tt__Config() { }
        /// Friend allocator used by soap_new_tt__Config(struct soap*, int)
        friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1747 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (619)
/* complex XSD type 'tt:PaneLayout': */
class SOAP_CMAC tt__PaneLayout {
      public:
        /// Required element 'tt:Pane' of XSD type 'tt:ReferenceToken'
        std::string Pane;
        /// Required element 'tt:Area' of XSD type 'tt:Rectangle'
        tt__Rectangle *Area;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PaneLayout
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PaneLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
        virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PaneLayout); }
      public:
        /// Constructor with initializations
        tt__PaneLayout() : Pane(), Area(), soap() { }
        virtual ~tt__PaneLayout() { }
        /// Friend allocator used by soap_new_tt__PaneLayout(struct soap*, int)
        friend SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1750 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (620)
/* complex XSD type 'tt:Layout': */
class SOAP_CMAC tt__Layout {
      public:
        /// Required element 'tt:PaneLayout' of XSD type 'tt:PaneLayout'
        std::vector<tt__PaneLayout *> PaneLayout;
        /// Optional element 'tt:Extension' of XSD type 'tt:LayoutExtension'
        tt__LayoutExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Layout
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Layout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Layout, default initialized and not managed by a soap context
        virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Layout); }
      public:
        /// Constructor with initializations
        tt__Layout() : PaneLayout(), Extension(), soap() { }
        virtual ~tt__Layout() { }
        /// Friend allocator used by soap_new_tt__Layout(struct soap*, int)
        friend SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1753 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (621)
/* complex XSD type 'tt:LayoutExtension': */
class SOAP_CMAC tt__LayoutExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LayoutExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LayoutExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
        virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LayoutExtension); }
      public:
        /// Constructor with initializations
        tt__LayoutExtension() : soap() { }
        virtual ~tt__LayoutExtension() { }
        /// Friend allocator used by soap_new_tt__LayoutExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1756 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (622)
/* complex XSD type 'tt:DateTimeRange': */
class SOAP_CMAC tt__DateTimeRange {
      public:
        /// Required element 'tt:From' of XSD type 'xsd:dateTime'
        time_t From;
        /// Required element 'tt:Until' of XSD type 'xsd:dateTime'
        time_t Until;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__DateTimeRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DateTimeRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
        virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DateTimeRange); }
      public:
        /// Constructor with initializations
        tt__DateTimeRange() : From(), Until(), soap() { }
        virtual ~tt__DateTimeRange() { }
        /// Friend allocator used by soap_new_tt__DateTimeRange(struct soap*, int)
        friend SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1762 */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (624)
/* complex XSD type 'tt:OSDPosConfiguration': */
class SOAP_CMAC tt__OSDPosConfiguration {
      public:
        /// Required element 'tt:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Optional element 'tt:Pos' of XSD type 'tt:Vector'
        tt__Vector *Pos;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDPosConfigurationExtension'
        tt__OSDPosConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDPosConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDPosConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDPosConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDPosConfiguration); }
      public:
        /// Constructor with initializations
        tt__OSDPosConfiguration() : Type(), Pos(), Extension(), soap() { }
        virtual ~tt__OSDPosConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDPosConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1765 */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (625)
/* complex XSD type 'tt:OSDPosConfigurationExtension': */
class SOAP_CMAC tt__OSDPosConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDPosConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDPosConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDPosConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDPosConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__OSDPosConfigurationExtension() : soap() { }
        virtual ~tt__OSDPosConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDPosConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1768 */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (626)
/* complex XSD type 'tt:OSDColor': */
class SOAP_CMAC tt__OSDColor {
      public:
        /// Required element 'tt:Color' of XSD type 'tt:Color'
        tt__Color *Color;
        /// optional attribute 'Transparent' of XSD type 'xsd:int'
        int *Transparent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColor
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColor, default initialized and not managed by a soap context
        virtual tt__OSDColor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColor); }
      public:
        /// Constructor with initializations
        tt__OSDColor() : Color(), Transparent(), soap() { }
        virtual ~tt__OSDColor() { }
        /// Friend allocator used by soap_new_tt__OSDColor(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1771 */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (627)
/* complex XSD type 'tt:OSDTextConfiguration': */
class SOAP_CMAC tt__OSDTextConfiguration {
      public:
        /// Required element 'tt:Type' of XSD type 'xsd:string'
        std::string Type;
        /// Optional element 'tt:DateFormat' of XSD type 'xsd:string'
        std::string *DateFormat;
        /// Optional element 'tt:TimeFormat' of XSD type 'xsd:string'
        std::string *TimeFormat;
        /// Optional element 'tt:FontSize' of XSD type 'xsd:int'
        int *FontSize;
        /// Optional element 'tt:FontColor' of XSD type 'tt:OSDColor'
        tt__OSDColor *FontColor;
        /// Optional element 'tt:BackgroundColor' of XSD type 'tt:OSDColor'
        tt__OSDColor *BackgroundColor;
        /// Optional element 'tt:PlainText' of XSD type 'xsd:string'
        std::string *PlainText;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDTextConfigurationExtension'
        tt__OSDTextConfigurationExtension *Extension;
        /// optional attribute 'IsPersistentText' of XSD type 'xsd:boolean'
        bool *IsPersistentText;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextConfiguration); }
      public:
        /// Constructor with initializations
        tt__OSDTextConfiguration() : Type(), DateFormat(), TimeFormat(), FontSize(), FontColor(), BackgroundColor(), PlainText(), Extension(), IsPersistentText(), soap() { }
        virtual ~tt__OSDTextConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDTextConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1774 */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (628)
/* complex XSD type 'tt:OSDTextConfigurationExtension': */
class SOAP_CMAC tt__OSDTextConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__OSDTextConfigurationExtension() : soap() { }
        virtual ~tt__OSDTextConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDTextConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1777 */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (629)
/* complex XSD type 'tt:OSDImgConfiguration': */
class SOAP_CMAC tt__OSDImgConfiguration {
      public:
        /// Required element 'tt:ImgPath' of XSD type 'xsd:anyURI'
        std::string ImgPath;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDImgConfigurationExtension'
        tt__OSDImgConfigurationExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgConfiguration); }
      public:
        /// Constructor with initializations
        tt__OSDImgConfiguration() : ImgPath(), Extension(), soap() { }
        virtual ~tt__OSDImgConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDImgConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1780 */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (630)
/* complex XSD type 'tt:OSDImgConfigurationExtension': */
class SOAP_CMAC tt__OSDImgConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__OSDImgConfigurationExtension() : soap() { }
        virtual ~tt__OSDImgConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDImgConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1783 */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (631)
/* complex XSD type 'tt:ColorspaceRange': */
class SOAP_CMAC tt__ColorspaceRange {
      public:
        /// Required element 'tt:X' of XSD type 'tt:FloatRange'
        tt__FloatRange *X;
        /// Required element 'tt:Y' of XSD type 'tt:FloatRange'
        tt__FloatRange *Y;
        /// Required element 'tt:Z' of XSD type 'tt:FloatRange'
        tt__FloatRange *Z;
        /// Required element 'tt:Colorspace' of XSD type 'xsd:anyURI'
        std::string Colorspace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorspaceRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorspaceRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorspaceRange, default initialized and not managed by a soap context
        virtual tt__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorspaceRange); }
      public:
        /// Constructor with initializations
        tt__ColorspaceRange() : X(), Y(), Z(), Colorspace(), soap() { }
        virtual ~tt__ColorspaceRange() { }
        /// Friend allocator used by soap_new_tt__ColorspaceRange(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:18728 */
#ifndef SOAP_TYPE__tt__union_ColorOptions
#define SOAP_TYPE__tt__union_ColorOptions (1621)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tt__union_ColorOptions
{
        #define SOAP_UNION__tt__union_ColorOptions_ColorList	(1)	/**< union variant selector value for member ColorList */
        std::vector<tt__Color *> *ColorList;
        #define SOAP_UNION__tt__union_ColorOptions_ColorspaceRange	(2)	/**< union variant selector value for member ColorspaceRange */
        std::vector<tt__ColorspaceRange *> *ColorspaceRange;
};
#endif

/* onvif.h:1786 */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (632)
/* Choice: */
class SOAP_CMAC tt__ColorOptions {
      public:
        /// Union with union _tt__union_ColorOptions variant selector __union_ColorOptions set to one of: SOAP_UNION__tt__union_ColorOptions_ColorList SOAP_UNION__tt__union_ColorOptions_ColorspaceRange
        int __union_ColorOptions;
        union _tt__union_ColorOptions union_ColorOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorOptions, default initialized and not managed by a soap context
        virtual tt__ColorOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorOptions); }
      public:
        /// Constructor with initializations
        tt__ColorOptions() : __union_ColorOptions(), soap() { }
        virtual ~tt__ColorOptions() { }
        /// Friend allocator used by soap_new_tt__ColorOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1789 */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (633)
/* complex XSD type 'tt:OSDColorOptions': */
class SOAP_CMAC tt__OSDColorOptions {
      public:
        /// Optional element 'tt:Color' of XSD type 'tt:ColorOptions'
        tt__ColorOptions *Color;
        /// Optional element 'tt:Transparent' of XSD type 'tt:IntRange'
        tt__IntRange *Transparent;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDColorOptionsExtension'
        tt__OSDColorOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColorOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColorOptions, default initialized and not managed by a soap context
        virtual tt__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColorOptions); }
      public:
        /// Constructor with initializations
        tt__OSDColorOptions() : Color(), Transparent(), Extension(), soap() { }
        virtual ~tt__OSDColorOptions() { }
        /// Friend allocator used by soap_new_tt__OSDColorOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1792 */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (634)
/* complex XSD type 'tt:OSDColorOptionsExtension': */
class SOAP_CMAC tt__OSDColorOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColorOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColorOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColorOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColorOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__OSDColorOptionsExtension() : soap() { }
        virtual ~tt__OSDColorOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDColorOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1795 */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (635)
/* complex XSD type 'tt:OSDTextOptions': */
class SOAP_CMAC tt__OSDTextOptions {
      public:
        /// Required element 'tt:Type' of XSD type 'xsd:string'
        std::vector<std::string> Type;
        /// Optional element 'tt:FontSizeRange' of XSD type 'tt:IntRange'
        tt__IntRange *FontSizeRange;
        /// Optional element 'tt:DateFormat' of XSD type 'xsd:string'
        std::vector<std::string> DateFormat;
        /// Optional element 'tt:TimeFormat' of XSD type 'xsd:string'
        std::vector<std::string> TimeFormat;
        /// Optional element 'tt:FontColor' of XSD type 'tt:OSDColorOptions'
        tt__OSDColorOptions *FontColor;
        /// Optional element 'tt:BackgroundColor' of XSD type 'tt:OSDColorOptions'
        tt__OSDColorOptions *BackgroundColor;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDTextOptionsExtension'
        tt__OSDTextOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextOptions, default initialized and not managed by a soap context
        virtual tt__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextOptions); }
      public:
        /// Constructor with initializations
        tt__OSDTextOptions() : Type(), FontSizeRange(), DateFormat(), TimeFormat(), FontColor(), BackgroundColor(), Extension(), soap() { }
        virtual ~tt__OSDTextOptions() { }
        /// Friend allocator used by soap_new_tt__OSDTextOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1798 */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (636)
/* complex XSD type 'tt:OSDTextOptionsExtension': */
class SOAP_CMAC tt__OSDTextOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__OSDTextOptionsExtension() : soap() { }
        virtual ~tt__OSDTextOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDTextOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1801 */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (637)
/* complex XSD type 'tt:OSDImgOptions': */
class SOAP_CMAC tt__OSDImgOptions {
      public:
        /// Required element 'tt:ImagePath' of XSD type 'xsd:anyURI'
        std::vector<std::string> ImagePath;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDImgOptionsExtension'
        tt__OSDImgOptionsExtension *Extension;
        /// optional attribute 'FormatsSupported' of XSD type 'tt:StringAttrList'
        std::string *FormatsSupported;
        /// optional attribute 'MaxSize' of XSD type 'xsd:int'
        int *MaxSize;
        /// optional attribute 'MaxWidth' of XSD type 'xsd:int'
        int *MaxWidth;
        /// optional attribute 'MaxHeight' of XSD type 'xsd:int'
        int *MaxHeight;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgOptions, default initialized and not managed by a soap context
        virtual tt__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgOptions); }
      public:
        /// Constructor with initializations
        tt__OSDImgOptions() : ImagePath(), Extension(), FormatsSupported(), MaxSize(), MaxWidth(), MaxHeight(), soap() { }
        virtual ~tt__OSDImgOptions() { }
        /// Friend allocator used by soap_new_tt__OSDImgOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1804 */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (638)
/* complex XSD type 'tt:OSDImgOptionsExtension': */
class SOAP_CMAC tt__OSDImgOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__OSDImgOptionsExtension() : soap() { }
        virtual ~tt__OSDImgOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDImgOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1810 */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (640)
/* complex XSD type 'tt:OSDConfigurationExtension': */
class SOAP_CMAC tt__OSDConfigurationExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationExtension); }
      public:
        /// Constructor with initializations
        tt__OSDConfigurationExtension() : soap() { }
        virtual ~tt__OSDConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1813 */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (641)
/* complex XSD type 'tt:MaximumNumberOfOSDs': */
class SOAP_CMAC tt__MaximumNumberOfOSDs {
      public:
        /// required attribute 'Total' of XSD type 'xsd:int'
        int Total;
        /// optional attribute 'Image' of XSD type 'xsd:int'
        int *Image;
        /// optional attribute 'PlainText' of XSD type 'xsd:int'
        int *PlainText;
        /// optional attribute 'Date' of XSD type 'xsd:int'
        int *Date;
        /// optional attribute 'Time' of XSD type 'xsd:int'
        int *Time;
        /// optional attribute 'DateAndTime' of XSD type 'xsd:int'
        int *DateAndTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__MaximumNumberOfOSDs
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MaximumNumberOfOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MaximumNumberOfOSDs, default initialized and not managed by a soap context
        virtual tt__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MaximumNumberOfOSDs); }
      public:
        /// Constructor with initializations
        tt__MaximumNumberOfOSDs() : Total(), Image(), PlainText(), Date(), Time(), DateAndTime(), soap() { }
        virtual ~tt__MaximumNumberOfOSDs() { }
        /// Friend allocator used by soap_new_tt__MaximumNumberOfOSDs(struct soap*, int)
        friend SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1816 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (642)
/* complex XSD type 'tt:OSDConfigurationOptions': */
class SOAP_CMAC tt__OSDConfigurationOptions {
      public:
        /// Required element 'tt:MaximumNumberOfOSDs' of XSD type 'tt:MaximumNumberOfOSDs'
        tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;
        /// Required element 'tt:Type' of XSD type 'tt:OSDType'
        std::vector<enum tt__OSDType> Type;
        /// Required element 'tt:PositionOption' of XSD type 'xsd:string'
        std::vector<std::string> PositionOption;
        /// Optional element 'tt:TextOption' of XSD type 'tt:OSDTextOptions'
        tt__OSDTextOptions *TextOption;
        /// Optional element 'tt:ImageOption' of XSD type 'tt:OSDImgOptions'
        tt__OSDImgOptions *ImageOption;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDConfigurationOptionsExtension'
        tt__OSDConfigurationOptionsExtension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationOptions); }
      public:
        /// Constructor with initializations
        tt__OSDConfigurationOptions() : MaximumNumberOfOSDs(), Type(), PositionOption(), TextOption(), ImageOption(), Extension(), soap() { }
        virtual ~tt__OSDConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1819 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (643)
/* complex XSD type 'tt:OSDConfigurationOptionsExtension': */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationOptionsExtension); }
      public:
        /// Constructor with initializations
        tt__OSDConfigurationOptionsExtension() : soap() { }
        virtual ~tt__OSDConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1822 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (644)
/* complex XSD type 'tt:IntRange': */
class SOAP_CMAC tt__IntRange {
      public:
        /// Required element 'tt:Min' of XSD type 'xsd:int'
        int Min;
        /// Required element 'tt:Max' of XSD type 'xsd:int'
        int Max;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
        virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRange); }
      public:
        /// Constructor with initializations
        tt__IntRange() : Min(), Max(), soap() { }
        virtual ~tt__IntRange() { }
        /// Friend allocator used by soap_new_tt__IntRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1825 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (645)
/* complex XSD type 'tt:Vector2D': */
class SOAP_CMAC tt__Vector2D {
      public:
        /// required attribute 'x' of XSD type 'xsd:float'
        float x;
        /// required attribute 'y' of XSD type 'xsd:float'
        float y;
        /// optional attribute 'space' of XSD type 'xsd:anyURI'
        std::string *space;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector2D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector2D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
        virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector2D); }
      public:
        /// Constructor with initializations
        tt__Vector2D() : x(), y(), space(), soap() { }
        virtual ~tt__Vector2D() { }
        /// Friend allocator used by soap_new_tt__Vector2D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1828 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (646)
/* complex XSD type 'tt:Vector1D': */
class SOAP_CMAC tt__Vector1D {
      public:
        /// required attribute 'x' of XSD type 'xsd:float'
        float x;
        /// optional attribute 'space' of XSD type 'xsd:anyURI'
        std::string *space;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector1D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector1D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
        virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector1D); }
      public:
        /// Constructor with initializations
        tt__Vector1D() : x(), space(), soap() { }
        virtual ~tt__Vector1D() { }
        /// Friend allocator used by soap_new_tt__Vector1D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1831 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (647)
/* complex XSD type 'tt:PTZVector': */
class SOAP_CMAC tt__PTZVector {
      public:
        /// Optional element 'tt:PanTilt' of XSD type 'tt:Vector2D'
        tt__Vector2D *PanTilt;
        /// Optional element 'tt:Zoom' of XSD type 'tt:Vector1D'
        tt__Vector1D *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZVector
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZVector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
        virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZVector); }
      public:
        /// Constructor with initializations
        tt__PTZVector() : PanTilt(), Zoom(), soap() { }
        virtual ~tt__PTZVector() { }
        /// Friend allocator used by soap_new_tt__PTZVector(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1834 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (648)
/* complex XSD type 'tt:PTZStatus': */
class SOAP_CMAC tt__PTZStatus {
      public:
        /// Optional element 'tt:Position' of XSD type 'tt:PTZVector'
        tt__PTZVector *Position;
        /// Optional element 'tt:MoveStatus' of XSD type 'tt:PTZMoveStatus'
        tt__PTZMoveStatus *MoveStatus;
        /// Optional element 'tt:Error' of XSD type 'xsd:string'
        std::string *Error;
        /// Required element 'tt:UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
        virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatus); }
      public:
        /// Constructor with initializations
        tt__PTZStatus() : Position(), MoveStatus(), Error(), UtcTime(), soap() { }
        virtual ~tt__PTZStatus() { }
        /// Friend allocator used by soap_new_tt__PTZStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1837 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (649)
/* complex XSD type 'tt:PTZMoveStatus': */
class SOAP_CMAC tt__PTZMoveStatus {
      public:
        /// Optional element 'tt:PanTilt' of XSD type 'tt:MoveStatus'
        enum tt__MoveStatus *PanTilt;
        /// Optional element 'tt:Zoom' of XSD type 'tt:MoveStatus'
        enum tt__MoveStatus *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZMoveStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZMoveStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
        virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZMoveStatus); }
      public:
        /// Constructor with initializations
        tt__PTZMoveStatus() : PanTilt(), Zoom(), soap() { }
        virtual ~tt__PTZMoveStatus() { }
        /// Friend allocator used by soap_new_tt__PTZMoveStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1840 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (650)
/* complex XSD type 'tt:Vector': */
class SOAP_CMAC tt__Vector {
      public:
        /// optional attribute 'x' of XSD type 'xsd:float'
        float *x;
        /// optional attribute 'y' of XSD type 'xsd:float'
        float *y;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector, default initialized and not managed by a soap context
        virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector); }
      public:
        /// Constructor with initializations
        tt__Vector() : x(), y(), soap() { }
        virtual ~tt__Vector() { }
        /// Friend allocator used by soap_new_tt__Vector(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1843 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (651)
/* complex XSD type 'tt:Rectangle': */
class SOAP_CMAC tt__Rectangle {
      public:
        /// optional attribute 'bottom' of XSD type 'xsd:float'
        float *bottom;
        /// optional attribute 'top' of XSD type 'xsd:float'
        float *top;
        /// optional attribute 'right' of XSD type 'xsd:float'
        float *right;
        /// optional attribute 'left' of XSD type 'xsd:float'
        float *left;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
        virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rectangle); }
      public:
        /// Constructor with initializations
        tt__Rectangle() : bottom(), top(), right(), left(), soap() { }
        virtual ~tt__Rectangle() { }
        /// Friend allocator used by soap_new_tt__Rectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1846 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (652)
/* complex XSD type 'tt:Polygon': */
class SOAP_CMAC tt__Polygon {
      public:
        /// Required element 'tt:Point' of XSD type 'tt:Vector'
        std::vector<tt__Vector *> Point;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polygon
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polygon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
        virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polygon); }
      public:
        /// Constructor with initializations
        tt__Polygon() : Point(), soap() { }
        virtual ~tt__Polygon() { }
        /// Friend allocator used by soap_new_tt__Polygon(struct soap*, int)
        friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1849 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (653)
/* complex XSD type 'tt:Color': */
class SOAP_CMAC tt__Color {
      public:
        /// required attribute 'X' of XSD type 'xsd:float'
        float X;
        /// required attribute 'Y' of XSD type 'xsd:float'
        float Y;
        /// required attribute 'Z' of XSD type 'xsd:float'
        float Z;
        /// optional attribute 'Colorspace' of XSD type 'xsd:anyURI'
        std::string *Colorspace;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__Color
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Color; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Color, default initialized and not managed by a soap context
        virtual tt__Color *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Color); }
      public:
        /// Constructor with initializations
        tt__Color() : X(), Y(), Z(), Colorspace(), soap() { }
        virtual ~tt__Color() { }
        /// Friend allocator used by soap_new_tt__Color(struct soap*, int)
        friend SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1852 */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (654)
/* complex XSD type 'tt:GeoLocation': */
class SOAP_CMAC tt__GeoLocation {
      public:
        /// optional attribute 'lon' of XSD type 'xsd:double'
        double *lon;
        /// optional attribute 'lat' of XSD type 'xsd:double'
        double *lat;
        /// optional attribute 'elevation' of XSD type 'xsd:float'
        float *elevation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__GeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GeoLocation, default initialized and not managed by a soap context
        virtual tt__GeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GeoLocation); }
      public:
        /// Constructor with initializations
        tt__GeoLocation() : lon(), lat(), elevation(), soap() { }
        virtual ~tt__GeoLocation() { }
        /// Friend allocator used by soap_new_tt__GeoLocation(struct soap*, int)
        friend SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1855 */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (655)
/* complex XSD type 'tt:GeoOrientation': */
class SOAP_CMAC tt__GeoOrientation {
      public:
        /// optional attribute 'roll' of XSD type 'xsd:float'
        float *roll;
        /// optional attribute 'pitch' of XSD type 'xsd:float'
        float *pitch;
        /// optional attribute 'yaw' of XSD type 'xsd:float'
        float *yaw;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__GeoOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GeoOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GeoOrientation, default initialized and not managed by a soap context
        virtual tt__GeoOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GeoOrientation); }
      public:
        /// Constructor with initializations
        tt__GeoOrientation() : roll(), pitch(), yaw(), soap() { }
        virtual ~tt__GeoOrientation() { }
        /// Friend allocator used by soap_new_tt__GeoOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1858 */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (656)
/* complex XSD type 'tt:LocalLocation': */
class SOAP_CMAC tt__LocalLocation {
      public:
        /// optional attribute 'x' of XSD type 'xsd:float'
        float *x;
        /// optional attribute 'y' of XSD type 'xsd:float'
        float *y;
        /// optional attribute 'z' of XSD type 'xsd:float'
        float *z;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocalLocation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocalLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocalLocation, default initialized and not managed by a soap context
        virtual tt__LocalLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocalLocation); }
      public:
        /// Constructor with initializations
        tt__LocalLocation() : x(), y(), z(), soap() { }
        virtual ~tt__LocalLocation() { }
        /// Friend allocator used by soap_new_tt__LocalLocation(struct soap*, int)
        friend SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1861 */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (657)
/* complex XSD type 'tt:LocalOrientation': */
class SOAP_CMAC tt__LocalOrientation {
      public:
        /// optional attribute 'pan' of XSD type 'xsd:float'
        float *pan;
        /// optional attribute 'tilt' of XSD type 'xsd:float'
        float *tilt;
        /// optional attribute 'roll' of XSD type 'xsd:float'
        float *roll;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocalOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocalOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocalOrientation, default initialized and not managed by a soap context
        virtual tt__LocalOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocalOrientation); }
      public:
        /// Constructor with initializations
        tt__LocalOrientation() : pan(), tilt(), roll(), soap() { }
        virtual ~tt__LocalOrientation() { }
        /// Friend allocator used by soap_new_tt__LocalOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1864 */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (658)
/* complex XSD type 'tt:LocationEntity': */
class SOAP_CMAC tt__LocationEntity {
      public:
        /// Optional element 'tt:GeoLocation' of XSD type 'tt:GeoLocation'
        tt__GeoLocation *GeoLocation;
        /// Optional element 'tt:GeoOrientation' of XSD type 'tt:GeoOrientation'
        tt__GeoOrientation *GeoOrientation;
        /// Optional element 'tt:LocalLocation' of XSD type 'tt:LocalLocation'
        tt__LocalLocation *LocalLocation;
        /// Optional element 'tt:LocalOrientation' of XSD type 'tt:LocalOrientation'
        tt__LocalOrientation *LocalOrientation;
        /// optional attribute 'Entity' of XSD type 'xsd:string'
        std::string *Entity;
        /// optional attribute 'Token' of XSD type 'tt:ReferenceToken'
        std::string *Token;
        /// optional attribute 'Fixed' of XSD type 'xsd:boolean'
        bool *Fixed;
        /// optional attribute 'GeoSource' of XSD type 'xsd:anyURI'
        std::string *GeoSource;
        /// optional attribute 'AutoGeo' of XSD type 'xsd:boolean'
        bool *AutoGeo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocationEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocationEntity, default initialized and not managed by a soap context
        virtual tt__LocationEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocationEntity); }
      public:
        /// Constructor with initializations
        tt__LocationEntity() : GeoLocation(), GeoOrientation(), LocalLocation(), LocalOrientation(), Entity(), Token(), Fixed(), GeoSource(), AutoGeo(), soap() { }
        virtual ~tt__LocationEntity() { }
        /// Friend allocator used by soap_new_tt__LocationEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1867 */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (659)
/* complex XSD type 'tt:StringItems': */
class SOAP_CMAC _tt__StringItems {
      public:
        /// Required element 'tt:Item' of XSD type 'xsd:string'
        std::vector<std::string> Item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__StringItems
        virtual long soap_type(void) const { return SOAP_TYPE__tt__StringItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__StringItems, default initialized and not managed by a soap context
        virtual _tt__StringItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__StringItems); }
      public:
        /// Constructor with initializations
        _tt__StringItems() : Item(), soap() { }
        virtual ~_tt__StringItems() { }
        /// Friend allocator used by soap_new__tt__StringItems(struct soap*, int)
        friend SOAP_FMAC1 _tt__StringItems * SOAP_FMAC2 soap_instantiate__tt__StringItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1870 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (660)
/* complex XSD type 'tt:Message': */
class SOAP_CMAC _tt__Message {
      public:
        /// Optional element 'tt:Source' of XSD type 'tt:ItemList'
        tt__ItemList *Source;
        /// Optional element 'tt:Key' of XSD type 'tt:ItemList'
        tt__ItemList *Key;
        /// Optional element 'tt:Data' of XSD type 'tt:ItemList'
        tt__ItemList *Data;
        /// Optional element 'tt:Extension' of XSD type 'tt:MessageExtension'
        tt__MessageExtension *Extension;
        /// required attribute 'UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// optional attribute 'PropertyOperation' of XSD type 'tt:PropertyOperation'
        enum tt__PropertyOperation *PropertyOperation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__Message
        virtual long soap_type(void) const { return SOAP_TYPE__tt__Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__Message, default initialized and not managed by a soap context
        virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__Message); }
      public:
        /// Constructor with initializations
        _tt__Message() : Source(), Key(), Data(), Extension(), UtcTime(), PropertyOperation(), soap() { }
        virtual ~_tt__Message() { }
        /// Friend allocator used by soap_new__tt__Message(struct soap*, int)
        friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1873 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (661)
/* complex XSD type 'wsnt:QueryExpressionType': */
class SOAP_CMAC wsnt__QueryExpressionType {
      public:
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
        virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__QueryExpressionType); }
      public:
        /// Constructor with initializations
        wsnt__QueryExpressionType() : Dialect(), __mixed(), soap() { }
        virtual ~wsnt__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1876 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (662)
/* complex XSD type 'wsnt:TopicExpressionType': */
class SOAP_CMAC wsnt__TopicExpressionType {
      public:
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionType); }
      public:
        /// Constructor with initializations
        wsnt__TopicExpressionType() : Dialect(), __mixed(), soap() { }
        virtual ~wsnt__TopicExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1879 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (663)
/* complex XSD type 'wsnt:FilterType': */
class SOAP_CMAC wsnt__FilterType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
        virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__FilterType); }
      public:
        /// Constructor with initializations
        wsnt__FilterType() : soap() { }
        virtual ~wsnt__FilterType() { }
        /// Friend allocator used by soap_new_wsnt__FilterType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1882 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (664)
/* complex XSD type 'wsnt:SubscriptionPolicyType': */
class SOAP_CMAC wsnt__SubscriptionPolicyType {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscriptionPolicyType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscriptionPolicyType); }
      public:
        /// Constructor with initializations
        wsnt__SubscriptionPolicyType() : soap() { }
        virtual ~wsnt__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_wsnt__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:19856 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1644)
/* complex XSD type 'wsnt:NotificationMessageHolderType-Message': */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message {
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with initializations
        _wsnt__NotificationMessageHolderType_Message() { }
        virtual ~_wsnt__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__wsnt__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1885 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (665)
/* complex XSD type 'wsnt:NotificationMessageHolderType': */
class SOAP_CMAC wsnt__NotificationMessageHolderType {
      public:
        /// Optional element 'wsnt:SubscriptionReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'wsnt:Topic' of XSD type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// Optional element 'wsnt:ProducerReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *ProducerReference;
        /// Required element 'wsnt:Message' of XSD type 'wsnt:NotificationMessageHolderType-Message'
        _wsnt__NotificationMessageHolderType_Message Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotificationMessageHolderType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotificationMessageHolderType); }
      public:
        /// Constructor with initializations
        wsnt__NotificationMessageHolderType() : SubscriptionReference(), Topic(), ProducerReference(), Message(), soap() { }
        virtual ~wsnt__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_wsnt__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1948 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (686)
/* complex XSD type 'wsnt:NotificationProducerRP': */
class SOAP_CMAC _wsnt__NotificationProducerRP {
      public:
        /// Optional element 'wsnt:TopicExpression' of XSD type 'wsnt:TopicExpressionType'
        std::vector<wsnt__TopicExpressionType *> TopicExpression;
        /// Optional element 'wsnt:FixedTopicSet' of XSD type 'xsd:boolean'
        bool *FixedTopicSet;	///< optional with default value = (bool)1
        /// Optional element 'wsnt:TopicExpressionDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'wstop:TopicSet' of XSD type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationProducerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationProducerRP); }
      public:
        /// Constructor with initializations
        _wsnt__NotificationProducerRP() : TopicExpression(), FixedTopicSet(), TopicExpressionDialect(), wstop__TopicSet(), soap() { }
        virtual ~_wsnt__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__wsnt__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1951 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (687)
/* complex XSD type 'wsnt:SubscriptionManagerRP': */
class SOAP_CMAC _wsnt__SubscriptionManagerRP {
      public:
        /// Required element 'wsnt:ConsumerReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XSD type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:SubscriptionPolicy' of XSD type 'wsnt:SubscriptionPolicyType'
        wsnt__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'wsnt:CreationTime' of XSD type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscriptionManagerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscriptionManagerRP); }
      public:
        /// Constructor with initializations
        _wsnt__SubscriptionManagerRP() : ConsumerReference(), Filter(), SubscriptionPolicy(), CreationTime(), soap() { }
        virtual ~_wsnt__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__wsnt__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1954 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (688)
/* complex XSD type 'wsnt:Notify': */
class SOAP_CMAC _wsnt__Notify {
      public:
        /// Required element 'wsnt:NotificationMessage' of XSD type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Notify
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
        virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Notify); }
      public:
        /// Constructor with initializations
        _wsnt__Notify() : NotificationMessage(), soap() { }
        virtual ~_wsnt__Notify() { }
        /// Friend allocator used by soap_new__wsnt__Notify(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1957 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (689)
/* complex XSD type 'wsnt:UseRaw': */
class SOAP_CMAC _wsnt__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UseRaw
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
        virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UseRaw); }
      public:
        /// Constructor with initializations
        _wsnt__UseRaw() : soap() { }
        virtual ~_wsnt__UseRaw() { }
        /// Friend allocator used by soap_new__wsnt__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:19995 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1651)
/* complex XSD type 'wsnt:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy {
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _wsnt__Subscribe_SubscriptionPolicy() { }
        virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1960 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (690)
/* complex XSD type 'wsnt:Subscribe': */
class SOAP_CMAC _wsnt__Subscribe {
      public:
        /// Required element 'wsnt:ConsumerReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XSD type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:InitialTerminationTime' of XSD type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'wsnt:SubscriptionPolicy' of XSD type 'wsnt:Subscribe-SubscriptionPolicy'
        _wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe); }
      public:
        /// Constructor with initializations
        _wsnt__Subscribe() : ConsumerReference(), Filter(), InitialTerminationTime(), SubscriptionPolicy(), soap() { }
        virtual ~_wsnt__Subscribe() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1963 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (691)
/* complex XSD type 'wsnt:SubscribeResponse': */
class SOAP_CMAC _wsnt__SubscribeResponse {
      public:
        /// Required element 'wsnt:SubscriptionReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Optional element 'wsnt:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'wsnt:TerminationTime' of XSD type 'xsd:dateTime'
        time_t *TerminationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscribeResponse); }
      public:
        /// Constructor with initializations
        _wsnt__SubscribeResponse() : SubscriptionReference(), CurrentTime(), TerminationTime(), soap() { }
        virtual ~_wsnt__SubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1966 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (692)
/* complex XSD type 'wsnt:GetCurrentMessage': */
class SOAP_CMAC _wsnt__GetCurrentMessage {
      public:
        /// Required element 'wsnt:Topic' of XSD type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessage
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessage); }
      public:
        /// Constructor with initializations
        _wsnt__GetCurrentMessage() : Topic(), soap() { }
        virtual ~_wsnt__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1969 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (693)
/* complex XSD type 'wsnt:GetCurrentMessageResponse': */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessageResponse); }
      public:
        /// Constructor with initializations
        _wsnt__GetCurrentMessageResponse() : soap() { }
        virtual ~_wsnt__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1972 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (694)
/* complex XSD type 'wsnt:GetMessages': */
class SOAP_CMAC _wsnt__GetMessages {
      public:
        /// Optional element 'wsnt:MaximumNumber' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessages
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
        virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessages); }
      public:
        /// Constructor with initializations
        _wsnt__GetMessages() : MaximumNumber(), soap() { }
        virtual ~_wsnt__GetMessages() { }
        /// Friend allocator used by soap_new__wsnt__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1975 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (695)
/* complex XSD type 'wsnt:GetMessagesResponse': */
class SOAP_CMAC _wsnt__GetMessagesResponse {
      public:
        /// Optional element 'wsnt:NotificationMessage' of XSD type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessagesResponse); }
      public:
        /// Constructor with initializations
        _wsnt__GetMessagesResponse() : NotificationMessage(), soap() { }
        virtual ~_wsnt__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1978 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (696)
/* complex XSD type 'wsnt:DestroyPullPoint': */
class SOAP_CMAC _wsnt__DestroyPullPoint {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPoint); }
      public:
        /// Constructor with initializations
        _wsnt__DestroyPullPoint() : soap() { }
        virtual ~_wsnt__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1981 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (697)
/* complex XSD type 'wsnt:DestroyPullPointResponse': */
class SOAP_CMAC _wsnt__DestroyPullPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPointResponse); }
      public:
        /// Constructor with initializations
        _wsnt__DestroyPullPointResponse() : soap() { }
        virtual ~_wsnt__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1984 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (698)
/* complex XSD type 'wsnt:CreatePullPoint': */
class SOAP_CMAC _wsnt__CreatePullPoint {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPoint); }
      public:
        /// Constructor with initializations
        _wsnt__CreatePullPoint() : soap() { }
        virtual ~_wsnt__CreatePullPoint() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1987 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (699)
/* complex XSD type 'wsnt:CreatePullPointResponse': */
class SOAP_CMAC _wsnt__CreatePullPointResponse {
      public:
        /// Required element 'wsnt:PullPoint' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType PullPoint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPointResponse); }
      public:
        /// Constructor with initializations
        _wsnt__CreatePullPointResponse() : PullPoint(), soap() { }
        virtual ~_wsnt__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1990 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (700)
/* complex XSD type 'wsnt:Renew': */
class SOAP_CMAC _wsnt__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'wsnt:TerminationTime' of XSD type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Renew
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
        virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Renew); }
      public:
        /// Constructor with initializations
        _wsnt__Renew() : TerminationTime(), soap() { }
        virtual ~_wsnt__Renew() { }
        /// Friend allocator used by soap_new__wsnt__Renew(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1993 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (701)
/* complex XSD type 'wsnt:RenewResponse': */
class SOAP_CMAC _wsnt__RenewResponse {
      public:
        /// Required element 'wsnt:TerminationTime' of XSD type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:CurrentTime' of XSD type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__RenewResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
        virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__RenewResponse); }
      public:
        /// Constructor with initializations
        _wsnt__RenewResponse() : TerminationTime(), CurrentTime(), soap() { }
        virtual ~_wsnt__RenewResponse() { }
        /// Friend allocator used by soap_new__wsnt__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1996 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (702)
/* complex XSD type 'wsnt:Unsubscribe': */
class SOAP_CMAC _wsnt__Unsubscribe {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Unsubscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
        virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Unsubscribe); }
      public:
        /// Constructor with initializations
        _wsnt__Unsubscribe() : soap() { }
        virtual ~_wsnt__Unsubscribe() { }
        /// Friend allocator used by soap_new__wsnt__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1999 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (703)
/* complex XSD type 'wsnt:UnsubscribeResponse': */
class SOAP_CMAC _wsnt__UnsubscribeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UnsubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UnsubscribeResponse); }
      public:
        /// Constructor with initializations
        _wsnt__UnsubscribeResponse() : soap() { }
        virtual ~_wsnt__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2002 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (704)
/* complex XSD type 'wsnt:PauseSubscription': */
class SOAP_CMAC _wsnt__PauseSubscription {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscription); }
      public:
        /// Constructor with initializations
        _wsnt__PauseSubscription() : soap() { }
        virtual ~_wsnt__PauseSubscription() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2005 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (705)
/* complex XSD type 'wsnt:PauseSubscriptionResponse': */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _wsnt__PauseSubscriptionResponse() : soap() { }
        virtual ~_wsnt__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2008 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (706)
/* complex XSD type 'wsnt:ResumeSubscription': */
class SOAP_CMAC _wsnt__ResumeSubscription {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscription); }
      public:
        /// Constructor with initializations
        _wsnt__ResumeSubscription() : soap() { }
        virtual ~_wsnt__ResumeSubscription() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2011 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (707)
/* complex XSD type 'wsnt:ResumeSubscriptionResponse': */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _wsnt__ResumeSubscriptionResponse() : soap() { }
        virtual ~_wsnt__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20513 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1654)
/* complex XSD type 'wsrfbf:BaseFaultType-ErrorCode': */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode {
      public:
        /// required attribute 'dialect' of XSD type 'xsd:anyURI'
        std::string dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with initializations
        _wsrfbf__BaseFaultType_ErrorCode() : dialect(), __mixed() { }
        virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20534 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1656)
/* simple XSD type 'wsrfbf:BaseFaultType-Description': */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// optional attribute 'xml:lang' of XSD type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_Description
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_Description); }
      public:
        /// Constructor with initializations
        _wsrfbf__BaseFaultType_Description() : __item(), xml__lang() { }
        virtual ~_wsrfbf__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20551 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1659)
/* complex XSD type 'wsrfbf:BaseFaultType-FaultCause': */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause {
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_FaultCause); }
      public:
        /// Constructor with initializations
        _wsrfbf__BaseFaultType_FaultCause() { }
        virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2014 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (708)
/* Type wsrfbf__BaseFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsrfbf:BaseFaultType': */
class SOAP_CMAC wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsrfbf:Timestamp' of XSD type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'wsrfbf:Originator' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *Originator;
        /// Optional element 'wsrfbf:ErrorCode' of XSD type 'wsrfbf:BaseFaultType-ErrorCode'
        _wsrfbf__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'wsrfbf:Description' of XSD type 'wsrfbf:BaseFaultType-Description'
        std::vector<_wsrfbf__BaseFaultType_Description> Description;
        /// Optional element 'wsrfbf:FaultCause' of XSD type 'wsrfbf:BaseFaultType-FaultCause'
        _wsrfbf__BaseFaultType_FaultCause *FaultCause;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wsrfbf__BaseFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfbf__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
        virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfbf__BaseFaultType); }
      public:
        /// Constructor with initializations
        wsrfbf__BaseFaultType() : Timestamp(), Originator(), ErrorCode(), Description(), FaultCause(), soap() { }
        virtual ~wsrfbf__BaseFaultType() { }
        /// Friend allocator used by soap_new_wsrfbf__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2017 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (709)
/* complex XSD type 'wstop:Documentation': */
class SOAP_CMAC wstop__Documentation {
      public:
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__Documentation
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
        virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__Documentation); }
      public:
        /// Constructor with initializations
        wstop__Documentation() : __mixed(), soap() { }
        virtual ~wstop__Documentation() { }
        /// Friend allocator used by soap_new_wstop__Documentation(struct soap*, int)
        friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2020 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (710)
/* Type wstop__ExtensibleDocumented is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wstop:ExtensibleDocumented': */
class SOAP_CMAC wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:documentation' of XSD type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ExtensibleDocumented
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ExtensibleDocumented); }
      public:
        /// Constructor with initializations
        wstop__ExtensibleDocumented() : documentation(), soap() { }
        virtual ~wstop__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_wstop__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2023 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (711)
/* complex XSD type 'wstop:QueryExpressionType': */
class SOAP_CMAC wstop__QueryExpressionType {
      public:
        /// required attribute 'Dialect' of XSD type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_wstop__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
        virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__QueryExpressionType); }
      public:
        /// Constructor with initializations
        wstop__QueryExpressionType() : Dialect(), __mixed(), soap() { }
        virtual ~wstop__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wstop__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2035 */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (715)
/* complex XSD type 'tev:Capabilities': */
class SOAP_CMAC tev__Capabilities {
      public:
        /// optional attribute 'WSSubscriptionPolicySupport' of XSD type 'xsd:boolean'
        bool *WSSubscriptionPolicySupport;
        /// optional attribute 'WSPullPointSupport' of XSD type 'xsd:boolean'
        bool *WSPullPointSupport;
        /// optional attribute 'WSPausableSubscriptionManagerInterfaceSupport' of XSD type 'xsd:boolean'
        bool *WSPausableSubscriptionManagerInterfaceSupport;
        /// optional attribute 'MaxNotificationProducers' of XSD type 'xsd:int'
        int *MaxNotificationProducers;
        /// optional attribute 'MaxPullPoints' of XSD type 'xsd:int'
        int *MaxPullPoints;
        /// optional attribute 'PersistentNotificationStorage' of XSD type 'xsd:boolean'
        bool *PersistentNotificationStorage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tev__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tev__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tev__Capabilities, default initialized and not managed by a soap context
        virtual tev__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tev__Capabilities); }
      public:
        /// Constructor with initializations
        tev__Capabilities() : WSSubscriptionPolicySupport(), WSPullPointSupport(), WSPausableSubscriptionManagerInterfaceSupport(), MaxNotificationProducers(), MaxPullPoints(), PersistentNotificationStorage(), soap() { }
        virtual ~tev__Capabilities() { }
        /// Friend allocator used by soap_new_tev__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tev__Capabilities * SOAP_FMAC2 soap_instantiate_tev__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2038 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (716)
/* complex XSD type 'tev:GetServiceCapabilities': */
class SOAP_CMAC _tev__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tev__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _tev__GetServiceCapabilities() : soap() { }
        virtual ~_tev__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tev__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2041 */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (717)
/* complex XSD type 'tev:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tev__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tev:Capabilities' of XSD type 'tev:Capabilities'
        tev__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tev__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tev__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tev__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tev__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20801 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (1663)
/* complex XSD type 'tev:CreatePullPointSubscription-SubscriptionPolicy': */
class SOAP_CMAC _tev__CreatePullPointSubscription_SubscriptionPolicy {
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with initializations
        _tev__CreatePullPointSubscription_SubscriptionPolicy() { }
        virtual ~_tev__CreatePullPointSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2044 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (718)
/* complex XSD type 'tev:CreatePullPointSubscription': */
class SOAP_CMAC _tev__CreatePullPointSubscription {
      public:
        /// Optional element 'tev:Filter' of XSD type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'tev:InitialTerminationTime' of XSD type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'tev:SubscriptionPolicy' of XSD type 'tev:CreatePullPointSubscription-SubscriptionPolicy'
        _tev__CreatePullPointSubscription_SubscriptionPolicy *SubscriptionPolicy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscription, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscription); }
      public:
        /// Constructor with initializations
        _tev__CreatePullPointSubscription() : Filter(), InitialTerminationTime(), SubscriptionPolicy(), soap() { }
        virtual ~_tev__CreatePullPointSubscription() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscription(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2047 */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (719)
/* complex XSD type 'tev:CreatePullPointSubscriptionResponse': */
class SOAP_CMAC _tev__CreatePullPointSubscriptionResponse {
      public:
        /// Required element 'tev:SubscriptionReference' of XSD type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Required element 'wsnt:CurrentTime' of XSD type 'xsd:dateTime'
        time_t wsnt__CurrentTime;
        /// Required element 'wsnt:TerminationTime' of XSD type 'xsd:dateTime'
        time_t wsnt__TerminationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__CreatePullPointSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__CreatePullPointSubscriptionResponse, default initialized and not managed by a soap context
        virtual _tev__CreatePullPointSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__CreatePullPointSubscriptionResponse); }
      public:
        /// Constructor with initializations
        _tev__CreatePullPointSubscriptionResponse() : SubscriptionReference(), wsnt__CurrentTime(), wsnt__TerminationTime(), soap() { }
        virtual ~_tev__CreatePullPointSubscriptionResponse() { }
        /// Friend allocator used by soap_new__tev__CreatePullPointSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC2 soap_instantiate__tev__CreatePullPointSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2050 */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (720)
/* complex XSD type 'tev:PullMessages': */
class SOAP_CMAC _tev__PullMessages {
      public:
        /// Required element 'tev:Timeout' of XSD type 'xsd:duration'
        std::string Timeout;
        /// Required element 'tev:MessageLimit' of XSD type 'xsd:int'
        int MessageLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessages
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessages, default initialized and not managed by a soap context
        virtual _tev__PullMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessages); }
      public:
        /// Constructor with initializations
        _tev__PullMessages() : Timeout(), MessageLimit(), soap() { }
        virtual ~_tev__PullMessages() { }
        /// Friend allocator used by soap_new__tev__PullMessages(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessages * SOAP_FMAC2 soap_instantiate__tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2053 */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (721)
/* complex XSD type 'tev:PullMessagesResponse': */
class SOAP_CMAC _tev__PullMessagesResponse {
      public:
        /// Required element 'tev:CurrentTime' of XSD type 'xsd:dateTime'
        time_t CurrentTime;
        /// Required element 'tev:TerminationTime' of XSD type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:NotificationMessage' of XSD type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> wsnt__NotificationMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessagesResponse, default initialized and not managed by a soap context
        virtual _tev__PullMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessagesResponse); }
      public:
        /// Constructor with initializations
        _tev__PullMessagesResponse() : CurrentTime(), TerminationTime(), wsnt__NotificationMessage(), soap() { }
        virtual ~_tev__PullMessagesResponse() { }
        /// Friend allocator used by soap_new__tev__PullMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessagesResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2056 */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (722)
/* complex XSD type 'tev:PullMessagesFaultResponse': */
class SOAP_CMAC _tev__PullMessagesFaultResponse {
      public:
        /// Required element 'tev:MaxTimeout' of XSD type 'xsd:duration'
        std::string MaxTimeout;
        /// Required element 'tev:MaxMessageLimit' of XSD type 'xsd:int'
        int MaxMessageLimit;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__PullMessagesFaultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__PullMessagesFaultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__PullMessagesFaultResponse, default initialized and not managed by a soap context
        virtual _tev__PullMessagesFaultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__PullMessagesFaultResponse); }
      public:
        /// Constructor with initializations
        _tev__PullMessagesFaultResponse() : MaxTimeout(), MaxMessageLimit(), soap() { }
        virtual ~_tev__PullMessagesFaultResponse() { }
        /// Friend allocator used by soap_new__tev__PullMessagesFaultResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__PullMessagesFaultResponse * SOAP_FMAC2 soap_instantiate__tev__PullMessagesFaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2059 */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (723)
/* complex XSD type 'tev:Seek': */
class SOAP_CMAC _tev__Seek {
      public:
        /// Required element 'tev:UtcTime' of XSD type 'xsd:dateTime'
        time_t UtcTime;
        /// Optional element 'tev:Reverse' of XSD type 'xsd:boolean'
        bool *Reverse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__Seek
        virtual long soap_type(void) const { return SOAP_TYPE__tev__Seek; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__Seek, default initialized and not managed by a soap context
        virtual _tev__Seek *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__Seek); }
      public:
        /// Constructor with initializations
        _tev__Seek() : UtcTime(), Reverse(), soap() { }
        virtual ~_tev__Seek() { }
        /// Friend allocator used by soap_new__tev__Seek(struct soap*, int)
        friend SOAP_FMAC1 _tev__Seek * SOAP_FMAC2 soap_instantiate__tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2062 */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (724)
/* complex XSD type 'tev:SeekResponse': */
class SOAP_CMAC _tev__SeekResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SeekResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SeekResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SeekResponse, default initialized and not managed by a soap context
        virtual _tev__SeekResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SeekResponse); }
      public:
        /// Constructor with initializations
        _tev__SeekResponse() : soap() { }
        virtual ~_tev__SeekResponse() { }
        /// Friend allocator used by soap_new__tev__SeekResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__SeekResponse * SOAP_FMAC2 soap_instantiate__tev__SeekResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2065 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (725)
/* complex XSD type 'tev:SetSynchronizationPoint': */
class SOAP_CMAC _tev__SetSynchronizationPoint {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SetSynchronizationPoint
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SetSynchronizationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SetSynchronizationPoint, default initialized and not managed by a soap context
        virtual _tev__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SetSynchronizationPoint); }
      public:
        /// Constructor with initializations
        _tev__SetSynchronizationPoint() : soap() { }
        virtual ~_tev__SetSynchronizationPoint() { }
        /// Friend allocator used by soap_new__tev__SetSynchronizationPoint(struct soap*, int)
        friend SOAP_FMAC1 _tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2068 */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (726)
/* complex XSD type 'tev:SetSynchronizationPointResponse': */
class SOAP_CMAC _tev__SetSynchronizationPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__SetSynchronizationPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__SetSynchronizationPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__SetSynchronizationPointResponse, default initialized and not managed by a soap context
        virtual _tev__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__SetSynchronizationPointResponse); }
      public:
        /// Constructor with initializations
        _tev__SetSynchronizationPointResponse() : soap() { }
        virtual ~_tev__SetSynchronizationPointResponse() { }
        /// Friend allocator used by soap_new__tev__SetSynchronizationPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__tev__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2071 */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (727)
/* complex XSD type 'tev:GetEventProperties': */
class SOAP_CMAC _tev__GetEventProperties {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventProperties
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventProperties; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventProperties, default initialized and not managed by a soap context
        virtual _tev__GetEventProperties *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventProperties); }
      public:
        /// Constructor with initializations
        _tev__GetEventProperties() : soap() { }
        virtual ~_tev__GetEventProperties() { }
        /// Friend allocator used by soap_new__tev__GetEventProperties(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventProperties * SOAP_FMAC2 soap_instantiate__tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2074 */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (728)
/* complex XSD type 'tev:GetEventPropertiesResponse': */
class SOAP_CMAC _tev__GetEventPropertiesResponse {
      public:
        /// Required element 'tev:TopicNamespaceLocation' of XSD type 'xsd:anyURI'
        std::vector<std::string> TopicNamespaceLocation;
        /// Required element 'wsnt:FixedTopicSet' of XSD type 'xsd:boolean'
        bool wsnt__FixedTopicSet;	///< initialized with default value = (bool)1
        /// Required element 'wstop:TopicSet' of XSD type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Required element 'wsnt:TopicExpressionDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> wsnt__TopicExpressionDialect;
        /// Required element 'tev:MessageContentFilterDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> MessageContentFilterDialect;
        /// Optional element 'tev:ProducerPropertiesFilterDialect' of XSD type 'xsd:anyURI'
        std::vector<std::string> ProducerPropertiesFilterDialect;
        /// Required element 'tev:MessageContentSchemaLocation' of XSD type 'xsd:anyURI'
        std::vector<std::string> MessageContentSchemaLocation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tev__GetEventPropertiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tev__GetEventPropertiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tev__GetEventPropertiesResponse, default initialized and not managed by a soap context
        virtual _tev__GetEventPropertiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tev__GetEventPropertiesResponse); }
      public:
        /// Constructor with initializations
        _tev__GetEventPropertiesResponse() : TopicNamespaceLocation(), wsnt__FixedTopicSet((bool)1), wstop__TopicSet(), wsnt__TopicExpressionDialect(), MessageContentFilterDialect(), ProducerPropertiesFilterDialect(), MessageContentSchemaLocation(), soap() { }
        virtual ~_tev__GetEventPropertiesResponse() { }
        /// Friend allocator used by soap_new__tev__GetEventPropertiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tev__GetEventPropertiesResponse * SOAP_FMAC2 soap_instantiate__tev__GetEventPropertiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2086 */
#ifndef SOAP_TYPE_tmd__Capabilities
#define SOAP_TYPE_tmd__Capabilities (731)
/* complex XSD type 'tmd:Capabilities': */
class SOAP_CMAC tmd__Capabilities {
      public:
        /// optional attribute 'VideoSources' of XSD type 'xsd:int'
        int VideoSources;	///< initialized with default value = 0
        /// optional attribute 'VideoOutputs' of XSD type 'xsd:int'
        int VideoOutputs;	///< initialized with default value = 0
        /// optional attribute 'AudioSources' of XSD type 'xsd:int'
        int AudioSources;	///< initialized with default value = 0
        /// optional attribute 'AudioOutputs' of XSD type 'xsd:int'
        int AudioOutputs;	///< initialized with default value = 0
        /// optional attribute 'RelayOutputs' of XSD type 'xsd:int'
        int RelayOutputs;	///< initialized with default value = 0
        /// optional attribute 'SerialPorts' of XSD type 'xsd:int'
        int SerialPorts;	///< initialized with default value = 0
        /// optional attribute 'DigitalInputs' of XSD type 'xsd:int'
        int DigitalInputs;	///< initialized with default value = 0
        /// optional attribute 'DigitalInputOptions' of XSD type 'xsd:boolean'
        bool DigitalInputOptions;	///< initialized with default value = (bool)0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__Capabilities, default initialized and not managed by a soap context
        virtual tmd__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__Capabilities); }
      public:
        /// Constructor with initializations
        tmd__Capabilities() : VideoSources(0), VideoOutputs(0), AudioSources(0), AudioOutputs(0), RelayOutputs(0), SerialPorts(0), DigitalInputs(0), DigitalInputOptions((bool)0), soap() { }
        virtual ~tmd__Capabilities() { }
        /// Friend allocator used by soap_new_tmd__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tmd__Capabilities * SOAP_FMAC2 soap_instantiate_tmd__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2089 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptions
#define SOAP_TYPE_tmd__RelayOutputOptions (732)
/* complex XSD type 'tmd:RelayOutputOptions': */
class SOAP_CMAC tmd__RelayOutputOptions {
      public:
        /// Required element 'tmd:Mode' of XSD type 'tt:RelayMode'
        std::vector<enum tt__RelayMode> Mode;
        /// Optional element 'tmd:DelayTimes' of XSD type 'tmd:DelayTimes'
        std::string *DelayTimes;
        /// Optional element 'tmd:Discrete' of XSD type 'xsd:boolean'
        bool *Discrete;
        /// Optional element 'tmd:Extension' of XSD type 'tmd:RelayOutputOptionsExtension'
        tmd__RelayOutputOptionsExtension *Extension;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__RelayOutputOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__RelayOutputOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__RelayOutputOptions, default initialized and not managed by a soap context
        virtual tmd__RelayOutputOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__RelayOutputOptions); }
      public:
        /// Constructor with initializations
        tmd__RelayOutputOptions() : Mode(), DelayTimes(), Discrete(), Extension(), token(), soap() { }
        virtual ~tmd__RelayOutputOptions() { }
        /// Friend allocator used by soap_new_tmd__RelayOutputOptions(struct soap*, int)
        friend SOAP_FMAC1 tmd__RelayOutputOptions * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2092 */
#ifndef SOAP_TYPE_tmd__RelayOutputOptionsExtension
#define SOAP_TYPE_tmd__RelayOutputOptionsExtension (733)
/* complex XSD type 'tmd:RelayOutputOptionsExtension': */
class SOAP_CMAC tmd__RelayOutputOptionsExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__RelayOutputOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__RelayOutputOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__RelayOutputOptionsExtension, default initialized and not managed by a soap context
        virtual tmd__RelayOutputOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__RelayOutputOptionsExtension); }
      public:
        /// Constructor with initializations
        tmd__RelayOutputOptionsExtension() : soap() { }
        virtual ~tmd__RelayOutputOptionsExtension() { }
        /// Friend allocator used by soap_new_tmd__RelayOutputOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tmd__RelayOutputOptionsExtension * SOAP_FMAC2 soap_instantiate_tmd__RelayOutputOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2095 */
#ifndef SOAP_TYPE_tmd__Get
#define SOAP_TYPE_tmd__Get (734)
/* complex XSD type 'tmd:Get': */
class SOAP_CMAC tmd__Get {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__Get
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__Get; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__Get, default initialized and not managed by a soap context
        virtual tmd__Get *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__Get); }
      public:
        /// Constructor with initializations
        tmd__Get() : soap() { }
        virtual ~tmd__Get() { }
        /// Friend allocator used by soap_new_tmd__Get(struct soap*, int)
        friend SOAP_FMAC1 tmd__Get * SOAP_FMAC2 soap_instantiate_tmd__Get(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2098 */
#ifndef SOAP_TYPE_tmd__GetResponse
#define SOAP_TYPE_tmd__GetResponse (735)
/* complex XSD type 'tmd:GetResponse': */
class SOAP_CMAC tmd__GetResponse {
      public:
        /// Optional element 'tmd:Token' of XSD type 'tt:ReferenceToken'
        std::vector<std::string> Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__GetResponse
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__GetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__GetResponse, default initialized and not managed by a soap context
        virtual tmd__GetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__GetResponse); }
      public:
        /// Constructor with initializations
        tmd__GetResponse() : Token(), soap() { }
        virtual ~tmd__GetResponse() { }
        /// Friend allocator used by soap_new_tmd__GetResponse(struct soap*, int)
        friend SOAP_FMAC1 tmd__GetResponse * SOAP_FMAC2 soap_instantiate_tmd__GetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2101 */
#ifndef SOAP_TYPE_tmd__DigitalInputConfigurationOptions
#define SOAP_TYPE_tmd__DigitalInputConfigurationOptions (736)
/* complex XSD type 'tmd:DigitalInputConfigurationOptions': */
class SOAP_CMAC tmd__DigitalInputConfigurationOptions {
      public:
        /// Required element 'tmd:IdleState' of XSD type 'tt:DigitalIdleState'
        std::vector<enum tt__DigitalIdleState> IdleState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__DigitalInputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__DigitalInputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__DigitalInputConfigurationOptions, default initialized and not managed by a soap context
        virtual tmd__DigitalInputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__DigitalInputConfigurationOptions); }
      public:
        /// Constructor with initializations
        tmd__DigitalInputConfigurationOptions() : IdleState(), soap() { }
        virtual ~tmd__DigitalInputConfigurationOptions() { }
        /// Friend allocator used by soap_new_tmd__DigitalInputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tmd__DigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tmd__DigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:21401 */
#ifndef SOAP_TYPE__tmd__union_SerialData
#define SOAP_TYPE__tmd__union_SerialData (1670)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tmd__union_SerialData
{
        #define SOAP_UNION__tmd__union_SerialData_Binary	(1)	/**< union variant selector value for member Binary */
        xsd__base64Binary *Binary;
        #define SOAP_UNION__tmd__union_SerialData_String	(2)	/**< union variant selector value for member String */
        std::string *String;
};
#endif

/* onvif.h:2104 */
#ifndef SOAP_TYPE_tmd__SerialData
#define SOAP_TYPE_tmd__SerialData (737)
/* Choice: */
class SOAP_CMAC tmd__SerialData {
      public:
        /// Union with union _tmd__union_SerialData variant selector __union_SerialData set to one of: SOAP_UNION__tmd__union_SerialData_Binary SOAP_UNION__tmd__union_SerialData_String
        int __union_SerialData;
        union _tmd__union_SerialData union_SerialData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__SerialData
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__SerialData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__SerialData, default initialized and not managed by a soap context
        virtual tmd__SerialData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__SerialData); }
      public:
        /// Constructor with initializations
        tmd__SerialData() : __union_SerialData(), soap() { }
        virtual ~tmd__SerialData() { }
        /// Friend allocator used by soap_new_tmd__SerialData(struct soap*, int)
        friend SOAP_FMAC1 tmd__SerialData * SOAP_FMAC2 soap_instantiate_tmd__SerialData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2110 */
#ifndef SOAP_TYPE_tmd__SerialPortConfiguration
#define SOAP_TYPE_tmd__SerialPortConfiguration (739)
/* complex XSD type 'tmd:SerialPortConfiguration': */
class SOAP_CMAC tmd__SerialPortConfiguration {
      public:
        /// Required element 'tmd:BaudRate' of XSD type 'xsd:int'
        int BaudRate;
        /// Required element 'tmd:ParityBit' of XSD type 'tmd:ParityBit'
        enum tmd__ParityBit ParityBit;
        /// Required element 'tmd:CharacterLength' of XSD type 'xsd:int'
        int CharacterLength;
        /// Required element 'tmd:StopBit' of XSD type 'xsd:float'
        float StopBit;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// required attribute 'type' of XSD type 'tmd:SerialPortType'
        enum tmd__SerialPortType type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__SerialPortConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__SerialPortConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__SerialPortConfiguration, default initialized and not managed by a soap context
        virtual tmd__SerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__SerialPortConfiguration); }
      public:
        /// Constructor with initializations
        tmd__SerialPortConfiguration() : BaudRate(), ParityBit(), CharacterLength(), StopBit(), token(), type(), soap() { }
        virtual ~tmd__SerialPortConfiguration() { }
        /// Friend allocator used by soap_new_tmd__SerialPortConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tmd__SerialPortConfiguration * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2113 */
#ifndef SOAP_TYPE_tmd__SerialPortConfigurationOptions
#define SOAP_TYPE_tmd__SerialPortConfigurationOptions (740)
/* complex XSD type 'tmd:SerialPortConfigurationOptions': */
class SOAP_CMAC tmd__SerialPortConfigurationOptions {
      public:
        /// Required element 'tmd:BaudRateList' of XSD type 'tt:IntList'
        tt__IntList *BaudRateList;
        /// Required element 'tmd:ParityBitList' of XSD type 'tmd:ParityBitList'
        tmd__ParityBitList *ParityBitList;
        /// Required element 'tmd:CharacterLengthList' of XSD type 'tt:IntList'
        tt__IntList *CharacterLengthList;
        /// Required element 'tmd:StopBitList' of XSD type 'tt:FloatList'
        tt__FloatList *StopBitList;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__SerialPortConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__SerialPortConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__SerialPortConfigurationOptions, default initialized and not managed by a soap context
        virtual tmd__SerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__SerialPortConfigurationOptions); }
      public:
        /// Constructor with initializations
        tmd__SerialPortConfigurationOptions() : BaudRateList(), ParityBitList(), CharacterLengthList(), StopBitList(), token(), soap() { }
        virtual ~tmd__SerialPortConfigurationOptions() { }
        /// Friend allocator used by soap_new_tmd__SerialPortConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tmd__SerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate_tmd__SerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2116 */
#ifndef SOAP_TYPE_tmd__ParityBitList
#define SOAP_TYPE_tmd__ParityBitList (741)
/* complex XSD type 'tmd:ParityBitList': */
class SOAP_CMAC tmd__ParityBitList {
      public:
        /// Optional element 'tmd:Items' of XSD type 'tmd:ParityBit'
        std::vector<enum tmd__ParityBit> Items;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tmd__ParityBitList
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__ParityBitList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__ParityBitList, default initialized and not managed by a soap context
        virtual tmd__ParityBitList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__ParityBitList); }
      public:
        /// Constructor with initializations
        tmd__ParityBitList() : Items(), soap() { }
        virtual ~tmd__ParityBitList() { }
        /// Friend allocator used by soap_new_tmd__ParityBitList(struct soap*, int)
        friend SOAP_FMAC1 tmd__ParityBitList * SOAP_FMAC2 soap_instantiate_tmd__ParityBitList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2119 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilities
#define SOAP_TYPE__tmd__GetServiceCapabilities (742)
/* complex XSD type 'tmd:GetServiceCapabilities': */
class SOAP_CMAC _tmd__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tmd__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _tmd__GetServiceCapabilities() : soap() { }
        virtual ~_tmd__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tmd__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2122 */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (743)
/* complex XSD type 'tmd:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tmd__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tmd:Capabilities' of XSD type 'tmd:Capabilities'
        tmd__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tmd__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tmd__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tmd__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tmd__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2125 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptions
#define SOAP_TYPE__tmd__GetRelayOutputOptions (744)
/* complex XSD type 'tmd:GetRelayOutputOptions': */
class SOAP_CMAC _tmd__GetRelayOutputOptions {
      public:
        /// Optional element 'tmd:RelayOutputToken' of XSD type 'tt:ReferenceToken'
        std::string *RelayOutputToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetRelayOutputOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetRelayOutputOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetRelayOutputOptions, default initialized and not managed by a soap context
        virtual _tmd__GetRelayOutputOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetRelayOutputOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetRelayOutputOptions() : RelayOutputToken(), soap() { }
        virtual ~_tmd__GetRelayOutputOptions() { }
        /// Friend allocator used by soap_new__tmd__GetRelayOutputOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2128 */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
#define SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (745)
/* complex XSD type 'tmd:GetRelayOutputOptionsResponse': */
class SOAP_CMAC _tmd__GetRelayOutputOptionsResponse {
      public:
        /// Optional element 'tmd:RelayOutputOptions' of XSD type 'tmd:RelayOutputOptions'
        std::vector<tmd__RelayOutputOptions *> RelayOutputOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetRelayOutputOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetRelayOutputOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetRelayOutputOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetRelayOutputOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetRelayOutputOptionsResponse() : RelayOutputOptions(), soap() { }
        virtual ~_tmd__GetRelayOutputOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetRelayOutputOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetRelayOutputOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetRelayOutputOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2131 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputs
#define SOAP_TYPE__tmd__GetVideoOutputs (746)
/* complex XSD type 'tmd:GetVideoOutputs': */
class SOAP_CMAC _tmd__GetVideoOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputs
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputs, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputs); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputs() : soap() { }
        virtual ~_tmd__GetVideoOutputs() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputs(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2134 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputsResponse
#define SOAP_TYPE__tmd__GetVideoOutputsResponse (747)
/* complex XSD type 'tmd:GetVideoOutputsResponse': */
class SOAP_CMAC _tmd__GetVideoOutputsResponse {
      public:
        /// Optional element 'tmd:VideoOutputs' of XSD type 'tt:VideoOutput'
        std::vector<tt__VideoOutput *> VideoOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputsResponse() : VideoOutputs(), soap() { }
        virtual ~_tmd__GetVideoOutputsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2137 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfiguration
#define SOAP_TYPE__tmd__GetAudioSourceConfiguration (748)
/* complex XSD type 'tmd:GetAudioSourceConfiguration': */
class SOAP_CMAC _tmd__GetAudioSourceConfiguration {
      public:
        /// Required element 'tmd:AudioSourceToken' of XSD type 'tt:ReferenceToken'
        std::string AudioSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _tmd__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioSourceConfiguration() : AudioSourceToken(), soap() { }
        virtual ~_tmd__GetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__tmd__GetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2140 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (749)
/* complex XSD type 'tmd:GetAudioSourceConfigurationResponse': */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationResponse {
      public:
        /// Required element 'tmd:AudioSourceConfiguration' of XSD type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *AudioSourceConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioSourceConfigurationResponse() : AudioSourceConfiguration(), soap() { }
        virtual ~_tmd__GetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__GetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2143 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfiguration
#define SOAP_TYPE__tmd__GetAudioOutputConfiguration (750)
/* complex XSD type 'tmd:GetAudioOutputConfiguration': */
class SOAP_CMAC _tmd__GetAudioOutputConfiguration {
      public:
        /// Required element 'tmd:AudioOutputToken' of XSD type 'tt:ReferenceToken'
        std::string AudioOutputToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _tmd__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioOutputConfiguration() : AudioOutputToken(), soap() { }
        virtual ~_tmd__GetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__tmd__GetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2146 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (751)
/* complex XSD type 'tmd:GetAudioOutputConfigurationResponse': */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationResponse {
      public:
        /// Required element 'tmd:AudioOutputConfiguration' of XSD type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *AudioOutputConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioOutputConfigurationResponse() : AudioOutputConfiguration(), soap() { }
        virtual ~_tmd__GetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__GetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2149 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfiguration
#define SOAP_TYPE__tmd__GetVideoSourceConfiguration (752)
/* complex XSD type 'tmd:GetVideoSourceConfiguration': */
class SOAP_CMAC _tmd__GetVideoSourceConfiguration {
      public:
        /// Required element 'tmd:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _tmd__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoSourceConfiguration() : VideoSourceToken(), soap() { }
        virtual ~_tmd__GetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__tmd__GetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2152 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (753)
/* complex XSD type 'tmd:GetVideoSourceConfigurationResponse': */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationResponse {
      public:
        /// Required element 'tmd:VideoSourceConfiguration' of XSD type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *VideoSourceConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoSourceConfigurationResponse() : VideoSourceConfiguration(), soap() { }
        virtual ~_tmd__GetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__GetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2155 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfiguration
#define SOAP_TYPE__tmd__GetVideoOutputConfiguration (754)
/* complex XSD type 'tmd:GetVideoOutputConfiguration': */
class SOAP_CMAC _tmd__GetVideoOutputConfiguration {
      public:
        /// Required element 'tmd:VideoOutputToken' of XSD type 'tt:ReferenceToken'
        std::string VideoOutputToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputConfiguration, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputConfiguration() : VideoOutputToken(), soap() { }
        virtual ~_tmd__GetVideoOutputConfiguration() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2158 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (755)
/* complex XSD type 'tmd:GetVideoOutputConfigurationResponse': */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationResponse {
      public:
        /// Required element 'tmd:VideoOutputConfiguration' of XSD type 'tt:VideoOutputConfiguration'
        tt__VideoOutputConfiguration *VideoOutputConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputConfigurationResponse() : VideoOutputConfiguration(), soap() { }
        virtual ~_tmd__GetVideoOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2161 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfiguration
#define SOAP_TYPE__tmd__SetAudioSourceConfiguration (756)
/* complex XSD type 'tmd:SetAudioSourceConfiguration': */
class SOAP_CMAC _tmd__SetAudioSourceConfiguration {
      public:
        /// Required element 'tmd:Configuration' of XSD type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *Configuration;
        /// Required element 'tmd:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _tmd__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__SetAudioSourceConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_tmd__SetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__tmd__SetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2164 */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (757)
/* complex XSD type 'tmd:SetAudioSourceConfigurationResponse': */
class SOAP_CMAC _tmd__SetAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetAudioSourceConfigurationResponse() : soap() { }
        virtual ~_tmd__SetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__SetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2167 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfiguration
#define SOAP_TYPE__tmd__SetAudioOutputConfiguration (758)
/* complex XSD type 'tmd:SetAudioOutputConfiguration': */
class SOAP_CMAC _tmd__SetAudioOutputConfiguration {
      public:
        /// Required element 'tmd:Configuration' of XSD type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *Configuration;
        /// Required element 'tmd:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _tmd__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__SetAudioOutputConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_tmd__SetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__tmd__SetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2170 */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (759)
/* complex XSD type 'tmd:SetAudioOutputConfigurationResponse': */
class SOAP_CMAC _tmd__SetAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetAudioOutputConfigurationResponse() : soap() { }
        virtual ~_tmd__SetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__SetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2173 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfiguration
#define SOAP_TYPE__tmd__SetVideoSourceConfiguration (760)
/* complex XSD type 'tmd:SetVideoSourceConfiguration': */
class SOAP_CMAC _tmd__SetVideoSourceConfiguration {
      public:
        /// Required element 'tmd:Configuration' of XSD type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *Configuration;
        /// Required element 'tmd:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _tmd__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__SetVideoSourceConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_tmd__SetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__tmd__SetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2176 */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (761)
/* complex XSD type 'tmd:SetVideoSourceConfigurationResponse': */
class SOAP_CMAC _tmd__SetVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetVideoSourceConfigurationResponse() : soap() { }
        virtual ~_tmd__SetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__SetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2179 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfiguration
#define SOAP_TYPE__tmd__SetVideoOutputConfiguration (762)
/* complex XSD type 'tmd:SetVideoOutputConfiguration': */
class SOAP_CMAC _tmd__SetVideoOutputConfiguration {
      public:
        /// Required element 'tmd:Configuration' of XSD type 'tt:VideoOutputConfiguration'
        tt__VideoOutputConfiguration *Configuration;
        /// Required element 'tmd:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetVideoOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetVideoOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetVideoOutputConfiguration, default initialized and not managed by a soap context
        virtual _tmd__SetVideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetVideoOutputConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__SetVideoOutputConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_tmd__SetVideoOutputConfiguration() { }
        /// Friend allocator used by soap_new__tmd__SetVideoOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2182 */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (763)
/* complex XSD type 'tmd:SetVideoOutputConfigurationResponse': */
class SOAP_CMAC _tmd__SetVideoOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetVideoOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__SetVideoOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetVideoOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetVideoOutputConfigurationResponse() : soap() { }
        virtual ~_tmd__SetVideoOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__SetVideoOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetVideoOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetVideoOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2185 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (764)
/* complex XSD type 'tmd:GetVideoSourceConfigurationOptions': */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptions {
      public:
        /// Required element 'tmd:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoSourceConfigurationOptions() : VideoSourceToken(), soap() { }
        virtual ~_tmd__GetVideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetVideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2188 */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (765)
/* complex XSD type 'tmd:GetVideoSourceConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetVideoSourceConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:VideoSourceConfigurationOptions' of XSD type 'tt:VideoSourceConfigurationOptions'
        tt__VideoSourceConfigurationOptions *VideoSourceConfigurationOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoSourceConfigurationOptionsResponse() : VideoSourceConfigurationOptions(), soap() { }
        virtual ~_tmd__GetVideoSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2191 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (766)
/* complex XSD type 'tmd:GetVideoOutputConfigurationOptions': */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptions {
      public:
        /// Required element 'tmd:VideoOutputToken' of XSD type 'tt:ReferenceToken'
        std::string VideoOutputToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputConfigurationOptions() : VideoOutputToken(), soap() { }
        virtual ~_tmd__GetVideoOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2194 */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (767)
/* complex XSD type 'tmd:GetVideoOutputConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetVideoOutputConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:VideoOutputConfigurationOptions' of XSD type 'tt:VideoOutputConfigurationOptions'
        tt__VideoOutputConfigurationOptions *VideoOutputConfigurationOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetVideoOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetVideoOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetVideoOutputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetVideoOutputConfigurationOptionsResponse() : VideoOutputConfigurationOptions(), soap() { }
        virtual ~_tmd__GetVideoOutputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetVideoOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetVideoOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2197 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (768)
/* complex XSD type 'tmd:GetAudioSourceConfigurationOptions': */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptions {
      public:
        /// Required element 'tmd:AudioSourceToken' of XSD type 'tt:ReferenceToken'
        std::string AudioSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioSourceConfigurationOptions() : AudioSourceToken(), soap() { }
        virtual ~_tmd__GetAudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetAudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2200 */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (769)
/* complex XSD type 'tmd:GetAudioSourceConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetAudioSourceConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:AudioSourceOptions' of XSD type 'tt:AudioSourceConfigurationOptions'
        tt__AudioSourceConfigurationOptions *AudioSourceOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioSourceConfigurationOptionsResponse() : AudioSourceOptions(), soap() { }
        virtual ~_tmd__GetAudioSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2203 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (770)
/* complex XSD type 'tmd:GetAudioOutputConfigurationOptions': */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptions {
      public:
        /// Required element 'tmd:AudioOutputToken' of XSD type 'tt:ReferenceToken'
        std::string AudioOutputToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioOutputConfigurationOptions() : AudioOutputToken(), soap() { }
        virtual ~_tmd__GetAudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetAudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2206 */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (771)
/* complex XSD type 'tmd:GetAudioOutputConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetAudioOutputConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:AudioOutputOptions' of XSD type 'tt:AudioOutputConfigurationOptions'
        tt__AudioOutputConfigurationOptions *AudioOutputOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetAudioOutputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetAudioOutputConfigurationOptionsResponse() : AudioOutputOptions(), soap() { }
        virtual ~_tmd__GetAudioOutputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2209 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettings
#define SOAP_TYPE__tmd__SetRelayOutputSettings (772)
/* complex XSD type 'tmd:SetRelayOutputSettings': */
class SOAP_CMAC _tmd__SetRelayOutputSettings {
      public:
        /// Required element 'tmd:RelayOutput' of XSD type 'tt:RelayOutput'
        tt__RelayOutput *RelayOutput;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetRelayOutputSettings
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetRelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetRelayOutputSettings, default initialized and not managed by a soap context
        virtual _tmd__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetRelayOutputSettings); }
      public:
        /// Constructor with initializations
        _tmd__SetRelayOutputSettings() : RelayOutput(), soap() { }
        virtual ~_tmd__SetRelayOutputSettings() { }
        /// Friend allocator used by soap_new__tmd__SetRelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2212 */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (773)
/* complex XSD type 'tmd:SetRelayOutputSettingsResponse': */
class SOAP_CMAC _tmd__SetRelayOutputSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetRelayOutputSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
        virtual _tmd__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetRelayOutputSettingsResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetRelayOutputSettingsResponse() : soap() { }
        virtual ~_tmd__SetRelayOutputSettingsResponse() { }
        /// Friend allocator used by soap_new__tmd__SetRelayOutputSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tmd__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2215 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputs
#define SOAP_TYPE__tmd__GetDigitalInputs (774)
/* complex XSD type 'tmd:GetDigitalInputs': */
class SOAP_CMAC _tmd__GetDigitalInputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetDigitalInputs
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetDigitalInputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetDigitalInputs, default initialized and not managed by a soap context
        virtual _tmd__GetDigitalInputs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetDigitalInputs); }
      public:
        /// Constructor with initializations
        _tmd__GetDigitalInputs() : soap() { }
        virtual ~_tmd__GetDigitalInputs() { }
        /// Friend allocator used by soap_new__tmd__GetDigitalInputs(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2218 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputsResponse
#define SOAP_TYPE__tmd__GetDigitalInputsResponse (775)
/* complex XSD type 'tmd:GetDigitalInputsResponse': */
class SOAP_CMAC _tmd__GetDigitalInputsResponse {
      public:
        /// Optional element 'tmd:DigitalInputs' of XSD type 'tt:DigitalInput'
        std::vector<tt__DigitalInput *> DigitalInputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetDigitalInputsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetDigitalInputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetDigitalInputsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetDigitalInputsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetDigitalInputsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetDigitalInputsResponse() : DigitalInputs(), soap() { }
        virtual ~_tmd__GetDigitalInputsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetDigitalInputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetDigitalInputsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2221 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (776)
/* complex XSD type 'tmd:GetDigitalInputConfigurationOptions': */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptions {
      public:
        /// Optional element 'tmd:Token' of XSD type 'tt:ReferenceToken'
        std::string *Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetDigitalInputConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetDigitalInputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetDigitalInputConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetDigitalInputConfigurationOptions() : Token(), soap() { }
        virtual ~_tmd__GetDigitalInputConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetDigitalInputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2224 */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (777)
/* complex XSD type 'tmd:GetDigitalInputConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetDigitalInputConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:DigitalInputOptions' of XSD type 'tmd:DigitalInputConfigurationOptions'
        tmd__DigitalInputConfigurationOptions *DigitalInputOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetDigitalInputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetDigitalInputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetDigitalInputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetDigitalInputConfigurationOptionsResponse() : DigitalInputOptions(), soap() { }
        virtual ~_tmd__GetDigitalInputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetDigitalInputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetDigitalInputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2227 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurations
#define SOAP_TYPE__tmd__SetDigitalInputConfigurations (778)
/* complex XSD type 'tmd:SetDigitalInputConfigurations': */
class SOAP_CMAC _tmd__SetDigitalInputConfigurations {
      public:
        /// Required element 'tmd:DigitalInputs' of XSD type 'tt:DigitalInput'
        std::vector<tt__DigitalInput *> DigitalInputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetDigitalInputConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetDigitalInputConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetDigitalInputConfigurations, default initialized and not managed by a soap context
        virtual _tmd__SetDigitalInputConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetDigitalInputConfigurations); }
      public:
        /// Constructor with initializations
        _tmd__SetDigitalInputConfigurations() : DigitalInputs(), soap() { }
        virtual ~_tmd__SetDigitalInputConfigurations() { }
        /// Friend allocator used by soap_new__tmd__SetDigitalInputConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetDigitalInputConfigurations * SOAP_FMAC2 soap_instantiate__tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2230 */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse
#define SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (779)
/* complex XSD type 'tmd:SetDigitalInputConfigurationsResponse': */
class SOAP_CMAC _tmd__SetDigitalInputConfigurationsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetDigitalInputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tmd__SetDigitalInputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetDigitalInputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetDigitalInputConfigurationsResponse() : soap() { }
        virtual ~_tmd__SetDigitalInputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tmd__SetDigitalInputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetDigitalInputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tmd__SetDigitalInputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2233 */
#ifndef SOAP_TYPE__tmd__GetSerialPorts
#define SOAP_TYPE__tmd__GetSerialPorts (780)
/* complex XSD type 'tmd:GetSerialPorts': */
class SOAP_CMAC _tmd__GetSerialPorts {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPorts
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPorts; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPorts, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPorts *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPorts); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPorts() : soap() { }
        virtual ~_tmd__GetSerialPorts() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPorts(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2236 */
#ifndef SOAP_TYPE__tmd__GetSerialPortsResponse
#define SOAP_TYPE__tmd__GetSerialPortsResponse (781)
/* complex XSD type 'tmd:GetSerialPortsResponse': */
class SOAP_CMAC _tmd__GetSerialPortsResponse {
      public:
        /// Optional element 'tmd:SerialPort' of XSD type 'tmd:SerialPort'
        std::vector<tmd__SerialPort *> SerialPort;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPortsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPortsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPortsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPortsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPortsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPortsResponse() : SerialPort(), soap() { }
        virtual ~_tmd__GetSerialPortsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPortsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPortsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2239 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfiguration
#define SOAP_TYPE__tmd__GetSerialPortConfiguration (782)
/* complex XSD type 'tmd:GetSerialPortConfiguration': */
class SOAP_CMAC _tmd__GetSerialPortConfiguration {
      public:
        /// Required element 'tmd:SerialPortToken' of XSD type 'tt:ReferenceToken'
        std::string SerialPortToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPortConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPortConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPortConfiguration, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPortConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPortConfiguration() : SerialPortToken(), soap() { }
        virtual ~_tmd__GetSerialPortConfiguration() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPortConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2242 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (783)
/* complex XSD type 'tmd:GetSerialPortConfigurationResponse': */
class SOAP_CMAC _tmd__GetSerialPortConfigurationResponse {
      public:
        /// Required element 'tmd:SerialPortConfiguration' of XSD type 'tmd:SerialPortConfiguration'
        tmd__SerialPortConfiguration *SerialPortConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPortConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPortConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPortConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPortConfigurationResponse() : SerialPortConfiguration(), soap() { }
        virtual ~_tmd__GetSerialPortConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPortConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2245 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfiguration
#define SOAP_TYPE__tmd__SetSerialPortConfiguration (784)
/* complex XSD type 'tmd:SetSerialPortConfiguration': */
class SOAP_CMAC _tmd__SetSerialPortConfiguration {
      public:
        /// Required element 'tmd:SerialPortConfiguration' of XSD type 'tmd:SerialPortConfiguration'
        tmd__SerialPortConfiguration *SerialPortConfiguration;
        /// Required element 'tmd:ForcePersistance' of XSD type 'xsd:boolean'
        bool ForcePersistance;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetSerialPortConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetSerialPortConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetSerialPortConfiguration, default initialized and not managed by a soap context
        virtual _tmd__SetSerialPortConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetSerialPortConfiguration); }
      public:
        /// Constructor with initializations
        _tmd__SetSerialPortConfiguration() : SerialPortConfiguration(), ForcePersistance(), soap() { }
        virtual ~_tmd__SetSerialPortConfiguration() { }
        /// Friend allocator used by soap_new__tmd__SetSerialPortConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2248 */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (785)
/* complex XSD type 'tmd:SetSerialPortConfigurationResponse': */
class SOAP_CMAC _tmd__SetSerialPortConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SetSerialPortConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SetSerialPortConfigurationResponse, default initialized and not managed by a soap context
        virtual _tmd__SetSerialPortConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SetSerialPortConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tmd__SetSerialPortConfigurationResponse() : soap() { }
        virtual ~_tmd__SetSerialPortConfigurationResponse() { }
        /// Friend allocator used by soap_new__tmd__SetSerialPortConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SetSerialPortConfigurationResponse * SOAP_FMAC2 soap_instantiate__tmd__SetSerialPortConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2251 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (786)
/* complex XSD type 'tmd:GetSerialPortConfigurationOptions': */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptions {
      public:
        /// Required element 'tmd:SerialPortToken' of XSD type 'tt:ReferenceToken'
        std::string SerialPortToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPortConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPortConfigurationOptions, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPortConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPortConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPortConfigurationOptions() : SerialPortToken(), soap() { }
        virtual ~_tmd__GetSerialPortConfigurationOptions() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPortConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2254 */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (787)
/* complex XSD type 'tmd:GetSerialPortConfigurationOptionsResponse': */
class SOAP_CMAC _tmd__GetSerialPortConfigurationOptionsResponse {
      public:
        /// Required element 'tmd:SerialPortOptions' of XSD type 'tmd:SerialPortConfigurationOptions'
        tmd__SerialPortConfigurationOptions *SerialPortOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__GetSerialPortConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tmd__GetSerialPortConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__GetSerialPortConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tmd__GetSerialPortConfigurationOptionsResponse() : SerialPortOptions(), soap() { }
        virtual ~_tmd__GetSerialPortConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tmd__GetSerialPortConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__GetSerialPortConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tmd__GetSerialPortConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2257 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommand
#define SOAP_TYPE__tmd__SendReceiveSerialCommand (788)
/* complex XSD type 'tmd:SendReceiveSerialCommand': */
class SOAP_CMAC _tmd__SendReceiveSerialCommand {
      public:
        /// Optional element 'tmd:Token' of XSD type 'tt:ReferenceToken'
        std::string *Token;
        /// Optional element 'tmd:SerialData' of XSD type 'tmd:SerialData'
        tmd__SerialData *SerialData;
        /// Optional element 'tmd:TimeOut' of XSD type 'xsd:duration'
        std::string *TimeOut;
        /// Optional element 'tmd:DataLength' of XSD type 'xsd:integer'
        std::string *DataLength;
        /// Optional element 'tmd:Delimiter' of XSD type 'xsd:string'
        std::string *Delimiter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SendReceiveSerialCommand
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SendReceiveSerialCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SendReceiveSerialCommand, default initialized and not managed by a soap context
        virtual _tmd__SendReceiveSerialCommand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SendReceiveSerialCommand); }
      public:
        /// Constructor with initializations
        _tmd__SendReceiveSerialCommand() : Token(), SerialData(), TimeOut(), DataLength(), Delimiter(), soap() { }
        virtual ~_tmd__SendReceiveSerialCommand() { }
        /// Friend allocator used by soap_new__tmd__SendReceiveSerialCommand(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2260 */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
#define SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (789)
/* complex XSD type 'tmd:SendReceiveSerialCommandResponse': */
class SOAP_CMAC _tmd__SendReceiveSerialCommandResponse {
      public:
        /// Optional element 'tmd:SerialData' of XSD type 'tmd:SerialData'
        tmd__SerialData *SerialData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tmd__SendReceiveSerialCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tmd__SendReceiveSerialCommandResponse, default initialized and not managed by a soap context
        virtual _tmd__SendReceiveSerialCommandResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tmd__SendReceiveSerialCommandResponse); }
      public:
        /// Constructor with initializations
        _tmd__SendReceiveSerialCommandResponse() : SerialData(), soap() { }
        virtual ~_tmd__SendReceiveSerialCommandResponse() { }
        /// Friend allocator used by soap_new__tmd__SendReceiveSerialCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _tmd__SendReceiveSerialCommandResponse * SOAP_FMAC2 soap_instantiate__tmd__SendReceiveSerialCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2263 */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (790)
/* complex XSD type 'timg:Capabilities': */
class SOAP_CMAC timg__Capabilities {
      public:
        /// optional attribute 'ImageStabilization' of XSD type 'xsd:boolean'
        bool *ImageStabilization;
        /// optional attribute 'Presets' of XSD type 'xsd:boolean'
        bool *Presets;
        /// optional attribute 'AdaptablePreset' of XSD type 'xsd:boolean'
        bool *AdaptablePreset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_timg__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_timg__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type timg__Capabilities, default initialized and not managed by a soap context
        virtual timg__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(timg__Capabilities); }
      public:
        /// Constructor with initializations
        timg__Capabilities() : ImageStabilization(), Presets(), AdaptablePreset(), soap() { }
        virtual ~timg__Capabilities() { }
        /// Friend allocator used by soap_new_timg__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 timg__Capabilities * SOAP_FMAC2 soap_instantiate_timg__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2266 */
#ifndef SOAP_TYPE_timg__ImagingPreset
#define SOAP_TYPE_timg__ImagingPreset (791)
/* complex XSD type 'timg:ImagingPreset': */
class SOAP_CMAC timg__ImagingPreset {
      public:
        /// Required element 'timg:Name' of XSD type 'tt:Name'
        std::string Name;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// required attribute 'type' of XSD type 'xsd:string'
        std::string type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_timg__ImagingPreset
        virtual long soap_type(void) const { return SOAP_TYPE_timg__ImagingPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type timg__ImagingPreset, default initialized and not managed by a soap context
        virtual timg__ImagingPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(timg__ImagingPreset); }
      public:
        /// Constructor with initializations
        timg__ImagingPreset() : Name(), token(), type(), soap() { }
        virtual ~timg__ImagingPreset() { }
        /// Friend allocator used by soap_new_timg__ImagingPreset(struct soap*, int)
        friend SOAP_FMAC1 timg__ImagingPreset * SOAP_FMAC2 soap_instantiate_timg__ImagingPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2269 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (792)
/* complex XSD type 'timg:GetServiceCapabilities': */
class SOAP_CMAC _timg__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _timg__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _timg__GetServiceCapabilities() : soap() { }
        virtual ~_timg__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__timg__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2272 */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (793)
/* complex XSD type 'timg:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _timg__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'timg:Capabilities' of XSD type 'timg:Capabilities'
        timg__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _timg__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _timg__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_timg__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__timg__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__timg__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2275 */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (794)
/* complex XSD type 'timg:GetImagingSettings': */
class SOAP_CMAC _timg__GetImagingSettings {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetImagingSettings, default initialized and not managed by a soap context
        virtual _timg__GetImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetImagingSettings); }
      public:
        /// Constructor with initializations
        _timg__GetImagingSettings() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetImagingSettings() { }
        /// Friend allocator used by soap_new__timg__GetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate__timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2278 */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (795)
/* complex XSD type 'timg:GetImagingSettingsResponse': */
class SOAP_CMAC _timg__GetImagingSettingsResponse {
      public:
        /// Required element 'timg:ImagingSettings' of XSD type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *ImagingSettings;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetImagingSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _timg__GetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetImagingSettingsResponse); }
      public:
        /// Constructor with initializations
        _timg__GetImagingSettingsResponse() : ImagingSettings(), soap() { }
        virtual ~_timg__GetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__timg__GetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__timg__GetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2281 */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (796)
/* complex XSD type 'timg:SetImagingSettings': */
class SOAP_CMAC _timg__SetImagingSettings {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:ImagingSettings' of XSD type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *ImagingSettings;
        /// Optional element 'timg:ForcePersistence' of XSD type 'xsd:boolean'
        bool *ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetImagingSettings, default initialized and not managed by a soap context
        virtual _timg__SetImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetImagingSettings); }
      public:
        /// Constructor with initializations
        _timg__SetImagingSettings() : VideoSourceToken(), ImagingSettings(), ForcePersistence(), soap() { }
        virtual ~_timg__SetImagingSettings() { }
        /// Friend allocator used by soap_new__timg__SetImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate__timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2284 */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (797)
/* complex XSD type 'timg:SetImagingSettingsResponse': */
class SOAP_CMAC _timg__SetImagingSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetImagingSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetImagingSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetImagingSettingsResponse, default initialized and not managed by a soap context
        virtual _timg__SetImagingSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetImagingSettingsResponse); }
      public:
        /// Constructor with initializations
        _timg__SetImagingSettingsResponse() : soap() { }
        virtual ~_timg__SetImagingSettingsResponse() { }
        /// Friend allocator used by soap_new__timg__SetImagingSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetImagingSettingsResponse * SOAP_FMAC2 soap_instantiate__timg__SetImagingSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2287 */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (798)
/* complex XSD type 'timg:GetOptions': */
class SOAP_CMAC _timg__GetOptions {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetOptions
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetOptions, default initialized and not managed by a soap context
        virtual _timg__GetOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetOptions); }
      public:
        /// Constructor with initializations
        _timg__GetOptions() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetOptions() { }
        /// Friend allocator used by soap_new__timg__GetOptions(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetOptions * SOAP_FMAC2 soap_instantiate__timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2290 */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (799)
/* complex XSD type 'timg:GetOptionsResponse': */
class SOAP_CMAC _timg__GetOptionsResponse {
      public:
        /// Required element 'timg:ImagingOptions' of XSD type 'tt:ImagingOptions20'
        tt__ImagingOptions20 *ImagingOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetOptionsResponse, default initialized and not managed by a soap context
        virtual _timg__GetOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetOptionsResponse); }
      public:
        /// Constructor with initializations
        _timg__GetOptionsResponse() : ImagingOptions(), soap() { }
        virtual ~_timg__GetOptionsResponse() { }
        /// Friend allocator used by soap_new__timg__GetOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetOptionsResponse * SOAP_FMAC2 soap_instantiate__timg__GetOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2293 */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (800)
/* complex XSD type 'timg:Move': */
class SOAP_CMAC _timg__Move {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:Focus' of XSD type 'tt:FocusMove'
        tt__FocusMove *Focus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__Move
        virtual long soap_type(void) const { return SOAP_TYPE__timg__Move; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__Move, default initialized and not managed by a soap context
        virtual _timg__Move *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__Move); }
      public:
        /// Constructor with initializations
        _timg__Move() : VideoSourceToken(), Focus(), soap() { }
        virtual ~_timg__Move() { }
        /// Friend allocator used by soap_new__timg__Move(struct soap*, int)
        friend SOAP_FMAC1 _timg__Move * SOAP_FMAC2 soap_instantiate__timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2296 */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (801)
/* complex XSD type 'timg:MoveResponse': */
class SOAP_CMAC _timg__MoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__MoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__MoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__MoveResponse, default initialized and not managed by a soap context
        virtual _timg__MoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__MoveResponse); }
      public:
        /// Constructor with initializations
        _timg__MoveResponse() : soap() { }
        virtual ~_timg__MoveResponse() { }
        /// Friend allocator used by soap_new__timg__MoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__MoveResponse * SOAP_FMAC2 soap_instantiate__timg__MoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2299 */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (802)
/* complex XSD type 'timg:GetMoveOptions': */
class SOAP_CMAC _timg__GetMoveOptions {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetMoveOptions
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetMoveOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetMoveOptions, default initialized and not managed by a soap context
        virtual _timg__GetMoveOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetMoveOptions); }
      public:
        /// Constructor with initializations
        _timg__GetMoveOptions() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetMoveOptions() { }
        /// Friend allocator used by soap_new__timg__GetMoveOptions(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate__timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2302 */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (803)
/* complex XSD type 'timg:GetMoveOptionsResponse': */
class SOAP_CMAC _timg__GetMoveOptionsResponse {
      public:
        /// Required element 'timg:MoveOptions' of XSD type 'tt:MoveOptions20'
        tt__MoveOptions20 *MoveOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetMoveOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetMoveOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetMoveOptionsResponse, default initialized and not managed by a soap context
        virtual _timg__GetMoveOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetMoveOptionsResponse); }
      public:
        /// Constructor with initializations
        _timg__GetMoveOptionsResponse() : MoveOptions(), soap() { }
        virtual ~_timg__GetMoveOptionsResponse() { }
        /// Friend allocator used by soap_new__timg__GetMoveOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetMoveOptionsResponse * SOAP_FMAC2 soap_instantiate__timg__GetMoveOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2305 */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (804)
/* complex XSD type 'timg:Stop': */
class SOAP_CMAC _timg__Stop {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__Stop
        virtual long soap_type(void) const { return SOAP_TYPE__timg__Stop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__Stop, default initialized and not managed by a soap context
        virtual _timg__Stop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__Stop); }
      public:
        /// Constructor with initializations
        _timg__Stop() : VideoSourceToken(), soap() { }
        virtual ~_timg__Stop() { }
        /// Friend allocator used by soap_new__timg__Stop(struct soap*, int)
        friend SOAP_FMAC1 _timg__Stop * SOAP_FMAC2 soap_instantiate__timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2308 */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (805)
/* complex XSD type 'timg:StopResponse': */
class SOAP_CMAC _timg__StopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__StopResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__StopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__StopResponse, default initialized and not managed by a soap context
        virtual _timg__StopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__StopResponse); }
      public:
        /// Constructor with initializations
        _timg__StopResponse() : soap() { }
        virtual ~_timg__StopResponse() { }
        /// Friend allocator used by soap_new__timg__StopResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__StopResponse * SOAP_FMAC2 soap_instantiate__timg__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2311 */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (806)
/* complex XSD type 'timg:GetStatus': */
class SOAP_CMAC _timg__GetStatus {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetStatus
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetStatus, default initialized and not managed by a soap context
        virtual _timg__GetStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetStatus); }
      public:
        /// Constructor with initializations
        _timg__GetStatus() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetStatus() { }
        /// Friend allocator used by soap_new__timg__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetStatus * SOAP_FMAC2 soap_instantiate__timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2314 */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (807)
/* complex XSD type 'timg:GetStatusResponse': */
class SOAP_CMAC _timg__GetStatusResponse {
      public:
        /// Required element 'timg:Status' of XSD type 'tt:ImagingStatus20'
        tt__ImagingStatus20 *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetStatusResponse, default initialized and not managed by a soap context
        virtual _timg__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetStatusResponse); }
      public:
        /// Constructor with initializations
        _timg__GetStatusResponse() : Status(), soap() { }
        virtual ~_timg__GetStatusResponse() { }
        /// Friend allocator used by soap_new__timg__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetStatusResponse * SOAP_FMAC2 soap_instantiate__timg__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2317 */
#ifndef SOAP_TYPE__timg__GetPresets
#define SOAP_TYPE__timg__GetPresets (808)
/* complex XSD type 'timg:GetPresets': */
class SOAP_CMAC _timg__GetPresets {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetPresets
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetPresets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetPresets, default initialized and not managed by a soap context
        virtual _timg__GetPresets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetPresets); }
      public:
        /// Constructor with initializations
        _timg__GetPresets() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetPresets() { }
        /// Friend allocator used by soap_new__timg__GetPresets(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetPresets * SOAP_FMAC2 soap_instantiate__timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2320 */
#ifndef SOAP_TYPE__timg__GetPresetsResponse
#define SOAP_TYPE__timg__GetPresetsResponse (809)
/* complex XSD type 'timg:GetPresetsResponse': */
class SOAP_CMAC _timg__GetPresetsResponse {
      public:
        /// Required element 'timg:Preset' of XSD type 'timg:ImagingPreset'
        std::vector<timg__ImagingPreset *> Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetPresetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetPresetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetPresetsResponse, default initialized and not managed by a soap context
        virtual _timg__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetPresetsResponse); }
      public:
        /// Constructor with initializations
        _timg__GetPresetsResponse() : Preset(), soap() { }
        virtual ~_timg__GetPresetsResponse() { }
        /// Friend allocator used by soap_new__timg__GetPresetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__timg__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2323 */
#ifndef SOAP_TYPE__timg__GetCurrentPreset
#define SOAP_TYPE__timg__GetCurrentPreset (810)
/* complex XSD type 'timg:GetCurrentPreset': */
class SOAP_CMAC _timg__GetCurrentPreset {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetCurrentPreset
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetCurrentPreset, default initialized and not managed by a soap context
        virtual _timg__GetCurrentPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetCurrentPreset); }
      public:
        /// Constructor with initializations
        _timg__GetCurrentPreset() : VideoSourceToken(), soap() { }
        virtual ~_timg__GetCurrentPreset() { }
        /// Friend allocator used by soap_new__timg__GetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetCurrentPreset * SOAP_FMAC2 soap_instantiate__timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2326 */
#ifndef SOAP_TYPE__timg__GetCurrentPresetResponse
#define SOAP_TYPE__timg__GetCurrentPresetResponse (811)
/* complex XSD type 'timg:GetCurrentPresetResponse': */
class SOAP_CMAC _timg__GetCurrentPresetResponse {
      public:
        /// Optional element 'timg:Preset' of XSD type 'timg:ImagingPreset'
        timg__ImagingPreset *Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__GetCurrentPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__GetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__GetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _timg__GetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__GetCurrentPresetResponse); }
      public:
        /// Constructor with initializations
        _timg__GetCurrentPresetResponse() : Preset(), soap() { }
        virtual ~_timg__GetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__timg__GetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__GetCurrentPresetResponse * SOAP_FMAC2 soap_instantiate__timg__GetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2329 */
#ifndef SOAP_TYPE__timg__SetCurrentPreset
#define SOAP_TYPE__timg__SetCurrentPreset (812)
/* complex XSD type 'timg:SetCurrentPreset': */
class SOAP_CMAC _timg__SetCurrentPreset {
      public:
        /// Required element 'timg:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'timg:PresetToken' of XSD type 'tt:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetCurrentPreset
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetCurrentPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetCurrentPreset, default initialized and not managed by a soap context
        virtual _timg__SetCurrentPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetCurrentPreset); }
      public:
        /// Constructor with initializations
        _timg__SetCurrentPreset() : VideoSourceToken(), PresetToken(), soap() { }
        virtual ~_timg__SetCurrentPreset() { }
        /// Friend allocator used by soap_new__timg__SetCurrentPreset(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetCurrentPreset * SOAP_FMAC2 soap_instantiate__timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2332 */
#ifndef SOAP_TYPE__timg__SetCurrentPresetResponse
#define SOAP_TYPE__timg__SetCurrentPresetResponse (813)
/* complex XSD type 'timg:SetCurrentPresetResponse': */
class SOAP_CMAC _timg__SetCurrentPresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__timg__SetCurrentPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__timg__SetCurrentPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _timg__SetCurrentPresetResponse, default initialized and not managed by a soap context
        virtual _timg__SetCurrentPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_timg__SetCurrentPresetResponse); }
      public:
        /// Constructor with initializations
        _timg__SetCurrentPresetResponse() : soap() { }
        virtual ~_timg__SetCurrentPresetResponse() { }
        /// Friend allocator used by soap_new__timg__SetCurrentPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _timg__SetCurrentPresetResponse * SOAP_FMAC2 soap_instantiate__timg__SetCurrentPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2335 */
#ifndef SOAP_TYPE_trt__Capabilities
#define SOAP_TYPE_trt__Capabilities (814)
/* complex XSD type 'trt:Capabilities': */
class SOAP_CMAC trt__Capabilities {
      public:
        /// Required element 'trt:ProfileCapabilities' of XSD type 'trt:ProfileCapabilities'
        trt__ProfileCapabilities *ProfileCapabilities;
        /// Required element 'trt:StreamingCapabilities' of XSD type 'trt:StreamingCapabilities'
        trt__StreamingCapabilities *StreamingCapabilities;
        /// optional attribute 'SnapshotUri' of XSD type 'xsd:boolean'
        bool *SnapshotUri;
        /// optional attribute 'Rotation' of XSD type 'xsd:boolean'
        bool *Rotation;
        /// optional attribute 'VideoSourceMode' of XSD type 'xsd:boolean'
        bool *VideoSourceMode;
        /// optional attribute 'OSD' of XSD type 'xsd:boolean'
        bool *OSD;
        /// optional attribute 'TemporaryOSDText' of XSD type 'xsd:boolean'
        bool *TemporaryOSDText;
        /// optional attribute 'EXICompression' of XSD type 'xsd:boolean'
        bool *EXICompression;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_trt__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_trt__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type trt__Capabilities, default initialized and not managed by a soap context
        virtual trt__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(trt__Capabilities); }
      public:
        /// Constructor with initializations
        trt__Capabilities() : ProfileCapabilities(), StreamingCapabilities(), SnapshotUri(), Rotation(), VideoSourceMode(), OSD(), TemporaryOSDText(), EXICompression(), soap() { }
        virtual ~trt__Capabilities() { }
        /// Friend allocator used by soap_new_trt__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 trt__Capabilities * SOAP_FMAC2 soap_instantiate_trt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2338 */
#ifndef SOAP_TYPE_trt__ProfileCapabilities
#define SOAP_TYPE_trt__ProfileCapabilities (815)
/* complex XSD type 'trt:ProfileCapabilities': */
class SOAP_CMAC trt__ProfileCapabilities {
      public:
        /// optional attribute 'MaximumNumberOfProfiles' of XSD type 'xsd:int'
        int *MaximumNumberOfProfiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_trt__ProfileCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_trt__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type trt__ProfileCapabilities, default initialized and not managed by a soap context
        virtual trt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(trt__ProfileCapabilities); }
      public:
        /// Constructor with initializations
        trt__ProfileCapabilities() : MaximumNumberOfProfiles(), soap() { }
        virtual ~trt__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_trt__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 trt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_trt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2341 */
#ifndef SOAP_TYPE_trt__StreamingCapabilities
#define SOAP_TYPE_trt__StreamingCapabilities (816)
/* complex XSD type 'trt:StreamingCapabilities': */
class SOAP_CMAC trt__StreamingCapabilities {
      public:
        /// optional attribute 'RTPMulticast' of XSD type 'xsd:boolean'
        bool *RTPMulticast;
        /// optional attribute 'RTP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORETCP;
        /// optional attribute 'RTP_RTSP_TCP' of XSD type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// optional attribute 'NonAggregateControl' of XSD type 'xsd:boolean'
        bool *NonAggregateControl;
        /// optional attribute 'NoRTSPStreaming' of XSD type 'xsd:boolean'
        bool *NoRTSPStreaming;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_trt__StreamingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_trt__StreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type trt__StreamingCapabilities, default initialized and not managed by a soap context
        virtual trt__StreamingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(trt__StreamingCapabilities); }
      public:
        /// Constructor with initializations
        trt__StreamingCapabilities() : RTPMulticast(), RTP_USCORETCP(), RTP_USCORERTSP_USCORETCP(), NonAggregateControl(), NoRTSPStreaming(), soap() { }
        virtual ~trt__StreamingCapabilities() { }
        /// Friend allocator used by soap_new_trt__StreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 trt__StreamingCapabilities * SOAP_FMAC2 soap_instantiate_trt__StreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2344 */
#ifndef SOAP_TYPE_trt__VideoSourceMode
#define SOAP_TYPE_trt__VideoSourceMode (817)
/* complex XSD type 'trt:VideoSourceMode': */
class SOAP_CMAC trt__VideoSourceMode {
      public:
        /// Required element 'trt:MaxFramerate' of XSD type 'xsd:float'
        float MaxFramerate;
        /// Required element 'trt:MaxResolution' of XSD type 'tt:VideoResolution'
        tt__VideoResolution *MaxResolution;
        /// Required element 'trt:Encodings' of XSD type 'trt:EncodingTypes'
        std::string Encodings;
        /// Required element 'trt:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Optional element 'trt:Description' of XSD type 'tt:Description'
        std::string *Description;
        /// Optional element 'trt:Extension' of XSD type 'trt:VideoSourceModeExtension'
        trt__VideoSourceModeExtension *Extension;
        /// required attribute 'token' of XSD type 'tt:ReferenceToken'
        std::string token;
        /// optional attribute 'Enabled' of XSD type 'xsd:boolean'
        bool *Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_trt__VideoSourceMode
        virtual long soap_type(void) const { return SOAP_TYPE_trt__VideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type trt__VideoSourceMode, default initialized and not managed by a soap context
        virtual trt__VideoSourceMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(trt__VideoSourceMode); }
      public:
        /// Constructor with initializations
        trt__VideoSourceMode() : MaxFramerate(), MaxResolution(), Encodings(), Reboot(), Description(), Extension(), token(), Enabled(), soap() { }
        virtual ~trt__VideoSourceMode() { }
        /// Friend allocator used by soap_new_trt__VideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 trt__VideoSourceMode * SOAP_FMAC2 soap_instantiate_trt__VideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2347 */
#ifndef SOAP_TYPE_trt__VideoSourceModeExtension
#define SOAP_TYPE_trt__VideoSourceModeExtension (818)
/* complex XSD type 'trt:VideoSourceModeExtension': */
class SOAP_CMAC trt__VideoSourceModeExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_trt__VideoSourceModeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_trt__VideoSourceModeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type trt__VideoSourceModeExtension, default initialized and not managed by a soap context
        virtual trt__VideoSourceModeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(trt__VideoSourceModeExtension); }
      public:
        /// Constructor with initializations
        trt__VideoSourceModeExtension() : soap() { }
        virtual ~trt__VideoSourceModeExtension() { }
        /// Friend allocator used by soap_new_trt__VideoSourceModeExtension(struct soap*, int)
        friend SOAP_FMAC1 trt__VideoSourceModeExtension * SOAP_FMAC2 soap_instantiate_trt__VideoSourceModeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2350 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilities
#define SOAP_TYPE__trt__GetServiceCapabilities (819)
/* complex XSD type 'trt:GetServiceCapabilities': */
class SOAP_CMAC _trt__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _trt__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _trt__GetServiceCapabilities() : soap() { }
        virtual ~_trt__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__trt__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2353 */
#ifndef SOAP_TYPE__trt__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trt__GetServiceCapabilitiesResponse (820)
/* complex XSD type 'trt:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _trt__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'trt:Capabilities' of XSD type 'trt:Capabilities'
        trt__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _trt__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_trt__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__trt__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__trt__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2356 */
#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (821)
/* complex XSD type 'trt:GetVideoSources': */
class SOAP_CMAC _trt__GetVideoSources {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSources
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSources; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSources, default initialized and not managed by a soap context
        virtual _trt__GetVideoSources *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSources); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSources() : soap() { }
        virtual ~_trt__GetVideoSources() { }
        /// Friend allocator used by soap_new__trt__GetVideoSources(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSources * SOAP_FMAC2 soap_instantiate__trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2359 */
#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (822)
/* complex XSD type 'trt:GetVideoSourcesResponse': */
class SOAP_CMAC _trt__GetVideoSourcesResponse {
      public:
        /// Optional element 'trt:VideoSources' of XSD type 'tt:VideoSource'
        std::vector<tt__VideoSource *> VideoSources;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourcesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourcesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourcesResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourcesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourcesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourcesResponse() : VideoSources(), soap() { }
        virtual ~_trt__GetVideoSourcesResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourcesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2362 */
#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (823)
/* complex XSD type 'trt:GetAudioSources': */
class SOAP_CMAC _trt__GetAudioSources {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSources
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSources; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSources, default initialized and not managed by a soap context
        virtual _trt__GetAudioSources *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSources); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSources() : soap() { }
        virtual ~_trt__GetAudioSources() { }
        /// Friend allocator used by soap_new__trt__GetAudioSources(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSources * SOAP_FMAC2 soap_instantiate__trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2365 */
#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (824)
/* complex XSD type 'trt:GetAudioSourcesResponse': */
class SOAP_CMAC _trt__GetAudioSourcesResponse {
      public:
        /// Optional element 'trt:AudioSources' of XSD type 'tt:AudioSource'
        std::vector<tt__AudioSource *> AudioSources;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourcesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourcesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourcesResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourcesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourcesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourcesResponse() : AudioSources(), soap() { }
        virtual ~_trt__GetAudioSourcesResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourcesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourcesResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourcesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2368 */
#ifndef SOAP_TYPE__trt__GetAudioOutputs
#define SOAP_TYPE__trt__GetAudioOutputs (825)
/* complex XSD type 'trt:GetAudioOutputs': */
class SOAP_CMAC _trt__GetAudioOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputs
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputs, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputs); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputs() : soap() { }
        virtual ~_trt__GetAudioOutputs() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputs(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2371 */
#ifndef SOAP_TYPE__trt__GetAudioOutputsResponse
#define SOAP_TYPE__trt__GetAudioOutputsResponse (826)
/* complex XSD type 'trt:GetAudioOutputsResponse': */
class SOAP_CMAC _trt__GetAudioOutputsResponse {
      public:
        /// Optional element 'trt:AudioOutputs' of XSD type 'tt:AudioOutput'
        std::vector<tt__AudioOutput *> AudioOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputsResponse() : AudioOutputs(), soap() { }
        virtual ~_trt__GetAudioOutputsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2374 */
#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (827)
/* complex XSD type 'trt:CreateProfile': */
class SOAP_CMAC _trt__CreateProfile {
      public:
        /// Required element 'trt:Name' of XSD type 'tt:Name'
        std::string Name;
        /// Optional element 'trt:Token' of XSD type 'tt:ReferenceToken'
        std::string *Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__CreateProfile
        virtual long soap_type(void) const { return SOAP_TYPE__trt__CreateProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__CreateProfile, default initialized and not managed by a soap context
        virtual _trt__CreateProfile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__CreateProfile); }
      public:
        /// Constructor with initializations
        _trt__CreateProfile() : Name(), Token(), soap() { }
        virtual ~_trt__CreateProfile() { }
        /// Friend allocator used by soap_new__trt__CreateProfile(struct soap*, int)
        friend SOAP_FMAC1 _trt__CreateProfile * SOAP_FMAC2 soap_instantiate__trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2377 */
#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (828)
/* complex XSD type 'trt:CreateProfileResponse': */
class SOAP_CMAC _trt__CreateProfileResponse {
      public:
        /// Required element 'trt:Profile' of XSD type 'tt:Profile'
        tt__Profile *Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__CreateProfileResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__CreateProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__CreateProfileResponse, default initialized and not managed by a soap context
        virtual _trt__CreateProfileResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__CreateProfileResponse); }
      public:
        /// Constructor with initializations
        _trt__CreateProfileResponse() : Profile(), soap() { }
        virtual ~_trt__CreateProfileResponse() { }
        /// Friend allocator used by soap_new__trt__CreateProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__CreateProfileResponse * SOAP_FMAC2 soap_instantiate__trt__CreateProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2380 */
#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (829)
/* complex XSD type 'trt:GetProfile': */
class SOAP_CMAC _trt__GetProfile {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetProfile
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetProfile, default initialized and not managed by a soap context
        virtual _trt__GetProfile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetProfile); }
      public:
        /// Constructor with initializations
        _trt__GetProfile() : ProfileToken(), soap() { }
        virtual ~_trt__GetProfile() { }
        /// Friend allocator used by soap_new__trt__GetProfile(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetProfile * SOAP_FMAC2 soap_instantiate__trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2383 */
#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (830)
/* complex XSD type 'trt:GetProfileResponse': */
class SOAP_CMAC _trt__GetProfileResponse {
      public:
        /// Required element 'trt:Profile' of XSD type 'tt:Profile'
        tt__Profile *Profile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetProfileResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetProfileResponse, default initialized and not managed by a soap context
        virtual _trt__GetProfileResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetProfileResponse); }
      public:
        /// Constructor with initializations
        _trt__GetProfileResponse() : Profile(), soap() { }
        virtual ~_trt__GetProfileResponse() { }
        /// Friend allocator used by soap_new__trt__GetProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetProfileResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2386 */
#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (831)
/* complex XSD type 'trt:GetProfiles': */
class SOAP_CMAC _trt__GetProfiles {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetProfiles
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetProfiles; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetProfiles, default initialized and not managed by a soap context
        virtual _trt__GetProfiles *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetProfiles); }
      public:
        /// Constructor with initializations
        _trt__GetProfiles() : soap() { }
        virtual ~_trt__GetProfiles() { }
        /// Friend allocator used by soap_new__trt__GetProfiles(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetProfiles * SOAP_FMAC2 soap_instantiate__trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2389 */
#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (832)
/* complex XSD type 'trt:GetProfilesResponse': */
class SOAP_CMAC _trt__GetProfilesResponse {
      public:
        /// Optional element 'trt:Profiles' of XSD type 'tt:Profile'
        std::vector<tt__Profile *> Profiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetProfilesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetProfilesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetProfilesResponse, default initialized and not managed by a soap context
        virtual _trt__GetProfilesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetProfilesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetProfilesResponse() : Profiles(), soap() { }
        virtual ~_trt__GetProfilesResponse() { }
        /// Friend allocator used by soap_new__trt__GetProfilesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetProfilesResponse * SOAP_FMAC2 soap_instantiate__trt__GetProfilesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2392 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (833)
/* complex XSD type 'trt:AddVideoEncoderConfiguration': */
class SOAP_CMAC _trt__AddVideoEncoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddVideoEncoderConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2395 */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (834)
/* complex XSD type 'trt:AddVideoEncoderConfigurationResponse': */
class SOAP_CMAC _trt__AddVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddVideoEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__AddVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2398 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (835)
/* complex XSD type 'trt:RemoveVideoEncoderConfiguration': */
class SOAP_CMAC _trt__RemoveVideoEncoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoEncoderConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2401 */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (836)
/* complex XSD type 'trt:RemoveVideoEncoderConfigurationResponse': */
class SOAP_CMAC _trt__RemoveVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2404 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (837)
/* complex XSD type 'trt:AddVideoSourceConfiguration': */
class SOAP_CMAC _trt__AddVideoSourceConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddVideoSourceConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2407 */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (838)
/* complex XSD type 'trt:AddVideoSourceConfigurationResponse': */
class SOAP_CMAC _trt__AddVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddVideoSourceConfigurationResponse() : soap() { }
        virtual ~_trt__AddVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2410 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (839)
/* complex XSD type 'trt:RemoveVideoSourceConfiguration': */
class SOAP_CMAC _trt__RemoveVideoSourceConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoSourceConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2413 */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (840)
/* complex XSD type 'trt:RemoveVideoSourceConfigurationResponse': */
class SOAP_CMAC _trt__RemoveVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoSourceConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2416 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (841)
/* complex XSD type 'trt:AddAudioEncoderConfiguration': */
class SOAP_CMAC _trt__AddAudioEncoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddAudioEncoderConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2419 */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (842)
/* complex XSD type 'trt:AddAudioEncoderConfigurationResponse': */
class SOAP_CMAC _trt__AddAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddAudioEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__AddAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2422 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (843)
/* complex XSD type 'trt:RemoveAudioEncoderConfiguration': */
class SOAP_CMAC _trt__RemoveAudioEncoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioEncoderConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2425 */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (844)
/* complex XSD type 'trt:RemoveAudioEncoderConfigurationResponse': */
class SOAP_CMAC _trt__RemoveAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2428 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (845)
/* complex XSD type 'trt:AddAudioSourceConfiguration': */
class SOAP_CMAC _trt__AddAudioSourceConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddAudioSourceConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2431 */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (846)
/* complex XSD type 'trt:AddAudioSourceConfigurationResponse': */
class SOAP_CMAC _trt__AddAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddAudioSourceConfigurationResponse() : soap() { }
        virtual ~_trt__AddAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2434 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (847)
/* complex XSD type 'trt:RemoveAudioSourceConfiguration': */
class SOAP_CMAC _trt__RemoveAudioSourceConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioSourceConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2437 */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (848)
/* complex XSD type 'trt:RemoveAudioSourceConfigurationResponse': */
class SOAP_CMAC _trt__RemoveAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioSourceConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2440 */
#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (849)
/* complex XSD type 'trt:AddPTZConfiguration': */
class SOAP_CMAC _trt__AddPTZConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddPTZConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddPTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddPTZConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddPTZConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddPTZConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddPTZConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddPTZConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddPTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2443 */
#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (850)
/* complex XSD type 'trt:AddPTZConfigurationResponse': */
class SOAP_CMAC _trt__AddPTZConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddPTZConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddPTZConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddPTZConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddPTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddPTZConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddPTZConfigurationResponse() : soap() { }
        virtual ~_trt__AddPTZConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddPTZConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddPTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddPTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2446 */
#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (851)
/* complex XSD type 'trt:RemovePTZConfiguration': */
class SOAP_CMAC _trt__RemovePTZConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemovePTZConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemovePTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemovePTZConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemovePTZConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemovePTZConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemovePTZConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemovePTZConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemovePTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2449 */
#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (852)
/* complex XSD type 'trt:RemovePTZConfigurationResponse': */
class SOAP_CMAC _trt__RemovePTZConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemovePTZConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemovePTZConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemovePTZConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemovePTZConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemovePTZConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemovePTZConfigurationResponse() : soap() { }
        virtual ~_trt__RemovePTZConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemovePTZConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemovePTZConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemovePTZConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2452 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (853)
/* complex XSD type 'trt:AddVideoAnalyticsConfiguration': */
class SOAP_CMAC _trt__AddVideoAnalyticsConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddVideoAnalyticsConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2455 */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (854)
/* complex XSD type 'trt:AddVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _trt__AddVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddVideoAnalyticsConfigurationResponse() : soap() { }
        virtual ~_trt__AddVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2458 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (855)
/* complex XSD type 'trt:RemoveVideoAnalyticsConfiguration': */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoAnalyticsConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2461 */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (856)
/* complex XSD type 'trt:RemoveVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _trt__RemoveVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveVideoAnalyticsConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2464 */
#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (857)
/* complex XSD type 'trt:AddMetadataConfiguration': */
class SOAP_CMAC _trt__AddMetadataConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddMetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddMetadataConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddMetadataConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddMetadataConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2467 */
#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (858)
/* complex XSD type 'trt:AddMetadataConfigurationResponse': */
class SOAP_CMAC _trt__AddMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddMetadataConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddMetadataConfigurationResponse() : soap() { }
        virtual ~_trt__AddMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2470 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (859)
/* complex XSD type 'trt:RemoveMetadataConfiguration': */
class SOAP_CMAC _trt__RemoveMetadataConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveMetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveMetadataConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveMetadataConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveMetadataConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2473 */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (860)
/* complex XSD type 'trt:RemoveMetadataConfigurationResponse': */
class SOAP_CMAC _trt__RemoveMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveMetadataConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2476 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfiguration
#define SOAP_TYPE__trt__AddAudioOutputConfiguration (861)
/* complex XSD type 'trt:AddAudioOutputConfiguration': */
class SOAP_CMAC _trt__AddAudioOutputConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddAudioOutputConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2479 */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (862)
/* complex XSD type 'trt:AddAudioOutputConfigurationResponse': */
class SOAP_CMAC _trt__AddAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddAudioOutputConfigurationResponse() : soap() { }
        virtual ~_trt__AddAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2482 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE__trt__RemoveAudioOutputConfiguration (863)
/* complex XSD type 'trt:RemoveAudioOutputConfiguration': */
class SOAP_CMAC _trt__RemoveAudioOutputConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioOutputConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2485 */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (864)
/* complex XSD type 'trt:RemoveAudioOutputConfigurationResponse': */
class SOAP_CMAC _trt__RemoveAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioOutputConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2488 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfiguration
#define SOAP_TYPE__trt__AddAudioDecoderConfiguration (865)
/* complex XSD type 'trt:AddAudioDecoderConfiguration': */
class SOAP_CMAC _trt__AddAudioDecoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__AddAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__AddAudioDecoderConfiguration() : ProfileToken(), ConfigurationToken(), soap() { }
        virtual ~_trt__AddAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__AddAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2491 */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (866)
/* complex XSD type 'trt:AddAudioDecoderConfigurationResponse': */
class SOAP_CMAC _trt__AddAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__AddAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__AddAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__AddAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__AddAudioDecoderConfigurationResponse() : soap() { }
        virtual ~_trt__AddAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__AddAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__AddAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__AddAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2494 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (867)
/* complex XSD type 'trt:RemoveAudioDecoderConfiguration': */
class SOAP_CMAC _trt__RemoveAudioDecoderConfiguration {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioDecoderConfiguration() : ProfileToken(), soap() { }
        virtual ~_trt__RemoveAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2497 */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (868)
/* complex XSD type 'trt:RemoveAudioDecoderConfigurationResponse': */
class SOAP_CMAC _trt__RemoveAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__RemoveAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__RemoveAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__RemoveAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__RemoveAudioDecoderConfigurationResponse() : soap() { }
        virtual ~_trt__RemoveAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__RemoveAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__RemoveAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__RemoveAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2500 */
#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (869)
/* complex XSD type 'trt:DeleteProfile': */
class SOAP_CMAC _trt__DeleteProfile {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__DeleteProfile
        virtual long soap_type(void) const { return SOAP_TYPE__trt__DeleteProfile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__DeleteProfile, default initialized and not managed by a soap context
        virtual _trt__DeleteProfile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__DeleteProfile); }
      public:
        /// Constructor with initializations
        _trt__DeleteProfile() : ProfileToken(), soap() { }
        virtual ~_trt__DeleteProfile() { }
        /// Friend allocator used by soap_new__trt__DeleteProfile(struct soap*, int)
        friend SOAP_FMAC1 _trt__DeleteProfile * SOAP_FMAC2 soap_instantiate__trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2503 */
#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (870)
/* complex XSD type 'trt:DeleteProfileResponse': */
class SOAP_CMAC _trt__DeleteProfileResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__DeleteProfileResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__DeleteProfileResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__DeleteProfileResponse, default initialized and not managed by a soap context
        virtual _trt__DeleteProfileResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__DeleteProfileResponse); }
      public:
        /// Constructor with initializations
        _trt__DeleteProfileResponse() : soap() { }
        virtual ~_trt__DeleteProfileResponse() { }
        /// Friend allocator used by soap_new__trt__DeleteProfileResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__DeleteProfileResponse * SOAP_FMAC2 soap_instantiate__trt__DeleteProfileResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2506 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (871)
/* complex XSD type 'trt:GetVideoEncoderConfigurations': */
class SOAP_CMAC _trt__GetVideoEncoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfigurations() : soap() { }
        virtual ~_trt__GetVideoEncoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2509 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (872)
/* complex XSD type 'trt:GetVideoEncoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoEncoderConfiguration'
        std::vector<tt__VideoEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetVideoEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2512 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (873)
/* complex XSD type 'trt:GetVideoSourceConfigurations': */
class SOAP_CMAC _trt__GetVideoSourceConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfigurations() : soap() { }
        virtual ~_trt__GetVideoSourceConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2515 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (874)
/* complex XSD type 'trt:GetVideoSourceConfigurationsResponse': */
class SOAP_CMAC _trt__GetVideoSourceConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoSourceConfiguration'
        std::vector<tt__VideoSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetVideoSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2518 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (875)
/* complex XSD type 'trt:GetAudioEncoderConfigurations': */
class SOAP_CMAC _trt__GetAudioEncoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfigurations() : soap() { }
        virtual ~_trt__GetAudioEncoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2521 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (876)
/* complex XSD type 'trt:GetAudioEncoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioEncoderConfiguration'
        std::vector<tt__AudioEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetAudioEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2524 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (877)
/* complex XSD type 'trt:GetAudioSourceConfigurations': */
class SOAP_CMAC _trt__GetAudioSourceConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfigurations() : soap() { }
        virtual ~_trt__GetAudioSourceConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2527 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (878)
/* complex XSD type 'trt:GetAudioSourceConfigurationsResponse': */
class SOAP_CMAC _trt__GetAudioSourceConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioSourceConfiguration'
        std::vector<tt__AudioSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetAudioSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2530 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (879)
/* complex XSD type 'trt:GetVideoAnalyticsConfigurations': */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoAnalyticsConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoAnalyticsConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoAnalyticsConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetVideoAnalyticsConfigurations() : soap() { }
        virtual ~_trt__GetVideoAnalyticsConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetVideoAnalyticsConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2533 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (880)
/* complex XSD type 'trt:GetVideoAnalyticsConfigurationsResponse': */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoAnalyticsConfiguration'
        std::vector<tt__VideoAnalyticsConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoAnalyticsConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoAnalyticsConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetVideoAnalyticsConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoAnalyticsConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2536 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (881)
/* complex XSD type 'trt:GetMetadataConfigurations': */
class SOAP_CMAC _trt__GetMetadataConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfigurations() : soap() { }
        virtual ~_trt__GetMetadataConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2539 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (882)
/* complex XSD type 'trt:GetMetadataConfigurationsResponse': */
class SOAP_CMAC _trt__GetMetadataConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:MetadataConfiguration'
        std::vector<tt__MetadataConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetMetadataConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2542 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurations
#define SOAP_TYPE__trt__GetAudioOutputConfigurations (883)
/* complex XSD type 'trt:GetAudioOutputConfigurations': */
class SOAP_CMAC _trt__GetAudioOutputConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfigurations() : soap() { }
        virtual ~_trt__GetAudioOutputConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2545 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (884)
/* complex XSD type 'trt:GetAudioOutputConfigurationsResponse': */
class SOAP_CMAC _trt__GetAudioOutputConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioOutputConfiguration'
        std::vector<tt__AudioOutputConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetAudioOutputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2548 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetAudioDecoderConfigurations (885)
/* complex XSD type 'trt:GetAudioDecoderConfigurations': */
class SOAP_CMAC _trt__GetAudioDecoderConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfigurations() : soap() { }
        virtual ~_trt__GetAudioDecoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2551 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (886)
/* complex XSD type 'trt:GetAudioDecoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioDecoderConfiguration'
        std::vector<tt__AudioDecoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetAudioDecoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2554 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (887)
/* complex XSD type 'trt:GetVideoSourceConfiguration': */
class SOAP_CMAC _trt__GetVideoSourceConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2557 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (888)
/* complex XSD type 'trt:GetVideoSourceConfigurationResponse': */
class SOAP_CMAC _trt__GetVideoSourceConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2560 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (889)
/* complex XSD type 'trt:GetVideoEncoderConfiguration': */
class SOAP_CMAC _trt__GetVideoEncoderConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2563 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (890)
/* complex XSD type 'trt:GetVideoEncoderConfigurationResponse': */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoEncoderConfiguration'
        tt__VideoEncoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2566 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (891)
/* complex XSD type 'trt:GetAudioSourceConfiguration': */
class SOAP_CMAC _trt__GetAudioSourceConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2569 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (892)
/* complex XSD type 'trt:GetAudioSourceConfigurationResponse': */
class SOAP_CMAC _trt__GetAudioSourceConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2572 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (893)
/* complex XSD type 'trt:GetAudioEncoderConfiguration': */
class SOAP_CMAC _trt__GetAudioEncoderConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2575 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (894)
/* complex XSD type 'trt:GetAudioEncoderConfigurationResponse': */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioEncoderConfiguration'
        tt__AudioEncoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2578 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (895)
/* complex XSD type 'trt:GetVideoAnalyticsConfiguration': */
class SOAP_CMAC _trt__GetVideoAnalyticsConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetVideoAnalyticsConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2581 */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (896)
/* complex XSD type 'trt:GetVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _trt__GetVideoAnalyticsConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoAnalyticsConfiguration'
        tt__VideoAnalyticsConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoAnalyticsConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2584 */
#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (897)
/* complex XSD type 'trt:GetMetadataConfiguration': */
class SOAP_CMAC _trt__GetMetadataConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetMetadataConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2587 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (898)
/* complex XSD type 'trt:GetMetadataConfigurationResponse': */
class SOAP_CMAC _trt__GetMetadataConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:MetadataConfiguration'
        tt__MetadataConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2590 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfiguration
#define SOAP_TYPE__trt__GetAudioOutputConfiguration (899)
/* complex XSD type 'trt:GetAudioOutputConfiguration': */
class SOAP_CMAC _trt__GetAudioOutputConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2593 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (900)
/* complex XSD type 'trt:GetAudioOutputConfigurationResponse': */
class SOAP_CMAC _trt__GetAudioOutputConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2596 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfiguration
#define SOAP_TYPE__trt__GetAudioDecoderConfiguration (901)
/* complex XSD type 'trt:GetAudioDecoderConfiguration': */
class SOAP_CMAC _trt__GetAudioDecoderConfiguration {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfiguration() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2599 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (902)
/* complex XSD type 'trt:GetAudioDecoderConfigurationResponse': */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationResponse {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioDecoderConfiguration'
        tt__AudioDecoderConfiguration *Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfigurationResponse() : Configuration(), soap() { }
        virtual ~_trt__GetAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2602 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (903)
/* complex XSD type 'trt:GetCompatibleVideoEncoderConfigurations': */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoEncoderConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleVideoEncoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2605 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (904)
/* complex XSD type 'trt:GetCompatibleVideoEncoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleVideoEncoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoEncoderConfiguration'
        std::vector<tt__VideoEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoEncoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleVideoEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2608 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (905)
/* complex XSD type 'trt:GetCompatibleVideoSourceConfigurations': */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoSourceConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoSourceConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoSourceConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoSourceConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleVideoSourceConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2611 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (906)
/* complex XSD type 'trt:GetCompatibleVideoSourceConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleVideoSourceConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoSourceConfiguration'
        std::vector<tt__VideoSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoSourceConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleVideoSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2614 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (907)
/* complex XSD type 'trt:GetCompatibleAudioEncoderConfigurations': */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioEncoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioEncoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioEncoderConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleAudioEncoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2617 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (908)
/* complex XSD type 'trt:GetCompatibleAudioEncoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleAudioEncoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioEncoderConfiguration'
        std::vector<tt__AudioEncoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioEncoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioEncoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioEncoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioEncoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleAudioEncoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioEncoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2620 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (909)
/* complex XSD type 'trt:GetCompatibleAudioSourceConfigurations': */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioSourceConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioSourceConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioSourceConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioSourceConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleAudioSourceConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioSourceConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2623 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (910)
/* complex XSD type 'trt:GetCompatibleAudioSourceConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleAudioSourceConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioSourceConfiguration'
        std::vector<tt__AudioSourceConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioSourceConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioSourceConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioSourceConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioSourceConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleAudioSourceConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioSourceConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2626 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (911)
/* complex XSD type 'trt:GetCompatibleVideoAnalyticsConfigurations': */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoAnalyticsConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoAnalyticsConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoAnalyticsConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleVideoAnalyticsConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2629 */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (912)
/* complex XSD type 'trt:GetCompatibleVideoAnalyticsConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleVideoAnalyticsConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:VideoAnalyticsConfiguration'
        std::vector<tt__VideoAnalyticsConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleVideoAnalyticsConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleVideoAnalyticsConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleVideoAnalyticsConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2632 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (913)
/* complex XSD type 'trt:GetCompatibleMetadataConfigurations': */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleMetadataConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleMetadataConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleMetadataConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleMetadataConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleMetadataConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleMetadataConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleMetadataConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2635 */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (914)
/* complex XSD type 'trt:GetCompatibleMetadataConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleMetadataConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:MetadataConfiguration'
        std::vector<tt__MetadataConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleMetadataConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleMetadataConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleMetadataConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleMetadataConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleMetadataConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleMetadataConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleMetadataConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleMetadataConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2638 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (915)
/* complex XSD type 'trt:GetCompatibleAudioOutputConfigurations': */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioOutputConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioOutputConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioOutputConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioOutputConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleAudioOutputConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioOutputConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2641 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (916)
/* complex XSD type 'trt:GetCompatibleAudioOutputConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleAudioOutputConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioOutputConfiguration'
        std::vector<tt__AudioOutputConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioOutputConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioOutputConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioOutputConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioOutputConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleAudioOutputConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioOutputConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2644 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (917)
/* complex XSD type 'trt:GetCompatibleAudioDecoderConfigurations': */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurations {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurations, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioDecoderConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioDecoderConfigurations); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioDecoderConfigurations() : ProfileToken(), soap() { }
        virtual ~_trt__GetCompatibleAudioDecoderConfigurations() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2647 */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (918)
/* complex XSD type 'trt:GetCompatibleAudioDecoderConfigurationsResponse': */
class SOAP_CMAC _trt__GetCompatibleAudioDecoderConfigurationsResponse {
      public:
        /// Optional element 'trt:Configurations' of XSD type 'tt:AudioDecoderConfiguration'
        std::vector<tt__AudioDecoderConfiguration *> Configurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetCompatibleAudioDecoderConfigurationsResponse, default initialized and not managed by a soap context
        virtual _trt__GetCompatibleAudioDecoderConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetCompatibleAudioDecoderConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetCompatibleAudioDecoderConfigurationsResponse() : Configurations(), soap() { }
        virtual ~_trt__GetCompatibleAudioDecoderConfigurationsResponse() { }
        /// Friend allocator used by soap_new__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetCompatibleAudioDecoderConfigurationsResponse * SOAP_FMAC2 soap_instantiate__trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2650 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (919)
/* complex XSD type 'trt:SetVideoEncoderConfiguration': */
class SOAP_CMAC _trt__SetVideoEncoderConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoEncoderConfiguration'
        tt__VideoEncoderConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetVideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetVideoEncoderConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetVideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetVideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2653 */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (920)
/* complex XSD type 'trt:SetVideoEncoderConfigurationResponse': */
class SOAP_CMAC _trt__SetVideoEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetVideoEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetVideoEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__SetVideoEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetVideoEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2656 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (921)
/* complex XSD type 'trt:SetVideoSourceConfiguration': */
class SOAP_CMAC _trt__SetVideoSourceConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetVideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetVideoSourceConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetVideoSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetVideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2659 */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (922)
/* complex XSD type 'trt:SetVideoSourceConfigurationResponse': */
class SOAP_CMAC _trt__SetVideoSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetVideoSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetVideoSourceConfigurationResponse() : soap() { }
        virtual ~_trt__SetVideoSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetVideoSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2662 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (923)
/* complex XSD type 'trt:SetAudioEncoderConfiguration': */
class SOAP_CMAC _trt__SetAudioEncoderConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioEncoderConfiguration'
        tt__AudioEncoderConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetAudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetAudioEncoderConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetAudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetAudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2665 */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (924)
/* complex XSD type 'trt:SetAudioEncoderConfigurationResponse': */
class SOAP_CMAC _trt__SetAudioEncoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioEncoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetAudioEncoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioEncoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetAudioEncoderConfigurationResponse() : soap() { }
        virtual ~_trt__SetAudioEncoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetAudioEncoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioEncoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioEncoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2668 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (925)
/* complex XSD type 'trt:SetAudioSourceConfiguration': */
class SOAP_CMAC _trt__SetAudioSourceConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioSourceConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetAudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetAudioSourceConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetAudioSourceConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetAudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2671 */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (926)
/* complex XSD type 'trt:SetAudioSourceConfigurationResponse': */
class SOAP_CMAC _trt__SetAudioSourceConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioSourceConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioSourceConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetAudioSourceConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioSourceConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetAudioSourceConfigurationResponse() : soap() { }
        virtual ~_trt__SetAudioSourceConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetAudioSourceConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioSourceConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioSourceConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2674 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (927)
/* complex XSD type 'trt:SetVideoAnalyticsConfiguration': */
class SOAP_CMAC _trt__SetVideoAnalyticsConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:VideoAnalyticsConfiguration'
        tt__VideoAnalyticsConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetVideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetVideoAnalyticsConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetVideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetVideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2677 */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (928)
/* complex XSD type 'trt:SetVideoAnalyticsConfigurationResponse': */
class SOAP_CMAC _trt__SetVideoAnalyticsConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoAnalyticsConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetVideoAnalyticsConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoAnalyticsConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetVideoAnalyticsConfigurationResponse() : soap() { }
        virtual ~_trt__SetVideoAnalyticsConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetVideoAnalyticsConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoAnalyticsConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoAnalyticsConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2680 */
#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (929)
/* complex XSD type 'trt:SetMetadataConfiguration': */
class SOAP_CMAC _trt__SetMetadataConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:MetadataConfiguration'
        tt__MetadataConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetMetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetMetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetMetadataConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetMetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetMetadataConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetMetadataConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetMetadataConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetMetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2683 */
#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (930)
/* complex XSD type 'trt:SetMetadataConfigurationResponse': */
class SOAP_CMAC _trt__SetMetadataConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetMetadataConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetMetadataConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetMetadataConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetMetadataConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetMetadataConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetMetadataConfigurationResponse() : soap() { }
        virtual ~_trt__SetMetadataConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetMetadataConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetMetadataConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetMetadataConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2686 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfiguration
#define SOAP_TYPE__trt__SetAudioOutputConfiguration (931)
/* complex XSD type 'trt:SetAudioOutputConfiguration': */
class SOAP_CMAC _trt__SetAudioOutputConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioOutputConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetAudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetAudioOutputConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetAudioOutputConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetAudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2689 */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (932)
/* complex XSD type 'trt:SetAudioOutputConfigurationResponse': */
class SOAP_CMAC _trt__SetAudioOutputConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioOutputConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioOutputConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetAudioOutputConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioOutputConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetAudioOutputConfigurationResponse() : soap() { }
        virtual ~_trt__SetAudioOutputConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetAudioOutputConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioOutputConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioOutputConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2692 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfiguration
#define SOAP_TYPE__trt__SetAudioDecoderConfiguration (933)
/* complex XSD type 'trt:SetAudioDecoderConfiguration': */
class SOAP_CMAC _trt__SetAudioDecoderConfiguration {
      public:
        /// Required element 'trt:Configuration' of XSD type 'tt:AudioDecoderConfiguration'
        tt__AudioDecoderConfiguration *Configuration;
        /// Required element 'trt:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual _trt__SetAudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        _trt__SetAudioDecoderConfiguration() : Configuration(), ForcePersistence(), soap() { }
        virtual ~_trt__SetAudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new__trt__SetAudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2695 */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (934)
/* complex XSD type 'trt:SetAudioDecoderConfigurationResponse': */
class SOAP_CMAC _trt__SetAudioDecoderConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetAudioDecoderConfigurationResponse, default initialized and not managed by a soap context
        virtual _trt__SetAudioDecoderConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetAudioDecoderConfigurationResponse); }
      public:
        /// Constructor with initializations
        _trt__SetAudioDecoderConfigurationResponse() : soap() { }
        virtual ~_trt__SetAudioDecoderConfigurationResponse() { }
        /// Friend allocator used by soap_new__trt__SetAudioDecoderConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetAudioDecoderConfigurationResponse * SOAP_FMAC2 soap_instantiate__trt__SetAudioDecoderConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2698 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (935)
/* complex XSD type 'trt:GetVideoSourceConfigurationOptions': */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetVideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2701 */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (936)
/* complex XSD type 'trt:GetVideoSourceConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetVideoSourceConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:VideoSourceConfigurationOptions'
        tt__VideoSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetVideoSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2704 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (937)
/* complex XSD type 'trt:GetVideoEncoderConfigurationOptions': */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetVideoEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2707 */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (938)
/* complex XSD type 'trt:GetVideoEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetVideoEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:VideoEncoderConfigurationOptions'
        tt__VideoEncoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoEncoderConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetVideoEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2710 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (939)
/* complex XSD type 'trt:GetAudioSourceConfigurationOptions': */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetAudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2713 */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (940)
/* complex XSD type 'trt:GetAudioSourceConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetAudioSourceConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:AudioSourceConfigurationOptions'
        tt__AudioSourceConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioSourceConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioSourceConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioSourceConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioSourceConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetAudioSourceConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioSourceConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioSourceConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioSourceConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2716 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (941)
/* complex XSD type 'trt:GetAudioEncoderConfigurationOptions': */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetAudioEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2719 */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (942)
/* complex XSD type 'trt:GetAudioEncoderConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetAudioEncoderConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:AudioEncoderConfigurationOptions'
        tt__AudioEncoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioEncoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioEncoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioEncoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioEncoderConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetAudioEncoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioEncoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioEncoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2722 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (943)
/* complex XSD type 'trt:GetMetadataConfigurationOptions': */
class SOAP_CMAC _trt__GetMetadataConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetMetadataConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2725 */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (944)
/* complex XSD type 'trt:GetMetadataConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetMetadataConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:MetadataConfigurationOptions'
        tt__MetadataConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetMetadataConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetMetadataConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetMetadataConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetMetadataConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetMetadataConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetMetadataConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetMetadataConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetMetadataConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2728 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (945)
/* complex XSD type 'trt:GetAudioOutputConfigurationOptions': */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetAudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2731 */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (946)
/* complex XSD type 'trt:GetAudioOutputConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetAudioOutputConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:AudioOutputConfigurationOptions'
        tt__AudioOutputConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioOutputConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioOutputConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioOutputConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioOutputConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetAudioOutputConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioOutputConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioOutputConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioOutputConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2734 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (947)
/* complex XSD type 'trt:GetAudioDecoderConfigurationOptions': */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptions {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Optional element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string *ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfigurationOptions); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfigurationOptions() : ConfigurationToken(), ProfileToken(), soap() { }
        virtual ~_trt__GetAudioDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2737 */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (948)
/* complex XSD type 'trt:GetAudioDecoderConfigurationOptionsResponse': */
class SOAP_CMAC _trt__GetAudioDecoderConfigurationOptionsResponse {
      public:
        /// Required element 'trt:Options' of XSD type 'tt:AudioDecoderConfigurationOptions'
        tt__AudioDecoderConfigurationOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetAudioDecoderConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetAudioDecoderConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetAudioDecoderConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetAudioDecoderConfigurationOptionsResponse() : Options(), soap() { }
        virtual ~_trt__GetAudioDecoderConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetAudioDecoderConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetAudioDecoderConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2740 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (949)
/* complex XSD type 'trt:GetGuaranteedNumberOfVideoEncoderInstances': */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstances {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstances, default initialized and not managed by a soap context
        virtual _trt__GetGuaranteedNumberOfVideoEncoderInstances *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetGuaranteedNumberOfVideoEncoderInstances); }
      public:
        /// Constructor with initializations
        _trt__GetGuaranteedNumberOfVideoEncoderInstances() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
        /// Friend allocator used by soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2743 */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (950)
/* complex XSD type 'trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse': */
class SOAP_CMAC _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse {
      public:
        /// Required element 'trt:TotalNumber' of XSD type 'xsd:int'
        int TotalNumber;
        /// Optional element 'trt:JPEG' of XSD type 'xsd:int'
        int *JPEG;
        /// Optional element 'trt:H264' of XSD type 'xsd:int'
        int *H264;
        /// Optional element 'trt:MPEG4' of XSD type 'xsd:int'
        int *MPEG4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, default initialized and not managed by a soap context
        virtual _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() : TotalNumber(), JPEG(), H264(), MPEG4(), soap() { }
        virtual ~_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
        /// Friend allocator used by soap_new__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse * SOAP_FMAC2 soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2746 */
#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (951)
/* complex XSD type 'trt:GetStreamUri': */
class SOAP_CMAC _trt__GetStreamUri {
      public:
        /// Required element 'trt:StreamSetup' of XSD type 'tt:StreamSetup'
        tt__StreamSetup *StreamSetup;
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetStreamUri
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetStreamUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetStreamUri, default initialized and not managed by a soap context
        virtual _trt__GetStreamUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetStreamUri); }
      public:
        /// Constructor with initializations
        _trt__GetStreamUri() : StreamSetup(), ProfileToken(), soap() { }
        virtual ~_trt__GetStreamUri() { }
        /// Friend allocator used by soap_new__trt__GetStreamUri(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetStreamUri * SOAP_FMAC2 soap_instantiate__trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2749 */
#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (952)
/* complex XSD type 'trt:GetStreamUriResponse': */
class SOAP_CMAC _trt__GetStreamUriResponse {
      public:
        /// Required element 'trt:MediaUri' of XSD type 'tt:MediaUri'
        tt__MediaUri *MediaUri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetStreamUriResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetStreamUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetStreamUriResponse, default initialized and not managed by a soap context
        virtual _trt__GetStreamUriResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetStreamUriResponse); }
      public:
        /// Constructor with initializations
        _trt__GetStreamUriResponse() : MediaUri(), soap() { }
        virtual ~_trt__GetStreamUriResponse() { }
        /// Friend allocator used by soap_new__trt__GetStreamUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetStreamUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetStreamUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2752 */
#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (953)
/* complex XSD type 'trt:StartMulticastStreaming': */
class SOAP_CMAC _trt__StartMulticastStreaming {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__StartMulticastStreaming
        virtual long soap_type(void) const { return SOAP_TYPE__trt__StartMulticastStreaming; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__StartMulticastStreaming, default initialized and not managed by a soap context
        virtual _trt__StartMulticastStreaming *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__StartMulticastStreaming); }
      public:
        /// Constructor with initializations
        _trt__StartMulticastStreaming() : ProfileToken(), soap() { }
        virtual ~_trt__StartMulticastStreaming() { }
        /// Friend allocator used by soap_new__trt__StartMulticastStreaming(struct soap*, int)
        friend SOAP_FMAC1 _trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2755 */
#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (954)
/* complex XSD type 'trt:StartMulticastStreamingResponse': */
class SOAP_CMAC _trt__StartMulticastStreamingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__StartMulticastStreamingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__StartMulticastStreamingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__StartMulticastStreamingResponse, default initialized and not managed by a soap context
        virtual _trt__StartMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__StartMulticastStreamingResponse); }
      public:
        /// Constructor with initializations
        _trt__StartMulticastStreamingResponse() : soap() { }
        virtual ~_trt__StartMulticastStreamingResponse() { }
        /// Friend allocator used by soap_new__trt__StartMulticastStreamingResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__StartMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StartMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2758 */
#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (955)
/* complex XSD type 'trt:StopMulticastStreaming': */
class SOAP_CMAC _trt__StopMulticastStreaming {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__StopMulticastStreaming
        virtual long soap_type(void) const { return SOAP_TYPE__trt__StopMulticastStreaming; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__StopMulticastStreaming, default initialized and not managed by a soap context
        virtual _trt__StopMulticastStreaming *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__StopMulticastStreaming); }
      public:
        /// Constructor with initializations
        _trt__StopMulticastStreaming() : ProfileToken(), soap() { }
        virtual ~_trt__StopMulticastStreaming() { }
        /// Friend allocator used by soap_new__trt__StopMulticastStreaming(struct soap*, int)
        friend SOAP_FMAC1 _trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2761 */
#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (956)
/* complex XSD type 'trt:StopMulticastStreamingResponse': */
class SOAP_CMAC _trt__StopMulticastStreamingResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__StopMulticastStreamingResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__StopMulticastStreamingResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__StopMulticastStreamingResponse, default initialized and not managed by a soap context
        virtual _trt__StopMulticastStreamingResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__StopMulticastStreamingResponse); }
      public:
        /// Constructor with initializations
        _trt__StopMulticastStreamingResponse() : soap() { }
        virtual ~_trt__StopMulticastStreamingResponse() { }
        /// Friend allocator used by soap_new__trt__StopMulticastStreamingResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__StopMulticastStreamingResponse * SOAP_FMAC2 soap_instantiate__trt__StopMulticastStreamingResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2764 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (957)
/* complex XSD type 'trt:SetSynchronizationPoint': */
class SOAP_CMAC _trt__SetSynchronizationPoint {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetSynchronizationPoint
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetSynchronizationPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetSynchronizationPoint, default initialized and not managed by a soap context
        virtual _trt__SetSynchronizationPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetSynchronizationPoint); }
      public:
        /// Constructor with initializations
        _trt__SetSynchronizationPoint() : ProfileToken(), soap() { }
        virtual ~_trt__SetSynchronizationPoint() { }
        /// Friend allocator used by soap_new__trt__SetSynchronizationPoint(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2767 */
#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (958)
/* complex XSD type 'trt:SetSynchronizationPointResponse': */
class SOAP_CMAC _trt__SetSynchronizationPointResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetSynchronizationPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetSynchronizationPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetSynchronizationPointResponse, default initialized and not managed by a soap context
        virtual _trt__SetSynchronizationPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetSynchronizationPointResponse); }
      public:
        /// Constructor with initializations
        _trt__SetSynchronizationPointResponse() : soap() { }
        virtual ~_trt__SetSynchronizationPointResponse() { }
        /// Friend allocator used by soap_new__trt__SetSynchronizationPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetSynchronizationPointResponse * SOAP_FMAC2 soap_instantiate__trt__SetSynchronizationPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2770 */
#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (959)
/* complex XSD type 'trt:GetSnapshotUri': */
class SOAP_CMAC _trt__GetSnapshotUri {
      public:
        /// Required element 'trt:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetSnapshotUri
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetSnapshotUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetSnapshotUri, default initialized and not managed by a soap context
        virtual _trt__GetSnapshotUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetSnapshotUri); }
      public:
        /// Constructor with initializations
        _trt__GetSnapshotUri() : ProfileToken(), soap() { }
        virtual ~_trt__GetSnapshotUri() { }
        /// Friend allocator used by soap_new__trt__GetSnapshotUri(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2773 */
#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (960)
/* complex XSD type 'trt:GetSnapshotUriResponse': */
class SOAP_CMAC _trt__GetSnapshotUriResponse {
      public:
        /// Required element 'trt:MediaUri' of XSD type 'tt:MediaUri'
        tt__MediaUri *MediaUri;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetSnapshotUriResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetSnapshotUriResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetSnapshotUriResponse, default initialized and not managed by a soap context
        virtual _trt__GetSnapshotUriResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetSnapshotUriResponse); }
      public:
        /// Constructor with initializations
        _trt__GetSnapshotUriResponse() : MediaUri(), soap() { }
        virtual ~_trt__GetSnapshotUriResponse() { }
        /// Friend allocator used by soap_new__trt__GetSnapshotUriResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetSnapshotUriResponse * SOAP_FMAC2 soap_instantiate__trt__GetSnapshotUriResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2776 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModes
#define SOAP_TYPE__trt__GetVideoSourceModes (961)
/* complex XSD type 'trt:GetVideoSourceModes': */
class SOAP_CMAC _trt__GetVideoSourceModes {
      public:
        /// Required element 'trt:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceModes
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceModes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceModes, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceModes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceModes); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceModes() : VideoSourceToken(), soap() { }
        virtual ~_trt__GetVideoSourceModes() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceModes(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2779 */
#ifndef SOAP_TYPE__trt__GetVideoSourceModesResponse
#define SOAP_TYPE__trt__GetVideoSourceModesResponse (962)
/* complex XSD type 'trt:GetVideoSourceModesResponse': */
class SOAP_CMAC _trt__GetVideoSourceModesResponse {
      public:
        /// Required element 'trt:VideoSourceModes' of XSD type 'trt:VideoSourceMode'
        std::vector<trt__VideoSourceMode *> VideoSourceModes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetVideoSourceModesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetVideoSourceModesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetVideoSourceModesResponse, default initialized and not managed by a soap context
        virtual _trt__GetVideoSourceModesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetVideoSourceModesResponse); }
      public:
        /// Constructor with initializations
        _trt__GetVideoSourceModesResponse() : VideoSourceModes(), soap() { }
        virtual ~_trt__GetVideoSourceModesResponse() { }
        /// Friend allocator used by soap_new__trt__GetVideoSourceModesResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetVideoSourceModesResponse * SOAP_FMAC2 soap_instantiate__trt__GetVideoSourceModesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2782 */
#ifndef SOAP_TYPE__trt__SetVideoSourceMode
#define SOAP_TYPE__trt__SetVideoSourceMode (963)
/* complex XSD type 'trt:SetVideoSourceMode': */
class SOAP_CMAC _trt__SetVideoSourceMode {
      public:
        /// Required element 'trt:VideoSourceToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceToken;
        /// Required element 'trt:VideoSourceModeToken' of XSD type 'tt:ReferenceToken'
        std::string VideoSourceModeToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoSourceMode
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoSourceMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoSourceMode, default initialized and not managed by a soap context
        virtual _trt__SetVideoSourceMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoSourceMode); }
      public:
        /// Constructor with initializations
        _trt__SetVideoSourceMode() : VideoSourceToken(), VideoSourceModeToken(), soap() { }
        virtual ~_trt__SetVideoSourceMode() { }
        /// Friend allocator used by soap_new__trt__SetVideoSourceMode(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2785 */
#ifndef SOAP_TYPE__trt__SetVideoSourceModeResponse
#define SOAP_TYPE__trt__SetVideoSourceModeResponse (964)
/* complex XSD type 'trt:SetVideoSourceModeResponse': */
class SOAP_CMAC _trt__SetVideoSourceModeResponse {
      public:
        /// Required element 'trt:Reboot' of XSD type 'xsd:boolean'
        bool Reboot;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetVideoSourceModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetVideoSourceModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetVideoSourceModeResponse, default initialized and not managed by a soap context
        virtual _trt__SetVideoSourceModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetVideoSourceModeResponse); }
      public:
        /// Constructor with initializations
        _trt__SetVideoSourceModeResponse() : Reboot(), soap() { }
        virtual ~_trt__SetVideoSourceModeResponse() { }
        /// Friend allocator used by soap_new__trt__SetVideoSourceModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetVideoSourceModeResponse * SOAP_FMAC2 soap_instantiate__trt__SetVideoSourceModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2788 */
#ifndef SOAP_TYPE__trt__GetOSDs
#define SOAP_TYPE__trt__GetOSDs (965)
/* complex XSD type 'trt:GetOSDs': */
class SOAP_CMAC _trt__GetOSDs {
      public:
        /// Optional element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string *ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSDs
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSDs, default initialized and not managed by a soap context
        virtual _trt__GetOSDs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSDs); }
      public:
        /// Constructor with initializations
        _trt__GetOSDs() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetOSDs() { }
        /// Friend allocator used by soap_new__trt__GetOSDs(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSDs * SOAP_FMAC2 soap_instantiate__trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2791 */
#ifndef SOAP_TYPE__trt__GetOSDsResponse
#define SOAP_TYPE__trt__GetOSDsResponse (966)
/* complex XSD type 'trt:GetOSDsResponse': */
class SOAP_CMAC _trt__GetOSDsResponse {
      public:
        /// Optional element 'trt:OSDs' of XSD type 'tt:OSDConfiguration'
        std::vector<tt__OSDConfiguration *> OSDs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSDsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSDsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSDsResponse, default initialized and not managed by a soap context
        virtual _trt__GetOSDsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSDsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetOSDsResponse() : OSDs(), soap() { }
        virtual ~_trt__GetOSDsResponse() { }
        /// Friend allocator used by soap_new__trt__GetOSDsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSDsResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2794 */
#ifndef SOAP_TYPE__trt__GetOSD
#define SOAP_TYPE__trt__GetOSD (967)
/* complex XSD type 'trt:GetOSD': */
class SOAP_CMAC _trt__GetOSD {
      public:
        /// Required element 'trt:OSDToken' of XSD type 'tt:ReferenceToken'
        std::string OSDToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSD
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSD, default initialized and not managed by a soap context
        virtual _trt__GetOSD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSD); }
      public:
        /// Constructor with initializations
        _trt__GetOSD() : OSDToken(), soap() { }
        virtual ~_trt__GetOSD() { }
        /// Friend allocator used by soap_new__trt__GetOSD(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSD * SOAP_FMAC2 soap_instantiate__trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2797 */
#ifndef SOAP_TYPE__trt__GetOSDResponse
#define SOAP_TYPE__trt__GetOSDResponse (968)
/* complex XSD type 'trt:GetOSDResponse': */
class SOAP_CMAC _trt__GetOSDResponse {
      public:
        /// Required element 'trt:OSD' of XSD type 'tt:OSDConfiguration'
        tt__OSDConfiguration *OSD;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSDResponse, default initialized and not managed by a soap context
        virtual _trt__GetOSDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSDResponse); }
      public:
        /// Constructor with initializations
        _trt__GetOSDResponse() : OSD(), soap() { }
        virtual ~_trt__GetOSDResponse() { }
        /// Friend allocator used by soap_new__trt__GetOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSDResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2800 */
#ifndef SOAP_TYPE__trt__SetOSD
#define SOAP_TYPE__trt__SetOSD (969)
/* complex XSD type 'trt:SetOSD': */
class SOAP_CMAC _trt__SetOSD {
      public:
        /// Required element 'trt:OSD' of XSD type 'tt:OSDConfiguration'
        tt__OSDConfiguration *OSD;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetOSD
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetOSD, default initialized and not managed by a soap context
        virtual _trt__SetOSD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetOSD); }
      public:
        /// Constructor with initializations
        _trt__SetOSD() : OSD(), soap() { }
        virtual ~_trt__SetOSD() { }
        /// Friend allocator used by soap_new__trt__SetOSD(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetOSD * SOAP_FMAC2 soap_instantiate__trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2803 */
#ifndef SOAP_TYPE__trt__SetOSDResponse
#define SOAP_TYPE__trt__SetOSDResponse (970)
/* complex XSD type 'trt:SetOSDResponse': */
class SOAP_CMAC _trt__SetOSDResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__SetOSDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__SetOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__SetOSDResponse, default initialized and not managed by a soap context
        virtual _trt__SetOSDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__SetOSDResponse); }
      public:
        /// Constructor with initializations
        _trt__SetOSDResponse() : soap() { }
        virtual ~_trt__SetOSDResponse() { }
        /// Friend allocator used by soap_new__trt__SetOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__SetOSDResponse * SOAP_FMAC2 soap_instantiate__trt__SetOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2806 */
#ifndef SOAP_TYPE__trt__GetOSDOptions
#define SOAP_TYPE__trt__GetOSDOptions (971)
/* complex XSD type 'trt:GetOSDOptions': */
class SOAP_CMAC _trt__GetOSDOptions {
      public:
        /// Required element 'trt:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSDOptions
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSDOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSDOptions, default initialized and not managed by a soap context
        virtual _trt__GetOSDOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSDOptions); }
      public:
        /// Constructor with initializations
        _trt__GetOSDOptions() : ConfigurationToken(), soap() { }
        virtual ~_trt__GetOSDOptions() { }
        /// Friend allocator used by soap_new__trt__GetOSDOptions(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSDOptions * SOAP_FMAC2 soap_instantiate__trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2809 */
#ifndef SOAP_TYPE__trt__GetOSDOptionsResponse
#define SOAP_TYPE__trt__GetOSDOptionsResponse (972)
/* complex XSD type 'trt:GetOSDOptionsResponse': */
class SOAP_CMAC _trt__GetOSDOptionsResponse {
      public:
        /// Required element 'trt:OSDOptions' of XSD type 'tt:OSDConfigurationOptions'
        tt__OSDConfigurationOptions *OSDOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__GetOSDOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__GetOSDOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__GetOSDOptionsResponse, default initialized and not managed by a soap context
        virtual _trt__GetOSDOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__GetOSDOptionsResponse); }
      public:
        /// Constructor with initializations
        _trt__GetOSDOptionsResponse() : OSDOptions(), soap() { }
        virtual ~_trt__GetOSDOptionsResponse() { }
        /// Friend allocator used by soap_new__trt__GetOSDOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__GetOSDOptionsResponse * SOAP_FMAC2 soap_instantiate__trt__GetOSDOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2812 */
#ifndef SOAP_TYPE__trt__CreateOSD
#define SOAP_TYPE__trt__CreateOSD (973)
/* complex XSD type 'trt:CreateOSD': */
class SOAP_CMAC _trt__CreateOSD {
      public:
        /// Required element 'trt:OSD' of XSD type 'tt:OSDConfiguration'
        tt__OSDConfiguration *OSD;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__CreateOSD
        virtual long soap_type(void) const { return SOAP_TYPE__trt__CreateOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__CreateOSD, default initialized and not managed by a soap context
        virtual _trt__CreateOSD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__CreateOSD); }
      public:
        /// Constructor with initializations
        _trt__CreateOSD() : OSD(), soap() { }
        virtual ~_trt__CreateOSD() { }
        /// Friend allocator used by soap_new__trt__CreateOSD(struct soap*, int)
        friend SOAP_FMAC1 _trt__CreateOSD * SOAP_FMAC2 soap_instantiate__trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2815 */
#ifndef SOAP_TYPE__trt__CreateOSDResponse
#define SOAP_TYPE__trt__CreateOSDResponse (974)
/* complex XSD type 'trt:CreateOSDResponse': */
class SOAP_CMAC _trt__CreateOSDResponse {
      public:
        /// Required element 'trt:OSDToken' of XSD type 'tt:ReferenceToken'
        std::string OSDToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__CreateOSDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__CreateOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__CreateOSDResponse, default initialized and not managed by a soap context
        virtual _trt__CreateOSDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__CreateOSDResponse); }
      public:
        /// Constructor with initializations
        _trt__CreateOSDResponse() : OSDToken(), soap() { }
        virtual ~_trt__CreateOSDResponse() { }
        /// Friend allocator used by soap_new__trt__CreateOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__CreateOSDResponse * SOAP_FMAC2 soap_instantiate__trt__CreateOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2818 */
#ifndef SOAP_TYPE__trt__DeleteOSD
#define SOAP_TYPE__trt__DeleteOSD (975)
/* complex XSD type 'trt:DeleteOSD': */
class SOAP_CMAC _trt__DeleteOSD {
      public:
        /// Required element 'trt:OSDToken' of XSD type 'tt:ReferenceToken'
        std::string OSDToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__DeleteOSD
        virtual long soap_type(void) const { return SOAP_TYPE__trt__DeleteOSD; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__DeleteOSD, default initialized and not managed by a soap context
        virtual _trt__DeleteOSD *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__DeleteOSD); }
      public:
        /// Constructor with initializations
        _trt__DeleteOSD() : OSDToken(), soap() { }
        virtual ~_trt__DeleteOSD() { }
        /// Friend allocator used by soap_new__trt__DeleteOSD(struct soap*, int)
        friend SOAP_FMAC1 _trt__DeleteOSD * SOAP_FMAC2 soap_instantiate__trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2821 */
#ifndef SOAP_TYPE__trt__DeleteOSDResponse
#define SOAP_TYPE__trt__DeleteOSDResponse (976)
/* complex XSD type 'trt:DeleteOSDResponse': */
class SOAP_CMAC _trt__DeleteOSDResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__trt__DeleteOSDResponse
        virtual long soap_type(void) const { return SOAP_TYPE__trt__DeleteOSDResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _trt__DeleteOSDResponse, default initialized and not managed by a soap context
        virtual _trt__DeleteOSDResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_trt__DeleteOSDResponse); }
      public:
        /// Constructor with initializations
        _trt__DeleteOSDResponse() : soap() { }
        virtual ~_trt__DeleteOSDResponse() { }
        /// Friend allocator used by soap_new__trt__DeleteOSDResponse(struct soap*, int)
        friend SOAP_FMAC1 _trt__DeleteOSDResponse * SOAP_FMAC2 soap_instantiate__trt__DeleteOSDResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2824 */
#ifndef SOAP_TYPE_tptz__Capabilities
#define SOAP_TYPE_tptz__Capabilities (977)
/* complex XSD type 'tptz:Capabilities': */
class SOAP_CMAC tptz__Capabilities {
      public:
        /// optional attribute 'EFlip' of XSD type 'xsd:boolean'
        bool *EFlip;
        /// optional attribute 'Reverse' of XSD type 'xsd:boolean'
        bool *Reverse;
        /// optional attribute 'GetCompatibleConfigurations' of XSD type 'xsd:boolean'
        bool *GetCompatibleConfigurations;
        /// optional attribute 'MoveStatus' of XSD type 'xsd:boolean'
        bool *MoveStatus;
        /// optional attribute 'StatusPosition' of XSD type 'xsd:boolean'
        bool *StatusPosition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tptz__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tptz__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tptz__Capabilities, default initialized and not managed by a soap context
        virtual tptz__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tptz__Capabilities); }
      public:
        /// Constructor with initializations
        tptz__Capabilities() : EFlip(), Reverse(), GetCompatibleConfigurations(), MoveStatus(), StatusPosition(), soap() { }
        virtual ~tptz__Capabilities() { }
        /// Friend allocator used by soap_new_tptz__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tptz__Capabilities * SOAP_FMAC2 soap_instantiate_tptz__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2827 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilities
#define SOAP_TYPE__tptz__GetServiceCapabilities (978)
/* complex XSD type 'tptz:GetServiceCapabilities': */
class SOAP_CMAC _tptz__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tptz__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _tptz__GetServiceCapabilities() : soap() { }
        virtual ~_tptz__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tptz__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2830 */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (979)
/* complex XSD type 'tptz:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tptz__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tptz:Capabilities' of XSD type 'tptz:Capabilities'
        tptz__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tptz__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tptz__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tptz__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2833 */
#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (980)
/* complex XSD type 'tptz:GetNodes': */
class SOAP_CMAC _tptz__GetNodes {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetNodes
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetNodes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetNodes, default initialized and not managed by a soap context
        virtual _tptz__GetNodes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetNodes); }
      public:
        /// Constructor with initializations
        _tptz__GetNodes() : soap() { }
        virtual ~_tptz__GetNodes() { }
        /// Friend allocator used by soap_new__tptz__GetNodes(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetNodes * SOAP_FMAC2 soap_instantiate__tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2836 */
#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (981)
/* complex XSD type 'tptz:GetNodesResponse': */
class SOAP_CMAC _tptz__GetNodesResponse {
      public:
        /// Optional element 'tptz:PTZNode' of XSD type 'tt:PTZNode'
        std::vector<tt__PTZNode *> PTZNode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetNodesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetNodesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetNodesResponse, default initialized and not managed by a soap context
        virtual _tptz__GetNodesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetNodesResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetNodesResponse() : PTZNode(), soap() { }
        virtual ~_tptz__GetNodesResponse() { }
        /// Friend allocator used by soap_new__tptz__GetNodesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetNodesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2839 */
#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (982)
/* complex XSD type 'tptz:GetNode': */
class SOAP_CMAC _tptz__GetNode {
      public:
        /// Required element 'tptz:NodeToken' of XSD type 'tt:ReferenceToken'
        std::string NodeToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetNode
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetNode, default initialized and not managed by a soap context
        virtual _tptz__GetNode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetNode); }
      public:
        /// Constructor with initializations
        _tptz__GetNode() : NodeToken(), soap() { }
        virtual ~_tptz__GetNode() { }
        /// Friend allocator used by soap_new__tptz__GetNode(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetNode * SOAP_FMAC2 soap_instantiate__tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2842 */
#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (983)
/* complex XSD type 'tptz:GetNodeResponse': */
class SOAP_CMAC _tptz__GetNodeResponse {
      public:
        /// Required element 'tptz:PTZNode' of XSD type 'tt:PTZNode'
        tt__PTZNode *PTZNode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetNodeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetNodeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetNodeResponse, default initialized and not managed by a soap context
        virtual _tptz__GetNodeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetNodeResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetNodeResponse() : PTZNode(), soap() { }
        virtual ~_tptz__GetNodeResponse() { }
        /// Friend allocator used by soap_new__tptz__GetNodeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetNodeResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2845 */
#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (984)
/* complex XSD type 'tptz:GetConfigurations': */
class SOAP_CMAC _tptz__GetConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfigurations, default initialized and not managed by a soap context
        virtual _tptz__GetConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfigurations); }
      public:
        /// Constructor with initializations
        _tptz__GetConfigurations() : soap() { }
        virtual ~_tptz__GetConfigurations() { }
        /// Friend allocator used by soap_new__tptz__GetConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2848 */
#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (985)
/* complex XSD type 'tptz:GetConfigurationsResponse': */
class SOAP_CMAC _tptz__GetConfigurationsResponse {
      public:
        /// Optional element 'tptz:PTZConfiguration' of XSD type 'tt:PTZConfiguration'
        std::vector<tt__PTZConfiguration *> PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tptz__GetConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetConfigurationsResponse() : PTZConfiguration(), soap() { }
        virtual ~_tptz__GetConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tptz__GetConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2851 */
#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (986)
/* complex XSD type 'tptz:GetConfiguration': */
class SOAP_CMAC _tptz__GetConfiguration {
      public:
        /// Required element 'tptz:PTZConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string PTZConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfiguration, default initialized and not managed by a soap context
        virtual _tptz__GetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfiguration); }
      public:
        /// Constructor with initializations
        _tptz__GetConfiguration() : PTZConfigurationToken(), soap() { }
        virtual ~_tptz__GetConfiguration() { }
        /// Friend allocator used by soap_new__tptz__GetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2854 */
#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (987)
/* complex XSD type 'tptz:GetConfigurationResponse': */
class SOAP_CMAC _tptz__GetConfigurationResponse {
      public:
        /// Required element 'tptz:PTZConfiguration' of XSD type 'tt:PTZConfiguration'
        tt__PTZConfiguration *PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfigurationResponse, default initialized and not managed by a soap context
        virtual _tptz__GetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetConfigurationResponse() : PTZConfiguration(), soap() { }
        virtual ~_tptz__GetConfigurationResponse() { }
        /// Friend allocator used by soap_new__tptz__GetConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2857 */
#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (988)
/* complex XSD type 'tptz:SetConfiguration': */
class SOAP_CMAC _tptz__SetConfiguration {
      public:
        /// Required element 'tptz:PTZConfiguration' of XSD type 'tt:PTZConfiguration'
        tt__PTZConfiguration *PTZConfiguration;
        /// Required element 'tptz:ForcePersistence' of XSD type 'xsd:boolean'
        bool ForcePersistence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetConfiguration, default initialized and not managed by a soap context
        virtual _tptz__SetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetConfiguration); }
      public:
        /// Constructor with initializations
        _tptz__SetConfiguration() : PTZConfiguration(), ForcePersistence(), soap() { }
        virtual ~_tptz__SetConfiguration() { }
        /// Friend allocator used by soap_new__tptz__SetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:27531 */
#ifndef SOAP_TYPE___tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE___tptz__SetConfigurationResponse_sequence (1736)
/* Wrapper: */
class SOAP_CMAC __tptz__SetConfigurationResponse_sequence {
      public:
        /// Return unique type id SOAP_TYPE___tptz__SetConfigurationResponse_sequence
        virtual long soap_type(void) const { return SOAP_TYPE___tptz__SetConfigurationResponse_sequence; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type __tptz__SetConfigurationResponse_sequence, default initialized and not managed by a soap context
        virtual __tptz__SetConfigurationResponse_sequence *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(__tptz__SetConfigurationResponse_sequence); }
      public:
        /// Constructor with initializations
        __tptz__SetConfigurationResponse_sequence() { }
        virtual ~__tptz__SetConfigurationResponse_sequence() { }
        /// Friend allocator used by soap_new___tptz__SetConfigurationResponse_sequence(struct soap*, int)
        friend SOAP_FMAC1 __tptz__SetConfigurationResponse_sequence * SOAP_FMAC2 soap_instantiate___tptz__SetConfigurationResponse_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2860 */
#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (989)
/* complex XSD type 'tptz:SetConfigurationResponse': */
class SOAP_CMAC _tptz__SetConfigurationResponse {
      public:
        __tptz__SetConfigurationResponse_sequence *__SetConfigurationResponse_sequence;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetConfigurationResponse, default initialized and not managed by a soap context
        virtual _tptz__SetConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tptz__SetConfigurationResponse() : __SetConfigurationResponse_sequence(), soap() { }
        virtual ~_tptz__SetConfigurationResponse() { }
        /// Friend allocator used by soap_new__tptz__SetConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__SetConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2863 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (990)
/* complex XSD type 'tptz:GetConfigurationOptions': */
class SOAP_CMAC _tptz__GetConfigurationOptions {
      public:
        /// Required element 'tptz:ConfigurationToken' of XSD type 'tt:ReferenceToken'
        std::string ConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfigurationOptions, default initialized and not managed by a soap context
        virtual _tptz__GetConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfigurationOptions); }
      public:
        /// Constructor with initializations
        _tptz__GetConfigurationOptions() : ConfigurationToken(), soap() { }
        virtual ~_tptz__GetConfigurationOptions() { }
        /// Friend allocator used by soap_new__tptz__GetConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2866 */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (991)
/* complex XSD type 'tptz:GetConfigurationOptionsResponse': */
class SOAP_CMAC _tptz__GetConfigurationOptionsResponse {
      public:
        /// Required element 'tptz:PTZConfigurationOptions' of XSD type 'tt:PTZConfigurationOptions'
        tt__PTZConfigurationOptions *PTZConfigurationOptions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetConfigurationOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetConfigurationOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetConfigurationOptionsResponse, default initialized and not managed by a soap context
        virtual _tptz__GetConfigurationOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetConfigurationOptionsResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetConfigurationOptionsResponse() : PTZConfigurationOptions(), soap() { }
        virtual ~_tptz__GetConfigurationOptionsResponse() { }
        /// Friend allocator used by soap_new__tptz__GetConfigurationOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2869 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (992)
/* complex XSD type 'tptz:SendAuxiliaryCommand': */
class SOAP_CMAC _tptz__SendAuxiliaryCommand {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:AuxiliaryData' of XSD type 'tt:AuxiliaryData'
        std::string AuxiliaryData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SendAuxiliaryCommand
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SendAuxiliaryCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SendAuxiliaryCommand, default initialized and not managed by a soap context
        virtual _tptz__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SendAuxiliaryCommand); }
      public:
        /// Constructor with initializations
        _tptz__SendAuxiliaryCommand() : ProfileToken(), AuxiliaryData(), soap() { }
        virtual ~_tptz__SendAuxiliaryCommand() { }
        /// Friend allocator used by soap_new__tptz__SendAuxiliaryCommand(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2872 */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (993)
/* complex XSD type 'tptz:SendAuxiliaryCommandResponse': */
class SOAP_CMAC _tptz__SendAuxiliaryCommandResponse {
      public:
        /// Required element 'tptz:AuxiliaryResponse' of XSD type 'tt:AuxiliaryData'
        std::string AuxiliaryResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SendAuxiliaryCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
        virtual _tptz__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SendAuxiliaryCommandResponse); }
      public:
        /// Constructor with initializations
        _tptz__SendAuxiliaryCommandResponse() : AuxiliaryResponse(), soap() { }
        virtual ~_tptz__SendAuxiliaryCommandResponse() { }
        /// Friend allocator used by soap_new__tptz__SendAuxiliaryCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2875 */
#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (994)
/* complex XSD type 'tptz:GetPresets': */
class SOAP_CMAC _tptz__GetPresets {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresets
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresets; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresets, default initialized and not managed by a soap context
        virtual _tptz__GetPresets *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresets); }
      public:
        /// Constructor with initializations
        _tptz__GetPresets() : ProfileToken(), soap() { }
        virtual ~_tptz__GetPresets() { }
        /// Friend allocator used by soap_new__tptz__GetPresets(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresets * SOAP_FMAC2 soap_instantiate__tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2878 */
#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (995)
/* complex XSD type 'tptz:GetPresetsResponse': */
class SOAP_CMAC _tptz__GetPresetsResponse {
      public:
        /// Optional element 'tptz:Preset' of XSD type 'tt:PTZPreset'
        std::vector<tt__PTZPreset *> Preset;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetsResponse, default initialized and not managed by a soap context
        virtual _tptz__GetPresetsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetsResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetsResponse() : Preset(), soap() { }
        virtual ~_tptz__GetPresetsResponse() { }
        /// Friend allocator used by soap_new__tptz__GetPresetsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2881 */
#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (996)
/* complex XSD type 'tptz:SetPreset': */
class SOAP_CMAC _tptz__SetPreset {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'tptz:PresetName' of XSD type 'xsd:string'
        std::string *PresetName;
        /// Optional element 'tptz:PresetToken' of XSD type 'tt:ReferenceToken'
        std::string *PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetPreset
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetPreset, default initialized and not managed by a soap context
        virtual _tptz__SetPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetPreset); }
      public:
        /// Constructor with initializations
        _tptz__SetPreset() : ProfileToken(), PresetName(), PresetToken(), soap() { }
        virtual ~_tptz__SetPreset() { }
        /// Friend allocator used by soap_new__tptz__SetPreset(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetPreset * SOAP_FMAC2 soap_instantiate__tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2884 */
#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (997)
/* complex XSD type 'tptz:SetPresetResponse': */
class SOAP_CMAC _tptz__SetPresetResponse {
      public:
        /// Required element 'tptz:PresetToken' of XSD type 'tt:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetPresetResponse, default initialized and not managed by a soap context
        virtual _tptz__SetPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetPresetResponse); }
      public:
        /// Constructor with initializations
        _tptz__SetPresetResponse() : PresetToken(), soap() { }
        virtual ~_tptz__SetPresetResponse() { }
        /// Friend allocator used by soap_new__tptz__SetPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__SetPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2887 */
#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (998)
/* complex XSD type 'tptz:RemovePreset': */
class SOAP_CMAC _tptz__RemovePreset {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetToken' of XSD type 'tt:ReferenceToken'
        std::string PresetToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RemovePreset
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RemovePreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RemovePreset, default initialized and not managed by a soap context
        virtual _tptz__RemovePreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RemovePreset); }
      public:
        /// Constructor with initializations
        _tptz__RemovePreset() : ProfileToken(), PresetToken(), soap() { }
        virtual ~_tptz__RemovePreset() { }
        /// Friend allocator used by soap_new__tptz__RemovePreset(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RemovePreset * SOAP_FMAC2 soap_instantiate__tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2890 */
#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (999)
/* complex XSD type 'tptz:RemovePresetResponse': */
class SOAP_CMAC _tptz__RemovePresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RemovePresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RemovePresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RemovePresetResponse, default initialized and not managed by a soap context
        virtual _tptz__RemovePresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RemovePresetResponse); }
      public:
        /// Constructor with initializations
        _tptz__RemovePresetResponse() : soap() { }
        virtual ~_tptz__RemovePresetResponse() { }
        /// Friend allocator used by soap_new__tptz__RemovePresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RemovePresetResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2893 */
#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (1000)
/* complex XSD type 'tptz:GotoPreset': */
class SOAP_CMAC _tptz__GotoPreset {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetToken' of XSD type 'tt:ReferenceToken'
        std::string PresetToken;
        /// Optional element 'tptz:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GotoPreset
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GotoPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GotoPreset, default initialized and not managed by a soap context
        virtual _tptz__GotoPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GotoPreset); }
      public:
        /// Constructor with initializations
        _tptz__GotoPreset() : ProfileToken(), PresetToken(), Speed(), soap() { }
        virtual ~_tptz__GotoPreset() { }
        /// Friend allocator used by soap_new__tptz__GotoPreset(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GotoPreset * SOAP_FMAC2 soap_instantiate__tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2896 */
#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (1001)
/* complex XSD type 'tptz:GotoPresetResponse': */
class SOAP_CMAC _tptz__GotoPresetResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GotoPresetResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GotoPresetResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GotoPresetResponse, default initialized and not managed by a soap context
        virtual _tptz__GotoPresetResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GotoPresetResponse); }
      public:
        /// Constructor with initializations
        _tptz__GotoPresetResponse() : soap() { }
        virtual ~_tptz__GotoPresetResponse() { }
        /// Friend allocator used by soap_new__tptz__GotoPresetResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GotoPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoPresetResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2899 */
#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (1002)
/* complex XSD type 'tptz:GetStatus': */
class SOAP_CMAC _tptz__GetStatus {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetStatus, default initialized and not managed by a soap context
        virtual _tptz__GetStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetStatus); }
      public:
        /// Constructor with initializations
        _tptz__GetStatus() : ProfileToken(), soap() { }
        virtual ~_tptz__GetStatus() { }
        /// Friend allocator used by soap_new__tptz__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetStatus * SOAP_FMAC2 soap_instantiate__tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2902 */
#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (1003)
/* complex XSD type 'tptz:GetStatusResponse': */
class SOAP_CMAC _tptz__GetStatusResponse {
      public:
        /// Required element 'tptz:PTZStatus' of XSD type 'tt:PTZStatus'
        tt__PTZStatus *PTZStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetStatusResponse, default initialized and not managed by a soap context
        virtual _tptz__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetStatusResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetStatusResponse() : PTZStatus(), soap() { }
        virtual ~_tptz__GetStatusResponse() { }
        /// Friend allocator used by soap_new__tptz__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetStatusResponse * SOAP_FMAC2 soap_instantiate__tptz__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2905 */
#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (1004)
/* complex XSD type 'tptz:GotoHomePosition': */
class SOAP_CMAC _tptz__GotoHomePosition {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'tptz:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GotoHomePosition
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GotoHomePosition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GotoHomePosition, default initialized and not managed by a soap context
        virtual _tptz__GotoHomePosition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GotoHomePosition); }
      public:
        /// Constructor with initializations
        _tptz__GotoHomePosition() : ProfileToken(), Speed(), soap() { }
        virtual ~_tptz__GotoHomePosition() { }
        /// Friend allocator used by soap_new__tptz__GotoHomePosition(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2908 */
#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (1005)
/* complex XSD type 'tptz:GotoHomePositionResponse': */
class SOAP_CMAC _tptz__GotoHomePositionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GotoHomePositionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GotoHomePositionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GotoHomePositionResponse, default initialized and not managed by a soap context
        virtual _tptz__GotoHomePositionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GotoHomePositionResponse); }
      public:
        /// Constructor with initializations
        _tptz__GotoHomePositionResponse() : soap() { }
        virtual ~_tptz__GotoHomePositionResponse() { }
        /// Friend allocator used by soap_new__tptz__GotoHomePositionResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GotoHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2911 */
#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (1006)
/* complex XSD type 'tptz:SetHomePosition': */
class SOAP_CMAC _tptz__SetHomePosition {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetHomePosition
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetHomePosition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetHomePosition, default initialized and not managed by a soap context
        virtual _tptz__SetHomePosition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetHomePosition); }
      public:
        /// Constructor with initializations
        _tptz__SetHomePosition() : ProfileToken(), soap() { }
        virtual ~_tptz__SetHomePosition() { }
        /// Friend allocator used by soap_new__tptz__SetHomePosition(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate__tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2914 */
#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (1007)
/* complex XSD type 'tptz:SetHomePositionResponse': */
class SOAP_CMAC _tptz__SetHomePositionResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__SetHomePositionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__SetHomePositionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__SetHomePositionResponse, default initialized and not managed by a soap context
        virtual _tptz__SetHomePositionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__SetHomePositionResponse); }
      public:
        /// Constructor with initializations
        _tptz__SetHomePositionResponse() : soap() { }
        virtual ~_tptz__SetHomePositionResponse() { }
        /// Friend allocator used by soap_new__tptz__SetHomePositionResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__SetHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__SetHomePositionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2917 */
#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (1008)
/* complex XSD type 'tptz:ContinuousMove': */
class SOAP_CMAC _tptz__ContinuousMove {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:Velocity' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Velocity;
        /// Optional element 'tptz:Timeout' of XSD type 'xsd:duration'
        std::string *Timeout;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__ContinuousMove
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__ContinuousMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__ContinuousMove, default initialized and not managed by a soap context
        virtual _tptz__ContinuousMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__ContinuousMove); }
      public:
        /// Constructor with initializations
        _tptz__ContinuousMove() : ProfileToken(), Velocity(), Timeout(), soap() { }
        virtual ~_tptz__ContinuousMove() { }
        /// Friend allocator used by soap_new__tptz__ContinuousMove(struct soap*, int)
        friend SOAP_FMAC1 _tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2920 */
#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (1009)
/* complex XSD type 'tptz:ContinuousMoveResponse': */
class SOAP_CMAC _tptz__ContinuousMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__ContinuousMoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__ContinuousMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__ContinuousMoveResponse, default initialized and not managed by a soap context
        virtual _tptz__ContinuousMoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__ContinuousMoveResponse); }
      public:
        /// Constructor with initializations
        _tptz__ContinuousMoveResponse() : soap() { }
        virtual ~_tptz__ContinuousMoveResponse() { }
        /// Friend allocator used by soap_new__tptz__ContinuousMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__ContinuousMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2923 */
#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (1010)
/* complex XSD type 'tptz:RelativeMove': */
class SOAP_CMAC _tptz__RelativeMove {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:Translation' of XSD type 'tt:PTZVector'
        tt__PTZVector *Translation;
        /// Optional element 'tptz:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RelativeMove
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RelativeMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RelativeMove, default initialized and not managed by a soap context
        virtual _tptz__RelativeMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RelativeMove); }
      public:
        /// Constructor with initializations
        _tptz__RelativeMove() : ProfileToken(), Translation(), Speed(), soap() { }
        virtual ~_tptz__RelativeMove() { }
        /// Friend allocator used by soap_new__tptz__RelativeMove(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RelativeMove * SOAP_FMAC2 soap_instantiate__tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2926 */
#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (1011)
/* complex XSD type 'tptz:RelativeMoveResponse': */
class SOAP_CMAC _tptz__RelativeMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RelativeMoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RelativeMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RelativeMoveResponse, default initialized and not managed by a soap context
        virtual _tptz__RelativeMoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RelativeMoveResponse); }
      public:
        /// Constructor with initializations
        _tptz__RelativeMoveResponse() : soap() { }
        virtual ~_tptz__RelativeMoveResponse() { }
        /// Friend allocator used by soap_new__tptz__RelativeMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RelativeMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__RelativeMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2929 */
#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (1012)
/* complex XSD type 'tptz:AbsoluteMove': */
class SOAP_CMAC _tptz__AbsoluteMove {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:Position' of XSD type 'tt:PTZVector'
        tt__PTZVector *Position;
        /// Optional element 'tptz:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__AbsoluteMove
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__AbsoluteMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__AbsoluteMove, default initialized and not managed by a soap context
        virtual _tptz__AbsoluteMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__AbsoluteMove); }
      public:
        /// Constructor with initializations
        _tptz__AbsoluteMove() : ProfileToken(), Position(), Speed(), soap() { }
        virtual ~_tptz__AbsoluteMove() { }
        /// Friend allocator used by soap_new__tptz__AbsoluteMove(struct soap*, int)
        friend SOAP_FMAC1 _tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2932 */
#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (1013)
/* complex XSD type 'tptz:AbsoluteMoveResponse': */
class SOAP_CMAC _tptz__AbsoluteMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__AbsoluteMoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__AbsoluteMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__AbsoluteMoveResponse, default initialized and not managed by a soap context
        virtual _tptz__AbsoluteMoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__AbsoluteMoveResponse); }
      public:
        /// Constructor with initializations
        _tptz__AbsoluteMoveResponse() : soap() { }
        virtual ~_tptz__AbsoluteMoveResponse() { }
        /// Friend allocator used by soap_new__tptz__AbsoluteMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__AbsoluteMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2935 */
#ifndef SOAP_TYPE__tptz__GeoMove
#define SOAP_TYPE__tptz__GeoMove (1014)
/* complex XSD type 'tptz:GeoMove': */
class SOAP_CMAC _tptz__GeoMove {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:Target' of XSD type 'tt:GeoLocation'
        tt__GeoLocation *Target;
        /// Optional element 'tptz:Speed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Optional element 'tptz:AreaHeight' of XSD type 'xsd:float'
        float *AreaHeight;
        /// Optional element 'tptz:AreaWidth' of XSD type 'xsd:float'
        float *AreaWidth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GeoMove
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GeoMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GeoMove, default initialized and not managed by a soap context
        virtual _tptz__GeoMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GeoMove); }
      public:
        /// Constructor with initializations
        _tptz__GeoMove() : ProfileToken(), Target(), Speed(), AreaHeight(), AreaWidth(), soap() { }
        virtual ~_tptz__GeoMove() { }
        /// Friend allocator used by soap_new__tptz__GeoMove(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GeoMove * SOAP_FMAC2 soap_instantiate__tptz__GeoMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2938 */
#ifndef SOAP_TYPE__tptz__GeoMoveResponse
#define SOAP_TYPE__tptz__GeoMoveResponse (1015)
/* complex XSD type 'tptz:GeoMoveResponse': */
class SOAP_CMAC _tptz__GeoMoveResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GeoMoveResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GeoMoveResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GeoMoveResponse, default initialized and not managed by a soap context
        virtual _tptz__GeoMoveResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GeoMoveResponse); }
      public:
        /// Constructor with initializations
        _tptz__GeoMoveResponse() : soap() { }
        virtual ~_tptz__GeoMoveResponse() { }
        /// Friend allocator used by soap_new__tptz__GeoMoveResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GeoMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__GeoMoveResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2941 */
#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (1016)
/* complex XSD type 'tptz:Stop': */
class SOAP_CMAC _tptz__Stop {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'tptz:PanTilt' of XSD type 'xsd:boolean'
        bool *PanTilt;
        /// Optional element 'tptz:Zoom' of XSD type 'xsd:boolean'
        bool *Zoom;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__Stop
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__Stop; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__Stop, default initialized and not managed by a soap context
        virtual _tptz__Stop *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__Stop); }
      public:
        /// Constructor with initializations
        _tptz__Stop() : ProfileToken(), PanTilt(), Zoom(), soap() { }
        virtual ~_tptz__Stop() { }
        /// Friend allocator used by soap_new__tptz__Stop(struct soap*, int)
        friend SOAP_FMAC1 _tptz__Stop * SOAP_FMAC2 soap_instantiate__tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2944 */
#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (1017)
/* complex XSD type 'tptz:StopResponse': */
class SOAP_CMAC _tptz__StopResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__StopResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__StopResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__StopResponse, default initialized and not managed by a soap context
        virtual _tptz__StopResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__StopResponse); }
      public:
        /// Constructor with initializations
        _tptz__StopResponse() : soap() { }
        virtual ~_tptz__StopResponse() { }
        /// Friend allocator used by soap_new__tptz__StopResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__StopResponse * SOAP_FMAC2 soap_instantiate__tptz__StopResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2947 */
#ifndef SOAP_TYPE__tptz__GetPresetTours
#define SOAP_TYPE__tptz__GetPresetTours (1018)
/* complex XSD type 'tptz:GetPresetTours': */
class SOAP_CMAC _tptz__GetPresetTours {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetTours
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetTours; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetTours, default initialized and not managed by a soap context
        virtual _tptz__GetPresetTours *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetTours); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetTours() : ProfileToken(), soap() { }
        virtual ~_tptz__GetPresetTours() { }
        /// Friend allocator used by soap_new__tptz__GetPresetTours(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2950 */
#ifndef SOAP_TYPE__tptz__GetPresetToursResponse
#define SOAP_TYPE__tptz__GetPresetToursResponse (1019)
/* complex XSD type 'tptz:GetPresetToursResponse': */
class SOAP_CMAC _tptz__GetPresetToursResponse {
      public:
        /// Optional element 'tptz:PresetTour' of XSD type 'tt:PresetTour'
        std::vector<tt__PresetTour *> PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetToursResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetToursResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetToursResponse, default initialized and not managed by a soap context
        virtual _tptz__GetPresetToursResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetToursResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetToursResponse() : PresetTour(), soap() { }
        virtual ~_tptz__GetPresetToursResponse() { }
        /// Friend allocator used by soap_new__tptz__GetPresetToursResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetToursResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetToursResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2953 */
#ifndef SOAP_TYPE__tptz__GetPresetTour
#define SOAP_TYPE__tptz__GetPresetTour (1020)
/* complex XSD type 'tptz:GetPresetTour': */
class SOAP_CMAC _tptz__GetPresetTour {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetTourToken' of XSD type 'tt:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetTour
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetTour, default initialized and not managed by a soap context
        virtual _tptz__GetPresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetTour); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetTour() : ProfileToken(), PresetTourToken(), soap() { }
        virtual ~_tptz__GetPresetTour() { }
        /// Friend allocator used by soap_new__tptz__GetPresetTour(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2956 */
#ifndef SOAP_TYPE__tptz__GetPresetTourResponse
#define SOAP_TYPE__tptz__GetPresetTourResponse (1021)
/* complex XSD type 'tptz:GetPresetTourResponse': */
class SOAP_CMAC _tptz__GetPresetTourResponse {
      public:
        /// Required element 'tptz:PresetTour' of XSD type 'tt:PresetTour'
        tt__PresetTour *PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetTourResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetTourResponse, default initialized and not managed by a soap context
        virtual _tptz__GetPresetTourResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetTourResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetTourResponse() : PresetTour(), soap() { }
        virtual ~_tptz__GetPresetTourResponse() { }
        /// Friend allocator used by soap_new__tptz__GetPresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2959 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptions
#define SOAP_TYPE__tptz__GetPresetTourOptions (1022)
/* complex XSD type 'tptz:GetPresetTourOptions': */
class SOAP_CMAC _tptz__GetPresetTourOptions {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Optional element 'tptz:PresetTourToken' of XSD type 'tt:ReferenceToken'
        std::string *PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetTourOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetTourOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetTourOptions, default initialized and not managed by a soap context
        virtual _tptz__GetPresetTourOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetTourOptions); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetTourOptions() : ProfileToken(), PresetTourToken(), soap() { }
        virtual ~_tptz__GetPresetTourOptions() { }
        /// Friend allocator used by soap_new__tptz__GetPresetTourOptions(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2962 */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptionsResponse
#define SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1023)
/* complex XSD type 'tptz:GetPresetTourOptionsResponse': */
class SOAP_CMAC _tptz__GetPresetTourOptionsResponse {
      public:
        /// Required element 'tptz:Options' of XSD type 'tt:PTZPresetTourOptions'
        tt__PTZPresetTourOptions *Options;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetPresetTourOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetPresetTourOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetPresetTourOptionsResponse, default initialized and not managed by a soap context
        virtual _tptz__GetPresetTourOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetPresetTourOptionsResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetPresetTourOptionsResponse() : Options(), soap() { }
        virtual ~_tptz__GetPresetTourOptionsResponse() { }
        /// Friend allocator used by soap_new__tptz__GetPresetTourOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetPresetTourOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2965 */
#ifndef SOAP_TYPE__tptz__CreatePresetTour
#define SOAP_TYPE__tptz__CreatePresetTour (1024)
/* complex XSD type 'tptz:CreatePresetTour': */
class SOAP_CMAC _tptz__CreatePresetTour {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__CreatePresetTour
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__CreatePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__CreatePresetTour, default initialized and not managed by a soap context
        virtual _tptz__CreatePresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__CreatePresetTour); }
      public:
        /// Constructor with initializations
        _tptz__CreatePresetTour() : ProfileToken(), soap() { }
        virtual ~_tptz__CreatePresetTour() { }
        /// Friend allocator used by soap_new__tptz__CreatePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2968 */
#ifndef SOAP_TYPE__tptz__CreatePresetTourResponse
#define SOAP_TYPE__tptz__CreatePresetTourResponse (1025)
/* complex XSD type 'tptz:CreatePresetTourResponse': */
class SOAP_CMAC _tptz__CreatePresetTourResponse {
      public:
        /// Required element 'tptz:PresetTourToken' of XSD type 'tt:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__CreatePresetTourResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__CreatePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__CreatePresetTourResponse, default initialized and not managed by a soap context
        virtual _tptz__CreatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__CreatePresetTourResponse); }
      public:
        /// Constructor with initializations
        _tptz__CreatePresetTourResponse() : PresetTourToken(), soap() { }
        virtual ~_tptz__CreatePresetTourResponse() { }
        /// Friend allocator used by soap_new__tptz__CreatePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__CreatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2971 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTour
#define SOAP_TYPE__tptz__ModifyPresetTour (1026)
/* complex XSD type 'tptz:ModifyPresetTour': */
class SOAP_CMAC _tptz__ModifyPresetTour {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetTour' of XSD type 'tt:PresetTour'
        tt__PresetTour *PresetTour;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__ModifyPresetTour
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__ModifyPresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__ModifyPresetTour, default initialized and not managed by a soap context
        virtual _tptz__ModifyPresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__ModifyPresetTour); }
      public:
        /// Constructor with initializations
        _tptz__ModifyPresetTour() : ProfileToken(), PresetTour(), soap() { }
        virtual ~_tptz__ModifyPresetTour() { }
        /// Friend allocator used by soap_new__tptz__ModifyPresetTour(struct soap*, int)
        friend SOAP_FMAC1 _tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2974 */
#ifndef SOAP_TYPE__tptz__ModifyPresetTourResponse
#define SOAP_TYPE__tptz__ModifyPresetTourResponse (1027)
/* complex XSD type 'tptz:ModifyPresetTourResponse': */
class SOAP_CMAC _tptz__ModifyPresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__ModifyPresetTourResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__ModifyPresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__ModifyPresetTourResponse, default initialized and not managed by a soap context
        virtual _tptz__ModifyPresetTourResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__ModifyPresetTourResponse); }
      public:
        /// Constructor with initializations
        _tptz__ModifyPresetTourResponse() : soap() { }
        virtual ~_tptz__ModifyPresetTourResponse() { }
        /// Friend allocator used by soap_new__tptz__ModifyPresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__ModifyPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2977 */
#ifndef SOAP_TYPE__tptz__OperatePresetTour
#define SOAP_TYPE__tptz__OperatePresetTour (1028)
/* complex XSD type 'tptz:OperatePresetTour': */
class SOAP_CMAC _tptz__OperatePresetTour {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetTourToken' of XSD type 'tt:ReferenceToken'
        std::string PresetTourToken;
        /// Required element 'tptz:Operation' of XSD type 'tt:PTZPresetTourOperation'
        enum tt__PTZPresetTourOperation Operation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__OperatePresetTour
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__OperatePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__OperatePresetTour, default initialized and not managed by a soap context
        virtual _tptz__OperatePresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__OperatePresetTour); }
      public:
        /// Constructor with initializations
        _tptz__OperatePresetTour() : ProfileToken(), PresetTourToken(), Operation(), soap() { }
        virtual ~_tptz__OperatePresetTour() { }
        /// Friend allocator used by soap_new__tptz__OperatePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2980 */
#ifndef SOAP_TYPE__tptz__OperatePresetTourResponse
#define SOAP_TYPE__tptz__OperatePresetTourResponse (1029)
/* complex XSD type 'tptz:OperatePresetTourResponse': */
class SOAP_CMAC _tptz__OperatePresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__OperatePresetTourResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__OperatePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__OperatePresetTourResponse, default initialized and not managed by a soap context
        virtual _tptz__OperatePresetTourResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__OperatePresetTourResponse); }
      public:
        /// Constructor with initializations
        _tptz__OperatePresetTourResponse() : soap() { }
        virtual ~_tptz__OperatePresetTourResponse() { }
        /// Friend allocator used by soap_new__tptz__OperatePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__OperatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2983 */
#ifndef SOAP_TYPE__tptz__RemovePresetTour
#define SOAP_TYPE__tptz__RemovePresetTour (1030)
/* complex XSD type 'tptz:RemovePresetTour': */
class SOAP_CMAC _tptz__RemovePresetTour {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Required element 'tptz:PresetTourToken' of XSD type 'tt:ReferenceToken'
        std::string PresetTourToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RemovePresetTour
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RemovePresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RemovePresetTour, default initialized and not managed by a soap context
        virtual _tptz__RemovePresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RemovePresetTour); }
      public:
        /// Constructor with initializations
        _tptz__RemovePresetTour() : ProfileToken(), PresetTourToken(), soap() { }
        virtual ~_tptz__RemovePresetTour() { }
        /// Friend allocator used by soap_new__tptz__RemovePresetTour(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2986 */
#ifndef SOAP_TYPE__tptz__RemovePresetTourResponse
#define SOAP_TYPE__tptz__RemovePresetTourResponse (1031)
/* complex XSD type 'tptz:RemovePresetTourResponse': */
class SOAP_CMAC _tptz__RemovePresetTourResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__RemovePresetTourResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__RemovePresetTourResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__RemovePresetTourResponse, default initialized and not managed by a soap context
        virtual _tptz__RemovePresetTourResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__RemovePresetTourResponse); }
      public:
        /// Constructor with initializations
        _tptz__RemovePresetTourResponse() : soap() { }
        virtual ~_tptz__RemovePresetTourResponse() { }
        /// Friend allocator used by soap_new__tptz__RemovePresetTourResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__RemovePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTourResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2989 */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurations
#define SOAP_TYPE__tptz__GetCompatibleConfigurations (1032)
/* complex XSD type 'tptz:GetCompatibleConfigurations': */
class SOAP_CMAC _tptz__GetCompatibleConfigurations {
      public:
        /// Required element 'tptz:ProfileToken' of XSD type 'tt:ReferenceToken'
        std::string ProfileToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetCompatibleConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetCompatibleConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetCompatibleConfigurations, default initialized and not managed by a soap context
        virtual _tptz__GetCompatibleConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetCompatibleConfigurations); }
      public:
        /// Constructor with initializations
        _tptz__GetCompatibleConfigurations() : ProfileToken(), soap() { }
        virtual ~_tptz__GetCompatibleConfigurations() { }
        /// Friend allocator used by soap_new__tptz__GetCompatibleConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate__tptz__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2992 */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse
#define SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse (1033)
/* complex XSD type 'tptz:GetCompatibleConfigurationsResponse': */
class SOAP_CMAC _tptz__GetCompatibleConfigurationsResponse {
      public:
        /// Optional element 'tptz:PTZConfiguration' of XSD type 'tt:PTZConfiguration'
        std::vector<tt__PTZConfiguration *> PTZConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tptz__GetCompatibleConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tptz__GetCompatibleConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tptz__GetCompatibleConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tptz__GetCompatibleConfigurationsResponse() : PTZConfiguration(), soap() { }
        virtual ~_tptz__GetCompatibleConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tptz__GetCompatibleConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetCompatibleConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:28643 */
#ifndef SOAP_TYPE__tas__KeyAttribute_Extension
#define SOAP_TYPE__tas__KeyAttribute_Extension (1745)
/* complex XSD type 'tas:KeyAttribute-Extension': */
class SOAP_CMAC _tas__KeyAttribute_Extension {
      public:
        /// Return unique type id SOAP_TYPE__tas__KeyAttribute_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tas__KeyAttribute_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__KeyAttribute_Extension, default initialized and not managed by a soap context
        virtual _tas__KeyAttribute_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__KeyAttribute_Extension); }
      public:
        /// Constructor with initializations
        _tas__KeyAttribute_Extension() { }
        virtual ~_tas__KeyAttribute_Extension() { }
        /// Friend allocator used by soap_new__tas__KeyAttribute_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tas__KeyAttribute_Extension * SOAP_FMAC2 soap_instantiate__tas__KeyAttribute_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2995 */
#ifndef SOAP_TYPE_tas__KeyAttribute
#define SOAP_TYPE_tas__KeyAttribute (1034)
/* complex XSD type 'tas:KeyAttribute': */
class SOAP_CMAC tas__KeyAttribute {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:hasPrivateKey' of XSD type 'xsd:boolean'
        bool *hasPrivateKey;
        /// Required element 'tas:KeyStatus' of XSD type 'xsd:string'
        std::string KeyStatus;
        /// Optional element 'tas:externallyGenerated' of XSD type 'xsd:boolean'
        bool *externallyGenerated;
        /// Optional element 'tas:securelyStored' of XSD type 'xsd:boolean'
        bool *securelyStored;
        /// Optional element 'tas:Extension' of XSD type 'tas:KeyAttribute-Extension'
        _tas__KeyAttribute_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__KeyAttribute
        virtual long soap_type(void) const { return SOAP_TYPE_tas__KeyAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__KeyAttribute, default initialized and not managed by a soap context
        virtual tas__KeyAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__KeyAttribute); }
      public:
        /// Constructor with initializations
        tas__KeyAttribute() : KeyID(), Alias(), hasPrivateKey(), KeyStatus(), externallyGenerated(), securelyStored(), Extension(), soap() { }
        virtual ~tas__KeyAttribute() { }
        /// Friend allocator used by soap_new_tas__KeyAttribute(struct soap*, int)
        friend SOAP_FMAC1 tas__KeyAttribute * SOAP_FMAC2 soap_instantiate_tas__KeyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2998 */
#ifndef SOAP_TYPE_tas__DNAttributeTypeAndValue
#define SOAP_TYPE_tas__DNAttributeTypeAndValue (1035)
/* complex XSD type 'tas:DNAttributeTypeAndValue': */
class SOAP_CMAC tas__DNAttributeTypeAndValue {
      public:
        /// Required element 'tas:Type' of XSD type 'tas:DNAttributeType'
        std::string Type;
        /// Required element 'tas:Value' of XSD type 'tas:DNAttributeValue'
        std::string Value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__DNAttributeTypeAndValue
        virtual long soap_type(void) const { return SOAP_TYPE_tas__DNAttributeTypeAndValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__DNAttributeTypeAndValue, default initialized and not managed by a soap context
        virtual tas__DNAttributeTypeAndValue *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__DNAttributeTypeAndValue); }
      public:
        /// Constructor with initializations
        tas__DNAttributeTypeAndValue() : Type(), Value(), soap() { }
        virtual ~tas__DNAttributeTypeAndValue() { }
        /// Friend allocator used by soap_new_tas__DNAttributeTypeAndValue(struct soap*, int)
        friend SOAP_FMAC1 tas__DNAttributeTypeAndValue * SOAP_FMAC2 soap_instantiate_tas__DNAttributeTypeAndValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3001 */
#ifndef SOAP_TYPE_tas__MultiValuedRDN
#define SOAP_TYPE_tas__MultiValuedRDN (1036)
/* complex XSD type 'tas:MultiValuedRDN': */
class SOAP_CMAC tas__MultiValuedRDN {
      public:
        /// Optional element 'tas:Attribute' of XSD type 'tas:DNAttributeTypeAndValue'
        std::vector<tas__DNAttributeTypeAndValue *> Attribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__MultiValuedRDN
        virtual long soap_type(void) const { return SOAP_TYPE_tas__MultiValuedRDN; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__MultiValuedRDN, default initialized and not managed by a soap context
        virtual tas__MultiValuedRDN *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__MultiValuedRDN); }
      public:
        /// Constructor with initializations
        tas__MultiValuedRDN() : Attribute(), soap() { }
        virtual ~tas__MultiValuedRDN() { }
        /// Friend allocator used by soap_new_tas__MultiValuedRDN(struct soap*, int)
        friend SOAP_FMAC1 tas__MultiValuedRDN * SOAP_FMAC2 soap_instantiate_tas__MultiValuedRDN(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:28842 */
#ifndef SOAP_TYPE__tas__DistinguishedName_anyAttribute
#define SOAP_TYPE__tas__DistinguishedName_anyAttribute (1752)
/* complex XSD type 'tas:DistinguishedName-anyAttribute': */
class SOAP_CMAC _tas__DistinguishedName_anyAttribute {
      public:
        /// Optional element 'tas:DomainComponent' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> DomainComponent;
      public:
        /// Return unique type id SOAP_TYPE__tas__DistinguishedName_anyAttribute
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DistinguishedName_anyAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DistinguishedName_anyAttribute, default initialized and not managed by a soap context
        virtual _tas__DistinguishedName_anyAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DistinguishedName_anyAttribute); }
      public:
        /// Constructor with initializations
        _tas__DistinguishedName_anyAttribute() : DomainComponent() { }
        virtual ~_tas__DistinguishedName_anyAttribute() { }
        /// Friend allocator used by soap_new__tas__DistinguishedName_anyAttribute(struct soap*, int)
        friend SOAP_FMAC1 _tas__DistinguishedName_anyAttribute * SOAP_FMAC2 soap_instantiate__tas__DistinguishedName_anyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3004 */
#ifndef SOAP_TYPE_tas__DistinguishedName
#define SOAP_TYPE_tas__DistinguishedName (1037)
/* complex XSD type 'tas:DistinguishedName': */
class SOAP_CMAC tas__DistinguishedName {
      public:
        /// Optional element 'tas:Country' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Country;
        /// Optional element 'tas:Organization' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Organization;
        /// Optional element 'tas:OrganizationalUnit' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> OrganizationalUnit;
        /// Optional element 'tas:DistinguishedNameQualifier' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> DistinguishedNameQualifier;
        /// Optional element 'tas:StateOrProvinceName' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> StateOrProvinceName;
        /// Optional element 'tas:CommonName' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> CommonName;
        /// Optional element 'tas:SerialNumber' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> SerialNumber;
        /// Optional element 'tas:Locality' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Locality;
        /// Optional element 'tas:Title' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Title;
        /// Optional element 'tas:Surname' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Surname;
        /// Optional element 'tas:GivenName' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> GivenName;
        /// Optional element 'tas:Initials' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Initials;
        /// Optional element 'tas:Pseudonym' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> Pseudonym;
        /// Optional element 'tas:GenerationQualifier' of XSD type 'tas:DNAttributeValue'
        std::vector<std::string> GenerationQualifier;
        /// Optional element 'tas:GenericAttribute' of XSD type 'tas:DNAttributeTypeAndValue'
        std::vector<tas__DNAttributeTypeAndValue *> GenericAttribute;
        /// Optional element 'tas:MultiValuedRDN' of XSD type 'tas:MultiValuedRDN'
        std::vector<tas__MultiValuedRDN *> MultiValuedRDN;
        /// Optional element 'tas:anyAttribute' of XSD type 'tas:DistinguishedName-anyAttribute'
        _tas__DistinguishedName_anyAttribute *anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__DistinguishedName
        virtual long soap_type(void) const { return SOAP_TYPE_tas__DistinguishedName; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__DistinguishedName, default initialized and not managed by a soap context
        virtual tas__DistinguishedName *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__DistinguishedName); }
      public:
        /// Constructor with initializations
        tas__DistinguishedName() : Country(), Organization(), OrganizationalUnit(), DistinguishedNameQualifier(), StateOrProvinceName(), CommonName(), SerialNumber(), Locality(), Title(), Surname(), GivenName(), Initials(), Pseudonym(), GenerationQualifier(), GenericAttribute(), MultiValuedRDN(), anyAttribute(), soap() { }
        virtual ~tas__DistinguishedName() { }
        /// Friend allocator used by soap_new_tas__DistinguishedName(struct soap*, int)
        friend SOAP_FMAC1 tas__DistinguishedName * SOAP_FMAC2 soap_instantiate_tas__DistinguishedName(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:28901 */
#ifndef SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters
#define SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters (1755)
/* complex XSD type 'tas:AlgorithmIdentifier-anyParameters': */
class SOAP_CMAC _tas__AlgorithmIdentifier_anyParameters {
      public:
        /// Return unique type id SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AlgorithmIdentifier_anyParameters, default initialized and not managed by a soap context
        virtual _tas__AlgorithmIdentifier_anyParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AlgorithmIdentifier_anyParameters); }
      public:
        /// Constructor with initializations
        _tas__AlgorithmIdentifier_anyParameters() { }
        virtual ~_tas__AlgorithmIdentifier_anyParameters() { }
        /// Friend allocator used by soap_new__tas__AlgorithmIdentifier_anyParameters(struct soap*, int)
        friend SOAP_FMAC1 _tas__AlgorithmIdentifier_anyParameters * SOAP_FMAC2 soap_instantiate__tas__AlgorithmIdentifier_anyParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3007 */
#ifndef SOAP_TYPE_tas__AlgorithmIdentifier
#define SOAP_TYPE_tas__AlgorithmIdentifier (1038)
/* complex XSD type 'tas:AlgorithmIdentifier': */
class SOAP_CMAC tas__AlgorithmIdentifier {
      public:
        /// Required element 'tas:algorithm' of XSD type 'tas:DotDecimalOID'
        std::string algorithm;
        /// Optional element 'tas:parameters' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary *parameters;
        /// Optional element 'tas:anyParameters' of XSD type 'tas:AlgorithmIdentifier-anyParameters'
        _tas__AlgorithmIdentifier_anyParameters *anyParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__AlgorithmIdentifier
        virtual long soap_type(void) const { return SOAP_TYPE_tas__AlgorithmIdentifier; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__AlgorithmIdentifier, default initialized and not managed by a soap context
        virtual tas__AlgorithmIdentifier *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__AlgorithmIdentifier); }
      public:
        /// Constructor with initializations
        tas__AlgorithmIdentifier() : algorithm(), parameters(), anyParameters(), soap() { }
        virtual ~tas__AlgorithmIdentifier() { }
        /// Friend allocator used by soap_new_tas__AlgorithmIdentifier(struct soap*, int)
        friend SOAP_FMAC1 tas__AlgorithmIdentifier * SOAP_FMAC2 soap_instantiate_tas__AlgorithmIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3010 */
#ifndef SOAP_TYPE_tas__BasicRequestAttribute
#define SOAP_TYPE_tas__BasicRequestAttribute (1039)
/* complex XSD type 'tas:BasicRequestAttribute': */
class SOAP_CMAC tas__BasicRequestAttribute {
      public:
        /// Required element 'tas:OID' of XSD type 'tas:DotDecimalOID'
        std::string OID;
        /// Required element 'tas:value' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__BasicRequestAttribute
        virtual long soap_type(void) const { return SOAP_TYPE_tas__BasicRequestAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__BasicRequestAttribute, default initialized and not managed by a soap context
        virtual tas__BasicRequestAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__BasicRequestAttribute); }
      public:
        /// Constructor with initializations
        tas__BasicRequestAttribute() : OID(), value(), soap() { }
        virtual ~tas__BasicRequestAttribute() { }
        /// Friend allocator used by soap_new_tas__BasicRequestAttribute(struct soap*, int)
        friend SOAP_FMAC1 tas__BasicRequestAttribute * SOAP_FMAC2 soap_instantiate_tas__BasicRequestAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29001 */
#ifndef SOAP_TYPE__tas__CSRAttribute_anyAttribute
#define SOAP_TYPE__tas__CSRAttribute_anyAttribute (1759)
/* complex XSD type 'tas:CSRAttribute-anyAttribute': */
class SOAP_CMAC _tas__CSRAttribute_anyAttribute {
      public:
        /// Return unique type id SOAP_TYPE__tas__CSRAttribute_anyAttribute
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CSRAttribute_anyAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CSRAttribute_anyAttribute, default initialized and not managed by a soap context
        virtual _tas__CSRAttribute_anyAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CSRAttribute_anyAttribute); }
      public:
        /// Constructor with initializations
        _tas__CSRAttribute_anyAttribute() { }
        virtual ~_tas__CSRAttribute_anyAttribute() { }
        /// Friend allocator used by soap_new__tas__CSRAttribute_anyAttribute(struct soap*, int)
        friend SOAP_FMAC1 _tas__CSRAttribute_anyAttribute * SOAP_FMAC2 soap_instantiate__tas__CSRAttribute_anyAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29010 */
#ifndef SOAP_TYPE__tas__union_CSRAttribute
#define SOAP_TYPE__tas__union_CSRAttribute (1761)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tas__union_CSRAttribute
{
        #define SOAP_UNION__tas__union_CSRAttribute_X509v3Extension	(1)	/**< union variant selector value for member X509v3Extension */
        tas__X509v3Extension *X509v3Extension;
        #define SOAP_UNION__tas__union_CSRAttribute_BasicRequestAttribute	(2)	/**< union variant selector value for member BasicRequestAttribute */
        tas__BasicRequestAttribute *BasicRequestAttribute;
        #define SOAP_UNION__tas__union_CSRAttribute_anyAttribute	(3)	/**< union variant selector value for member anyAttribute */
        _tas__CSRAttribute_anyAttribute *anyAttribute;
};
#endif

/* onvif.h:3013 */
#ifndef SOAP_TYPE_tas__CSRAttribute
#define SOAP_TYPE_tas__CSRAttribute (1040)
/* Choice: */
class SOAP_CMAC tas__CSRAttribute {
      public:
        /// Union with union _tas__union_CSRAttribute variant selector __union_CSRAttribute set to one of: SOAP_UNION__tas__union_CSRAttribute_X509v3Extension SOAP_UNION__tas__union_CSRAttribute_BasicRequestAttribute SOAP_UNION__tas__union_CSRAttribute_anyAttribute
        int __union_CSRAttribute;
        union _tas__union_CSRAttribute union_CSRAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CSRAttribute
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CSRAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CSRAttribute, default initialized and not managed by a soap context
        virtual tas__CSRAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CSRAttribute); }
      public:
        /// Constructor with initializations
        tas__CSRAttribute() : __union_CSRAttribute(), soap() { }
        virtual ~tas__CSRAttribute() { }
        /// Friend allocator used by soap_new_tas__CSRAttribute(struct soap*, int)
        friend SOAP_FMAC1 tas__CSRAttribute * SOAP_FMAC2 soap_instantiate_tas__CSRAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3016 */
#ifndef SOAP_TYPE_tas__X509v3Extension
#define SOAP_TYPE_tas__X509v3Extension (1041)
/* complex XSD type 'tas:X509v3Extension': */
class SOAP_CMAC tas__X509v3Extension {
      public:
        /// Required element 'tas:extnOID' of XSD type 'tas:DotDecimalOID'
        std::string extnOID;
        /// Required element 'tas:critical' of XSD type 'xsd:boolean'
        bool critical;	///< initialized with default value = (bool)0
        /// Required element 'tas:extnValue' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary extnValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__X509v3Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tas__X509v3Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__X509v3Extension, default initialized and not managed by a soap context
        virtual tas__X509v3Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__X509v3Extension); }
      public:
        /// Constructor with initializations
        tas__X509v3Extension() : extnOID(), critical((bool)0), extnValue(), soap() { }
        virtual ~tas__X509v3Extension() { }
        /// Friend allocator used by soap_new_tas__X509v3Extension(struct soap*, int)
        friend SOAP_FMAC1 tas__X509v3Extension * SOAP_FMAC2 soap_instantiate_tas__X509v3Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3019 */
#ifndef SOAP_TYPE_tas__X509Certificate
#define SOAP_TYPE_tas__X509Certificate (1042)
/* complex XSD type 'tas:X509Certificate': */
class SOAP_CMAC tas__X509Certificate {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Required element 'tas:CertificateContent' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary CertificateContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__X509Certificate
        virtual long soap_type(void) const { return SOAP_TYPE_tas__X509Certificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__X509Certificate, default initialized and not managed by a soap context
        virtual tas__X509Certificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__X509Certificate); }
      public:
        /// Constructor with initializations
        tas__X509Certificate() : CertificateID(), KeyID(), Alias(), CertificateContent(), soap() { }
        virtual ~tas__X509Certificate() { }
        /// Friend allocator used by soap_new_tas__X509Certificate(struct soap*, int)
        friend SOAP_FMAC1 tas__X509Certificate * SOAP_FMAC2 soap_instantiate_tas__X509Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3022 */
#ifndef SOAP_TYPE_tas__CertificateIDs
#define SOAP_TYPE_tas__CertificateIDs (1043)
/* complex XSD type 'tas:CertificateIDs': */
class SOAP_CMAC tas__CertificateIDs {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::vector<std::string> CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CertificateIDs
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CertificateIDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CertificateIDs, default initialized and not managed by a soap context
        virtual tas__CertificateIDs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CertificateIDs); }
      public:
        /// Constructor with initializations
        tas__CertificateIDs() : CertificateID(), soap() { }
        virtual ~tas__CertificateIDs() { }
        /// Friend allocator used by soap_new_tas__CertificateIDs(struct soap*, int)
        friend SOAP_FMAC1 tas__CertificateIDs * SOAP_FMAC2 soap_instantiate_tas__CertificateIDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29184 */
#ifndef SOAP_TYPE__tas__CertificationPath_anyElement
#define SOAP_TYPE__tas__CertificationPath_anyElement (1763)
/* complex XSD type 'tas:CertificationPath-anyElement': */
class SOAP_CMAC _tas__CertificationPath_anyElement {
      public:
        /// Return unique type id SOAP_TYPE__tas__CertificationPath_anyElement
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CertificationPath_anyElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CertificationPath_anyElement, default initialized and not managed by a soap context
        virtual _tas__CertificationPath_anyElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CertificationPath_anyElement); }
      public:
        /// Constructor with initializations
        _tas__CertificationPath_anyElement() { }
        virtual ~_tas__CertificationPath_anyElement() { }
        /// Friend allocator used by soap_new__tas__CertificationPath_anyElement(struct soap*, int)
        friend SOAP_FMAC1 _tas__CertificationPath_anyElement * SOAP_FMAC2 soap_instantiate__tas__CertificationPath_anyElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3025 */
#ifndef SOAP_TYPE_tas__CertificationPath
#define SOAP_TYPE_tas__CertificationPath (1044)
/* complex XSD type 'tas:CertificationPath': */
class SOAP_CMAC tas__CertificationPath {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::vector<std::string> CertificateID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:anyElement' of XSD type 'tas:CertificationPath-anyElement'
        _tas__CertificationPath_anyElement *anyElement;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CertificationPath
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CertificationPath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CertificationPath, default initialized and not managed by a soap context
        virtual tas__CertificationPath *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CertificationPath); }
      public:
        /// Constructor with initializations
        tas__CertificationPath() : CertificateID(), Alias(), anyElement(), soap() { }
        virtual ~tas__CertificationPath() { }
        /// Friend allocator used by soap_new_tas__CertificationPath(struct soap*, int)
        friend SOAP_FMAC1 tas__CertificationPath * SOAP_FMAC2 soap_instantiate_tas__CertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3028 */
#ifndef SOAP_TYPE_tas__PassphraseAttribute
#define SOAP_TYPE_tas__PassphraseAttribute (1045)
/* complex XSD type 'tas:PassphraseAttribute': */
class SOAP_CMAC tas__PassphraseAttribute {
      public:
        /// Required element 'tas:PassphraseID' of XSD type 'tas:PassphraseID'
        std::string PassphraseID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__PassphraseAttribute
        virtual long soap_type(void) const { return SOAP_TYPE_tas__PassphraseAttribute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__PassphraseAttribute, default initialized and not managed by a soap context
        virtual tas__PassphraseAttribute *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__PassphraseAttribute); }
      public:
        /// Constructor with initializations
        tas__PassphraseAttribute() : PassphraseID(), Alias(), soap() { }
        virtual ~tas__PassphraseAttribute() { }
        /// Friend allocator used by soap_new_tas__PassphraseAttribute(struct soap*, int)
        friend SOAP_FMAC1 tas__PassphraseAttribute * SOAP_FMAC2 soap_instantiate_tas__PassphraseAttribute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3031 */
#ifndef SOAP_TYPE_tas__Dot1XCapabilities
#define SOAP_TYPE_tas__Dot1XCapabilities (1046)
/* complex XSD type 'tas:Dot1XCapabilities': */
class SOAP_CMAC tas__Dot1XCapabilities {
      public:
        /// optional attribute 'MaximumNumberOfDot1XConfigurations' of XSD type 'xsd:positiveInteger'
        std::string *MaximumNumberOfDot1XConfigurations;
        /// optional attribute 'Dot1XMethods' of XSD type 'tas:Dot1XMethods'
        std::string *Dot1XMethods;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__Dot1XCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tas__Dot1XCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__Dot1XCapabilities, default initialized and not managed by a soap context
        virtual tas__Dot1XCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__Dot1XCapabilities); }
      public:
        /// Constructor with initializations
        tas__Dot1XCapabilities() : MaximumNumberOfDot1XConfigurations(), Dot1XMethods(), soap() { }
        virtual ~tas__Dot1XCapabilities() { }
        /// Friend allocator used by soap_new_tas__Dot1XCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tas__Dot1XCapabilities * SOAP_FMAC2 soap_instantiate_tas__Dot1XCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3034 */
#ifndef SOAP_TYPE_tas__Dot1XStage
#define SOAP_TYPE_tas__Dot1XStage (1047)
/* Type tas__Dot1XStage is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tas:Dot1XStage': */
class SOAP_CMAC tas__Dot1XStage {
      public:
        /// Optional element 'tas:Identity' of XSD type 'xsd:string'
        std::string *Identity;
        /// Optional element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string *CertificationPathID;
        /// Optional element 'tas:PassphraseID' of XSD type 'tas:PassphraseID'
        std::string *PassphraseID;
        /// Optional element 'tas:Inner' of XSD type 'tas:Dot1XStage'
        tas__Dot1XStage *Inner;
        /// Optional element 'tas:Extension' of XSD type 'tas:Dot1XStageExtension'
        tas__Dot1XStageExtension *Extension;
        /// required attribute 'Method' of XSD type 'xsd:string'
        std::string Method;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__Dot1XStage
        virtual long soap_type(void) const { return SOAP_TYPE_tas__Dot1XStage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__Dot1XStage, default initialized and not managed by a soap context
        virtual tas__Dot1XStage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__Dot1XStage); }
      public:
        /// Constructor with initializations
        tas__Dot1XStage() : Identity(), CertificationPathID(), PassphraseID(), Inner(), Extension(), Method(), soap() { }
        virtual ~tas__Dot1XStage() { }
        /// Friend allocator used by soap_new_tas__Dot1XStage(struct soap*, int)
        friend SOAP_FMAC1 tas__Dot1XStage * SOAP_FMAC2 soap_instantiate_tas__Dot1XStage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3037 */
#ifndef SOAP_TYPE_tas__Dot1XStageExtension
#define SOAP_TYPE_tas__Dot1XStageExtension (1048)
/* complex XSD type 'tas:Dot1XStageExtension': */
class SOAP_CMAC tas__Dot1XStageExtension {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__Dot1XStageExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tas__Dot1XStageExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__Dot1XStageExtension, default initialized and not managed by a soap context
        virtual tas__Dot1XStageExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__Dot1XStageExtension); }
      public:
        /// Constructor with initializations
        tas__Dot1XStageExtension() : soap() { }
        virtual ~tas__Dot1XStageExtension() { }
        /// Friend allocator used by soap_new_tas__Dot1XStageExtension(struct soap*, int)
        friend SOAP_FMAC1 tas__Dot1XStageExtension * SOAP_FMAC2 soap_instantiate_tas__Dot1XStageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3040 */
#ifndef SOAP_TYPE_tas__Dot1XConfiguration
#define SOAP_TYPE_tas__Dot1XConfiguration (1049)
/* complex XSD type 'tas:Dot1XConfiguration': */
class SOAP_CMAC tas__Dot1XConfiguration {
      public:
        /// Optional element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string *Dot1XID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Required element 'tas:Outer' of XSD type 'tas:Dot1XStage'
        tas__Dot1XStage *Outer;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__Dot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tas__Dot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__Dot1XConfiguration, default initialized and not managed by a soap context
        virtual tas__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__Dot1XConfiguration); }
      public:
        /// Constructor with initializations
        tas__Dot1XConfiguration() : Dot1XID(), Alias(), Outer(), soap() { }
        virtual ~tas__Dot1XConfiguration() { }
        /// Friend allocator used by soap_new_tas__Dot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tas__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tas__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3043 */
#ifndef SOAP_TYPE_tas__CRL
#define SOAP_TYPE_tas__CRL (1050)
/* complex XSD type 'tas:CRL': */
class SOAP_CMAC tas__CRL {
      public:
        /// Required element 'tas:CRLID' of XSD type 'tas:CRLID'
        std::string CRLID;
        /// Required element 'tas:Alias' of XSD type 'xsd:string'
        std::string Alias;
        /// Required element 'tas:CRLContent' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary CRLContent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CRL
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CRL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CRL, default initialized and not managed by a soap context
        virtual tas__CRL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CRL); }
      public:
        /// Constructor with initializations
        tas__CRL() : CRLID(), Alias(), CRLContent(), soap() { }
        virtual ~tas__CRL() { }
        /// Friend allocator used by soap_new_tas__CRL(struct soap*, int)
        friend SOAP_FMAC1 tas__CRL * SOAP_FMAC2 soap_instantiate_tas__CRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29461 */
#ifndef SOAP_TYPE__tas__CertPathValidationParameters_anyParameters
#define SOAP_TYPE__tas__CertPathValidationParameters_anyParameters (1772)
/* complex XSD type 'tas:CertPathValidationParameters-anyParameters': */
class SOAP_CMAC _tas__CertPathValidationParameters_anyParameters {
      public:
        /// Return unique type id SOAP_TYPE__tas__CertPathValidationParameters_anyParameters
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CertPathValidationParameters_anyParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CertPathValidationParameters_anyParameters, default initialized and not managed by a soap context
        virtual _tas__CertPathValidationParameters_anyParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CertPathValidationParameters_anyParameters); }
      public:
        /// Constructor with initializations
        _tas__CertPathValidationParameters_anyParameters() { }
        virtual ~_tas__CertPathValidationParameters_anyParameters() { }
        /// Friend allocator used by soap_new__tas__CertPathValidationParameters_anyParameters(struct soap*, int)
        friend SOAP_FMAC1 _tas__CertPathValidationParameters_anyParameters * SOAP_FMAC2 soap_instantiate__tas__CertPathValidationParameters_anyParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3046 */
#ifndef SOAP_TYPE_tas__CertPathValidationParameters
#define SOAP_TYPE_tas__CertPathValidationParameters (1051)
/* complex XSD type 'tas:CertPathValidationParameters': */
class SOAP_CMAC tas__CertPathValidationParameters {
      public:
        /// Optional element 'tas:RequireTLSWWWClientAuthExtendedKeyUsage' of XSD type 'xsd:boolean'
        bool *RequireTLSWWWClientAuthExtendedKeyUsage;	///< optional with default value = (bool)0
        /// Optional element 'tas:UseDeltaCRLs' of XSD type 'xsd:boolean'
        bool *UseDeltaCRLs;	///< optional with default value = (bool)0
        /// Optional element 'tas:anyParameters' of XSD type 'tas:CertPathValidationParameters-anyParameters'
        _tas__CertPathValidationParameters_anyParameters *anyParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CertPathValidationParameters
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CertPathValidationParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CertPathValidationParameters, default initialized and not managed by a soap context
        virtual tas__CertPathValidationParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CertPathValidationParameters); }
      public:
        /// Constructor with initializations
        tas__CertPathValidationParameters() : RequireTLSWWWClientAuthExtendedKeyUsage(), UseDeltaCRLs(), anyParameters(), soap() { }
        virtual ~tas__CertPathValidationParameters() { }
        /// Friend allocator used by soap_new_tas__CertPathValidationParameters(struct soap*, int)
        friend SOAP_FMAC1 tas__CertPathValidationParameters * SOAP_FMAC2 soap_instantiate_tas__CertPathValidationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3049 */
#ifndef SOAP_TYPE_tas__TrustAnchor
#define SOAP_TYPE_tas__TrustAnchor (1052)
/* complex XSD type 'tas:TrustAnchor': */
class SOAP_CMAC tas__TrustAnchor {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__TrustAnchor
        virtual long soap_type(void) const { return SOAP_TYPE_tas__TrustAnchor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__TrustAnchor, default initialized and not managed by a soap context
        virtual tas__TrustAnchor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__TrustAnchor); }
      public:
        /// Constructor with initializations
        tas__TrustAnchor() : CertificateID(), soap() { }
        virtual ~tas__TrustAnchor() { }
        /// Friend allocator used by soap_new_tas__TrustAnchor(struct soap*, int)
        friend SOAP_FMAC1 tas__TrustAnchor * SOAP_FMAC2 soap_instantiate_tas__TrustAnchor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29533 */
#ifndef SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters
#define SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters (1777)
/* complex XSD type 'tas:CertPathValidationPolicy-anyParameters': */
class SOAP_CMAC _tas__CertPathValidationPolicy_anyParameters {
      public:
        /// Return unique type id SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CertPathValidationPolicy_anyParameters, default initialized and not managed by a soap context
        virtual _tas__CertPathValidationPolicy_anyParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CertPathValidationPolicy_anyParameters); }
      public:
        /// Constructor with initializations
        _tas__CertPathValidationPolicy_anyParameters() { }
        virtual ~_tas__CertPathValidationPolicy_anyParameters() { }
        /// Friend allocator used by soap_new__tas__CertPathValidationPolicy_anyParameters(struct soap*, int)
        friend SOAP_FMAC1 _tas__CertPathValidationPolicy_anyParameters * SOAP_FMAC2 soap_instantiate__tas__CertPathValidationPolicy_anyParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3052 */
#ifndef SOAP_TYPE_tas__CertPathValidationPolicy
#define SOAP_TYPE_tas__CertPathValidationPolicy (1053)
/* complex XSD type 'tas:CertPathValidationPolicy': */
class SOAP_CMAC tas__CertPathValidationPolicy {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Required element 'tas:Parameters' of XSD type 'tas:CertPathValidationParameters'
        tas__CertPathValidationParameters *Parameters;
        /// Required element 'tas:TrustAnchor' of XSD type 'tas:TrustAnchor'
        std::vector<tas__TrustAnchor *> TrustAnchor;
        /// Optional element 'tas:anyParameters' of XSD type 'tas:CertPathValidationPolicy-anyParameters'
        _tas__CertPathValidationPolicy_anyParameters *anyParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__CertPathValidationPolicy
        virtual long soap_type(void) const { return SOAP_TYPE_tas__CertPathValidationPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__CertPathValidationPolicy, default initialized and not managed by a soap context
        virtual tas__CertPathValidationPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__CertPathValidationPolicy); }
      public:
        /// Constructor with initializations
        tas__CertPathValidationPolicy() : CertPathValidationPolicyID(), Alias(), Parameters(), TrustAnchor(), anyParameters(), soap() { }
        virtual ~tas__CertPathValidationPolicy() { }
        /// Friend allocator used by soap_new_tas__CertPathValidationPolicy(struct soap*, int)
        friend SOAP_FMAC1 tas__CertPathValidationPolicy * SOAP_FMAC2 soap_instantiate_tas__CertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:29577 */
#ifndef SOAP_TYPE__tas__KeystoreCapabilities_anyElement
#define SOAP_TYPE__tas__KeystoreCapabilities_anyElement (1781)
/* complex XSD type 'tas:KeystoreCapabilities-anyElement': */
class SOAP_CMAC _tas__KeystoreCapabilities_anyElement {
      public:
        /// Return unique type id SOAP_TYPE__tas__KeystoreCapabilities_anyElement
        virtual long soap_type(void) const { return SOAP_TYPE__tas__KeystoreCapabilities_anyElement; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__KeystoreCapabilities_anyElement, default initialized and not managed by a soap context
        virtual _tas__KeystoreCapabilities_anyElement *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__KeystoreCapabilities_anyElement); }
      public:
        /// Constructor with initializations
        _tas__KeystoreCapabilities_anyElement() { }
        virtual ~_tas__KeystoreCapabilities_anyElement() { }
        /// Friend allocator used by soap_new__tas__KeystoreCapabilities_anyElement(struct soap*, int)
        friend SOAP_FMAC1 _tas__KeystoreCapabilities_anyElement * SOAP_FMAC2 soap_instantiate__tas__KeystoreCapabilities_anyElement(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3055 */
#ifndef SOAP_TYPE_tas__KeystoreCapabilities
#define SOAP_TYPE_tas__KeystoreCapabilities (1054)
/* complex XSD type 'tas:KeystoreCapabilities': */
class SOAP_CMAC tas__KeystoreCapabilities {
      public:
        /// Optional element 'tas:SignatureAlgorithms' of XSD type 'tas:AlgorithmIdentifier'
        std::vector<tas__AlgorithmIdentifier *> SignatureAlgorithms;
        /// Optional element 'tas:anyElement' of XSD type 'tas:KeystoreCapabilities-anyElement'
        _tas__KeystoreCapabilities_anyElement *anyElement;
        /// optional attribute 'MaximumNumberOfKeys' of XSD type 'xsd:positiveInteger'
        std::string *MaximumNumberOfKeys;
        /// optional attribute 'MaximumNumberOfCertificates' of XSD type 'xsd:positiveInteger'
        std::string *MaximumNumberOfCertificates;
        /// optional attribute 'MaximumNumberOfCertificationPaths' of XSD type 'xsd:positiveInteger'
        std::string *MaximumNumberOfCertificationPaths;
        /// optional attribute 'RSAKeyPairGeneration' of XSD type 'xsd:boolean'
        bool *RSAKeyPairGeneration;
        /// optional attribute 'RSAKeyLengths' of XSD type 'tas:RSAKeyLengths'
        std::string *RSAKeyLengths;
        /// optional attribute 'PKCS10ExternalCertificationWithRSA' of XSD type 'xsd:boolean'
        bool *PKCS10ExternalCertificationWithRSA;
        /// optional attribute 'SelfSignedCertificateCreationWithRSA' of XSD type 'xsd:boolean'
        bool *SelfSignedCertificateCreationWithRSA;
        /// optional attribute 'X509Versions' of XSD type 'tas:X509Versions'
        std::string *X509Versions;
        /// optional attribute 'MaximumNumberOfPassphrases' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumberOfPassphrases;
        /// optional attribute 'PKCS8RSAKeyPairUpload' of XSD type 'xsd:boolean'
        bool *PKCS8RSAKeyPairUpload;
        /// optional attribute 'PKCS12CertificateWithRSAPrivateKeyUpload' of XSD type 'xsd:boolean'
        bool *PKCS12CertificateWithRSAPrivateKeyUpload;
        /// optional attribute 'PasswordBasedEncryptionAlgorithms' of XSD type 'tas:PasswordBasedEncryptionAlgorithms'
        std::string *PasswordBasedEncryptionAlgorithms;
        /// optional attribute 'PasswordBasedMACAlgorithms' of XSD type 'tas:PasswordBasedMACAlgorithms'
        std::string *PasswordBasedMACAlgorithms;
        /// optional attribute 'MaximumNumberOfCRLs' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumberOfCRLs;
        /// optional attribute 'MaximumNumberOfCertificationPathValidationPolicies' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumberOfCertificationPathValidationPolicies;
        /// optional attribute 'EnforceTLSWebClientAuthExtKeyUsage' of XSD type 'xsd:boolean'
        bool *EnforceTLSWebClientAuthExtKeyUsage;
        /// optional attribute 'NoPrivateKeySharing' of XSD type 'xsd:boolean'
        bool *NoPrivateKeySharing;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__KeystoreCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tas__KeystoreCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__KeystoreCapabilities, default initialized and not managed by a soap context
        virtual tas__KeystoreCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__KeystoreCapabilities); }
      public:
        /// Constructor with initializations
        tas__KeystoreCapabilities() : SignatureAlgorithms(), anyElement(), MaximumNumberOfKeys(), MaximumNumberOfCertificates(), MaximumNumberOfCertificationPaths(), RSAKeyPairGeneration(), RSAKeyLengths(), PKCS10ExternalCertificationWithRSA(), SelfSignedCertificateCreationWithRSA(), X509Versions(), MaximumNumberOfPassphrases(), PKCS8RSAKeyPairUpload(), PKCS12CertificateWithRSAPrivateKeyUpload(), PasswordBasedEncryptionAlgorithms(), PasswordBasedMACAlgorithms(), MaximumNumberOfCRLs(), MaximumNumberOfCertificationPathValidationPolicies(), EnforceTLSWebClientAuthExtKeyUsage(), NoPrivateKeySharing(), soap() { }
        virtual ~tas__KeystoreCapabilities() { }
        /// Friend allocator used by soap_new_tas__KeystoreCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tas__KeystoreCapabilities * SOAP_FMAC2 soap_instantiate_tas__KeystoreCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3058 */
#ifndef SOAP_TYPE_tas__TLSServerCapabilities
#define SOAP_TYPE_tas__TLSServerCapabilities (1055)
/* complex XSD type 'tas:TLSServerCapabilities': */
class SOAP_CMAC tas__TLSServerCapabilities {
      public:
        /// optional attribute 'TLSServerSupported' of XSD type 'tas:TLSVersions'
        std::string *TLSServerSupported;
        /// optional attribute 'EnabledVersionsSupported' of XSD type 'xsd:boolean'
        bool *EnabledVersionsSupported;
        /// optional attribute 'MaximumNumberOfTLSCertificationPaths' of XSD type 'xsd:positiveInteger'
        std::string *MaximumNumberOfTLSCertificationPaths;
        /// optional attribute 'TLSClientAuthSupported' of XSD type 'xsd:boolean'
        bool *TLSClientAuthSupported;
        /// optional attribute 'MaximumNumberOfTLSCertificationPathValidationPolicies' of XSD type 'xsd:nonNegativeInteger'
        std::string *MaximumNumberOfTLSCertificationPathValidationPolicies;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__TLSServerCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tas__TLSServerCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__TLSServerCapabilities, default initialized and not managed by a soap context
        virtual tas__TLSServerCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__TLSServerCapabilities); }
      public:
        /// Constructor with initializations
        tas__TLSServerCapabilities() : TLSServerSupported(), EnabledVersionsSupported(), MaximumNumberOfTLSCertificationPaths(), TLSClientAuthSupported(), MaximumNumberOfTLSCertificationPathValidationPolicies(), soap() { }
        virtual ~tas__TLSServerCapabilities() { }
        /// Friend allocator used by soap_new_tas__TLSServerCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tas__TLSServerCapabilities * SOAP_FMAC2 soap_instantiate_tas__TLSServerCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3061 */
#ifndef SOAP_TYPE_tas__Capabilities
#define SOAP_TYPE_tas__Capabilities (1056)
/* complex XSD type 'tas:Capabilities': */
class SOAP_CMAC tas__Capabilities {
      public:
        /// Required element 'tas:KeystoreCapabilities' of XSD type 'tas:KeystoreCapabilities'
        tas__KeystoreCapabilities *KeystoreCapabilities;
        /// Required element 'tas:TLSServerCapabilities' of XSD type 'tas:TLSServerCapabilities'
        tas__TLSServerCapabilities *TLSServerCapabilities;
        /// Optional element 'tas:Dot1XCapabilities' of XSD type 'tas:Dot1XCapabilities'
        tas__Dot1XCapabilities *Dot1XCapabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tas__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tas__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tas__Capabilities, default initialized and not managed by a soap context
        virtual tas__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tas__Capabilities); }
      public:
        /// Constructor with initializations
        tas__Capabilities() : KeystoreCapabilities(), TLSServerCapabilities(), Dot1XCapabilities(), soap() { }
        virtual ~tas__Capabilities() { }
        /// Friend allocator used by soap_new_tas__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tas__Capabilities * SOAP_FMAC2 soap_instantiate_tas__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3064 */
#ifndef SOAP_TYPE__tas__GetServiceCapabilities
#define SOAP_TYPE__tas__GetServiceCapabilities (1057)
/* complex XSD type 'tas:GetServiceCapabilities': */
class SOAP_CMAC _tas__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tas__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetServiceCapabilities); }
      public:
        /// Constructor with initializations
        _tas__GetServiceCapabilities() : soap() { }
        virtual ~_tas__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tas__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tas__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3067 */
#ifndef SOAP_TYPE__tas__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tas__GetServiceCapabilitiesResponse (1058)
/* complex XSD type 'tas:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tas__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tas:Capabilities' of XSD type 'tas:Capabilities'
        tas__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tas__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        virtual ~_tas__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tas__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tas__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3070 */
#ifndef SOAP_TYPE__tas__CreateRSAKeyPair
#define SOAP_TYPE__tas__CreateRSAKeyPair (1059)
/* complex XSD type 'tas:CreateRSAKeyPair': */
class SOAP_CMAC _tas__CreateRSAKeyPair {
      public:
        /// Required element 'tas:KeyLength' of XSD type 'xsd:nonNegativeInteger'
        std::string KeyLength;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateRSAKeyPair
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateRSAKeyPair; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateRSAKeyPair, default initialized and not managed by a soap context
        virtual _tas__CreateRSAKeyPair *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateRSAKeyPair); }
      public:
        /// Constructor with initializations
        _tas__CreateRSAKeyPair() : KeyLength(), Alias(), soap() { }
        virtual ~_tas__CreateRSAKeyPair() { }
        /// Friend allocator used by soap_new__tas__CreateRSAKeyPair(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateRSAKeyPair * SOAP_FMAC2 soap_instantiate__tas__CreateRSAKeyPair(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3073 */
#ifndef SOAP_TYPE__tas__CreateRSAKeyPairResponse
#define SOAP_TYPE__tas__CreateRSAKeyPairResponse (1060)
/* complex XSD type 'tas:CreateRSAKeyPairResponse': */
class SOAP_CMAC _tas__CreateRSAKeyPairResponse {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Required element 'tas:EstimatedCreationTime' of XSD type 'xsd:duration'
        std::string EstimatedCreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateRSAKeyPairResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateRSAKeyPairResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateRSAKeyPairResponse, default initialized and not managed by a soap context
        virtual _tas__CreateRSAKeyPairResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateRSAKeyPairResponse); }
      public:
        /// Constructor with initializations
        _tas__CreateRSAKeyPairResponse() : KeyID(), EstimatedCreationTime(), soap() { }
        virtual ~_tas__CreateRSAKeyPairResponse() { }
        /// Friend allocator used by soap_new__tas__CreateRSAKeyPairResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateRSAKeyPairResponse * SOAP_FMAC2 soap_instantiate__tas__CreateRSAKeyPairResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3076 */
#ifndef SOAP_TYPE__tas__UploadKeyPairInPKCS8
#define SOAP_TYPE__tas__UploadKeyPairInPKCS8 (1061)
/* complex XSD type 'tas:UploadKeyPairInPKCS8': */
class SOAP_CMAC _tas__UploadKeyPairInPKCS8 {
      public:
        /// Required element 'tas:KeyPair' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary KeyPair;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:EncryptionPassphraseID' of XSD type 'tas:PassphraseID'
        std::string *EncryptionPassphraseID;
        /// Optional element 'tas:EncryptionPassphrase' of XSD type 'xsd:string'
        std::string *EncryptionPassphrase;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadKeyPairInPKCS8
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadKeyPairInPKCS8; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadKeyPairInPKCS8, default initialized and not managed by a soap context
        virtual _tas__UploadKeyPairInPKCS8 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadKeyPairInPKCS8); }
      public:
        /// Constructor with initializations
        _tas__UploadKeyPairInPKCS8() : KeyPair(), Alias(), EncryptionPassphraseID(), EncryptionPassphrase(), soap() { }
        virtual ~_tas__UploadKeyPairInPKCS8() { }
        /// Friend allocator used by soap_new__tas__UploadKeyPairInPKCS8(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadKeyPairInPKCS8 * SOAP_FMAC2 soap_instantiate__tas__UploadKeyPairInPKCS8(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3079 */
#ifndef SOAP_TYPE__tas__UploadKeyPairInPKCS8Response
#define SOAP_TYPE__tas__UploadKeyPairInPKCS8Response (1062)
/* complex XSD type 'tas:UploadKeyPairInPKCS8Response': */
class SOAP_CMAC _tas__UploadKeyPairInPKCS8Response {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadKeyPairInPKCS8Response
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadKeyPairInPKCS8Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadKeyPairInPKCS8Response, default initialized and not managed by a soap context
        virtual _tas__UploadKeyPairInPKCS8Response *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadKeyPairInPKCS8Response); }
      public:
        /// Constructor with initializations
        _tas__UploadKeyPairInPKCS8Response() : KeyID(), soap() { }
        virtual ~_tas__UploadKeyPairInPKCS8Response() { }
        /// Friend allocator used by soap_new__tas__UploadKeyPairInPKCS8Response(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadKeyPairInPKCS8Response * SOAP_FMAC2 soap_instantiate__tas__UploadKeyPairInPKCS8Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3082 */
#ifndef SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12
#define SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12 (1063)
/* complex XSD type 'tas:UploadCertificateWithPrivateKeyInPKCS12': */
class SOAP_CMAC _tas__UploadCertificateWithPrivateKeyInPKCS12 {
      public:
        /// Required element 'tas:CertWithPrivateKey' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary CertWithPrivateKey;
        /// Optional element 'tas:CertificationPathAlias' of XSD type 'xsd:string'
        std::string *CertificationPathAlias;
        /// Optional element 'tas:KeyAlias' of XSD type 'xsd:string'
        std::string *KeyAlias;
        /// Optional element 'tas:IgnoreAdditionalCertificates' of XSD type 'xsd:boolean'
        bool *IgnoreAdditionalCertificates;	///< optional with default value = (bool)0
        /// Optional element 'tas:IntegrityPassphraseID' of XSD type 'tas:PassphraseID'
        std::string *IntegrityPassphraseID;
        /// Optional element 'tas:EncryptionPassphraseID' of XSD type 'tas:PassphraseID'
        std::string *EncryptionPassphraseID;
        /// Optional element 'tas:Passphrase' of XSD type 'xsd:string'
        std::string *Passphrase;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCertificateWithPrivateKeyInPKCS12, default initialized and not managed by a soap context
        virtual _tas__UploadCertificateWithPrivateKeyInPKCS12 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCertificateWithPrivateKeyInPKCS12); }
      public:
        /// Constructor with initializations
        _tas__UploadCertificateWithPrivateKeyInPKCS12() : CertWithPrivateKey(), CertificationPathAlias(), KeyAlias(), IgnoreAdditionalCertificates(), IntegrityPassphraseID(), EncryptionPassphraseID(), Passphrase(), soap() { }
        virtual ~_tas__UploadCertificateWithPrivateKeyInPKCS12() { }
        /// Friend allocator used by soap_new__tas__UploadCertificateWithPrivateKeyInPKCS12(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCertificateWithPrivateKeyInPKCS12 * SOAP_FMAC2 soap_instantiate__tas__UploadCertificateWithPrivateKeyInPKCS12(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3085 */
#ifndef SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response
#define SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response (1064)
/* complex XSD type 'tas:UploadCertificateWithPrivateKeyInPKCS12Response': */
class SOAP_CMAC _tas__UploadCertificateWithPrivateKeyInPKCS12Response {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCertificateWithPrivateKeyInPKCS12Response, default initialized and not managed by a soap context
        virtual _tas__UploadCertificateWithPrivateKeyInPKCS12Response *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCertificateWithPrivateKeyInPKCS12Response); }
      public:
        /// Constructor with initializations
        _tas__UploadCertificateWithPrivateKeyInPKCS12Response() : CertificationPathID(), KeyID(), soap() { }
        virtual ~_tas__UploadCertificateWithPrivateKeyInPKCS12Response() { }
        /// Friend allocator used by soap_new__tas__UploadCertificateWithPrivateKeyInPKCS12Response(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCertificateWithPrivateKeyInPKCS12Response * SOAP_FMAC2 soap_instantiate__tas__UploadCertificateWithPrivateKeyInPKCS12Response(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3088 */
#ifndef SOAP_TYPE__tas__GetKeyStatus
#define SOAP_TYPE__tas__GetKeyStatus (1065)
/* complex XSD type 'tas:GetKeyStatus': */
class SOAP_CMAC _tas__GetKeyStatus {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetKeyStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetKeyStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetKeyStatus, default initialized and not managed by a soap context
        virtual _tas__GetKeyStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetKeyStatus); }
      public:
        /// Constructor with initializations
        _tas__GetKeyStatus() : KeyID(), soap() { }
        virtual ~_tas__GetKeyStatus() { }
        /// Friend allocator used by soap_new__tas__GetKeyStatus(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetKeyStatus * SOAP_FMAC2 soap_instantiate__tas__GetKeyStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3091 */
#ifndef SOAP_TYPE__tas__GetKeyStatusResponse
#define SOAP_TYPE__tas__GetKeyStatusResponse (1066)
/* complex XSD type 'tas:GetKeyStatusResponse': */
class SOAP_CMAC _tas__GetKeyStatusResponse {
      public:
        /// Required element 'tas:KeyStatus' of XSD type 'xsd:string'
        std::string KeyStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetKeyStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetKeyStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetKeyStatusResponse, default initialized and not managed by a soap context
        virtual _tas__GetKeyStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetKeyStatusResponse); }
      public:
        /// Constructor with initializations
        _tas__GetKeyStatusResponse() : KeyStatus(), soap() { }
        virtual ~_tas__GetKeyStatusResponse() { }
        /// Friend allocator used by soap_new__tas__GetKeyStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetKeyStatusResponse * SOAP_FMAC2 soap_instantiate__tas__GetKeyStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3094 */
#ifndef SOAP_TYPE__tas__GetPrivateKeyStatus
#define SOAP_TYPE__tas__GetPrivateKeyStatus (1067)
/* complex XSD type 'tas:GetPrivateKeyStatus': */
class SOAP_CMAC _tas__GetPrivateKeyStatus {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetPrivateKeyStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetPrivateKeyStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetPrivateKeyStatus, default initialized and not managed by a soap context
        virtual _tas__GetPrivateKeyStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetPrivateKeyStatus); }
      public:
        /// Constructor with initializations
        _tas__GetPrivateKeyStatus() : KeyID(), soap() { }
        virtual ~_tas__GetPrivateKeyStatus() { }
        /// Friend allocator used by soap_new__tas__GetPrivateKeyStatus(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetPrivateKeyStatus * SOAP_FMAC2 soap_instantiate__tas__GetPrivateKeyStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3097 */
#ifndef SOAP_TYPE__tas__GetPrivateKeyStatusResponse
#define SOAP_TYPE__tas__GetPrivateKeyStatusResponse (1068)
/* complex XSD type 'tas:GetPrivateKeyStatusResponse': */
class SOAP_CMAC _tas__GetPrivateKeyStatusResponse {
      public:
        /// Required element 'tas:hasPrivateKey' of XSD type 'xsd:boolean'
        bool hasPrivateKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetPrivateKeyStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetPrivateKeyStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetPrivateKeyStatusResponse, default initialized and not managed by a soap context
        virtual _tas__GetPrivateKeyStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetPrivateKeyStatusResponse); }
      public:
        /// Constructor with initializations
        _tas__GetPrivateKeyStatusResponse() : hasPrivateKey(), soap() { }
        virtual ~_tas__GetPrivateKeyStatusResponse() { }
        /// Friend allocator used by soap_new__tas__GetPrivateKeyStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetPrivateKeyStatusResponse * SOAP_FMAC2 soap_instantiate__tas__GetPrivateKeyStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3100 */
#ifndef SOAP_TYPE__tas__GetAllKeys
#define SOAP_TYPE__tas__GetAllKeys (1069)
/* complex XSD type 'tas:GetAllKeys': */
class SOAP_CMAC _tas__GetAllKeys {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllKeys
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllKeys; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllKeys, default initialized and not managed by a soap context
        virtual _tas__GetAllKeys *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllKeys); }
      public:
        /// Constructor with initializations
        _tas__GetAllKeys() : soap() { }
        virtual ~_tas__GetAllKeys() { }
        /// Friend allocator used by soap_new__tas__GetAllKeys(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllKeys * SOAP_FMAC2 soap_instantiate__tas__GetAllKeys(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3103 */
#ifndef SOAP_TYPE__tas__GetAllKeysResponse
#define SOAP_TYPE__tas__GetAllKeysResponse (1070)
/* complex XSD type 'tas:GetAllKeysResponse': */
class SOAP_CMAC _tas__GetAllKeysResponse {
      public:
        /// Optional element 'tas:KeyAttribute' of XSD type 'tas:KeyAttribute'
        std::vector<tas__KeyAttribute *> KeyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllKeysResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllKeysResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllKeysResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllKeysResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllKeysResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllKeysResponse() : KeyAttribute(), soap() { }
        virtual ~_tas__GetAllKeysResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllKeysResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllKeysResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllKeysResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3106 */
#ifndef SOAP_TYPE__tas__DeleteKey
#define SOAP_TYPE__tas__DeleteKey (1071)
/* complex XSD type 'tas:DeleteKey': */
class SOAP_CMAC _tas__DeleteKey {
      public:
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteKey
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteKey, default initialized and not managed by a soap context
        virtual _tas__DeleteKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteKey); }
      public:
        /// Constructor with initializations
        _tas__DeleteKey() : KeyID(), soap() { }
        virtual ~_tas__DeleteKey() { }
        /// Friend allocator used by soap_new__tas__DeleteKey(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteKey * SOAP_FMAC2 soap_instantiate__tas__DeleteKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3109 */
#ifndef SOAP_TYPE__tas__DeleteKeyResponse
#define SOAP_TYPE__tas__DeleteKeyResponse (1072)
/* complex XSD type 'tas:DeleteKeyResponse': */
class SOAP_CMAC _tas__DeleteKeyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteKeyResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteKeyResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteKeyResponse() : soap() { }
        virtual ~_tas__DeleteKeyResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteKeyResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3112 */
#ifndef SOAP_TYPE__tas__CreatePKCS10CSR
#define SOAP_TYPE__tas__CreatePKCS10CSR (1073)
/* complex XSD type 'tas:CreatePKCS10CSR': */
class SOAP_CMAC _tas__CreatePKCS10CSR {
      public:
        /// Required element 'tas:Subject' of XSD type 'tas:DistinguishedName'
        tas__DistinguishedName *Subject;
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Optional element 'tas:CSRAttribute' of XSD type 'tas:CSRAttribute'
        std::vector<tas__CSRAttribute *> CSRAttribute;
        /// Required element 'tas:SignatureAlgorithm' of XSD type 'tas:AlgorithmIdentifier'
        tas__AlgorithmIdentifier *SignatureAlgorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreatePKCS10CSR
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreatePKCS10CSR; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreatePKCS10CSR, default initialized and not managed by a soap context
        virtual _tas__CreatePKCS10CSR *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreatePKCS10CSR); }
      public:
        /// Constructor with initializations
        _tas__CreatePKCS10CSR() : Subject(), KeyID(), CSRAttribute(), SignatureAlgorithm(), soap() { }
        virtual ~_tas__CreatePKCS10CSR() { }
        /// Friend allocator used by soap_new__tas__CreatePKCS10CSR(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreatePKCS10CSR * SOAP_FMAC2 soap_instantiate__tas__CreatePKCS10CSR(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3115 */
#ifndef SOAP_TYPE__tas__CreatePKCS10CSRResponse
#define SOAP_TYPE__tas__CreatePKCS10CSRResponse (1074)
/* complex XSD type 'tas:CreatePKCS10CSRResponse': */
class SOAP_CMAC _tas__CreatePKCS10CSRResponse {
      public:
        /// Required element 'tas:PKCS10CSR' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary PKCS10CSR;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreatePKCS10CSRResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreatePKCS10CSRResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreatePKCS10CSRResponse, default initialized and not managed by a soap context
        virtual _tas__CreatePKCS10CSRResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreatePKCS10CSRResponse); }
      public:
        /// Constructor with initializations
        _tas__CreatePKCS10CSRResponse() : PKCS10CSR(), soap() { }
        virtual ~_tas__CreatePKCS10CSRResponse() { }
        /// Friend allocator used by soap_new__tas__CreatePKCS10CSRResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreatePKCS10CSRResponse * SOAP_FMAC2 soap_instantiate__tas__CreatePKCS10CSRResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3118 */
#ifndef SOAP_TYPE__tas__CreateSelfSignedCertificate
#define SOAP_TYPE__tas__CreateSelfSignedCertificate (1075)
/* complex XSD type 'tas:CreateSelfSignedCertificate': */
class SOAP_CMAC _tas__CreateSelfSignedCertificate {
      public:
        /// Optional element 'tas:X509Version' of XSD type 'xsd:positiveInteger'
        std::string *X509Version;
        /// Required element 'tas:Subject' of XSD type 'tas:DistinguishedName'
        tas__DistinguishedName *Subject;
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:notValidBefore' of XSD type 'xsd:dateTime'
        time_t *notValidBefore;
        /// Optional element 'tas:notValidAfter' of XSD type 'xsd:dateTime'
        time_t *notValidAfter;
        /// Required element 'tas:SignatureAlgorithm' of XSD type 'tas:AlgorithmIdentifier'
        tas__AlgorithmIdentifier *SignatureAlgorithm;
        /// Optional element 'tas:Extension' of XSD type 'tas:X509v3Extension'
        std::vector<tas__X509v3Extension *> Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateSelfSignedCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateSelfSignedCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateSelfSignedCertificate, default initialized and not managed by a soap context
        virtual _tas__CreateSelfSignedCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateSelfSignedCertificate); }
      public:
        /// Constructor with initializations
        _tas__CreateSelfSignedCertificate() : X509Version(), Subject(), KeyID(), Alias(), notValidBefore(), notValidAfter(), SignatureAlgorithm(), Extension(), soap() { }
        virtual ~_tas__CreateSelfSignedCertificate() { }
        /// Friend allocator used by soap_new__tas__CreateSelfSignedCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateSelfSignedCertificate * SOAP_FMAC2 soap_instantiate__tas__CreateSelfSignedCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3121 */
#ifndef SOAP_TYPE__tas__CreateSelfSignedCertificateResponse
#define SOAP_TYPE__tas__CreateSelfSignedCertificateResponse (1076)
/* complex XSD type 'tas:CreateSelfSignedCertificateResponse': */
class SOAP_CMAC _tas__CreateSelfSignedCertificateResponse {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateSelfSignedCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateSelfSignedCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateSelfSignedCertificateResponse, default initialized and not managed by a soap context
        virtual _tas__CreateSelfSignedCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateSelfSignedCertificateResponse); }
      public:
        /// Constructor with initializations
        _tas__CreateSelfSignedCertificateResponse() : CertificateID(), soap() { }
        virtual ~_tas__CreateSelfSignedCertificateResponse() { }
        /// Friend allocator used by soap_new__tas__CreateSelfSignedCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateSelfSignedCertificateResponse * SOAP_FMAC2 soap_instantiate__tas__CreateSelfSignedCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3124 */
#ifndef SOAP_TYPE__tas__UploadCertificate
#define SOAP_TYPE__tas__UploadCertificate (1077)
/* complex XSD type 'tas:UploadCertificate': */
class SOAP_CMAC _tas__UploadCertificate {
      public:
        /// Required element 'tas:Certificate' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary Certificate;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:KeyAlias' of XSD type 'xsd:string'
        std::string *KeyAlias;
        /// Optional element 'tas:PrivateKeyRequired' of XSD type 'xsd:boolean'
        bool *PrivateKeyRequired;	///< optional with default value = (bool)0
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCertificate, default initialized and not managed by a soap context
        virtual _tas__UploadCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCertificate); }
      public:
        /// Constructor with initializations
        _tas__UploadCertificate() : Certificate(), Alias(), KeyAlias(), PrivateKeyRequired(), soap() { }
        virtual ~_tas__UploadCertificate() { }
        /// Friend allocator used by soap_new__tas__UploadCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCertificate * SOAP_FMAC2 soap_instantiate__tas__UploadCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3127 */
#ifndef SOAP_TYPE__tas__UploadCertificateResponse
#define SOAP_TYPE__tas__UploadCertificateResponse (1078)
/* complex XSD type 'tas:UploadCertificateResponse': */
class SOAP_CMAC _tas__UploadCertificateResponse {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Required element 'tas:KeyID' of XSD type 'tas:KeyID'
        std::string KeyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCertificateResponse, default initialized and not managed by a soap context
        virtual _tas__UploadCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCertificateResponse); }
      public:
        /// Constructor with initializations
        _tas__UploadCertificateResponse() : CertificateID(), KeyID(), soap() { }
        virtual ~_tas__UploadCertificateResponse() { }
        /// Friend allocator used by soap_new__tas__UploadCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCertificateResponse * SOAP_FMAC2 soap_instantiate__tas__UploadCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3130 */
#ifndef SOAP_TYPE__tas__GetCertificate
#define SOAP_TYPE__tas__GetCertificate (1079)
/* complex XSD type 'tas:GetCertificate': */
class SOAP_CMAC _tas__GetCertificate {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertificate, default initialized and not managed by a soap context
        virtual _tas__GetCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertificate); }
      public:
        /// Constructor with initializations
        _tas__GetCertificate() : CertificateID(), soap() { }
        virtual ~_tas__GetCertificate() { }
        /// Friend allocator used by soap_new__tas__GetCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertificate * SOAP_FMAC2 soap_instantiate__tas__GetCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3133 */
#ifndef SOAP_TYPE__tas__GetCertificateResponse
#define SOAP_TYPE__tas__GetCertificateResponse (1080)
/* complex XSD type 'tas:GetCertificateResponse': */
class SOAP_CMAC _tas__GetCertificateResponse {
      public:
        /// Required element 'tas:Certificate' of XSD type 'tas:X509Certificate'
        tas__X509Certificate *Certificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertificateResponse, default initialized and not managed by a soap context
        virtual _tas__GetCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertificateResponse); }
      public:
        /// Constructor with initializations
        _tas__GetCertificateResponse() : Certificate(), soap() { }
        virtual ~_tas__GetCertificateResponse() { }
        /// Friend allocator used by soap_new__tas__GetCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertificateResponse * SOAP_FMAC2 soap_instantiate__tas__GetCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3136 */
#ifndef SOAP_TYPE__tas__GetAllCertificates
#define SOAP_TYPE__tas__GetAllCertificates (1081)
/* complex XSD type 'tas:GetAllCertificates': */
class SOAP_CMAC _tas__GetAllCertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertificates, default initialized and not managed by a soap context
        virtual _tas__GetAllCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertificates); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertificates() : soap() { }
        virtual ~_tas__GetAllCertificates() { }
        /// Friend allocator used by soap_new__tas__GetAllCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertificates * SOAP_FMAC2 soap_instantiate__tas__GetAllCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3139 */
#ifndef SOAP_TYPE__tas__GetAllCertificatesResponse
#define SOAP_TYPE__tas__GetAllCertificatesResponse (1082)
/* complex XSD type 'tas:GetAllCertificatesResponse': */
class SOAP_CMAC _tas__GetAllCertificatesResponse {
      public:
        /// Optional element 'tas:Certificate' of XSD type 'tas:X509Certificate'
        std::vector<tas__X509Certificate *> Certificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertificatesResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertificatesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertificatesResponse() : Certificate(), soap() { }
        virtual ~_tas__GetAllCertificatesResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertificatesResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3142 */
#ifndef SOAP_TYPE__tas__DeleteCertificate
#define SOAP_TYPE__tas__DeleteCertificate (1083)
/* complex XSD type 'tas:DeleteCertificate': */
class SOAP_CMAC _tas__DeleteCertificate {
      public:
        /// Required element 'tas:CertificateID' of XSD type 'tas:CertificateID'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertificate, default initialized and not managed by a soap context
        virtual _tas__DeleteCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertificate); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertificate() : CertificateID(), soap() { }
        virtual ~_tas__DeleteCertificate() { }
        /// Friend allocator used by soap_new__tas__DeleteCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertificate * SOAP_FMAC2 soap_instantiate__tas__DeleteCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3145 */
#ifndef SOAP_TYPE__tas__DeleteCertificateResponse
#define SOAP_TYPE__tas__DeleteCertificateResponse (1084)
/* complex XSD type 'tas:DeleteCertificateResponse': */
class SOAP_CMAC _tas__DeleteCertificateResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertificateResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertificateResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertificateResponse() : soap() { }
        virtual ~_tas__DeleteCertificateResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertificateResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3148 */
#ifndef SOAP_TYPE__tas__CreateCertificationPath
#define SOAP_TYPE__tas__CreateCertificationPath (1085)
/* complex XSD type 'tas:CreateCertificationPath': */
class SOAP_CMAC _tas__CreateCertificationPath {
      public:
        /// Required element 'tas:CertificateIDs' of XSD type 'tas:CertificateIDs'
        tas__CertificateIDs *CertificateIDs;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateCertificationPath
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateCertificationPath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateCertificationPath, default initialized and not managed by a soap context
        virtual _tas__CreateCertificationPath *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateCertificationPath); }
      public:
        /// Constructor with initializations
        _tas__CreateCertificationPath() : CertificateIDs(), Alias(), soap() { }
        virtual ~_tas__CreateCertificationPath() { }
        /// Friend allocator used by soap_new__tas__CreateCertificationPath(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateCertificationPath * SOAP_FMAC2 soap_instantiate__tas__CreateCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3151 */
#ifndef SOAP_TYPE__tas__CreateCertificationPathResponse
#define SOAP_TYPE__tas__CreateCertificationPathResponse (1086)
/* complex XSD type 'tas:CreateCertificationPathResponse': */
class SOAP_CMAC _tas__CreateCertificationPathResponse {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateCertificationPathResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateCertificationPathResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateCertificationPathResponse, default initialized and not managed by a soap context
        virtual _tas__CreateCertificationPathResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateCertificationPathResponse); }
      public:
        /// Constructor with initializations
        _tas__CreateCertificationPathResponse() : CertificationPathID(), soap() { }
        virtual ~_tas__CreateCertificationPathResponse() { }
        /// Friend allocator used by soap_new__tas__CreateCertificationPathResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateCertificationPathResponse * SOAP_FMAC2 soap_instantiate__tas__CreateCertificationPathResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3154 */
#ifndef SOAP_TYPE__tas__GetCertificationPath
#define SOAP_TYPE__tas__GetCertificationPath (1087)
/* complex XSD type 'tas:GetCertificationPath': */
class SOAP_CMAC _tas__GetCertificationPath {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertificationPath
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertificationPath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertificationPath, default initialized and not managed by a soap context
        virtual _tas__GetCertificationPath *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertificationPath); }
      public:
        /// Constructor with initializations
        _tas__GetCertificationPath() : CertificationPathID(), soap() { }
        virtual ~_tas__GetCertificationPath() { }
        /// Friend allocator used by soap_new__tas__GetCertificationPath(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertificationPath * SOAP_FMAC2 soap_instantiate__tas__GetCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3157 */
#ifndef SOAP_TYPE__tas__GetCertificationPathResponse
#define SOAP_TYPE__tas__GetCertificationPathResponse (1088)
/* complex XSD type 'tas:GetCertificationPathResponse': */
class SOAP_CMAC _tas__GetCertificationPathResponse {
      public:
        /// Required element 'tas:CertificationPath' of XSD type 'tas:CertificationPath'
        tas__CertificationPath *CertificationPath;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertificationPathResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertificationPathResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertificationPathResponse, default initialized and not managed by a soap context
        virtual _tas__GetCertificationPathResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertificationPathResponse); }
      public:
        /// Constructor with initializations
        _tas__GetCertificationPathResponse() : CertificationPath(), soap() { }
        virtual ~_tas__GetCertificationPathResponse() { }
        /// Friend allocator used by soap_new__tas__GetCertificationPathResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertificationPathResponse * SOAP_FMAC2 soap_instantiate__tas__GetCertificationPathResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3160 */
#ifndef SOAP_TYPE__tas__GetAllCertificationPaths
#define SOAP_TYPE__tas__GetAllCertificationPaths (1089)
/* complex XSD type 'tas:GetAllCertificationPaths': */
class SOAP_CMAC _tas__GetAllCertificationPaths {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertificationPaths
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertificationPaths; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertificationPaths, default initialized and not managed by a soap context
        virtual _tas__GetAllCertificationPaths *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertificationPaths); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertificationPaths() : soap() { }
        virtual ~_tas__GetAllCertificationPaths() { }
        /// Friend allocator used by soap_new__tas__GetAllCertificationPaths(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertificationPaths * SOAP_FMAC2 soap_instantiate__tas__GetAllCertificationPaths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3163 */
#ifndef SOAP_TYPE__tas__GetAllCertificationPathsResponse
#define SOAP_TYPE__tas__GetAllCertificationPathsResponse (1090)
/* complex XSD type 'tas:GetAllCertificationPathsResponse': */
class SOAP_CMAC _tas__GetAllCertificationPathsResponse {
      public:
        /// Optional element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::vector<std::string> CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertificationPathsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertificationPathsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertificationPathsResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllCertificationPathsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertificationPathsResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertificationPathsResponse() : CertificationPathID(), soap() { }
        virtual ~_tas__GetAllCertificationPathsResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllCertificationPathsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertificationPathsResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllCertificationPathsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3166 */
#ifndef SOAP_TYPE__tas__DeleteCertificationPath
#define SOAP_TYPE__tas__DeleteCertificationPath (1091)
/* complex XSD type 'tas:DeleteCertificationPath': */
class SOAP_CMAC _tas__DeleteCertificationPath {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertificationPath
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertificationPath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertificationPath, default initialized and not managed by a soap context
        virtual _tas__DeleteCertificationPath *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertificationPath); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertificationPath() : CertificationPathID(), soap() { }
        virtual ~_tas__DeleteCertificationPath() { }
        /// Friend allocator used by soap_new__tas__DeleteCertificationPath(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertificationPath * SOAP_FMAC2 soap_instantiate__tas__DeleteCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3169 */
#ifndef SOAP_TYPE__tas__DeleteCertificationPathResponse
#define SOAP_TYPE__tas__DeleteCertificationPathResponse (1092)
/* complex XSD type 'tas:DeleteCertificationPathResponse': */
class SOAP_CMAC _tas__DeleteCertificationPathResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertificationPathResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertificationPathResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertificationPathResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteCertificationPathResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertificationPathResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertificationPathResponse() : soap() { }
        virtual ~_tas__DeleteCertificationPathResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteCertificationPathResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertificationPathResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteCertificationPathResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3172 */
#ifndef SOAP_TYPE__tas__UploadPassphrase
#define SOAP_TYPE__tas__UploadPassphrase (1093)
/* complex XSD type 'tas:UploadPassphrase': */
class SOAP_CMAC _tas__UploadPassphrase {
      public:
        /// Required element 'tas:Passphrase' of XSD type 'xsd:string'
        std::string Passphrase;
        /// Optional element 'tas:PassphraseAlias' of XSD type 'xsd:string'
        std::string *PassphraseAlias;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadPassphrase
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadPassphrase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadPassphrase, default initialized and not managed by a soap context
        virtual _tas__UploadPassphrase *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadPassphrase); }
      public:
        /// Constructor with initializations
        _tas__UploadPassphrase() : Passphrase(), PassphraseAlias(), soap() { }
        virtual ~_tas__UploadPassphrase() { }
        /// Friend allocator used by soap_new__tas__UploadPassphrase(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadPassphrase * SOAP_FMAC2 soap_instantiate__tas__UploadPassphrase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3175 */
#ifndef SOAP_TYPE__tas__UploadPassphraseResponse
#define SOAP_TYPE__tas__UploadPassphraseResponse (1094)
/* complex XSD type 'tas:UploadPassphraseResponse': */
class SOAP_CMAC _tas__UploadPassphraseResponse {
      public:
        /// Required element 'tas:PassphraseID' of XSD type 'tas:PassphraseID'
        std::string PassphraseID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadPassphraseResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadPassphraseResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadPassphraseResponse, default initialized and not managed by a soap context
        virtual _tas__UploadPassphraseResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadPassphraseResponse); }
      public:
        /// Constructor with initializations
        _tas__UploadPassphraseResponse() : PassphraseID(), soap() { }
        virtual ~_tas__UploadPassphraseResponse() { }
        /// Friend allocator used by soap_new__tas__UploadPassphraseResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadPassphraseResponse * SOAP_FMAC2 soap_instantiate__tas__UploadPassphraseResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3178 */
#ifndef SOAP_TYPE__tas__GetAllPassphrases
#define SOAP_TYPE__tas__GetAllPassphrases (1095)
/* complex XSD type 'tas:GetAllPassphrases': */
class SOAP_CMAC _tas__GetAllPassphrases {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllPassphrases
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllPassphrases; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllPassphrases, default initialized and not managed by a soap context
        virtual _tas__GetAllPassphrases *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllPassphrases); }
      public:
        /// Constructor with initializations
        _tas__GetAllPassphrases() : soap() { }
        virtual ~_tas__GetAllPassphrases() { }
        /// Friend allocator used by soap_new__tas__GetAllPassphrases(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllPassphrases * SOAP_FMAC2 soap_instantiate__tas__GetAllPassphrases(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3181 */
#ifndef SOAP_TYPE__tas__GetAllPassphrasesResponse
#define SOAP_TYPE__tas__GetAllPassphrasesResponse (1096)
/* complex XSD type 'tas:GetAllPassphrasesResponse': */
class SOAP_CMAC _tas__GetAllPassphrasesResponse {
      public:
        /// Optional element 'tas:PassphraseAttribute' of XSD type 'tas:PassphraseAttribute'
        std::vector<tas__PassphraseAttribute *> PassphraseAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllPassphrasesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllPassphrasesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllPassphrasesResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllPassphrasesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllPassphrasesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllPassphrasesResponse() : PassphraseAttribute(), soap() { }
        virtual ~_tas__GetAllPassphrasesResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllPassphrasesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllPassphrasesResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllPassphrasesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3184 */
#ifndef SOAP_TYPE__tas__DeletePassphrase
#define SOAP_TYPE__tas__DeletePassphrase (1097)
/* complex XSD type 'tas:DeletePassphrase': */
class SOAP_CMAC _tas__DeletePassphrase {
      public:
        /// Required element 'tas:PassphraseID' of XSD type 'tas:PassphraseID'
        std::string PassphraseID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeletePassphrase
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeletePassphrase; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeletePassphrase, default initialized and not managed by a soap context
        virtual _tas__DeletePassphrase *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeletePassphrase); }
      public:
        /// Constructor with initializations
        _tas__DeletePassphrase() : PassphraseID(), soap() { }
        virtual ~_tas__DeletePassphrase() { }
        /// Friend allocator used by soap_new__tas__DeletePassphrase(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeletePassphrase * SOAP_FMAC2 soap_instantiate__tas__DeletePassphrase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3187 */
#ifndef SOAP_TYPE__tas__DeletePassphraseResponse
#define SOAP_TYPE__tas__DeletePassphraseResponse (1098)
/* complex XSD type 'tas:DeletePassphraseResponse': */
class SOAP_CMAC _tas__DeletePassphraseResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeletePassphraseResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeletePassphraseResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeletePassphraseResponse, default initialized and not managed by a soap context
        virtual _tas__DeletePassphraseResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeletePassphraseResponse); }
      public:
        /// Constructor with initializations
        _tas__DeletePassphraseResponse() : soap() { }
        virtual ~_tas__DeletePassphraseResponse() { }
        /// Friend allocator used by soap_new__tas__DeletePassphraseResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeletePassphraseResponse * SOAP_FMAC2 soap_instantiate__tas__DeletePassphraseResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3190 */
#ifndef SOAP_TYPE__tas__AddServerCertificateAssignment
#define SOAP_TYPE__tas__AddServerCertificateAssignment (1099)
/* complex XSD type 'tas:AddServerCertificateAssignment': */
class SOAP_CMAC _tas__AddServerCertificateAssignment {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddServerCertificateAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddServerCertificateAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddServerCertificateAssignment, default initialized and not managed by a soap context
        virtual _tas__AddServerCertificateAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddServerCertificateAssignment); }
      public:
        /// Constructor with initializations
        _tas__AddServerCertificateAssignment() : CertificationPathID(), soap() { }
        virtual ~_tas__AddServerCertificateAssignment() { }
        /// Friend allocator used by soap_new__tas__AddServerCertificateAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddServerCertificateAssignment * SOAP_FMAC2 soap_instantiate__tas__AddServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3193 */
#ifndef SOAP_TYPE__tas__AddServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__AddServerCertificateAssignmentResponse (1100)
/* complex XSD type 'tas:AddServerCertificateAssignmentResponse': */
class SOAP_CMAC _tas__AddServerCertificateAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddServerCertificateAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddServerCertificateAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddServerCertificateAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__AddServerCertificateAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddServerCertificateAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__AddServerCertificateAssignmentResponse() : soap() { }
        virtual ~_tas__AddServerCertificateAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__AddServerCertificateAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddServerCertificateAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__AddServerCertificateAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3196 */
#ifndef SOAP_TYPE__tas__RemoveServerCertificateAssignment
#define SOAP_TYPE__tas__RemoveServerCertificateAssignment (1101)
/* complex XSD type 'tas:RemoveServerCertificateAssignment': */
class SOAP_CMAC _tas__RemoveServerCertificateAssignment {
      public:
        /// Required element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__RemoveServerCertificateAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__RemoveServerCertificateAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__RemoveServerCertificateAssignment, default initialized and not managed by a soap context
        virtual _tas__RemoveServerCertificateAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__RemoveServerCertificateAssignment); }
      public:
        /// Constructor with initializations
        _tas__RemoveServerCertificateAssignment() : CertificationPathID(), soap() { }
        virtual ~_tas__RemoveServerCertificateAssignment() { }
        /// Friend allocator used by soap_new__tas__RemoveServerCertificateAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__RemoveServerCertificateAssignment * SOAP_FMAC2 soap_instantiate__tas__RemoveServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3199 */
#ifndef SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse (1102)
/* complex XSD type 'tas:RemoveServerCertificateAssignmentResponse': */
class SOAP_CMAC _tas__RemoveServerCertificateAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__RemoveServerCertificateAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__RemoveServerCertificateAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__RemoveServerCertificateAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__RemoveServerCertificateAssignmentResponse() : soap() { }
        virtual ~_tas__RemoveServerCertificateAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__RemoveServerCertificateAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__RemoveServerCertificateAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__RemoveServerCertificateAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3202 */
#ifndef SOAP_TYPE__tas__ReplaceServerCertificateAssignment
#define SOAP_TYPE__tas__ReplaceServerCertificateAssignment (1103)
/* complex XSD type 'tas:ReplaceServerCertificateAssignment': */
class SOAP_CMAC _tas__ReplaceServerCertificateAssignment {
      public:
        /// Required element 'tas:OldCertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string OldCertificationPathID;
        /// Required element 'tas:NewCertificationPathID' of XSD type 'tas:CertificationPathID'
        std::string NewCertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__ReplaceServerCertificateAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__ReplaceServerCertificateAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__ReplaceServerCertificateAssignment, default initialized and not managed by a soap context
        virtual _tas__ReplaceServerCertificateAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__ReplaceServerCertificateAssignment); }
      public:
        /// Constructor with initializations
        _tas__ReplaceServerCertificateAssignment() : OldCertificationPathID(), NewCertificationPathID(), soap() { }
        virtual ~_tas__ReplaceServerCertificateAssignment() { }
        /// Friend allocator used by soap_new__tas__ReplaceServerCertificateAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__ReplaceServerCertificateAssignment * SOAP_FMAC2 soap_instantiate__tas__ReplaceServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3205 */
#ifndef SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse (1104)
/* complex XSD type 'tas:ReplaceServerCertificateAssignmentResponse': */
class SOAP_CMAC _tas__ReplaceServerCertificateAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__ReplaceServerCertificateAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__ReplaceServerCertificateAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__ReplaceServerCertificateAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__ReplaceServerCertificateAssignmentResponse() : soap() { }
        virtual ~_tas__ReplaceServerCertificateAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__ReplaceServerCertificateAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__ReplaceServerCertificateAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__ReplaceServerCertificateAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3208 */
#ifndef SOAP_TYPE__tas__GetAssignedServerCertificates
#define SOAP_TYPE__tas__GetAssignedServerCertificates (1105)
/* complex XSD type 'tas:GetAssignedServerCertificates': */
class SOAP_CMAC _tas__GetAssignedServerCertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAssignedServerCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAssignedServerCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAssignedServerCertificates, default initialized and not managed by a soap context
        virtual _tas__GetAssignedServerCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAssignedServerCertificates); }
      public:
        /// Constructor with initializations
        _tas__GetAssignedServerCertificates() : soap() { }
        virtual ~_tas__GetAssignedServerCertificates() { }
        /// Friend allocator used by soap_new__tas__GetAssignedServerCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAssignedServerCertificates * SOAP_FMAC2 soap_instantiate__tas__GetAssignedServerCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3211 */
#ifndef SOAP_TYPE__tas__GetAssignedServerCertificatesResponse
#define SOAP_TYPE__tas__GetAssignedServerCertificatesResponse (1106)
/* complex XSD type 'tas:GetAssignedServerCertificatesResponse': */
class SOAP_CMAC _tas__GetAssignedServerCertificatesResponse {
      public:
        /// Optional element 'tas:CertificationPathID' of XSD type 'tas:CertificationPathID'
        std::vector<std::string> CertificationPathID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAssignedServerCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAssignedServerCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAssignedServerCertificatesResponse, default initialized and not managed by a soap context
        virtual _tas__GetAssignedServerCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAssignedServerCertificatesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAssignedServerCertificatesResponse() : CertificationPathID(), soap() { }
        virtual ~_tas__GetAssignedServerCertificatesResponse() { }
        /// Friend allocator used by soap_new__tas__GetAssignedServerCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAssignedServerCertificatesResponse * SOAP_FMAC2 soap_instantiate__tas__GetAssignedServerCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3214 */
#ifndef SOAP_TYPE__tas__SetEnabledTLSVersions
#define SOAP_TYPE__tas__SetEnabledTLSVersions (1107)
/* complex XSD type 'tas:SetEnabledTLSVersions': */
class SOAP_CMAC _tas__SetEnabledTLSVersions {
      public:
        /// Required element 'tas:Versions' of XSD type 'tas:TLSVersions'
        std::string Versions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetEnabledTLSVersions
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetEnabledTLSVersions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetEnabledTLSVersions, default initialized and not managed by a soap context
        virtual _tas__SetEnabledTLSVersions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetEnabledTLSVersions); }
      public:
        /// Constructor with initializations
        _tas__SetEnabledTLSVersions() : Versions(), soap() { }
        virtual ~_tas__SetEnabledTLSVersions() { }
        /// Friend allocator used by soap_new__tas__SetEnabledTLSVersions(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetEnabledTLSVersions * SOAP_FMAC2 soap_instantiate__tas__SetEnabledTLSVersions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3217 */
#ifndef SOAP_TYPE__tas__SetEnabledTLSVersionsResponse
#define SOAP_TYPE__tas__SetEnabledTLSVersionsResponse (1108)
/* complex XSD type 'tas:SetEnabledTLSVersionsResponse': */
class SOAP_CMAC _tas__SetEnabledTLSVersionsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetEnabledTLSVersionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetEnabledTLSVersionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetEnabledTLSVersionsResponse, default initialized and not managed by a soap context
        virtual _tas__SetEnabledTLSVersionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetEnabledTLSVersionsResponse); }
      public:
        /// Constructor with initializations
        _tas__SetEnabledTLSVersionsResponse() : soap() { }
        virtual ~_tas__SetEnabledTLSVersionsResponse() { }
        /// Friend allocator used by soap_new__tas__SetEnabledTLSVersionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetEnabledTLSVersionsResponse * SOAP_FMAC2 soap_instantiate__tas__SetEnabledTLSVersionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3220 */
#ifndef SOAP_TYPE__tas__GetEnabledTLSVersions
#define SOAP_TYPE__tas__GetEnabledTLSVersions (1109)
/* complex XSD type 'tas:GetEnabledTLSVersions': */
class SOAP_CMAC _tas__GetEnabledTLSVersions {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetEnabledTLSVersions
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetEnabledTLSVersions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetEnabledTLSVersions, default initialized and not managed by a soap context
        virtual _tas__GetEnabledTLSVersions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetEnabledTLSVersions); }
      public:
        /// Constructor with initializations
        _tas__GetEnabledTLSVersions() : soap() { }
        virtual ~_tas__GetEnabledTLSVersions() { }
        /// Friend allocator used by soap_new__tas__GetEnabledTLSVersions(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetEnabledTLSVersions * SOAP_FMAC2 soap_instantiate__tas__GetEnabledTLSVersions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3223 */
#ifndef SOAP_TYPE__tas__GetEnabledTLSVersionsResponse
#define SOAP_TYPE__tas__GetEnabledTLSVersionsResponse (1110)
/* complex XSD type 'tas:GetEnabledTLSVersionsResponse': */
class SOAP_CMAC _tas__GetEnabledTLSVersionsResponse {
      public:
        /// Required element 'tas:Versions' of XSD type 'tas:TLSVersions'
        std::string Versions;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetEnabledTLSVersionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetEnabledTLSVersionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetEnabledTLSVersionsResponse, default initialized and not managed by a soap context
        virtual _tas__GetEnabledTLSVersionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetEnabledTLSVersionsResponse); }
      public:
        /// Constructor with initializations
        _tas__GetEnabledTLSVersionsResponse() : Versions(), soap() { }
        virtual ~_tas__GetEnabledTLSVersionsResponse() { }
        /// Friend allocator used by soap_new__tas__GetEnabledTLSVersionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetEnabledTLSVersionsResponse * SOAP_FMAC2 soap_instantiate__tas__GetEnabledTLSVersionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31122 */
#ifndef SOAP_TYPE__tas__UploadCRL_anyParameters
#define SOAP_TYPE__tas__UploadCRL_anyParameters (1805)
/* complex XSD type 'tas:UploadCRL-anyParameters': */
class SOAP_CMAC _tas__UploadCRL_anyParameters {
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCRL_anyParameters
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCRL_anyParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCRL_anyParameters, default initialized and not managed by a soap context
        virtual _tas__UploadCRL_anyParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCRL_anyParameters); }
      public:
        /// Constructor with initializations
        _tas__UploadCRL_anyParameters() { }
        virtual ~_tas__UploadCRL_anyParameters() { }
        /// Friend allocator used by soap_new__tas__UploadCRL_anyParameters(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCRL_anyParameters * SOAP_FMAC2 soap_instantiate__tas__UploadCRL_anyParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3226 */
#ifndef SOAP_TYPE__tas__UploadCRL
#define SOAP_TYPE__tas__UploadCRL (1111)
/* complex XSD type 'tas:UploadCRL': */
class SOAP_CMAC _tas__UploadCRL {
      public:
        /// Required element 'tas:Crl' of XSD type 'tas:Base64DERencodedASN1Value'
        xsd__base64Binary Crl;
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Optional element 'tas:anyParameters' of XSD type 'tas:UploadCRL-anyParameters'
        _tas__UploadCRL_anyParameters *anyParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCRL
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCRL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCRL, default initialized and not managed by a soap context
        virtual _tas__UploadCRL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCRL); }
      public:
        /// Constructor with initializations
        _tas__UploadCRL() : Crl(), Alias(), anyParameters(), soap() { }
        virtual ~_tas__UploadCRL() { }
        /// Friend allocator used by soap_new__tas__UploadCRL(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCRL * SOAP_FMAC2 soap_instantiate__tas__UploadCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3229 */
#ifndef SOAP_TYPE__tas__UploadCRLResponse
#define SOAP_TYPE__tas__UploadCRLResponse (1112)
/* complex XSD type 'tas:UploadCRLResponse': */
class SOAP_CMAC _tas__UploadCRLResponse {
      public:
        /// Required element 'tas:CrlID' of XSD type 'tas:CRLID'
        std::string CrlID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__UploadCRLResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__UploadCRLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__UploadCRLResponse, default initialized and not managed by a soap context
        virtual _tas__UploadCRLResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__UploadCRLResponse); }
      public:
        /// Constructor with initializations
        _tas__UploadCRLResponse() : CrlID(), soap() { }
        virtual ~_tas__UploadCRLResponse() { }
        /// Friend allocator used by soap_new__tas__UploadCRLResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__UploadCRLResponse * SOAP_FMAC2 soap_instantiate__tas__UploadCRLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3232 */
#ifndef SOAP_TYPE__tas__GetCRL
#define SOAP_TYPE__tas__GetCRL (1113)
/* complex XSD type 'tas:GetCRL': */
class SOAP_CMAC _tas__GetCRL {
      public:
        /// Required element 'tas:CrlID' of XSD type 'tas:CRLID'
        std::string CrlID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCRL
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCRL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCRL, default initialized and not managed by a soap context
        virtual _tas__GetCRL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCRL); }
      public:
        /// Constructor with initializations
        _tas__GetCRL() : CrlID(), soap() { }
        virtual ~_tas__GetCRL() { }
        /// Friend allocator used by soap_new__tas__GetCRL(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCRL * SOAP_FMAC2 soap_instantiate__tas__GetCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3235 */
#ifndef SOAP_TYPE__tas__GetCRLResponse
#define SOAP_TYPE__tas__GetCRLResponse (1114)
/* complex XSD type 'tas:GetCRLResponse': */
class SOAP_CMAC _tas__GetCRLResponse {
      public:
        /// Required element 'tas:Crl' of XSD type 'tas:CRL'
        tas__CRL *Crl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCRLResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCRLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCRLResponse, default initialized and not managed by a soap context
        virtual _tas__GetCRLResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCRLResponse); }
      public:
        /// Constructor with initializations
        _tas__GetCRLResponse() : Crl(), soap() { }
        virtual ~_tas__GetCRLResponse() { }
        /// Friend allocator used by soap_new__tas__GetCRLResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCRLResponse * SOAP_FMAC2 soap_instantiate__tas__GetCRLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3238 */
#ifndef SOAP_TYPE__tas__GetAllCRLs
#define SOAP_TYPE__tas__GetAllCRLs (1115)
/* complex XSD type 'tas:GetAllCRLs': */
class SOAP_CMAC _tas__GetAllCRLs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCRLs
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCRLs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCRLs, default initialized and not managed by a soap context
        virtual _tas__GetAllCRLs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCRLs); }
      public:
        /// Constructor with initializations
        _tas__GetAllCRLs() : soap() { }
        virtual ~_tas__GetAllCRLs() { }
        /// Friend allocator used by soap_new__tas__GetAllCRLs(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCRLs * SOAP_FMAC2 soap_instantiate__tas__GetAllCRLs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3241 */
#ifndef SOAP_TYPE__tas__GetAllCRLsResponse
#define SOAP_TYPE__tas__GetAllCRLsResponse (1116)
/* complex XSD type 'tas:GetAllCRLsResponse': */
class SOAP_CMAC _tas__GetAllCRLsResponse {
      public:
        /// Optional element 'tas:Crl' of XSD type 'tas:CRL'
        std::vector<tas__CRL *> Crl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCRLsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCRLsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCRLsResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllCRLsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCRLsResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllCRLsResponse() : Crl(), soap() { }
        virtual ~_tas__GetAllCRLsResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllCRLsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCRLsResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllCRLsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3244 */
#ifndef SOAP_TYPE__tas__DeleteCRL
#define SOAP_TYPE__tas__DeleteCRL (1117)
/* complex XSD type 'tas:DeleteCRL': */
class SOAP_CMAC _tas__DeleteCRL {
      public:
        /// Required element 'tas:CrlID' of XSD type 'tas:CRLID'
        std::string CrlID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCRL
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCRL; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCRL, default initialized and not managed by a soap context
        virtual _tas__DeleteCRL *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCRL); }
      public:
        /// Constructor with initializations
        _tas__DeleteCRL() : CrlID(), soap() { }
        virtual ~_tas__DeleteCRL() { }
        /// Friend allocator used by soap_new__tas__DeleteCRL(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCRL * SOAP_FMAC2 soap_instantiate__tas__DeleteCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3247 */
#ifndef SOAP_TYPE__tas__DeleteCRLResponse
#define SOAP_TYPE__tas__DeleteCRLResponse (1118)
/* complex XSD type 'tas:DeleteCRLResponse': */
class SOAP_CMAC _tas__DeleteCRLResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCRLResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCRLResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCRLResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteCRLResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCRLResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteCRLResponse() : soap() { }
        virtual ~_tas__DeleteCRLResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteCRLResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCRLResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteCRLResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31325 */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters
#define SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters (1809)
/* complex XSD type 'tas:CreateCertPathValidationPolicy-anyParameters': */
class SOAP_CMAC _tas__CreateCertPathValidationPolicy_anyParameters {
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateCertPathValidationPolicy_anyParameters, default initialized and not managed by a soap context
        virtual _tas__CreateCertPathValidationPolicy_anyParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateCertPathValidationPolicy_anyParameters); }
      public:
        /// Constructor with initializations
        _tas__CreateCertPathValidationPolicy_anyParameters() { }
        virtual ~_tas__CreateCertPathValidationPolicy_anyParameters() { }
        /// Friend allocator used by soap_new__tas__CreateCertPathValidationPolicy_anyParameters(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateCertPathValidationPolicy_anyParameters * SOAP_FMAC2 soap_instantiate__tas__CreateCertPathValidationPolicy_anyParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3250 */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicy
#define SOAP_TYPE__tas__CreateCertPathValidationPolicy (1119)
/* complex XSD type 'tas:CreateCertPathValidationPolicy': */
class SOAP_CMAC _tas__CreateCertPathValidationPolicy {
      public:
        /// Optional element 'tas:Alias' of XSD type 'xsd:string'
        std::string *Alias;
        /// Required element 'tas:Parameters' of XSD type 'tas:CertPathValidationParameters'
        tas__CertPathValidationParameters *Parameters;
        /// Required element 'tas:TrustAnchor' of XSD type 'tas:TrustAnchor'
        std::vector<tas__TrustAnchor *> TrustAnchor;
        /// Optional element 'tas:anyParameters' of XSD type 'tas:CreateCertPathValidationPolicy-anyParameters'
        _tas__CreateCertPathValidationPolicy_anyParameters *anyParameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateCertPathValidationPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateCertPathValidationPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateCertPathValidationPolicy, default initialized and not managed by a soap context
        virtual _tas__CreateCertPathValidationPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateCertPathValidationPolicy); }
      public:
        /// Constructor with initializations
        _tas__CreateCertPathValidationPolicy() : Alias(), Parameters(), TrustAnchor(), anyParameters(), soap() { }
        virtual ~_tas__CreateCertPathValidationPolicy() { }
        /// Friend allocator used by soap_new__tas__CreateCertPathValidationPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate__tas__CreateCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3253 */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse (1120)
/* complex XSD type 'tas:CreateCertPathValidationPolicyResponse': */
class SOAP_CMAC _tas__CreateCertPathValidationPolicyResponse {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__CreateCertPathValidationPolicyResponse, default initialized and not managed by a soap context
        virtual _tas__CreateCertPathValidationPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__CreateCertPathValidationPolicyResponse); }
      public:
        /// Constructor with initializations
        _tas__CreateCertPathValidationPolicyResponse() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__CreateCertPathValidationPolicyResponse() { }
        /// Friend allocator used by soap_new__tas__CreateCertPathValidationPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__CreateCertPathValidationPolicyResponse * SOAP_FMAC2 soap_instantiate__tas__CreateCertPathValidationPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3256 */
#ifndef SOAP_TYPE__tas__GetCertPathValidationPolicy
#define SOAP_TYPE__tas__GetCertPathValidationPolicy (1121)
/* complex XSD type 'tas:GetCertPathValidationPolicy': */
class SOAP_CMAC _tas__GetCertPathValidationPolicy {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertPathValidationPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertPathValidationPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertPathValidationPolicy, default initialized and not managed by a soap context
        virtual _tas__GetCertPathValidationPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertPathValidationPolicy); }
      public:
        /// Constructor with initializations
        _tas__GetCertPathValidationPolicy() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__GetCertPathValidationPolicy() { }
        /// Friend allocator used by soap_new__tas__GetCertPathValidationPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate__tas__GetCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3259 */
#ifndef SOAP_TYPE__tas__GetCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__GetCertPathValidationPolicyResponse (1122)
/* complex XSD type 'tas:GetCertPathValidationPolicyResponse': */
class SOAP_CMAC _tas__GetCertPathValidationPolicyResponse {
      public:
        /// Required element 'tas:CertPathValidationPolicy' of XSD type 'tas:CertPathValidationPolicy'
        tas__CertPathValidationPolicy *CertPathValidationPolicy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetCertPathValidationPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetCertPathValidationPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetCertPathValidationPolicyResponse, default initialized and not managed by a soap context
        virtual _tas__GetCertPathValidationPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetCertPathValidationPolicyResponse); }
      public:
        /// Constructor with initializations
        _tas__GetCertPathValidationPolicyResponse() : CertPathValidationPolicy(), soap() { }
        virtual ~_tas__GetCertPathValidationPolicyResponse() { }
        /// Friend allocator used by soap_new__tas__GetCertPathValidationPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetCertPathValidationPolicyResponse * SOAP_FMAC2 soap_instantiate__tas__GetCertPathValidationPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3262 */
#ifndef SOAP_TYPE__tas__GetAllCertPathValidationPolicies
#define SOAP_TYPE__tas__GetAllCertPathValidationPolicies (1123)
/* complex XSD type 'tas:GetAllCertPathValidationPolicies': */
class SOAP_CMAC _tas__GetAllCertPathValidationPolicies {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertPathValidationPolicies
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertPathValidationPolicies; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertPathValidationPolicies, default initialized and not managed by a soap context
        virtual _tas__GetAllCertPathValidationPolicies *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertPathValidationPolicies); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertPathValidationPolicies() : soap() { }
        virtual ~_tas__GetAllCertPathValidationPolicies() { }
        /// Friend allocator used by soap_new__tas__GetAllCertPathValidationPolicies(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertPathValidationPolicies * SOAP_FMAC2 soap_instantiate__tas__GetAllCertPathValidationPolicies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3265 */
#ifndef SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse
#define SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse (1124)
/* complex XSD type 'tas:GetAllCertPathValidationPoliciesResponse': */
class SOAP_CMAC _tas__GetAllCertPathValidationPoliciesResponse {
      public:
        /// Optional element 'tas:CertPathValidationPolicy' of XSD type 'tas:CertPathValidationPolicy'
        std::vector<tas__CertPathValidationPolicy *> CertPathValidationPolicy;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllCertPathValidationPoliciesResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllCertPathValidationPoliciesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllCertPathValidationPoliciesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllCertPathValidationPoliciesResponse() : CertPathValidationPolicy(), soap() { }
        virtual ~_tas__GetAllCertPathValidationPoliciesResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllCertPathValidationPoliciesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllCertPathValidationPoliciesResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllCertPathValidationPoliciesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3268 */
#ifndef SOAP_TYPE__tas__DeleteCertPathValidationPolicy
#define SOAP_TYPE__tas__DeleteCertPathValidationPolicy (1125)
/* complex XSD type 'tas:DeleteCertPathValidationPolicy': */
class SOAP_CMAC _tas__DeleteCertPathValidationPolicy {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertPathValidationPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertPathValidationPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertPathValidationPolicy, default initialized and not managed by a soap context
        virtual _tas__DeleteCertPathValidationPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertPathValidationPolicy); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertPathValidationPolicy() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__DeleteCertPathValidationPolicy() { }
        /// Friend allocator used by soap_new__tas__DeleteCertPathValidationPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate__tas__DeleteCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3271 */
#ifndef SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse (1126)
/* complex XSD type 'tas:DeleteCertPathValidationPolicyResponse': */
class SOAP_CMAC _tas__DeleteCertPathValidationPolicyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteCertPathValidationPolicyResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteCertPathValidationPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteCertPathValidationPolicyResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteCertPathValidationPolicyResponse() : soap() { }
        virtual ~_tas__DeleteCertPathValidationPolicyResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteCertPathValidationPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteCertPathValidationPolicyResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteCertPathValidationPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3274 */
#ifndef SOAP_TYPE__tas__SetClientAuthenticationRequired
#define SOAP_TYPE__tas__SetClientAuthenticationRequired (1127)
/* complex XSD type 'tas:SetClientAuthenticationRequired': */
class SOAP_CMAC _tas__SetClientAuthenticationRequired {
      public:
        /// Required element 'tas:clientAuthenticationRequired' of XSD type 'xsd:boolean'
        bool clientAuthenticationRequired;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetClientAuthenticationRequired
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetClientAuthenticationRequired; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetClientAuthenticationRequired, default initialized and not managed by a soap context
        virtual _tas__SetClientAuthenticationRequired *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetClientAuthenticationRequired); }
      public:
        /// Constructor with initializations
        _tas__SetClientAuthenticationRequired() : clientAuthenticationRequired(), soap() { }
        virtual ~_tas__SetClientAuthenticationRequired() { }
        /// Friend allocator used by soap_new__tas__SetClientAuthenticationRequired(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetClientAuthenticationRequired * SOAP_FMAC2 soap_instantiate__tas__SetClientAuthenticationRequired(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3277 */
#ifndef SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse
#define SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse (1128)
/* complex XSD type 'tas:SetClientAuthenticationRequiredResponse': */
class SOAP_CMAC _tas__SetClientAuthenticationRequiredResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetClientAuthenticationRequiredResponse, default initialized and not managed by a soap context
        virtual _tas__SetClientAuthenticationRequiredResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetClientAuthenticationRequiredResponse); }
      public:
        /// Constructor with initializations
        _tas__SetClientAuthenticationRequiredResponse() : soap() { }
        virtual ~_tas__SetClientAuthenticationRequiredResponse() { }
        /// Friend allocator used by soap_new__tas__SetClientAuthenticationRequiredResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetClientAuthenticationRequiredResponse * SOAP_FMAC2 soap_instantiate__tas__SetClientAuthenticationRequiredResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3280 */
#ifndef SOAP_TYPE__tas__GetClientAuthenticationRequired
#define SOAP_TYPE__tas__GetClientAuthenticationRequired (1129)
/* complex XSD type 'tas:GetClientAuthenticationRequired': */
class SOAP_CMAC _tas__GetClientAuthenticationRequired {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetClientAuthenticationRequired
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetClientAuthenticationRequired; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetClientAuthenticationRequired, default initialized and not managed by a soap context
        virtual _tas__GetClientAuthenticationRequired *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetClientAuthenticationRequired); }
      public:
        /// Constructor with initializations
        _tas__GetClientAuthenticationRequired() : soap() { }
        virtual ~_tas__GetClientAuthenticationRequired() { }
        /// Friend allocator used by soap_new__tas__GetClientAuthenticationRequired(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetClientAuthenticationRequired * SOAP_FMAC2 soap_instantiate__tas__GetClientAuthenticationRequired(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3283 */
#ifndef SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse
#define SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse (1130)
/* complex XSD type 'tas:GetClientAuthenticationRequiredResponse': */
class SOAP_CMAC _tas__GetClientAuthenticationRequiredResponse {
      public:
        /// Required element 'tas:clientAuthenticationRequired' of XSD type 'xsd:boolean'
        bool clientAuthenticationRequired;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetClientAuthenticationRequiredResponse, default initialized and not managed by a soap context
        virtual _tas__GetClientAuthenticationRequiredResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetClientAuthenticationRequiredResponse); }
      public:
        /// Constructor with initializations
        _tas__GetClientAuthenticationRequiredResponse() : clientAuthenticationRequired(), soap() { }
        virtual ~_tas__GetClientAuthenticationRequiredResponse() { }
        /// Friend allocator used by soap_new__tas__GetClientAuthenticationRequiredResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetClientAuthenticationRequiredResponse * SOAP_FMAC2 soap_instantiate__tas__GetClientAuthenticationRequiredResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3286 */
#ifndef SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment (1131)
/* complex XSD type 'tas:AddCertPathValidationPolicyAssignment': */
class SOAP_CMAC _tas__AddCertPathValidationPolicyAssignment {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddCertPathValidationPolicyAssignment, default initialized and not managed by a soap context
        virtual _tas__AddCertPathValidationPolicyAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddCertPathValidationPolicyAssignment); }
      public:
        /// Constructor with initializations
        _tas__AddCertPathValidationPolicyAssignment() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__AddCertPathValidationPolicyAssignment() { }
        /// Friend allocator used by soap_new__tas__AddCertPathValidationPolicyAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate__tas__AddCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3289 */
#ifndef SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse (1132)
/* complex XSD type 'tas:AddCertPathValidationPolicyAssignmentResponse': */
class SOAP_CMAC _tas__AddCertPathValidationPolicyAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddCertPathValidationPolicyAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__AddCertPathValidationPolicyAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddCertPathValidationPolicyAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__AddCertPathValidationPolicyAssignmentResponse() : soap() { }
        virtual ~_tas__AddCertPathValidationPolicyAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__AddCertPathValidationPolicyAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddCertPathValidationPolicyAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__AddCertPathValidationPolicyAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3292 */
#ifndef SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment (1133)
/* complex XSD type 'tas:RemoveCertPathValidationPolicyAssignment': */
class SOAP_CMAC _tas__RemoveCertPathValidationPolicyAssignment {
      public:
        /// Required element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__RemoveCertPathValidationPolicyAssignment, default initialized and not managed by a soap context
        virtual _tas__RemoveCertPathValidationPolicyAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__RemoveCertPathValidationPolicyAssignment); }
      public:
        /// Constructor with initializations
        _tas__RemoveCertPathValidationPolicyAssignment() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__RemoveCertPathValidationPolicyAssignment() { }
        /// Friend allocator used by soap_new__tas__RemoveCertPathValidationPolicyAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__RemoveCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate__tas__RemoveCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3295 */
#ifndef SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse (1134)
/* complex XSD type 'tas:RemoveCertPathValidationPolicyAssignmentResponse': */
class SOAP_CMAC _tas__RemoveCertPathValidationPolicyAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__RemoveCertPathValidationPolicyAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__RemoveCertPathValidationPolicyAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__RemoveCertPathValidationPolicyAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__RemoveCertPathValidationPolicyAssignmentResponse() : soap() { }
        virtual ~_tas__RemoveCertPathValidationPolicyAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__RemoveCertPathValidationPolicyAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__RemoveCertPathValidationPolicyAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__RemoveCertPathValidationPolicyAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3298 */
#ifndef SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment (1135)
/* complex XSD type 'tas:ReplaceCertPathValidationPolicyAssignment': */
class SOAP_CMAC _tas__ReplaceCertPathValidationPolicyAssignment {
      public:
        /// Required element 'tas:OldCertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string OldCertPathValidationPolicyID;
        /// Required element 'tas:NewCertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::string NewCertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment
        virtual long soap_type(void) const { return SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__ReplaceCertPathValidationPolicyAssignment, default initialized and not managed by a soap context
        virtual _tas__ReplaceCertPathValidationPolicyAssignment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__ReplaceCertPathValidationPolicyAssignment); }
      public:
        /// Constructor with initializations
        _tas__ReplaceCertPathValidationPolicyAssignment() : OldCertPathValidationPolicyID(), NewCertPathValidationPolicyID(), soap() { }
        virtual ~_tas__ReplaceCertPathValidationPolicyAssignment() { }
        /// Friend allocator used by soap_new__tas__ReplaceCertPathValidationPolicyAssignment(struct soap*, int)
        friend SOAP_FMAC1 _tas__ReplaceCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate__tas__ReplaceCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3301 */
#ifndef SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse (1136)
/* complex XSD type 'tas:ReplaceCertPathValidationPolicyAssignmentResponse': */
class SOAP_CMAC _tas__ReplaceCertPathValidationPolicyAssignmentResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__ReplaceCertPathValidationPolicyAssignmentResponse, default initialized and not managed by a soap context
        virtual _tas__ReplaceCertPathValidationPolicyAssignmentResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__ReplaceCertPathValidationPolicyAssignmentResponse); }
      public:
        /// Constructor with initializations
        _tas__ReplaceCertPathValidationPolicyAssignmentResponse() : soap() { }
        virtual ~_tas__ReplaceCertPathValidationPolicyAssignmentResponse() { }
        /// Friend allocator used by soap_new__tas__ReplaceCertPathValidationPolicyAssignmentResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__ReplaceCertPathValidationPolicyAssignmentResponse * SOAP_FMAC2 soap_instantiate__tas__ReplaceCertPathValidationPolicyAssignmentResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3304 */
#ifndef SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies
#define SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies (1137)
/* complex XSD type 'tas:GetAssignedCertPathValidationPolicies': */
class SOAP_CMAC _tas__GetAssignedCertPathValidationPolicies {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAssignedCertPathValidationPolicies, default initialized and not managed by a soap context
        virtual _tas__GetAssignedCertPathValidationPolicies *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAssignedCertPathValidationPolicies); }
      public:
        /// Constructor with initializations
        _tas__GetAssignedCertPathValidationPolicies() : soap() { }
        virtual ~_tas__GetAssignedCertPathValidationPolicies() { }
        /// Friend allocator used by soap_new__tas__GetAssignedCertPathValidationPolicies(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAssignedCertPathValidationPolicies * SOAP_FMAC2 soap_instantiate__tas__GetAssignedCertPathValidationPolicies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3307 */
#ifndef SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse
#define SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse (1138)
/* complex XSD type 'tas:GetAssignedCertPathValidationPoliciesResponse': */
class SOAP_CMAC _tas__GetAssignedCertPathValidationPoliciesResponse {
      public:
        /// Optional element 'tas:CertPathValidationPolicyID' of XSD type 'tas:CertPathValidationPolicyID'
        std::vector<std::string> CertPathValidationPolicyID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAssignedCertPathValidationPoliciesResponse, default initialized and not managed by a soap context
        virtual _tas__GetAssignedCertPathValidationPoliciesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAssignedCertPathValidationPoliciesResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAssignedCertPathValidationPoliciesResponse() : CertPathValidationPolicyID(), soap() { }
        virtual ~_tas__GetAssignedCertPathValidationPoliciesResponse() { }
        /// Friend allocator used by soap_new__tas__GetAssignedCertPathValidationPoliciesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAssignedCertPathValidationPoliciesResponse * SOAP_FMAC2 soap_instantiate__tas__GetAssignedCertPathValidationPoliciesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3310 */
#ifndef SOAP_TYPE__tas__AddDot1XConfiguration
#define SOAP_TYPE__tas__AddDot1XConfiguration (1139)
/* complex XSD type 'tas:AddDot1XConfiguration': */
class SOAP_CMAC _tas__AddDot1XConfiguration {
      public:
        /// Required element 'tas:Dot1XConfiguration' of XSD type 'tas:Dot1XConfiguration'
        tas__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__AddDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__AddDot1XConfiguration() : Dot1XConfiguration(), soap() { }
        virtual ~_tas__AddDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__AddDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__AddDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3313 */
#ifndef SOAP_TYPE__tas__AddDot1XConfigurationResponse
#define SOAP_TYPE__tas__AddDot1XConfigurationResponse (1140)
/* complex XSD type 'tas:AddDot1XConfigurationResponse': */
class SOAP_CMAC _tas__AddDot1XConfigurationResponse {
      public:
        /// Required element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string Dot1XID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__AddDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__AddDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__AddDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__AddDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__AddDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__AddDot1XConfigurationResponse() : Dot1XID(), soap() { }
        virtual ~_tas__AddDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__AddDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__AddDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__AddDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3316 */
#ifndef SOAP_TYPE__tas__GetAllDot1XConfigurations
#define SOAP_TYPE__tas__GetAllDot1XConfigurations (1141)
/* complex XSD type 'tas:GetAllDot1XConfigurations': */
class SOAP_CMAC _tas__GetAllDot1XConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllDot1XConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllDot1XConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllDot1XConfigurations, default initialized and not managed by a soap context
        virtual _tas__GetAllDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllDot1XConfigurations); }
      public:
        /// Constructor with initializations
        _tas__GetAllDot1XConfigurations() : soap() { }
        virtual ~_tas__GetAllDot1XConfigurations() { }
        /// Friend allocator used by soap_new__tas__GetAllDot1XConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tas__GetAllDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3319 */
#ifndef SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse
#define SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse (1142)
/* complex XSD type 'tas:GetAllDot1XConfigurationsResponse': */
class SOAP_CMAC _tas__GetAllDot1XConfigurationsResponse {
      public:
        /// Optional element 'tas:Configuration' of XSD type 'tas:Dot1XConfiguration'
        std::vector<tas__Dot1XConfiguration *> Configuration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetAllDot1XConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tas__GetAllDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetAllDot1XConfigurationsResponse); }
      public:
        /// Constructor with initializations
        _tas__GetAllDot1XConfigurationsResponse() : Configuration(), soap() { }
        virtual ~_tas__GetAllDot1XConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tas__GetAllDot1XConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetAllDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tas__GetAllDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3322 */
#ifndef SOAP_TYPE__tas__GetDot1XConfiguration
#define SOAP_TYPE__tas__GetDot1XConfiguration (1143)
/* complex XSD type 'tas:GetDot1XConfiguration': */
class SOAP_CMAC _tas__GetDot1XConfiguration {
      public:
        /// Required element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string Dot1XID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__GetDot1XConfiguration() : Dot1XID(), soap() { }
        virtual ~_tas__GetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__GetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3325 */
#ifndef SOAP_TYPE__tas__GetDot1XConfigurationResponse
#define SOAP_TYPE__tas__GetDot1XConfigurationResponse (1144)
/* complex XSD type 'tas:GetDot1XConfigurationResponse': */
class SOAP_CMAC _tas__GetDot1XConfigurationResponse {
      public:
        /// Required element 'tas:Dot1XConfiguration' of XSD type 'tas:Dot1XConfiguration'
        tas__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__GetDot1XConfigurationResponse() : Dot1XConfiguration(), soap() { }
        virtual ~_tas__GetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__GetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3328 */
#ifndef SOAP_TYPE__tas__DeleteDot1XConfiguration
#define SOAP_TYPE__tas__DeleteDot1XConfiguration (1145)
/* complex XSD type 'tas:DeleteDot1XConfiguration': */
class SOAP_CMAC _tas__DeleteDot1XConfiguration {
      public:
        /// Required element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string Dot1XID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__DeleteDot1XConfiguration() : Dot1XID(), soap() { }
        virtual ~_tas__DeleteDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__DeleteDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3331 */
#ifndef SOAP_TYPE__tas__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tas__DeleteDot1XConfigurationResponse (1146)
/* complex XSD type 'tas:DeleteDot1XConfigurationResponse': */
class SOAP_CMAC _tas__DeleteDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteDot1XConfigurationResponse() : soap() { }
        virtual ~_tas__DeleteDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3334 */
#ifndef SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration (1147)
/* complex XSD type 'tas:SetNetworkInterfaceDot1XConfiguration': */
class SOAP_CMAC _tas__SetNetworkInterfaceDot1XConfiguration {
      public:
        /// Required element 'tas:token' of XSD type 'xsd:string'
        std::string token;
        /// Required element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string Dot1XID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetNetworkInterfaceDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__SetNetworkInterfaceDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetNetworkInterfaceDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__SetNetworkInterfaceDot1XConfiguration() : token(), Dot1XID(), soap() { }
        virtual ~_tas__SetNetworkInterfaceDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__SetNetworkInterfaceDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__SetNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3337 */
#ifndef SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse (1148)
/* complex XSD type 'tas:SetNetworkInterfaceDot1XConfigurationResponse': */
class SOAP_CMAC _tas__SetNetworkInterfaceDot1XConfigurationResponse {
      public:
        /// Required element 'tas:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__SetNetworkInterfaceDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__SetNetworkInterfaceDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__SetNetworkInterfaceDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__SetNetworkInterfaceDot1XConfigurationResponse() : RebootNeeded(), soap() { }
        virtual ~_tas__SetNetworkInterfaceDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__SetNetworkInterfaceDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__SetNetworkInterfaceDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__SetNetworkInterfaceDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3340 */
#ifndef SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration (1149)
/* complex XSD type 'tas:GetNetworkInterfaceDot1XConfiguration': */
class SOAP_CMAC _tas__GetNetworkInterfaceDot1XConfiguration {
      public:
        /// Required element 'tas:token' of XSD type 'xsd:string'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetNetworkInterfaceDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__GetNetworkInterfaceDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetNetworkInterfaceDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__GetNetworkInterfaceDot1XConfiguration() : token(), soap() { }
        virtual ~_tas__GetNetworkInterfaceDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__GetNetworkInterfaceDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__GetNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3343 */
#ifndef SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse (1150)
/* complex XSD type 'tas:GetNetworkInterfaceDot1XConfigurationResponse': */
class SOAP_CMAC _tas__GetNetworkInterfaceDot1XConfigurationResponse {
      public:
        /// Optional element 'tas:Dot1XID' of XSD type 'tas:Dot1XID'
        std::string *Dot1XID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__GetNetworkInterfaceDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__GetNetworkInterfaceDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__GetNetworkInterfaceDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__GetNetworkInterfaceDot1XConfigurationResponse() : Dot1XID(), soap() { }
        virtual ~_tas__GetNetworkInterfaceDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__GetNetworkInterfaceDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__GetNetworkInterfaceDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__GetNetworkInterfaceDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3346 */
#ifndef SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration (1151)
/* complex XSD type 'tas:DeleteNetworkInterfaceDot1XConfiguration': */
class SOAP_CMAC _tas__DeleteNetworkInterfaceDot1XConfiguration {
      public:
        /// Required element 'tas:token' of XSD type 'xsd:string'
        std::string token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteNetworkInterfaceDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tas__DeleteNetworkInterfaceDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteNetworkInterfaceDot1XConfiguration); }
      public:
        /// Constructor with initializations
        _tas__DeleteNetworkInterfaceDot1XConfiguration() : token(), soap() { }
        virtual ~_tas__DeleteNetworkInterfaceDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tas__DeleteNetworkInterfaceDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tas__DeleteNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3349 */
#ifndef SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse (1152)
/* complex XSD type 'tas:DeleteNetworkInterfaceDot1XConfigurationResponse': */
class SOAP_CMAC _tas__DeleteNetworkInterfaceDot1XConfigurationResponse {
      public:
        /// Required element 'tas:RebootNeeded' of XSD type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tas__DeleteNetworkInterfaceDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tas__DeleteNetworkInterfaceDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tas__DeleteNetworkInterfaceDot1XConfigurationResponse); }
      public:
        /// Constructor with initializations
        _tas__DeleteNetworkInterfaceDot1XConfigurationResponse() : RebootNeeded(), soap() { }
        virtual ~_tas__DeleteNetworkInterfaceDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tas__DeleteNetworkInterfaceDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tas__DeleteNetworkInterfaceDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tas__DeleteNetworkInterfaceDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:301 */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (137)
/* Type tds__StorageConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tds:StorageConfiguration': */
class SOAP_CMAC tds__StorageConfiguration : public tt__DeviceEntity {
      public:
        /// Required element 'tds:Data' of XSD type 'tds:StorageConfigurationData'
        tds__StorageConfigurationData *Data;
      public:
        /// Return unique type id SOAP_TYPE_tds__StorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tds__StorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__StorageConfiguration, default initialized and not managed by a soap context
        virtual tds__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__StorageConfiguration); }
      public:
        /// Constructor with initializations
        tds__StorageConfiguration() : Data() { }
        virtual ~tds__StorageConfiguration() { }
        /// Friend allocator used by soap_new_tds__StorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:865 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (325)
/* Type tt__VideoSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoSource': */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Framerate' of XSD type 'xsd:float'
        float Framerate;
        /// Required element 'tt:Resolution' of XSD type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Optional element 'tt:Imaging' of XSD type 'tt:ImagingSettings'
        tt__ImagingSettings *Imaging;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceExtension'
        tt__VideoSourceExtension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
        virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSource); }
      public:
        /// Constructor with initializations
        tt__VideoSource() : Framerate(), Resolution(), Imaging(), Extension() { }
        virtual ~tt__VideoSource() { }
        /// Friend allocator used by soap_new_tt__VideoSource(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:874 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (328)
/* Type tt__AudioSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioSource': */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Channels' of XSD type 'xsd:int'
        int Channels;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
        virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSource); }
      public:
        /// Constructor with initializations
        tt__AudioSource() : Channels() { }
        virtual ~tt__AudioSource() { }
        /// Friend allocator used by soap_new_tt__AudioSource(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:889 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (333)
/* Type tt__VideoSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoSourceConfiguration': */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XSD type 'tt:ReferenceToken'
        std::string SourceToken;
        /// Required element 'tt:Bounds' of XSD type 'tt:IntRectangle'
        tt__IntRectangle *Bounds;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoSourceConfigurationExtension'
        tt__VideoSourceConfigurationExtension *Extension;
        /// optional attribute 'ViewMode' of XSD type 'xsd:string'
        std::string *ViewMode;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfiguration); }
      public:
        /// Constructor with initializations
        tt__VideoSourceConfiguration() : SourceToken(), Bounds(), Extension(), ViewMode() { }
        virtual ~tt__VideoSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:931 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (347)
/* Type tt__VideoEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoEncoderConfiguration': */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XSD type 'tt:VideoEncoding'
        enum tt__VideoEncoding Encoding;
        /// Required element 'tt:Resolution' of XSD type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Required element 'tt:Quality' of XSD type 'xsd:float'
        float Quality;
        /// Optional element 'tt:RateControl' of XSD type 'tt:VideoRateControl'
        tt__VideoRateControl *RateControl;
        /// Optional element 'tt:MPEG4' of XSD type 'tt:Mpeg4Configuration'
        tt__Mpeg4Configuration *MPEG4;
        /// Optional element 'tt:H264' of XSD type 'tt:H264Configuration'
        tt__H264Configuration *H264;
        /// Required element 'tt:Multicast' of XSD type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// optional attribute 'GuaranteedFrameRate' of XSD type 'xsd:boolean'
        bool *GuaranteedFrameRate;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderConfiguration); }
      public:
        /// Constructor with initializations
        tt__VideoEncoderConfiguration() : Encoding(), Resolution(), Quality(), RateControl(), MPEG4(), H264(), Multicast(), SessionTimeout(), GuaranteedFrameRate() { }
        virtual ~tt__VideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:958 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (356)
/* Type tt__JpegOptions2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:JpegOptions2': */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions {
      public:
        /// Required element 'tt:BitrateRange' of XSD type 'tt:IntRange'
        tt__IntRange *BitrateRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__JpegOptions2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JpegOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
        virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JpegOptions2); }
      public:
        /// Constructor with initializations
        tt__JpegOptions2() : BitrateRange() { }
        virtual ~tt__JpegOptions2() { }
        /// Friend allocator used by soap_new_tt__JpegOptions2(struct soap*, int)
        friend SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:964 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (358)
/* Type tt__Mpeg4Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:Mpeg4Options2': */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options {
      public:
        /// Required element 'tt:BitrateRange' of XSD type 'tt:IntRange'
        tt__IntRange *BitrateRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Options2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
        virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Options2); }
      public:
        /// Constructor with initializations
        tt__Mpeg4Options2() : BitrateRange() { }
        virtual ~tt__Mpeg4Options2() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Options2(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:970 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (360)
/* Type tt__H264Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:H264Options2': */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options {
      public:
        /// Required element 'tt:BitrateRange' of XSD type 'tt:IntRange'
        tt__IntRange *BitrateRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Options2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
        virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Options2); }
      public:
        /// Constructor with initializations
        tt__H264Options2() : BitrateRange() { }
        virtual ~tt__H264Options2() { }
        /// Friend allocator used by soap_new_tt__H264Options2(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:973 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (361)
/* Type tt__AudioSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioSourceConfiguration': */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XSD type 'tt:ReferenceToken'
        std::string SourceToken;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceConfiguration); }
      public:
        /// Constructor with initializations
        tt__AudioSourceConfiguration() : SourceToken() { }
        virtual ~tt__AudioSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:982 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (364)
/* Type tt__AudioEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioEncoderConfiguration': */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XSD type 'tt:AudioEncoding'
        enum tt__AudioEncoding Encoding;
        /// Required element 'tt:Bitrate' of XSD type 'xsd:int'
        int Bitrate;
        /// Required element 'tt:SampleRate' of XSD type 'xsd:int'
        int SampleRate;
        /// Required element 'tt:Multicast' of XSD type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfiguration); }
      public:
        /// Constructor with initializations
        tt__AudioEncoderConfiguration() : Encoding(), Bitrate(), SampleRate(), Multicast(), SessionTimeout() { }
        virtual ~tt__AudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:991 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (367)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoAnalyticsConfiguration': */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:AnalyticsEngineConfiguration' of XSD type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Required element 'tt:RuleEngineConfiguration' of XSD type 'tt:RuleEngineConfiguration'
        tt__RuleEngineConfiguration *RuleEngineConfiguration;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoAnalyticsConfiguration); }
      public:
        /// Constructor with initializations
        tt__VideoAnalyticsConfiguration() : AnalyticsEngineConfiguration(), RuleEngineConfiguration() { }
        virtual ~tt__VideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:994 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (368)
/* Type tt__MetadataConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:MetadataConfiguration': */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity {
      public:
        /// Optional element 'tt:PTZStatus' of XSD type 'tt:PTZFilter'
        tt__PTZFilter *PTZStatus;
        /// Optional element 'tt:Events' of XSD type 'tt:EventSubscription'
        tt__EventSubscription *Events;
        /// Optional element 'tt:Analytics' of XSD type 'xsd:boolean'
        bool *Analytics;
        /// Required element 'tt:Multicast' of XSD type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XSD type 'xsd:duration'
        std::string SessionTimeout;
        /// Optional element 'tt:AnalyticsEngineConfiguration' of XSD type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Optional element 'tt:Extension' of XSD type 'tt:MetadataConfigurationExtension'
        tt__MetadataConfigurationExtension *Extension;
        /// optional attribute 'CompressionType' of XSD type 'xsd:string'
        std::string *CompressionType;
        /// optional attribute 'GeoLocation' of XSD type 'xsd:boolean'
        bool *GeoLocation;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
        virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfiguration); }
      public:
        /// Constructor with initializations
        tt__MetadataConfiguration() : PTZStatus(), Events(), Analytics(), Multicast(), SessionTimeout(), AnalyticsEngineConfiguration(), Extension(), CompressionType(), GeoLocation() { }
        virtual ~tt__MetadataConfiguration() { }
        /// Friend allocator used by soap_new_tt__MetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1021 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (377)
/* Type tt__VideoOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoOutput': */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Layout' of XSD type 'tt:Layout'
        tt__Layout *Layout;
        /// Optional element 'tt:Resolution' of XSD type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Optional element 'tt:RefreshRate' of XSD type 'xsd:float'
        float *RefreshRate;
        /// Optional element 'tt:AspectRatio' of XSD type 'xsd:float'
        float *AspectRatio;
        /// Optional element 'tt:Extension' of XSD type 'tt:VideoOutputExtension'
        tt__VideoOutputExtension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
        virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutput); }
      public:
        /// Constructor with initializations
        tt__VideoOutput() : Layout(), Resolution(), RefreshRate(), AspectRatio(), Extension() { }
        virtual ~tt__VideoOutput() { }
        /// Friend allocator used by soap_new_tt__VideoOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1027 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (379)
/* Type tt__VideoOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:VideoOutputConfiguration': */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:OutputToken' of XSD type 'tt:ReferenceToken'
        std::string OutputToken;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputConfiguration); }
      public:
        /// Constructor with initializations
        tt__VideoOutputConfiguration() : OutputToken() { }
        virtual ~tt__VideoOutputConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1033 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (381)
/* Type tt__AudioOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioOutput': */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity {
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
        virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutput); }
      public:
        /// Constructor with initializations
        tt__AudioOutput() { }
        virtual ~tt__AudioOutput() { }
        /// Friend allocator used by soap_new_tt__AudioOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1036 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (382)
/* Type tt__AudioOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioOutputConfiguration': */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:OutputToken' of XSD type 'tt:ReferenceToken'
        std::string OutputToken;
        /// Optional element 'tt:SendPrimacy' of XSD type 'xsd:anyURI'
        std::string *SendPrimacy;
        /// Required element 'tt:OutputLevel' of XSD type 'xsd:int'
        int OutputLevel;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutputConfiguration); }
      public:
        /// Constructor with initializations
        tt__AudioOutputConfiguration() : OutputToken(), SendPrimacy(), OutputLevel() { }
        virtual ~tt__AudioOutputConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1042 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (384)
/* Type tt__AudioDecoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:AudioDecoderConfiguration': */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfiguration); }
      public:
        /// Constructor with initializations
        tt__AudioDecoderConfiguration() { }
        virtual ~tt__AudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1075 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (395)
/* Type tt__NetworkInterface is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:NetworkInterface': */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Enabled' of XSD type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Info' of XSD type 'tt:NetworkInterfaceInfo'
        tt__NetworkInterfaceInfo *Info;
        /// Optional element 'tt:Link' of XSD type 'tt:NetworkInterfaceLink'
        tt__NetworkInterfaceLink *Link;
        /// Optional element 'tt:IPv4' of XSD type 'tt:IPv4NetworkInterface'
        tt__IPv4NetworkInterface *IPv4;
        /// Optional element 'tt:IPv6' of XSD type 'tt:IPv6NetworkInterface'
        tt__IPv6NetworkInterface *IPv6;
        /// Optional element 'tt:Extension' of XSD type 'tt:NetworkInterfaceExtension'
        tt__NetworkInterfaceExtension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
        virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterface); }
      public:
        /// Constructor with initializations
        tt__NetworkInterface() : Enabled(), Info(), Link(), IPv4(), IPv6(), Extension() { }
        virtual ~tt__NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1381 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (497)
/* simple XSD type 'tt:CertificateUsage': */
class SOAP_CMAC tt__CertificateUsage {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'Critical' of XSD type 'xsd:boolean'
        bool Critical;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateUsage
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateUsage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
        virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateUsage); }
      public:
        /// Constructor with initializations
        tt__CertificateUsage() : __item(), Critical(), soap() { }
        virtual ~tt__CertificateUsage() { }
        /// Friend allocator used by soap_new_tt__CertificateUsage(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1405 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (505)
/* Type tt__RelayOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:RelayOutput': */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Properties' of XSD type 'tt:RelayOutputSettings'
        tt__RelayOutputSettings *Properties;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
        virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayOutput); }
      public:
        /// Constructor with initializations
        tt__RelayOutput() : Properties() { }
        virtual ~tt__RelayOutput() { }
        /// Friend allocator used by soap_new_tt__RelayOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1408 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (506)
/* Type tt__DigitalInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:DigitalInput': */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity {
      public:
        /// optional attribute 'IdleState' of XSD type 'tt:DigitalIdleState'
        enum tt__DigitalIdleState *IdleState;
      public:
        /// Return unique type id SOAP_TYPE_tt__DigitalInput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DigitalInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
        virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DigitalInput); }
      public:
        /// Constructor with initializations
        tt__DigitalInput() : IdleState() { }
        virtual ~tt__DigitalInput() { }
        /// Friend allocator used by soap_new_tt__DigitalInput(struct soap*, int)
        friend SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1411 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (507)
/* Type tt__PTZNode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:PTZNode': */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity {
      public:
        /// Optional element 'tt:Name' of XSD type 'tt:Name'
        std::string *Name;
        /// Required element 'tt:SupportedPTZSpaces' of XSD type 'tt:PTZSpaces'
        tt__PTZSpaces *SupportedPTZSpaces;
        /// Required element 'tt:MaximumNumberOfPresets' of XSD type 'xsd:int'
        int MaximumNumberOfPresets;
        /// Required element 'tt:HomeSupported' of XSD type 'xsd:boolean'
        bool HomeSupported;
        /// Optional element 'tt:AuxiliaryCommands' of XSD type 'tt:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZNodeExtension'
        tt__PTZNodeExtension *Extension;
        /// optional attribute 'FixedHomePosition' of XSD type 'xsd:boolean'
        bool *FixedHomePosition;
        /// optional attribute 'GeoMove' of XSD type 'xsd:boolean'
        bool *GeoMove;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNode
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
        virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNode); }
      public:
        /// Constructor with initializations
        tt__PTZNode() : Name(), SupportedPTZSpaces(), MaximumNumberOfPresets(), HomeSupported(), AuxiliaryCommands(), Extension(), FixedHomePosition(), GeoMove() { }
        virtual ~tt__PTZNode() { }
        /// Friend allocator used by soap_new_tt__PTZNode(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1426 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (512)
/* Type tt__PTZConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:PTZConfiguration': */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:NodeToken' of XSD type 'tt:ReferenceToken'
        std::string NodeToken;
        /// Optional element 'tt:DefaultAbsolutePantTiltPositionSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultAbsolutePantTiltPositionSpace;
        /// Optional element 'tt:DefaultAbsoluteZoomPositionSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultAbsoluteZoomPositionSpace;
        /// Optional element 'tt:DefaultRelativePanTiltTranslationSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultRelativePanTiltTranslationSpace;
        /// Optional element 'tt:DefaultRelativeZoomTranslationSpace' of XSD type 'xsd:anyURI'
        std::string *DefaultRelativeZoomTranslationSpace;
        /// Optional element 'tt:DefaultContinuousPanTiltVelocitySpace' of XSD type 'xsd:anyURI'
        std::string *DefaultContinuousPanTiltVelocitySpace;
        /// Optional element 'tt:DefaultContinuousZoomVelocitySpace' of XSD type 'xsd:anyURI'
        std::string *DefaultContinuousZoomVelocitySpace;
        /// Optional element 'tt:DefaultPTZSpeed' of XSD type 'tt:PTZSpeed'
        tt__PTZSpeed *DefaultPTZSpeed;
        /// Optional element 'tt:DefaultPTZTimeout' of XSD type 'xsd:duration'
        std::string *DefaultPTZTimeout;
        /// Optional element 'tt:PanTiltLimits' of XSD type 'tt:PanTiltLimits'
        tt__PanTiltLimits *PanTiltLimits;
        /// Optional element 'tt:ZoomLimits' of XSD type 'tt:ZoomLimits'
        tt__ZoomLimits *ZoomLimits;
        /// Optional element 'tt:Extension' of XSD type 'tt:PTZConfigurationExtension'
        tt__PTZConfigurationExtension *Extension;
        /// optional attribute 'MoveRamp' of XSD type 'xsd:int'
        int *MoveRamp;
        /// optional attribute 'PresetRamp' of XSD type 'xsd:int'
        int *PresetRamp;
        /// optional attribute 'PresetTourRamp' of XSD type 'xsd:int'
        int *PresetTourRamp;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
        virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfiguration); }
      public:
        /// Constructor with initializations
        tt__PTZConfiguration() : NodeToken(), DefaultAbsolutePantTiltPositionSpace(), DefaultAbsoluteZoomPositionSpace(), DefaultRelativePanTiltTranslationSpace(), DefaultRelativeZoomTranslationSpace(), DefaultContinuousPanTiltVelocitySpace(), DefaultContinuousZoomVelocitySpace(), DefaultPTZSpeed(), DefaultPTZTimeout(), PanTiltLimits(), ZoomLimits(), Extension(), MoveRamp(), PresetRamp(), PresetTourRamp() { }
        virtual ~tt__PTZConfiguration() { }
        /// Friend allocator used by soap_new_tt__PTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1807 */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (639)
/* Type tt__OSDConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tt:OSDConfiguration': */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity {
      public:
        /// Required element 'tt:VideoSourceConfigurationToken' of XSD type 'tt:OSDReference'
        tt__OSDReference *VideoSourceConfigurationToken;
        /// Required element 'tt:Type' of XSD type 'tt:OSDType'
        enum tt__OSDType Type;
        /// Required element 'tt:Position' of XSD type 'tt:OSDPosConfiguration'
        tt__OSDPosConfiguration *Position;
        /// Optional element 'tt:TextString' of XSD type 'tt:OSDTextConfiguration'
        tt__OSDTextConfiguration *TextString;
        /// Optional element 'tt:Image' of XSD type 'tt:OSDImgConfiguration'
        tt__OSDImgConfiguration *Image;
        /// Optional element 'tt:Extension' of XSD type 'tt:OSDConfigurationExtension'
        tt__OSDConfigurationExtension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfiguration); }
      public:
        /// Constructor with initializations
        tt__OSDConfiguration() : VideoSourceConfigurationToken(), Type(), Position(), TextString(), Image(), Extension() { }
        virtual ~tt__OSDConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1888 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (666)
/* Type wsnt__SubscribeCreationFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:SubscribeCreationFailedFaultType': */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__SubscribeCreationFailedFaultType() { }
        virtual ~wsnt__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1891 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (667)
/* Type wsnt__InvalidFilterFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:InvalidFilterFaultType': */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:UnknownFilter' of XSD type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidFilterFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidFilterFaultType); }
      public:
        /// Constructor with initializations
        wsnt__InvalidFilterFaultType() : UnknownFilter() { }
        virtual ~wsnt__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1894 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (668)
/* Type wsnt__TopicExpressionDialectUnknownFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with initializations
        wsnt__TopicExpressionDialectUnknownFaultType() { }
        virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1897 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (669)
/* Type wsnt__InvalidTopicExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:InvalidTopicExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with initializations
        wsnt__InvalidTopicExpressionFaultType() { }
        virtual ~wsnt__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1900 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (670)
/* Type wsnt__TopicNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:TopicNotSupportedFaultType': */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__TopicNotSupportedFaultType() { }
        virtual ~wsnt__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1903 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (671)
/* Type wsnt__MultipleTopicsSpecifiedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__MultipleTopicsSpecifiedFaultType() { }
        virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1906 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (672)
/* Type wsnt__InvalidProducerPropertiesExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with initializations
        wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1909 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (673)
/* Type wsnt__InvalidMessageContentExpressionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with initializations
        wsnt__InvalidMessageContentExpressionFaultType() { }
        virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1912 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (674)
/* Type wsnt__UnrecognizedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnrecognizedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnrecognizedPolicyRequestFaultType() : UnrecognizedPolicy() { }
        virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1915 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (675)
/* Type wsnt__UnsupportedPolicyRequestFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnsupportedPolicy' of XSD type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnsupportedPolicyRequestFaultType() : UnsupportedPolicy() { }
        virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1918 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (676)
/* Type wsnt__NotifyMessageNotSupportedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__NotifyMessageNotSupportedFaultType() { }
        virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1921 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (677)
/* Type wsnt__UnacceptableInitialTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnacceptableInitialTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1924 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (678)
/* Type wsnt__NoCurrentMessageOnTopicFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with initializations
        wsnt__NoCurrentMessageOnTopicFaultType() { }
        virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1927 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (679)
/* Type wsnt__UnableToGetMessagesFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnableToGetMessagesFaultType': */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnableToGetMessagesFaultType() { }
        virtual ~wsnt__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1930 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (680)
/* Type wsnt__UnableToDestroyPullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnableToDestroyPullPointFaultType() { }
        virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1933 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (681)
/* Type wsnt__UnableToCreatePullPointFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnableToCreatePullPointFaultType': */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnableToCreatePullPointFaultType() { }
        virtual ~wsnt__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1936 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (682)
/* Type wsnt__UnacceptableTerminationTimeFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XSD type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XSD type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnacceptableTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1939 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (683)
/* Type wsnt__UnableToDestroySubscriptionFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with initializations
        wsnt__UnableToDestroySubscriptionFaultType() { }
        virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1942 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (684)
/* Type wsnt__PauseFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:PauseFailedFaultType': */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__PauseFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__PauseFailedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__PauseFailedFaultType() { }
        virtual ~wsnt__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1945 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (685)
/* Type wsnt__ResumeFailedFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsnt:ResumeFailedFaultType': */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__ResumeFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__ResumeFailedFaultType); }
      public:
        /// Constructor with initializations
        wsnt__ResumeFailedFaultType() { }
        virtual ~wsnt__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35240 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1847)
/* complex XSD type 'wstop:TopicNamespaceType-Topic': */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic {
      public:
        /// Optional element 'wstop:documentation' of XSD type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Optional element 'wstop:MessagePattern' of XSD type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XSD type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
        /// optional attribute 'parent' of XSD type 'wstop:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__wstop__TopicNamespaceType_Topic
        virtual long soap_type(void) const { return SOAP_TYPE__wstop__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wstop__TopicNamespaceType_Topic); }
      public:
        /// Constructor with initializations
        _wstop__TopicNamespaceType_Topic() : documentation(), MessagePattern(), Topic(), name(), messageTypes(), final_((bool)0), parent() { }
        virtual ~_wstop__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__wstop__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2026 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (712)
/* Type wstop__TopicNamespaceType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wstop:TopicNamespaceType': */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:Topic' of XSD type 'wstop:TopicNamespaceType-Topic'
        std::vector<_wstop__TopicNamespaceType_Topic> Topic;
        /// optional attribute 'name' of XSD type 'xsd:NCName'
        std::string *name;
        /// required attribute 'targetNamespace' of XSD type 'xsd:anyURI'
        std::string targetNamespace;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicNamespaceType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
        virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicNamespaceType); }
      public:
        /// Constructor with initializations
        wstop__TopicNamespaceType() : Topic(), name(), targetNamespace(), final_((bool)0) { }
        virtual ~wstop__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_wstop__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2029 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (713)
/* Type wstop__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wstop:TopicType': */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:MessagePattern' of XSD type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XSD type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        /// required attribute 'name' of XSD type 'xsd:NCName'
        std::string name;
        /// optional attribute 'messageTypes' of XSD type 'xsd:QName'
        std::string *messageTypes;
        /// optional attribute 'final' of XSD type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
        virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicType); }
      public:
        /// Constructor with initializations
        wstop__TopicType() : MessagePattern(), Topic(), name(), messageTypes(), final_((bool)0) { }
        virtual ~wstop__TopicType() { }
        /// Friend allocator used by soap_new_wstop__TopicType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2032 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (714)
/* Type wstop__TopicSetType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wstop:TopicSetType': */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented {
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicSetType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
        virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicSetType); }
      public:
        /// Constructor with initializations
        wstop__TopicSetType() { }
        virtual ~wstop__TopicSetType() { }
        /// Friend allocator used by soap_new_wstop__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2080 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (729)
/* Type wsrfr__ResourceUnknownFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsrfr:ResourceUnknownFaultType': */
class SOAP_CMAC wsrfr__ResourceUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsrfr__ResourceUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfr__ResourceUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfr__ResourceUnknownFaultType, default initialized and not managed by a soap context
        virtual wsrfr__ResourceUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfr__ResourceUnknownFaultType); }
      public:
        /// Constructor with initializations
        wsrfr__ResourceUnknownFaultType() { }
        virtual ~wsrfr__ResourceUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsrfr__ResourceUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfr__ResourceUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2083 */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (730)
/* Type wsrfr__ResourceUnavailableFaultType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'wsrfr:ResourceUnavailableFaultType': */
class SOAP_CMAC wsrfr__ResourceUnavailableFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfr__ResourceUnavailableFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfr__ResourceUnavailableFaultType, default initialized and not managed by a soap context
        virtual wsrfr__ResourceUnavailableFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfr__ResourceUnavailableFaultType); }
      public:
        /// Constructor with initializations
        wsrfr__ResourceUnavailableFaultType() { }
        virtual ~wsrfr__ResourceUnavailableFaultType() { }
        /// Friend allocator used by soap_new_wsrfr__ResourceUnavailableFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfr__ResourceUnavailableFaultType * SOAP_FMAC2 soap_instantiate_wsrfr__ResourceUnavailableFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2107 */
#ifndef SOAP_TYPE_tmd__SerialPort
#define SOAP_TYPE_tmd__SerialPort (738)
/* Type tmd__SerialPort is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'tmd:SerialPort': */
class SOAP_CMAC tmd__SerialPort : public tt__DeviceEntity {
      public:
        /// Return unique type id SOAP_TYPE_tmd__SerialPort
        virtual long soap_type(void) const { return SOAP_TYPE_tmd__SerialPort; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tmd__SerialPort, default initialized and not managed by a soap context
        virtual tmd__SerialPort *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tmd__SerialPort); }
      public:
        /// Constructor with initializations
        tmd__SerialPort() { }
        virtual ~tmd__SerialPort() { }
        /// Friend allocator used by soap_new_tmd__SerialPort(struct soap*, int)
        friend SOAP_FMAC1 tmd__SerialPort * SOAP_FMAC2 soap_instantiate_tmd__SerialPort(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1759 */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (623)
/* simple XSD type 'tt:OSDReference': */
class SOAP_CMAC tt__OSDReference {
      public:
        /// Simple content of XSD type 'tt:ReferenceToken' wrapped by this struct
        std::string __item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDReference
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDReference, default initialized and not managed by a soap context
        virtual tt__OSDReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDReference); }
      public:
        /// Constructor with initializations
        tt__OSDReference() : __item(), soap() { }
        virtual ~tt__OSDReference() { }
        /// Friend allocator used by soap_new_tt__OSDReference(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:281 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (44)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'wsnt:InvalidFilterFault' of XSD type 'wsnt:InvalidFilterFaultType' */
        wsnt__InvalidFilterFaultType *wsnt__InvalidFilterFault;
        /** Optional element 'wsnt:InvalidMessageContentExpressionFault' of XSD type 'wsnt:InvalidMessageContentExpressionFaultType' */
        wsnt__InvalidMessageContentExpressionFaultType *wsnt__InvalidMessageContentExpressionFault;
        /** Optional element 'wsnt:InvalidProducerPropertiesExpressionFault' of XSD type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
        wsnt__InvalidProducerPropertiesExpressionFaultType *wsnt__InvalidProducerPropertiesExpressionFault;
        /** Optional element 'wsnt:InvalidTopicExpressionFault' of XSD type 'wsnt:InvalidTopicExpressionFaultType' */
        wsnt__InvalidTopicExpressionFaultType *wsnt__InvalidTopicExpressionFault;
        /** Optional element 'wsnt:MultipleTopicsSpecifiedFault' of XSD type 'wsnt:MultipleTopicsSpecifiedFaultType' */
        wsnt__MultipleTopicsSpecifiedFaultType *wsnt__MultipleTopicsSpecifiedFault;
        /** Optional element 'wsnt:NoCurrentMessageOnTopicFault' of XSD type 'wsnt:NoCurrentMessageOnTopicFaultType' */
        wsnt__NoCurrentMessageOnTopicFaultType *wsnt__NoCurrentMessageOnTopicFault;
        /** Optional element 'wsnt:NotifyMessageNotSupportedFault' of XSD type 'wsnt:NotifyMessageNotSupportedFaultType' */
        wsnt__NotifyMessageNotSupportedFaultType *wsnt__NotifyMessageNotSupportedFault;
        /** Optional element 'wsnt:PauseFailedFault' of XSD type 'wsnt:PauseFailedFaultType' */
        wsnt__PauseFailedFaultType *wsnt__PauseFailedFault;
        /** Optional element 'tev:PullMessagesFaultResponse' of XSD type 'tev:PullMessagesFaultResponse' */
        _tev__PullMessagesFaultResponse *tev__PullMessagesFaultResponse;
        /** Optional element 'wsrfr:ResourceUnknownFault' of XSD type 'wsrfr:ResourceUnknownFaultType' */
        wsrfr__ResourceUnknownFaultType *wsrfr__ResourceUnknownFault;
        /** Optional element 'wsnt:ResumeFailedFault' of XSD type 'wsnt:ResumeFailedFaultType' */
        wsnt__ResumeFailedFaultType *wsnt__ResumeFailedFault;
        /** Optional element 'wsnt:SubscribeCreationFailedFault' of XSD type 'wsnt:SubscribeCreationFailedFaultType' */
        wsnt__SubscribeCreationFailedFaultType *wsnt__SubscribeCreationFailedFault;
        /** Optional element 'wsnt:TopicExpressionDialectUnknownFault' of XSD type 'wsnt:TopicExpressionDialectUnknownFaultType' */
        wsnt__TopicExpressionDialectUnknownFaultType *wsnt__TopicExpressionDialectUnknownFault;
        /** Optional element 'wsnt:TopicNotSupportedFault' of XSD type 'wsnt:TopicNotSupportedFaultType' */
        wsnt__TopicNotSupportedFaultType *wsnt__TopicNotSupportedFault;
        /** Optional element 'wsnt:UnableToCreatePullPointFault' of XSD type 'wsnt:UnableToCreatePullPointFaultType' */
        wsnt__UnableToCreatePullPointFaultType *wsnt__UnableToCreatePullPointFault;
        /** Optional element 'wsnt:UnableToDestroyPullPointFault' of XSD type 'wsnt:UnableToDestroyPullPointFaultType' */
        wsnt__UnableToDestroyPullPointFaultType *wsnt__UnableToDestroyPullPointFault;
        /** Optional element 'wsnt:UnableToDestroySubscriptionFault' of XSD type 'wsnt:UnableToDestroySubscriptionFaultType' */
        wsnt__UnableToDestroySubscriptionFaultType *wsnt__UnableToDestroySubscriptionFault;
        /** Optional element 'wsnt:UnableToGetMessagesFault' of XSD type 'wsnt:UnableToGetMessagesFaultType' */
        wsnt__UnableToGetMessagesFaultType *wsnt__UnableToGetMessagesFault;
        /** Optional element 'wsnt:UnacceptableInitialTerminationTimeFault' of XSD type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
        wsnt__UnacceptableInitialTerminationTimeFaultType *wsnt__UnacceptableInitialTerminationTimeFault;
        /** Optional element 'wsnt:UnacceptableTerminationTimeFault' of XSD type 'wsnt:UnacceptableTerminationTimeFaultType' */
        wsnt__UnacceptableTerminationTimeFaultType *wsnt__UnacceptableTerminationTimeFault;
        /** Optional element 'wsnt:UnrecognizedPolicyRequestFault' of XSD type 'wsnt:UnrecognizedPolicyRequestFaultType' */
        wsnt__UnrecognizedPolicyRequestFaultType *wsnt__UnrecognizedPolicyRequestFault;
        /** Optional element 'wsnt:UnsupportedPolicyRequestFault' of XSD type 'wsnt:UnsupportedPolicyRequestFaultType' */
        wsnt__UnsupportedPolicyRequestFaultType *wsnt__UnsupportedPolicyRequestFault;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : wsnt__InvalidFilterFault(), wsnt__InvalidMessageContentExpressionFault(), wsnt__InvalidProducerPropertiesExpressionFault(), wsnt__InvalidTopicExpressionFault(), wsnt__MultipleTopicsSpecifiedFault(), wsnt__NoCurrentMessageOnTopicFault(), wsnt__NotifyMessageNotSupportedFault(), wsnt__PauseFailedFault(), tev__PullMessagesFaultResponse(), wsrfr__ResourceUnknownFault(), wsnt__ResumeFailedFault(), wsnt__SubscribeCreationFailedFault(), wsnt__TopicExpressionDialectUnknownFault(), wsnt__TopicNotSupportedFault(), wsnt__UnableToCreatePullPointFault(), wsnt__UnableToDestroyPullPointFault(), wsnt__UnableToDestroySubscriptionFault(), wsnt__UnableToGetMessagesFault(), wsnt__UnacceptableInitialTerminationTimeFault(), wsnt__UnacceptableTerminationTimeFault(), wsnt__UnrecognizedPolicyRequestFault(), wsnt__UnsupportedPolicyRequestFault(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvif.h:37203 */
#ifndef SOAP_TYPE___tas__GetServiceCapabilities
#define SOAP_TYPE___tas__GetServiceCapabilities (1881)
/* Wrapper: */
struct SOAP_CMAC __tas__GetServiceCapabilities {
      public:
        /** Optional element 'tas:GetServiceCapabilities' of XSD type 'tas:GetServiceCapabilities' */
        _tas__GetServiceCapabilities *tas__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tas__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tas__GetServiceCapabilities() : tas__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tas__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37295 */
#ifndef SOAP_TYPE___tas__CreateRSAKeyPair
#define SOAP_TYPE___tas__CreateRSAKeyPair (1885)
/* Wrapper: */
struct SOAP_CMAC __tas__CreateRSAKeyPair {
      public:
        /** Optional element 'tas:CreateRSAKeyPair' of XSD type 'tas:CreateRSAKeyPair' */
        _tas__CreateRSAKeyPair *tas__CreateRSAKeyPair;
      public:
        /** Return unique type id SOAP_TYPE___tas__CreateRSAKeyPair */
        long soap_type() const { return SOAP_TYPE___tas__CreateRSAKeyPair; }
        /** Constructor with member initializations */
        __tas__CreateRSAKeyPair() : tas__CreateRSAKeyPair() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__CreateRSAKeyPair * SOAP_FMAC2 soap_instantiate___tas__CreateRSAKeyPair(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37375 */
#ifndef SOAP_TYPE___tas__UploadKeyPairInPKCS8
#define SOAP_TYPE___tas__UploadKeyPairInPKCS8 (1889)
/* Wrapper: */
struct SOAP_CMAC __tas__UploadKeyPairInPKCS8 {
      public:
        /** Optional element 'tas:UploadKeyPairInPKCS8' of XSD type 'tas:UploadKeyPairInPKCS8' */
        _tas__UploadKeyPairInPKCS8 *tas__UploadKeyPairInPKCS8;
      public:
        /** Return unique type id SOAP_TYPE___tas__UploadKeyPairInPKCS8 */
        long soap_type() const { return SOAP_TYPE___tas__UploadKeyPairInPKCS8; }
        /** Constructor with member initializations */
        __tas__UploadKeyPairInPKCS8() : tas__UploadKeyPairInPKCS8() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__UploadKeyPairInPKCS8 * SOAP_FMAC2 soap_instantiate___tas__UploadKeyPairInPKCS8(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37475 */
#ifndef SOAP_TYPE___tas__UploadCertificateWithPrivateKeyInPKCS12
#define SOAP_TYPE___tas__UploadCertificateWithPrivateKeyInPKCS12 (1893)
/* Wrapper: */
struct SOAP_CMAC __tas__UploadCertificateWithPrivateKeyInPKCS12 {
      public:
        /** Optional element 'tas:UploadCertificateWithPrivateKeyInPKCS12' of XSD type 'tas:UploadCertificateWithPrivateKeyInPKCS12' */
        _tas__UploadCertificateWithPrivateKeyInPKCS12 *tas__UploadCertificateWithPrivateKeyInPKCS12;
      public:
        /** Return unique type id SOAP_TYPE___tas__UploadCertificateWithPrivateKeyInPKCS12 */
        long soap_type() const { return SOAP_TYPE___tas__UploadCertificateWithPrivateKeyInPKCS12; }
        /** Constructor with member initializations */
        __tas__UploadCertificateWithPrivateKeyInPKCS12() : tas__UploadCertificateWithPrivateKeyInPKCS12() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__UploadCertificateWithPrivateKeyInPKCS12 * SOAP_FMAC2 soap_instantiate___tas__UploadCertificateWithPrivateKeyInPKCS12(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37549 */
#ifndef SOAP_TYPE___tas__GetKeyStatus
#define SOAP_TYPE___tas__GetKeyStatus (1897)
/* Wrapper: */
struct SOAP_CMAC __tas__GetKeyStatus {
      public:
        /** Optional element 'tas:GetKeyStatus' of XSD type 'tas:GetKeyStatus' */
        _tas__GetKeyStatus *tas__GetKeyStatus;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetKeyStatus */
        long soap_type() const { return SOAP_TYPE___tas__GetKeyStatus; }
        /** Constructor with member initializations */
        __tas__GetKeyStatus() : tas__GetKeyStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetKeyStatus * SOAP_FMAC2 soap_instantiate___tas__GetKeyStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37626 */
#ifndef SOAP_TYPE___tas__GetPrivateKeyStatus
#define SOAP_TYPE___tas__GetPrivateKeyStatus (1901)
/* Wrapper: */
struct SOAP_CMAC __tas__GetPrivateKeyStatus {
      public:
        /** Optional element 'tas:GetPrivateKeyStatus' of XSD type 'tas:GetPrivateKeyStatus' */
        _tas__GetPrivateKeyStatus *tas__GetPrivateKeyStatus;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetPrivateKeyStatus */
        long soap_type() const { return SOAP_TYPE___tas__GetPrivateKeyStatus; }
        /** Constructor with member initializations */
        __tas__GetPrivateKeyStatus() : tas__GetPrivateKeyStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetPrivateKeyStatus * SOAP_FMAC2 soap_instantiate___tas__GetPrivateKeyStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37701 */
#ifndef SOAP_TYPE___tas__GetAllKeys
#define SOAP_TYPE___tas__GetAllKeys (1905)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllKeys {
      public:
        /** Optional element 'tas:GetAllKeys' of XSD type 'tas:GetAllKeys' */
        _tas__GetAllKeys *tas__GetAllKeys;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllKeys */
        long soap_type() const { return SOAP_TYPE___tas__GetAllKeys; }
        /** Constructor with member initializations */
        __tas__GetAllKeys() : tas__GetAllKeys() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllKeys * SOAP_FMAC2 soap_instantiate___tas__GetAllKeys(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37785 */
#ifndef SOAP_TYPE___tas__DeleteKey
#define SOAP_TYPE___tas__DeleteKey (1909)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteKey {
      public:
        /** Optional element 'tas:DeleteKey' of XSD type 'tas:DeleteKey' */
        _tas__DeleteKey *tas__DeleteKey;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteKey */
        long soap_type() const { return SOAP_TYPE___tas__DeleteKey; }
        /** Constructor with member initializations */
        __tas__DeleteKey() : tas__DeleteKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteKey * SOAP_FMAC2 soap_instantiate___tas__DeleteKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37878 */
#ifndef SOAP_TYPE___tas__CreatePKCS10CSR
#define SOAP_TYPE___tas__CreatePKCS10CSR (1913)
/* Wrapper: */
struct SOAP_CMAC __tas__CreatePKCS10CSR {
      public:
        /** Optional element 'tas:CreatePKCS10CSR' of XSD type 'tas:CreatePKCS10CSR' */
        _tas__CreatePKCS10CSR *tas__CreatePKCS10CSR;
      public:
        /** Return unique type id SOAP_TYPE___tas__CreatePKCS10CSR */
        long soap_type() const { return SOAP_TYPE___tas__CreatePKCS10CSR; }
        /** Constructor with member initializations */
        __tas__CreatePKCS10CSR() : tas__CreatePKCS10CSR() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__CreatePKCS10CSR * SOAP_FMAC2 soap_instantiate___tas__CreatePKCS10CSR(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37980 */
#ifndef SOAP_TYPE___tas__CreateSelfSignedCertificate
#define SOAP_TYPE___tas__CreateSelfSignedCertificate (1917)
/* Wrapper: */
struct SOAP_CMAC __tas__CreateSelfSignedCertificate {
      public:
        /** Optional element 'tas:CreateSelfSignedCertificate' of XSD type 'tas:CreateSelfSignedCertificate' */
        _tas__CreateSelfSignedCertificate *tas__CreateSelfSignedCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tas__CreateSelfSignedCertificate */
        long soap_type() const { return SOAP_TYPE___tas__CreateSelfSignedCertificate; }
        /** Constructor with member initializations */
        __tas__CreateSelfSignedCertificate() : tas__CreateSelfSignedCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__CreateSelfSignedCertificate * SOAP_FMAC2 soap_instantiate___tas__CreateSelfSignedCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38116 */
#ifndef SOAP_TYPE___tas__UploadCertificate
#define SOAP_TYPE___tas__UploadCertificate (1921)
/* Wrapper: */
struct SOAP_CMAC __tas__UploadCertificate {
      public:
        /** Optional element 'tas:UploadCertificate' of XSD type 'tas:UploadCertificate' */
        _tas__UploadCertificate *tas__UploadCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tas__UploadCertificate */
        long soap_type() const { return SOAP_TYPE___tas__UploadCertificate; }
        /** Constructor with member initializations */
        __tas__UploadCertificate() : tas__UploadCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__UploadCertificate * SOAP_FMAC2 soap_instantiate___tas__UploadCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38192 */
#ifndef SOAP_TYPE___tas__GetCertificate
#define SOAP_TYPE___tas__GetCertificate (1925)
/* Wrapper: */
struct SOAP_CMAC __tas__GetCertificate {
      public:
        /** Optional element 'tas:GetCertificate' of XSD type 'tas:GetCertificate' */
        _tas__GetCertificate *tas__GetCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetCertificate */
        long soap_type() const { return SOAP_TYPE___tas__GetCertificate; }
        /** Constructor with member initializations */
        __tas__GetCertificate() : tas__GetCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetCertificate * SOAP_FMAC2 soap_instantiate___tas__GetCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38267 */
#ifndef SOAP_TYPE___tas__GetAllCertificates
#define SOAP_TYPE___tas__GetAllCertificates (1929)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllCertificates {
      public:
        /** Optional element 'tas:GetAllCertificates' of XSD type 'tas:GetAllCertificates' */
        _tas__GetAllCertificates *tas__GetAllCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllCertificates */
        long soap_type() const { return SOAP_TYPE___tas__GetAllCertificates; }
        /** Constructor with member initializations */
        __tas__GetAllCertificates() : tas__GetAllCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllCertificates * SOAP_FMAC2 soap_instantiate___tas__GetAllCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38350 */
#ifndef SOAP_TYPE___tas__DeleteCertificate
#define SOAP_TYPE___tas__DeleteCertificate (1933)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteCertificate {
      public:
        /** Optional element 'tas:DeleteCertificate' of XSD type 'tas:DeleteCertificate' */
        _tas__DeleteCertificate *tas__DeleteCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteCertificate */
        long soap_type() const { return SOAP_TYPE___tas__DeleteCertificate; }
        /** Constructor with member initializations */
        __tas__DeleteCertificate() : tas__DeleteCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteCertificate * SOAP_FMAC2 soap_instantiate___tas__DeleteCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38439 */
#ifndef SOAP_TYPE___tas__CreateCertificationPath
#define SOAP_TYPE___tas__CreateCertificationPath (1937)
/* Wrapper: */
struct SOAP_CMAC __tas__CreateCertificationPath {
      public:
        /** Optional element 'tas:CreateCertificationPath' of XSD type 'tas:CreateCertificationPath' */
        _tas__CreateCertificationPath *tas__CreateCertificationPath;
      public:
        /** Return unique type id SOAP_TYPE___tas__CreateCertificationPath */
        long soap_type() const { return SOAP_TYPE___tas__CreateCertificationPath; }
        /** Constructor with member initializations */
        __tas__CreateCertificationPath() : tas__CreateCertificationPath() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__CreateCertificationPath * SOAP_FMAC2 soap_instantiate___tas__CreateCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38514 */
#ifndef SOAP_TYPE___tas__GetCertificationPath
#define SOAP_TYPE___tas__GetCertificationPath (1941)
/* Wrapper: */
struct SOAP_CMAC __tas__GetCertificationPath {
      public:
        /** Optional element 'tas:GetCertificationPath' of XSD type 'tas:GetCertificationPath' */
        _tas__GetCertificationPath *tas__GetCertificationPath;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetCertificationPath */
        long soap_type() const { return SOAP_TYPE___tas__GetCertificationPath; }
        /** Constructor with member initializations */
        __tas__GetCertificationPath() : tas__GetCertificationPath() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetCertificationPath * SOAP_FMAC2 soap_instantiate___tas__GetCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38589 */
#ifndef SOAP_TYPE___tas__GetAllCertificationPaths
#define SOAP_TYPE___tas__GetAllCertificationPaths (1945)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllCertificationPaths {
      public:
        /** Optional element 'tas:GetAllCertificationPaths' of XSD type 'tas:GetAllCertificationPaths' */
        _tas__GetAllCertificationPaths *tas__GetAllCertificationPaths;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllCertificationPaths */
        long soap_type() const { return SOAP_TYPE___tas__GetAllCertificationPaths; }
        /** Constructor with member initializations */
        __tas__GetAllCertificationPaths() : tas__GetAllCertificationPaths() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllCertificationPaths * SOAP_FMAC2 soap_instantiate___tas__GetAllCertificationPaths(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38675 */
#ifndef SOAP_TYPE___tas__DeleteCertificationPath
#define SOAP_TYPE___tas__DeleteCertificationPath (1949)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteCertificationPath {
      public:
        /** Optional element 'tas:DeleteCertificationPath' of XSD type 'tas:DeleteCertificationPath' */
        _tas__DeleteCertificationPath *tas__DeleteCertificationPath;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteCertificationPath */
        long soap_type() const { return SOAP_TYPE___tas__DeleteCertificationPath; }
        /** Constructor with member initializations */
        __tas__DeleteCertificationPath() : tas__DeleteCertificationPath() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteCertificationPath * SOAP_FMAC2 soap_instantiate___tas__DeleteCertificationPath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38745 */
#ifndef SOAP_TYPE___tas__UploadPassphrase
#define SOAP_TYPE___tas__UploadPassphrase (1953)
/* Wrapper: */
struct SOAP_CMAC __tas__UploadPassphrase {
      public:
        /** Optional element 'tas:UploadPassphrase' of XSD type 'tas:UploadPassphrase' */
        _tas__UploadPassphrase *tas__UploadPassphrase;
      public:
        /** Return unique type id SOAP_TYPE___tas__UploadPassphrase */
        long soap_type() const { return SOAP_TYPE___tas__UploadPassphrase; }
        /** Constructor with member initializations */
        __tas__UploadPassphrase() : tas__UploadPassphrase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__UploadPassphrase * SOAP_FMAC2 soap_instantiate___tas__UploadPassphrase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38820 */
#ifndef SOAP_TYPE___tas__GetAllPassphrases
#define SOAP_TYPE___tas__GetAllPassphrases (1957)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllPassphrases {
      public:
        /** Optional element 'tas:GetAllPassphrases' of XSD type 'tas:GetAllPassphrases' */
        _tas__GetAllPassphrases *tas__GetAllPassphrases;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllPassphrases */
        long soap_type() const { return SOAP_TYPE___tas__GetAllPassphrases; }
        /** Constructor with member initializations */
        __tas__GetAllPassphrases() : tas__GetAllPassphrases() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllPassphrases * SOAP_FMAC2 soap_instantiate___tas__GetAllPassphrases(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38890 */
#ifndef SOAP_TYPE___tas__DeletePassphrase
#define SOAP_TYPE___tas__DeletePassphrase (1961)
/* Wrapper: */
struct SOAP_CMAC __tas__DeletePassphrase {
      public:
        /** Optional element 'tas:DeletePassphrase' of XSD type 'tas:DeletePassphrase' */
        _tas__DeletePassphrase *tas__DeletePassphrase;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeletePassphrase */
        long soap_type() const { return SOAP_TYPE___tas__DeletePassphrase; }
        /** Constructor with member initializations */
        __tas__DeletePassphrase() : tas__DeletePassphrase() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeletePassphrase * SOAP_FMAC2 soap_instantiate___tas__DeletePassphrase(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38969 */
#ifndef SOAP_TYPE___tas__UploadCRL
#define SOAP_TYPE___tas__UploadCRL (1965)
/* Wrapper: */
struct SOAP_CMAC __tas__UploadCRL {
      public:
        /** Optional element 'tas:UploadCRL' of XSD type 'tas:UploadCRL' */
        _tas__UploadCRL *tas__UploadCRL;
      public:
        /** Return unique type id SOAP_TYPE___tas__UploadCRL */
        long soap_type() const { return SOAP_TYPE___tas__UploadCRL; }
        /** Constructor with member initializations */
        __tas__UploadCRL() : tas__UploadCRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__UploadCRL * SOAP_FMAC2 soap_instantiate___tas__UploadCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39042 */
#ifndef SOAP_TYPE___tas__GetCRL
#define SOAP_TYPE___tas__GetCRL (1969)
/* Wrapper: */
struct SOAP_CMAC __tas__GetCRL {
      public:
        /** Optional element 'tas:GetCRL' of XSD type 'tas:GetCRL' */
        _tas__GetCRL *tas__GetCRL;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetCRL */
        long soap_type() const { return SOAP_TYPE___tas__GetCRL; }
        /** Constructor with member initializations */
        __tas__GetCRL() : tas__GetCRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetCRL * SOAP_FMAC2 soap_instantiate___tas__GetCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39115 */
#ifndef SOAP_TYPE___tas__GetAllCRLs
#define SOAP_TYPE___tas__GetAllCRLs (1973)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllCRLs {
      public:
        /** Optional element 'tas:GetAllCRLs' of XSD type 'tas:GetAllCRLs' */
        _tas__GetAllCRLs *tas__GetAllCRLs;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllCRLs */
        long soap_type() const { return SOAP_TYPE___tas__GetAllCRLs; }
        /** Constructor with member initializations */
        __tas__GetAllCRLs() : tas__GetAllCRLs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllCRLs * SOAP_FMAC2 soap_instantiate___tas__GetAllCRLs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39192 */
#ifndef SOAP_TYPE___tas__DeleteCRL
#define SOAP_TYPE___tas__DeleteCRL (1977)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteCRL {
      public:
        /** Optional element 'tas:DeleteCRL' of XSD type 'tas:DeleteCRL' */
        _tas__DeleteCRL *tas__DeleteCRL;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteCRL */
        long soap_type() const { return SOAP_TYPE___tas__DeleteCRL; }
        /** Constructor with member initializations */
        __tas__DeleteCRL() : tas__DeleteCRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteCRL * SOAP_FMAC2 soap_instantiate___tas__DeleteCRL(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39279 */
#ifndef SOAP_TYPE___tas__CreateCertPathValidationPolicy
#define SOAP_TYPE___tas__CreateCertPathValidationPolicy (1981)
/* Wrapper: */
struct SOAP_CMAC __tas__CreateCertPathValidationPolicy {
      public:
        /** Optional element 'tas:CreateCertPathValidationPolicy' of XSD type 'tas:CreateCertPathValidationPolicy' */
        _tas__CreateCertPathValidationPolicy *tas__CreateCertPathValidationPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tas__CreateCertPathValidationPolicy */
        long soap_type() const { return SOAP_TYPE___tas__CreateCertPathValidationPolicy; }
        /** Constructor with member initializations */
        __tas__CreateCertPathValidationPolicy() : tas__CreateCertPathValidationPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__CreateCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate___tas__CreateCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39354 */
#ifndef SOAP_TYPE___tas__GetCertPathValidationPolicy
#define SOAP_TYPE___tas__GetCertPathValidationPolicy (1985)
/* Wrapper: */
struct SOAP_CMAC __tas__GetCertPathValidationPolicy {
      public:
        /** Optional element 'tas:GetCertPathValidationPolicy' of XSD type 'tas:GetCertPathValidationPolicy' */
        _tas__GetCertPathValidationPolicy *tas__GetCertPathValidationPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetCertPathValidationPolicy */
        long soap_type() const { return SOAP_TYPE___tas__GetCertPathValidationPolicy; }
        /** Constructor with member initializations */
        __tas__GetCertPathValidationPolicy() : tas__GetCertPathValidationPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate___tas__GetCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39427 */
#ifndef SOAP_TYPE___tas__GetAllCertPathValidationPolicies
#define SOAP_TYPE___tas__GetAllCertPathValidationPolicies (1989)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllCertPathValidationPolicies {
      public:
        /** Optional element 'tas:GetAllCertPathValidationPolicies' of XSD type 'tas:GetAllCertPathValidationPolicies' */
        _tas__GetAllCertPathValidationPolicies *tas__GetAllCertPathValidationPolicies;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllCertPathValidationPolicies */
        long soap_type() const { return SOAP_TYPE___tas__GetAllCertPathValidationPolicies; }
        /** Constructor with member initializations */
        __tas__GetAllCertPathValidationPolicies() : tas__GetAllCertPathValidationPolicies() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllCertPathValidationPolicies * SOAP_FMAC2 soap_instantiate___tas__GetAllCertPathValidationPolicies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39507 */
#ifndef SOAP_TYPE___tas__DeleteCertPathValidationPolicy
#define SOAP_TYPE___tas__DeleteCertPathValidationPolicy (1993)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteCertPathValidationPolicy {
      public:
        /** Optional element 'tas:DeleteCertPathValidationPolicy' of XSD type 'tas:DeleteCertPathValidationPolicy' */
        _tas__DeleteCertPathValidationPolicy *tas__DeleteCertPathValidationPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteCertPathValidationPolicy */
        long soap_type() const { return SOAP_TYPE___tas__DeleteCertPathValidationPolicy; }
        /** Constructor with member initializations */
        __tas__DeleteCertPathValidationPolicy() : tas__DeleteCertPathValidationPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteCertPathValidationPolicy * SOAP_FMAC2 soap_instantiate___tas__DeleteCertPathValidationPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39613 */
#ifndef SOAP_TYPE___tas__AddServerCertificateAssignment
#define SOAP_TYPE___tas__AddServerCertificateAssignment (1997)
/* Wrapper: */
struct SOAP_CMAC __tas__AddServerCertificateAssignment {
      public:
        /** Optional element 'tas:AddServerCertificateAssignment' of XSD type 'tas:AddServerCertificateAssignment' */
        _tas__AddServerCertificateAssignment *tas__AddServerCertificateAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__AddServerCertificateAssignment */
        long soap_type() const { return SOAP_TYPE___tas__AddServerCertificateAssignment; }
        /** Constructor with member initializations */
        __tas__AddServerCertificateAssignment() : tas__AddServerCertificateAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__AddServerCertificateAssignment * SOAP_FMAC2 soap_instantiate___tas__AddServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39687 */
#ifndef SOAP_TYPE___tas__RemoveServerCertificateAssignment
#define SOAP_TYPE___tas__RemoveServerCertificateAssignment (2001)
/* Wrapper: */
struct SOAP_CMAC __tas__RemoveServerCertificateAssignment {
      public:
        /** Optional element 'tas:RemoveServerCertificateAssignment' of XSD type 'tas:RemoveServerCertificateAssignment' */
        _tas__RemoveServerCertificateAssignment *tas__RemoveServerCertificateAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__RemoveServerCertificateAssignment */
        long soap_type() const { return SOAP_TYPE___tas__RemoveServerCertificateAssignment; }
        /** Constructor with member initializations */
        __tas__RemoveServerCertificateAssignment() : tas__RemoveServerCertificateAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__RemoveServerCertificateAssignment * SOAP_FMAC2 soap_instantiate___tas__RemoveServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39795 */
#ifndef SOAP_TYPE___tas__ReplaceServerCertificateAssignment
#define SOAP_TYPE___tas__ReplaceServerCertificateAssignment (2005)
/* Wrapper: */
struct SOAP_CMAC __tas__ReplaceServerCertificateAssignment {
      public:
        /** Optional element 'tas:ReplaceServerCertificateAssignment' of XSD type 'tas:ReplaceServerCertificateAssignment' */
        _tas__ReplaceServerCertificateAssignment *tas__ReplaceServerCertificateAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__ReplaceServerCertificateAssignment */
        long soap_type() const { return SOAP_TYPE___tas__ReplaceServerCertificateAssignment; }
        /** Constructor with member initializations */
        __tas__ReplaceServerCertificateAssignment() : tas__ReplaceServerCertificateAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__ReplaceServerCertificateAssignment * SOAP_FMAC2 soap_instantiate___tas__ReplaceServerCertificateAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39871 */
#ifndef SOAP_TYPE___tas__GetAssignedServerCertificates
#define SOAP_TYPE___tas__GetAssignedServerCertificates (2009)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAssignedServerCertificates {
      public:
        /** Optional element 'tas:GetAssignedServerCertificates' of XSD type 'tas:GetAssignedServerCertificates' */
        _tas__GetAssignedServerCertificates *tas__GetAssignedServerCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAssignedServerCertificates */
        long soap_type() const { return SOAP_TYPE___tas__GetAssignedServerCertificates; }
        /** Constructor with member initializations */
        __tas__GetAssignedServerCertificates() : tas__GetAssignedServerCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAssignedServerCertificates * SOAP_FMAC2 soap_instantiate___tas__GetAssignedServerCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:39960 */
#ifndef SOAP_TYPE___tas__SetEnabledTLSVersions
#define SOAP_TYPE___tas__SetEnabledTLSVersions (2013)
/* Wrapper: */
struct SOAP_CMAC __tas__SetEnabledTLSVersions {
      public:
        /** Optional element 'tas:SetEnabledTLSVersions' of XSD type 'tas:SetEnabledTLSVersions' */
        _tas__SetEnabledTLSVersions *tas__SetEnabledTLSVersions;
      public:
        /** Return unique type id SOAP_TYPE___tas__SetEnabledTLSVersions */
        long soap_type() const { return SOAP_TYPE___tas__SetEnabledTLSVersions; }
        /** Constructor with member initializations */
        __tas__SetEnabledTLSVersions() : tas__SetEnabledTLSVersions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__SetEnabledTLSVersions * SOAP_FMAC2 soap_instantiate___tas__SetEnabledTLSVersions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40031 */
#ifndef SOAP_TYPE___tas__GetEnabledTLSVersions
#define SOAP_TYPE___tas__GetEnabledTLSVersions (2017)
/* Wrapper: */
struct SOAP_CMAC __tas__GetEnabledTLSVersions {
      public:
        /** Optional element 'tas:GetEnabledTLSVersions' of XSD type 'tas:GetEnabledTLSVersions' */
        _tas__GetEnabledTLSVersions *tas__GetEnabledTLSVersions;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetEnabledTLSVersions */
        long soap_type() const { return SOAP_TYPE___tas__GetEnabledTLSVersions; }
        /** Constructor with member initializations */
        __tas__GetEnabledTLSVersions() : tas__GetEnabledTLSVersions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetEnabledTLSVersions * SOAP_FMAC2 soap_instantiate___tas__GetEnabledTLSVersions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40109 */
#ifndef SOAP_TYPE___tas__SetClientAuthenticationRequired
#define SOAP_TYPE___tas__SetClientAuthenticationRequired (2021)
/* Wrapper: */
struct SOAP_CMAC __tas__SetClientAuthenticationRequired {
      public:
        /** Optional element 'tas:SetClientAuthenticationRequired' of XSD type 'tas:SetClientAuthenticationRequired' */
        _tas__SetClientAuthenticationRequired *tas__SetClientAuthenticationRequired;
      public:
        /** Return unique type id SOAP_TYPE___tas__SetClientAuthenticationRequired */
        long soap_type() const { return SOAP_TYPE___tas__SetClientAuthenticationRequired; }
        /** Constructor with member initializations */
        __tas__SetClientAuthenticationRequired() : tas__SetClientAuthenticationRequired() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__SetClientAuthenticationRequired * SOAP_FMAC2 soap_instantiate___tas__SetClientAuthenticationRequired(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40179 */
#ifndef SOAP_TYPE___tas__GetClientAuthenticationRequired
#define SOAP_TYPE___tas__GetClientAuthenticationRequired (2025)
/* Wrapper: */
struct SOAP_CMAC __tas__GetClientAuthenticationRequired {
      public:
        /** Optional element 'tas:GetClientAuthenticationRequired' of XSD type 'tas:GetClientAuthenticationRequired' */
        _tas__GetClientAuthenticationRequired *tas__GetClientAuthenticationRequired;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetClientAuthenticationRequired */
        long soap_type() const { return SOAP_TYPE___tas__GetClientAuthenticationRequired; }
        /** Constructor with member initializations */
        __tas__GetClientAuthenticationRequired() : tas__GetClientAuthenticationRequired() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetClientAuthenticationRequired * SOAP_FMAC2 soap_instantiate___tas__GetClientAuthenticationRequired(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40262 */
#ifndef SOAP_TYPE___tas__AddCertPathValidationPolicyAssignment
#define SOAP_TYPE___tas__AddCertPathValidationPolicyAssignment (2029)
/* Wrapper: */
struct SOAP_CMAC __tas__AddCertPathValidationPolicyAssignment {
      public:
        /** Optional element 'tas:AddCertPathValidationPolicyAssignment' of XSD type 'tas:AddCertPathValidationPolicyAssignment' */
        _tas__AddCertPathValidationPolicyAssignment *tas__AddCertPathValidationPolicyAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__AddCertPathValidationPolicyAssignment */
        long soap_type() const { return SOAP_TYPE___tas__AddCertPathValidationPolicyAssignment; }
        /** Constructor with member initializations */
        __tas__AddCertPathValidationPolicyAssignment() : tas__AddCertPathValidationPolicyAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__AddCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate___tas__AddCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40336 */
#ifndef SOAP_TYPE___tas__RemoveCertPathValidationPolicyAssignment
#define SOAP_TYPE___tas__RemoveCertPathValidationPolicyAssignment (2033)
/* Wrapper: */
struct SOAP_CMAC __tas__RemoveCertPathValidationPolicyAssignment {
      public:
        /** Optional element 'tas:RemoveCertPathValidationPolicyAssignment' of XSD type 'tas:RemoveCertPathValidationPolicyAssignment' */
        _tas__RemoveCertPathValidationPolicyAssignment *tas__RemoveCertPathValidationPolicyAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__RemoveCertPathValidationPolicyAssignment */
        long soap_type() const { return SOAP_TYPE___tas__RemoveCertPathValidationPolicyAssignment; }
        /** Constructor with member initializations */
        __tas__RemoveCertPathValidationPolicyAssignment() : tas__RemoveCertPathValidationPolicyAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__RemoveCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate___tas__RemoveCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40417 */
#ifndef SOAP_TYPE___tas__ReplaceCertPathValidationPolicyAssignment
#define SOAP_TYPE___tas__ReplaceCertPathValidationPolicyAssignment (2037)
/* Wrapper: */
struct SOAP_CMAC __tas__ReplaceCertPathValidationPolicyAssignment {
      public:
        /** Optional element 'tas:ReplaceCertPathValidationPolicyAssignment' of XSD type 'tas:ReplaceCertPathValidationPolicyAssignment' */
        _tas__ReplaceCertPathValidationPolicyAssignment *tas__ReplaceCertPathValidationPolicyAssignment;
      public:
        /** Return unique type id SOAP_TYPE___tas__ReplaceCertPathValidationPolicyAssignment */
        long soap_type() const { return SOAP_TYPE___tas__ReplaceCertPathValidationPolicyAssignment; }
        /** Constructor with member initializations */
        __tas__ReplaceCertPathValidationPolicyAssignment() : tas__ReplaceCertPathValidationPolicyAssignment() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__ReplaceCertPathValidationPolicyAssignment * SOAP_FMAC2 soap_instantiate___tas__ReplaceCertPathValidationPolicyAssignment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40488 */
#ifndef SOAP_TYPE___tas__GetAssignedCertPathValidationPolicies
#define SOAP_TYPE___tas__GetAssignedCertPathValidationPolicies (2041)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAssignedCertPathValidationPolicies {
      public:
        /** Optional element 'tas:GetAssignedCertPathValidationPolicies' of XSD type 'tas:GetAssignedCertPathValidationPolicies' */
        _tas__GetAssignedCertPathValidationPolicies *tas__GetAssignedCertPathValidationPolicies;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAssignedCertPathValidationPolicies */
        long soap_type() const { return SOAP_TYPE___tas__GetAssignedCertPathValidationPolicies; }
        /** Constructor with member initializations */
        __tas__GetAssignedCertPathValidationPolicies() : tas__GetAssignedCertPathValidationPolicies() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAssignedCertPathValidationPolicies * SOAP_FMAC2 soap_instantiate___tas__GetAssignedCertPathValidationPolicies(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40558 */
#ifndef SOAP_TYPE___tas__AddDot1XConfiguration
#define SOAP_TYPE___tas__AddDot1XConfiguration (2045)
/* Wrapper: */
struct SOAP_CMAC __tas__AddDot1XConfiguration {
      public:
        /** Optional element 'tas:AddDot1XConfiguration' of XSD type 'tas:AddDot1XConfiguration' */
        _tas__AddDot1XConfiguration *tas__AddDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__AddDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__AddDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__AddDot1XConfiguration() : tas__AddDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__AddDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__AddDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40628 */
#ifndef SOAP_TYPE___tas__GetAllDot1XConfigurations
#define SOAP_TYPE___tas__GetAllDot1XConfigurations (2049)
/* Wrapper: */
struct SOAP_CMAC __tas__GetAllDot1XConfigurations {
      public:
        /** Optional element 'tas:GetAllDot1XConfigurations' of XSD type 'tas:GetAllDot1XConfigurations' */
        _tas__GetAllDot1XConfigurations *tas__GetAllDot1XConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetAllDot1XConfigurations */
        long soap_type() const { return SOAP_TYPE___tas__GetAllDot1XConfigurations; }
        /** Constructor with member initializations */
        __tas__GetAllDot1XConfigurations() : tas__GetAllDot1XConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetAllDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tas__GetAllDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40698 */
#ifndef SOAP_TYPE___tas__GetDot1XConfiguration
#define SOAP_TYPE___tas__GetDot1XConfiguration (2053)
/* Wrapper: */
struct SOAP_CMAC __tas__GetDot1XConfiguration {
      public:
        /** Optional element 'tas:GetDot1XConfiguration' of XSD type 'tas:GetDot1XConfiguration' */
        _tas__GetDot1XConfiguration *tas__GetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__GetDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__GetDot1XConfiguration() : tas__GetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40768 */
#ifndef SOAP_TYPE___tas__DeleteDot1XConfiguration
#define SOAP_TYPE___tas__DeleteDot1XConfiguration (2057)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteDot1XConfiguration {
      public:
        /** Optional element 'tas:DeleteDot1XConfiguration' of XSD type 'tas:DeleteDot1XConfiguration' */
        _tas__DeleteDot1XConfiguration *tas__DeleteDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__DeleteDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__DeleteDot1XConfiguration() : tas__DeleteDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40838 */
#ifndef SOAP_TYPE___tas__SetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE___tas__SetNetworkInterfaceDot1XConfiguration (2061)
/* Wrapper: */
struct SOAP_CMAC __tas__SetNetworkInterfaceDot1XConfiguration {
      public:
        /** Optional element 'tas:SetNetworkInterfaceDot1XConfiguration' of XSD type 'tas:SetNetworkInterfaceDot1XConfiguration' */
        _tas__SetNetworkInterfaceDot1XConfiguration *tas__SetNetworkInterfaceDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__SetNetworkInterfaceDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__SetNetworkInterfaceDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__SetNetworkInterfaceDot1XConfiguration() : tas__SetNetworkInterfaceDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__SetNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__SetNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40908 */
#ifndef SOAP_TYPE___tas__GetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE___tas__GetNetworkInterfaceDot1XConfiguration (2065)
/* Wrapper: */
struct SOAP_CMAC __tas__GetNetworkInterfaceDot1XConfiguration {
      public:
        /** Optional element 'tas:GetNetworkInterfaceDot1XConfiguration' of XSD type 'tas:GetNetworkInterfaceDot1XConfiguration' */
        _tas__GetNetworkInterfaceDot1XConfiguration *tas__GetNetworkInterfaceDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__GetNetworkInterfaceDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__GetNetworkInterfaceDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__GetNetworkInterfaceDot1XConfiguration() : tas__GetNetworkInterfaceDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__GetNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__GetNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:40978 */
#ifndef SOAP_TYPE___tas__DeleteNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE___tas__DeleteNetworkInterfaceDot1XConfiguration (2069)
/* Wrapper: */
struct SOAP_CMAC __tas__DeleteNetworkInterfaceDot1XConfiguration {
      public:
        /** Optional element 'tas:DeleteNetworkInterfaceDot1XConfiguration' of XSD type 'tas:DeleteNetworkInterfaceDot1XConfiguration' */
        _tas__DeleteNetworkInterfaceDot1XConfiguration *tas__DeleteNetworkInterfaceDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tas__DeleteNetworkInterfaceDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tas__DeleteNetworkInterfaceDot1XConfiguration; }
        /** Constructor with member initializations */
        __tas__DeleteNetworkInterfaceDot1XConfiguration() : tas__DeleteNetworkInterfaceDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tas__DeleteNetworkInterfaceDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tas__DeleteNetworkInterfaceDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41063 */
#ifndef SOAP_TYPE___tdn__Hello
#define SOAP_TYPE___tdn__Hello (2072)
/* Wrapper: */
struct SOAP_CMAC __tdn__Hello {
      public:
        /** Required element 'tdn:Hello' of XSD type 'wsdd:HelloType' */
        struct wsdd__HelloType tdn__Hello;
      public:
        /** Return unique type id SOAP_TYPE___tdn__Hello */
        long soap_type() const { return SOAP_TYPE___tdn__Hello; }
        /** Constructor with member initializations */
        __tdn__Hello() : tdn__Hello() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tdn__Hello * SOAP_FMAC2 soap_instantiate___tdn__Hello(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41130 */
#ifndef SOAP_TYPE___tdn__Bye
#define SOAP_TYPE___tdn__Bye (2074)
/* Wrapper: */
struct SOAP_CMAC __tdn__Bye {
      public:
        /** Required element 'tdn:Bye' of XSD type 'wsdd:ByeType' */
        struct wsdd__ByeType tdn__Bye;
      public:
        /** Return unique type id SOAP_TYPE___tdn__Bye */
        long soap_type() const { return SOAP_TYPE___tdn__Bye; }
        /** Constructor with member initializations */
        __tdn__Bye() : tdn__Bye() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tdn__Bye * SOAP_FMAC2 soap_instantiate___tdn__Bye(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41197 */
#ifndef SOAP_TYPE___tdn__Probe
#define SOAP_TYPE___tdn__Probe (2077)
/* Wrapper: */
struct SOAP_CMAC __tdn__Probe {
      public:
        /** Required element 'tdn:Probe' of XSD type 'wsdd:ProbeType' */
        struct wsdd__ProbeType tdn__Probe;
      public:
        /** Return unique type id SOAP_TYPE___tdn__Probe */
        long soap_type() const { return SOAP_TYPE___tdn__Probe; }
        /** Constructor with member initializations */
        __tdn__Probe() : tdn__Probe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tdn__Probe * SOAP_FMAC2 soap_instantiate___tdn__Probe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41283 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (2081)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServices {
      public:
        /** Optional element 'tds:GetServices' of XSD type 'tds:GetServices' */
        _tds__GetServices *tds__GetServices;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServices */
        long soap_type() const { return SOAP_TYPE___tds__GetServices; }
        /** Constructor with member initializations */
        __tds__GetServices() : tds__GetServices() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41352 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (2085)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServiceCapabilities {
      public:
        /** Optional element 'tds:GetServiceCapabilities' of XSD type 'tds:GetServiceCapabilities' */
        _tds__GetServiceCapabilities *tds__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tds__GetServiceCapabilities() : tds__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41420 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (2089)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDeviceInformation {
      public:
        /** Optional element 'tds:GetDeviceInformation' of XSD type 'tds:GetDeviceInformation' */
        _tds__GetDeviceInformation *tds__GetDeviceInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDeviceInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetDeviceInformation; }
        /** Constructor with member initializations */
        __tds__GetDeviceInformation() : tds__GetDeviceInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41502 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (2093)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemDateAndTime {
      public:
        /** Optional element 'tds:SetSystemDateAndTime' of XSD type 'tds:SetSystemDateAndTime' */
        _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemDateAndTime; }
        /** Constructor with member initializations */
        __tds__SetSystemDateAndTime() : tds__SetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41576 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (2097)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemDateAndTime {
      public:
        /** Optional element 'tds:GetSystemDateAndTime' of XSD type 'tds:GetSystemDateAndTime' */
        _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemDateAndTime; }
        /** Constructor with member initializations */
        __tds__GetSystemDateAndTime() : tds__GetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41644 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (2101)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemFactoryDefault {
      public:
        /** Optional element 'tds:SetSystemFactoryDefault' of XSD type 'tds:SetSystemFactoryDefault' */
        _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemFactoryDefault; }
        /** Constructor with member initializations */
        __tds__SetSystemFactoryDefault() : tds__SetSystemFactoryDefault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41718 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (2105)
/* Wrapper: */
struct SOAP_CMAC __tds__UpgradeSystemFirmware {
      public:
        /** Optional element 'tds:UpgradeSystemFirmware' of XSD type 'tds:UpgradeSystemFirmware' */
        _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;
      public:
        /** Return unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
        long soap_type() const { return SOAP_TYPE___tds__UpgradeSystemFirmware; }
        /** Constructor with member initializations */
        __tds__UpgradeSystemFirmware() : tds__UpgradeSystemFirmware() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41786 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (2109)
/* Wrapper: */
struct SOAP_CMAC __tds__SystemReboot {
      public:
        /** Optional element 'tds:SystemReboot' of XSD type 'tds:SystemReboot' */
        _tds__SystemReboot *tds__SystemReboot;
      public:
        /** Return unique type id SOAP_TYPE___tds__SystemReboot */
        long soap_type() const { return SOAP_TYPE___tds__SystemReboot; }
        /** Constructor with member initializations */
        __tds__SystemReboot() : tds__SystemReboot() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41862 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (2113)
/* Wrapper: */
struct SOAP_CMAC __tds__RestoreSystem {
      public:
        /** Optional element 'tds:RestoreSystem' of XSD type 'tds:RestoreSystem' */
        _tds__RestoreSystem *tds__RestoreSystem;
      public:
        /** Return unique type id SOAP_TYPE___tds__RestoreSystem */
        long soap_type() const { return SOAP_TYPE___tds__RestoreSystem; }
        /** Constructor with member initializations */
        __tds__RestoreSystem() : tds__RestoreSystem() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:41937 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (2117)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemBackup {
      public:
        /** Optional element 'tds:GetSystemBackup' of XSD type 'tds:GetSystemBackup' */
        _tds__GetSystemBackup *tds__GetSystemBackup;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemBackup */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemBackup; }
        /** Constructor with member initializations */
        __tds__GetSystemBackup() : tds__GetSystemBackup() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42006 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (2121)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemLog {
      public:
        /** Optional element 'tds:GetSystemLog' of XSD type 'tds:GetSystemLog' */
        _tds__GetSystemLog *tds__GetSystemLog;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemLog */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemLog; }
        /** Constructor with member initializations */
        __tds__GetSystemLog() : tds__GetSystemLog() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42074 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (2125)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemSupportInformation {
      public:
        /** Optional element 'tds:GetSystemSupportInformation' of XSD type 'tds:GetSystemSupportInformation' */
        _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemSupportInformation; }
        /** Constructor with member initializations */
        __tds__GetSystemSupportInformation() : tds__GetSystemSupportInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42157 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (2129)
/* Wrapper: */
struct SOAP_CMAC __tds__GetScopes {
      public:
        /** Optional element 'tds:GetScopes' of XSD type 'tds:GetScopes' */
        _tds__GetScopes *tds__GetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetScopes */
        long soap_type() const { return SOAP_TYPE___tds__GetScopes; }
        /** Constructor with member initializations */
        __tds__GetScopes() : tds__GetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42233 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (2133)
/* Wrapper: */
struct SOAP_CMAC __tds__SetScopes {
      public:
        /** Optional element 'tds:SetScopes' of XSD type 'tds:SetScopes' */
        _tds__SetScopes *tds__SetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetScopes */
        long soap_type() const { return SOAP_TYPE___tds__SetScopes; }
        /** Constructor with member initializations */
        __tds__SetScopes() : tds__SetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42305 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (2137)
/* Wrapper: */
struct SOAP_CMAC __tds__AddScopes {
      public:
        /** Optional element 'tds:AddScopes' of XSD type 'tds:AddScopes' */
        _tds__AddScopes *tds__AddScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddScopes */
        long soap_type() const { return SOAP_TYPE___tds__AddScopes; }
        /** Constructor with member initializations */
        __tds__AddScopes() : tds__AddScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42379 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (2141)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveScopes {
      public:
        /** Optional element 'tds:RemoveScopes' of XSD type 'tds:RemoveScopes' */
        _tds__RemoveScopes *tds__RemoveScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveScopes */
        long soap_type() const { return SOAP_TYPE___tds__RemoveScopes; }
        /** Constructor with member initializations */
        __tds__RemoveScopes() : tds__RemoveScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42451 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (2145)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDiscoveryMode {
      public:
        /** Optional element 'tds:GetDiscoveryMode' of XSD type 'tds:GetDiscoveryMode' */
        _tds__GetDiscoveryMode *tds__GetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__GetDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__GetDiscoveryMode() : tds__GetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42524 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (2149)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDiscoveryMode {
      public:
        /** Optional element 'tds:SetDiscoveryMode' of XSD type 'tds:SetDiscoveryMode' */
        _tds__SetDiscoveryMode *tds__SetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__SetDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__SetDiscoveryMode() : tds__SetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42598 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (2153)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteDiscoveryMode {
      public:
        /** Optional element 'tds:GetRemoteDiscoveryMode' of XSD type 'tds:GetRemoteDiscoveryMode' */
        _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__GetRemoteDiscoveryMode() : tds__GetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42672 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (2157)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteDiscoveryMode {
      public:
        /** Optional element 'tds:SetRemoteDiscoveryMode' of XSD type 'tds:SetRemoteDiscoveryMode' */
        _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__SetRemoteDiscoveryMode() : tds__SetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42744 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (2161)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDPAddresses {
      public:
        /** Optional element 'tds:GetDPAddresses' of XSD type 'tds:GetDPAddresses' */
        _tds__GetDPAddresses *tds__GetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDPAddresses */
        long soap_type() const { return SOAP_TYPE___tds__GetDPAddresses; }
        /** Constructor with member initializations */
        __tds__GetDPAddresses() : tds__GetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42818 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (2165)
/* Wrapper: */
struct SOAP_CMAC __tds__GetEndpointReference {
      public:
        /** Optional element 'tds:GetEndpointReference' of XSD type 'tds:GetEndpointReference' */
        _tds__GetEndpointReference *tds__GetEndpointReference;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetEndpointReference */
        long soap_type() const { return SOAP_TYPE___tds__GetEndpointReference; }
        /** Constructor with member initializations */
        __tds__GetEndpointReference() : tds__GetEndpointReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42892 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (2169)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteUser {
      public:
        /** Optional element 'tds:GetRemoteUser' of XSD type 'tds:GetRemoteUser' */
        _tds__GetRemoteUser *tds__GetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteUser */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteUser; }
        /** Constructor with member initializations */
        __tds__GetRemoteUser() : tds__GetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:42971 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (2173)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteUser {
      public:
        /** Optional element 'tds:SetRemoteUser' of XSD type 'tds:SetRemoteUser' */
        _tds__SetRemoteUser *tds__SetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteUser */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteUser; }
        /** Constructor with member initializations */
        __tds__SetRemoteUser() : tds__SetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43043 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (2177)
/* Wrapper: */
struct SOAP_CMAC __tds__GetUsers {
      public:
        /** Optional element 'tds:GetUsers' of XSD type 'tds:GetUsers' */
        _tds__GetUsers *tds__GetUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetUsers */
        long soap_type() const { return SOAP_TYPE___tds__GetUsers; }
        /** Constructor with member initializations */
        __tds__GetUsers() : tds__GetUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43123 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (2181)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateUsers {
      public:
        /** Optional element 'tds:CreateUsers' of XSD type 'tds:CreateUsers' */
        _tds__CreateUsers *tds__CreateUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateUsers */
        long soap_type() const { return SOAP_TYPE___tds__CreateUsers; }
        /** Constructor with member initializations */
        __tds__CreateUsers() : tds__CreateUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43198 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (2185)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteUsers {
      public:
        /** Optional element 'tds:DeleteUsers' of XSD type 'tds:DeleteUsers' */
        _tds__DeleteUsers *tds__DeleteUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteUsers */
        long soap_type() const { return SOAP_TYPE___tds__DeleteUsers; }
        /** Constructor with member initializations */
        __tds__DeleteUsers() : tds__DeleteUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43271 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (2189)
/* Wrapper: */
struct SOAP_CMAC __tds__SetUser {
      public:
        /** Optional element 'tds:SetUser' of XSD type 'tds:SetUser' */
        _tds__SetUser *tds__SetUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetUser */
        long soap_type() const { return SOAP_TYPE___tds__SetUser; }
        /** Constructor with member initializations */
        __tds__SetUser() : tds__SetUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43346 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (2193)
/* Wrapper: */
struct SOAP_CMAC __tds__GetWsdlUrl {
      public:
        /** Optional element 'tds:GetWsdlUrl' of XSD type 'tds:GetWsdlUrl' */
        _tds__GetWsdlUrl *tds__GetWsdlUrl;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetWsdlUrl */
        long soap_type() const { return SOAP_TYPE___tds__GetWsdlUrl; }
        /** Constructor with member initializations */
        __tds__GetWsdlUrl() : tds__GetWsdlUrl() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43416 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (2197)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCapabilities {
      public:
        /** Optional element 'tds:GetCapabilities' of XSD type 'tds:GetCapabilities' */
        _tds__GetCapabilities *tds__GetCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCapabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetCapabilities; }
        /** Constructor with member initializations */
        __tds__GetCapabilities() : tds__GetCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43489 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (2201)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDPAddresses {
      public:
        /** Optional element 'tds:SetDPAddresses' of XSD type 'tds:SetDPAddresses' */
        _tds__SetDPAddresses *tds__SetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDPAddresses */
        long soap_type() const { return SOAP_TYPE___tds__SetDPAddresses; }
        /** Constructor with member initializations */
        __tds__SetDPAddresses() : tds__SetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43560 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (2205)
/* Wrapper: */
struct SOAP_CMAC __tds__GetHostname {
      public:
        /** Optional element 'tds:GetHostname' of XSD type 'tds:GetHostname' */
        _tds__GetHostname *tds__GetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetHostname */
        long soap_type() const { return SOAP_TYPE___tds__GetHostname; }
        /** Constructor with member initializations */
        __tds__GetHostname() : tds__GetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43635 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (2209)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostname {
      public:
        /** Optional element 'tds:SetHostname' of XSD type 'tds:SetHostname' */
        _tds__SetHostname *tds__SetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostname */
        long soap_type() const { return SOAP_TYPE___tds__SetHostname; }
        /** Constructor with member initializations */
        __tds__SetHostname() : tds__SetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43703 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (2213)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostnameFromDHCP {
      public:
        /** Optional element 'tds:SetHostnameFromDHCP' of XSD type 'tds:SetHostnameFromDHCP' */
        _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
        long soap_type() const { return SOAP_TYPE___tds__SetHostnameFromDHCP; }
        /** Constructor with member initializations */
        __tds__SetHostnameFromDHCP() : tds__SetHostnameFromDHCP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43773 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (2217)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDNS {
      public:
        /** Optional element 'tds:GetDNS' of XSD type 'tds:GetDNS' */
        _tds__GetDNS *tds__GetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDNS */
        long soap_type() const { return SOAP_TYPE___tds__GetDNS; }
        /** Constructor with member initializations */
        __tds__GetDNS() : tds__GetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43843 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (2221)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDNS {
      public:
        /** Optional element 'tds:SetDNS' of XSD type 'tds:SetDNS' */
        _tds__SetDNS *tds__SetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDNS */
        long soap_type() const { return SOAP_TYPE___tds__SetDNS; }
        /** Constructor with member initializations */
        __tds__SetDNS() : tds__SetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43914 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (2225)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNTP {
      public:
        /** Optional element 'tds:GetNTP' of XSD type 'tds:GetNTP' */
        _tds__GetNTP *tds__GetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNTP */
        long soap_type() const { return SOAP_TYPE___tds__GetNTP; }
        /** Constructor with member initializations */
        __tds__GetNTP() : tds__GetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:43992 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (2229)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNTP {
      public:
        /** Optional element 'tds:SetNTP' of XSD type 'tds:SetNTP' */
        _tds__SetNTP *tds__SetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNTP */
        long soap_type() const { return SOAP_TYPE___tds__SetNTP; }
        /** Constructor with member initializations */
        __tds__SetNTP() : tds__SetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44064 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (2233)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDynamicDNS {
      public:
        /** Optional element 'tds:GetDynamicDNS' of XSD type 'tds:GetDynamicDNS' */
        _tds__GetDynamicDNS *tds__GetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDynamicDNS */
        long soap_type() const { return SOAP_TYPE___tds__GetDynamicDNS; }
        /** Constructor with member initializations */
        __tds__GetDynamicDNS() : tds__GetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44136 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (2237)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDynamicDNS {
      public:
        /** Optional element 'tds:SetDynamicDNS' of XSD type 'tds:SetDynamicDNS' */
        _tds__SetDynamicDNS *tds__SetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDynamicDNS */
        long soap_type() const { return SOAP_TYPE___tds__SetDynamicDNS; }
        /** Constructor with member initializations */
        __tds__SetDynamicDNS() : tds__SetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44208 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (2241)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkInterfaces {
      public:
        /** Optional element 'tds:GetNetworkInterfaces' of XSD type 'tds:GetNetworkInterfaces' */
        _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkInterfaces; }
        /** Constructor with member initializations */
        __tds__GetNetworkInterfaces() : tds__GetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44285 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (2245)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkInterfaces {
      public:
        /** Optional element 'tds:SetNetworkInterfaces' of XSD type 'tds:SetNetworkInterfaces' */
        _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkInterfaces; }
        /** Constructor with member initializations */
        __tds__SetNetworkInterfaces() : tds__SetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44356 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (2249)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkProtocols {
      public:
        /** Optional element 'tds:GetNetworkProtocols' of XSD type 'tds:GetNetworkProtocols' */
        _tds__GetNetworkProtocols *tds__GetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkProtocols */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkProtocols; }
        /** Constructor with member initializations */
        __tds__GetNetworkProtocols() : tds__GetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44427 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (2253)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkProtocols {
      public:
        /** Optional element 'tds:SetNetworkProtocols' of XSD type 'tds:SetNetworkProtocols' */
        _tds__SetNetworkProtocols *tds__SetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkProtocols */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkProtocols; }
        /** Constructor with member initializations */
        __tds__SetNetworkProtocols() : tds__SetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44498 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (2257)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkDefaultGateway {
      public:
        /** Optional element 'tds:GetNetworkDefaultGateway' of XSD type 'tds:GetNetworkDefaultGateway' */
        _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __tds__GetNetworkDefaultGateway() : tds__GetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44568 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (2261)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkDefaultGateway {
      public:
        /** Optional element 'tds:SetNetworkDefaultGateway' of XSD type 'tds:SetNetworkDefaultGateway' */
        _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __tds__SetNetworkDefaultGateway() : tds__SetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44643 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (2265)
/* Wrapper: */
struct SOAP_CMAC __tds__GetZeroConfiguration {
      public:
        /** Optional element 'tds:GetZeroConfiguration' of XSD type 'tds:GetZeroConfiguration' */
        _tds__GetZeroConfiguration *tds__GetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetZeroConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetZeroConfiguration; }
        /** Constructor with member initializations */
        __tds__GetZeroConfiguration() : tds__GetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44712 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (2269)
/* Wrapper: */
struct SOAP_CMAC __tds__SetZeroConfiguration {
      public:
        /** Optional element 'tds:SetZeroConfiguration' of XSD type 'tds:SetZeroConfiguration' */
        _tds__SetZeroConfiguration *tds__SetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetZeroConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetZeroConfiguration; }
        /** Constructor with member initializations */
        __tds__SetZeroConfiguration() : tds__SetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44784 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (2273)
/* Wrapper: */
struct SOAP_CMAC __tds__GetIPAddressFilter {
      public:
        /** Optional element 'tds:GetIPAddressFilter' of XSD type 'tds:GetIPAddressFilter' */
        _tds__GetIPAddressFilter *tds__GetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__GetIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__GetIPAddressFilter() : tds__GetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44858 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (2277)
/* Wrapper: */
struct SOAP_CMAC __tds__SetIPAddressFilter {
      public:
        /** Optional element 'tds:SetIPAddressFilter' of XSD type 'tds:SetIPAddressFilter' */
        _tds__SetIPAddressFilter *tds__SetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__SetIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__SetIPAddressFilter() : tds__SetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:44931 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (2281)
/* Wrapper: */
struct SOAP_CMAC __tds__AddIPAddressFilter {
      public:
        /** Optional element 'tds:AddIPAddressFilter' of XSD type 'tds:AddIPAddressFilter' */
        _tds__AddIPAddressFilter *tds__AddIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__AddIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__AddIPAddressFilter() : tds__AddIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45004 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (2285)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveIPAddressFilter {
      public:
        /** Optional element 'tds:RemoveIPAddressFilter' of XSD type 'tds:RemoveIPAddressFilter' */
        _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__RemoveIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__RemoveIPAddressFilter() : tds__RemoveIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45086 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (2289)
/* Wrapper: */
struct SOAP_CMAC __tds__GetAccessPolicy {
      public:
        /** Optional element 'tds:GetAccessPolicy' of XSD type 'tds:GetAccessPolicy' */
        _tds__GetAccessPolicy *tds__GetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetAccessPolicy */
        long soap_type() const { return SOAP_TYPE___tds__GetAccessPolicy; }
        /** Constructor with member initializations */
        __tds__GetAccessPolicy() : tds__GetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45159 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (2293)
/* Wrapper: */
struct SOAP_CMAC __tds__SetAccessPolicy {
      public:
        /** Optional element 'tds:SetAccessPolicy' of XSD type 'tds:SetAccessPolicy' */
        _tds__SetAccessPolicy *tds__SetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetAccessPolicy */
        long soap_type() const { return SOAP_TYPE___tds__SetAccessPolicy; }
        /** Constructor with member initializations */
        __tds__SetAccessPolicy() : tds__SetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45242 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (2297)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateCertificate {
      public:
        /** Optional element 'tds:CreateCertificate' of XSD type 'tds:CreateCertificate' */
        _tds__CreateCertificate *tds__CreateCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateCertificate */
        long soap_type() const { return SOAP_TYPE___tds__CreateCertificate; }
        /** Constructor with member initializations */
        __tds__CreateCertificate() : tds__CreateCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45322 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (2301)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificates {
      public:
        /** Optional element 'tds:GetCertificates' of XSD type 'tds:GetCertificates' */
        _tds__GetCertificates *tds__GetCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificates */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificates; }
        /** Constructor with member initializations */
        __tds__GetCertificates() : tds__GetCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45393 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (2305)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificatesStatus {
      public:
        /** Optional element 'tds:GetCertificatesStatus' of XSD type 'tds:GetCertificatesStatus' */
        _tds__GetCertificatesStatus *tds__GetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificatesStatus */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificatesStatus; }
        /** Constructor with member initializations */
        __tds__GetCertificatesStatus() : tds__GetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45466 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (2309)
/* Wrapper: */
struct SOAP_CMAC __tds__SetCertificatesStatus {
      public:
        /** Optional element 'tds:SetCertificatesStatus' of XSD type 'tds:SetCertificatesStatus' */
        _tds__SetCertificatesStatus *tds__SetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetCertificatesStatus */
        long soap_type() const { return SOAP_TYPE___tds__SetCertificatesStatus; }
        /** Constructor with member initializations */
        __tds__SetCertificatesStatus() : tds__SetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45542 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (2313)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteCertificates {
      public:
        /** Optional element 'tds:DeleteCertificates' of XSD type 'tds:DeleteCertificates' */
        _tds__DeleteCertificates *tds__DeleteCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteCertificates */
        long soap_type() const { return SOAP_TYPE___tds__DeleteCertificates; }
        /** Constructor with member initializations */
        __tds__DeleteCertificates() : tds__DeleteCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45623 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (2317)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPkcs10Request {
      public:
        /** Optional element 'tds:GetPkcs10Request' of XSD type 'tds:GetPkcs10Request' */
        _tds__GetPkcs10Request *tds__GetPkcs10Request;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPkcs10Request */
        long soap_type() const { return SOAP_TYPE___tds__GetPkcs10Request; }
        /** Constructor with member initializations */
        __tds__GetPkcs10Request() : tds__GetPkcs10Request() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45714 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (2321)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificates {
      public:
        /** Optional element 'tds:LoadCertificates' of XSD type 'tds:LoadCertificates' */
        _tds__LoadCertificates *tds__LoadCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificates */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificates; }
        /** Constructor with member initializations */
        __tds__LoadCertificates() : tds__LoadCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45785 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (2325)
/* Wrapper: */
struct SOAP_CMAC __tds__GetClientCertificateMode {
      public:
        /** Optional element 'tds:GetClientCertificateMode' of XSD type 'tds:GetClientCertificateMode' */
        _tds__GetClientCertificateMode *tds__GetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetClientCertificateMode */
        long soap_type() const { return SOAP_TYPE___tds__GetClientCertificateMode; }
        /** Constructor with member initializations */
        __tds__GetClientCertificateMode() : tds__GetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45856 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (2329)
/* Wrapper: */
struct SOAP_CMAC __tds__SetClientCertificateMode {
      public:
        /** Optional element 'tds:SetClientCertificateMode' of XSD type 'tds:SetClientCertificateMode' */
        _tds__SetClientCertificateMode *tds__SetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetClientCertificateMode */
        long soap_type() const { return SOAP_TYPE___tds__SetClientCertificateMode; }
        /** Constructor with member initializations */
        __tds__SetClientCertificateMode() : tds__SetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45926 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (2333)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRelayOutputs {
      public:
        /** Optional element 'tds:GetRelayOutputs' of XSD type 'tds:GetRelayOutputs' */
        _tds__GetRelayOutputs *tds__GetRelayOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRelayOutputs */
        long soap_type() const { return SOAP_TYPE___tds__GetRelayOutputs; }
        /** Constructor with member initializations */
        __tds__GetRelayOutputs() : tds__GetRelayOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:45996 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (2337)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputSettings {
      public:
        /** Optional element 'tds:SetRelayOutputSettings' of XSD type 'tds:SetRelayOutputSettings' */
        _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputSettings; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputSettings() : tds__SetRelayOutputSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46066 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (2341)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputState {
      public:
        /** Optional element 'tds:SetRelayOutputState' of XSD type 'tds:SetRelayOutputState' */
        _tds__SetRelayOutputState *tds__SetRelayOutputState;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputState */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputState; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputState() : tds__SetRelayOutputState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46165 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (2345)
/* Wrapper: */
struct SOAP_CMAC __tds__SendAuxiliaryCommand {
      public:
        /** Optional element 'tds:SendAuxiliaryCommand' of XSD type 'tds:SendAuxiliaryCommand' */
        _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
        long soap_type() const { return SOAP_TYPE___tds__SendAuxiliaryCommand; }
        /** Constructor with member initializations */
        __tds__SendAuxiliaryCommand() : tds__SendAuxiliaryCommand() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46244 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (2349)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCACertificates {
      public:
        /** Optional element 'tds:GetCACertificates' of XSD type 'tds:GetCACertificates' */
        _tds__GetCACertificates *tds__GetCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCACertificates */
        long soap_type() const { return SOAP_TYPE___tds__GetCACertificates; }
        /** Constructor with member initializations */
        __tds__GetCACertificates() : tds__GetCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46335 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (2353)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificateWithPrivateKey {
      public:
        /** Optional element 'tds:LoadCertificateWithPrivateKey' of XSD type 'tds:LoadCertificateWithPrivateKey' */
        _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificateWithPrivateKey; }
        /** Constructor with member initializations */
        __tds__LoadCertificateWithPrivateKey() : tds__LoadCertificateWithPrivateKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46413 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (2357)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificateInformation {
      public:
        /** Optional element 'tds:GetCertificateInformation' of XSD type 'tds:GetCertificateInformation' */
        _tds__GetCertificateInformation *tds__GetCertificateInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificateInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificateInformation; }
        /** Constructor with member initializations */
        __tds__GetCertificateInformation() : tds__GetCertificateInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46498 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (2361)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCACertificates {
      public:
        /** Optional element 'tds:LoadCACertificates' of XSD type 'tds:LoadCACertificates' */
        _tds__LoadCACertificates *tds__LoadCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCACertificates */
        long soap_type() const { return SOAP_TYPE___tds__LoadCACertificates; }
        /** Constructor with member initializations */
        __tds__LoadCACertificates() : tds__LoadCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46574 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (2365)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateDot1XConfiguration {
      public:
        /** Optional element 'tds:CreateDot1XConfiguration' of XSD type 'tds:CreateDot1XConfiguration' */
        _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__CreateDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__CreateDot1XConfiguration() : tds__CreateDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46646 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (2369)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDot1XConfiguration {
      public:
        /** Optional element 'tds:SetDot1XConfiguration' of XSD type 'tds:SetDot1XConfiguration' */
        _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__SetDot1XConfiguration() : tds__SetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46722 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (2373)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfiguration {
      public:
        /** Optional element 'tds:GetDot1XConfiguration' of XSD type 'tds:GetDot1XConfiguration' */
        _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfiguration() : tds__GetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46801 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (2377)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfigurations {
      public:
        /** Optional element 'tds:GetDot1XConfigurations' of XSD type 'tds:GetDot1XConfigurations' */
        _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfigurations; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfigurations() : tds__GetDot1XConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46874 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (2381)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteDot1XConfiguration {
      public:
        /** Optional element 'tds:DeleteDot1XConfiguration' of XSD type 'tds:DeleteDot1XConfiguration' */
        _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__DeleteDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__DeleteDot1XConfiguration() : tds__DeleteDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:46943 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (2385)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Capabilities {
      public:
        /** Optional element 'tds:GetDot11Capabilities' of XSD type 'tds:GetDot11Capabilities' */
        _tds__GetDot11Capabilities *tds__GetDot11Capabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Capabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Capabilities; }
        /** Constructor with member initializations */
        __tds__GetDot11Capabilities() : tds__GetDot11Capabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47013 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (2389)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Status {
      public:
        /** Optional element 'tds:GetDot11Status' of XSD type 'tds:GetDot11Status' */
        _tds__GetDot11Status *tds__GetDot11Status;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Status */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Status; }
        /** Constructor with member initializations */
        __tds__GetDot11Status() : tds__GetDot11Status() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47083 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (2393)
/* Wrapper: */
struct SOAP_CMAC __tds__ScanAvailableDot11Networks {
      public:
        /** Optional element 'tds:ScanAvailableDot11Networks' of XSD type 'tds:ScanAvailableDot11Networks' */
        _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;
      public:
        /** Return unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
        long soap_type() const { return SOAP_TYPE___tds__ScanAvailableDot11Networks; }
        /** Constructor with member initializations */
        __tds__ScanAvailableDot11Networks() : tds__ScanAvailableDot11Networks() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47170 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (2397)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemUris {
      public:
        /** Optional element 'tds:GetSystemUris' of XSD type 'tds:GetSystemUris' */
        _tds__GetSystemUris *tds__GetSystemUris;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemUris */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemUris; }
        /** Constructor with member initializations */
        __tds__GetSystemUris() : tds__GetSystemUris() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47266 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (2401)
/* Wrapper: */
struct SOAP_CMAC __tds__StartFirmwareUpgrade {
      public:
        /** Optional element 'tds:StartFirmwareUpgrade' of XSD type 'tds:StartFirmwareUpgrade' */
        _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
        long soap_type() const { return SOAP_TYPE___tds__StartFirmwareUpgrade; }
        /** Constructor with member initializations */
        __tds__StartFirmwareUpgrade() : tds__StartFirmwareUpgrade() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47361 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (2405)
/* Wrapper: */
struct SOAP_CMAC __tds__StartSystemRestore {
      public:
        /** Optional element 'tds:StartSystemRestore' of XSD type 'tds:StartSystemRestore' */
        _tds__StartSystemRestore *tds__StartSystemRestore;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartSystemRestore */
        long soap_type() const { return SOAP_TYPE___tds__StartSystemRestore; }
        /** Constructor with member initializations */
        __tds__StartSystemRestore() : tds__StartSystemRestore() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47432 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations
#define SOAP_TYPE___tds__GetStorageConfigurations (2409)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfigurations {
      public:
        /** Optional element 'tds:GetStorageConfigurations' of XSD type 'tds:GetStorageConfigurations' */
        _tds__GetStorageConfigurations *tds__GetStorageConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfigurations */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfigurations; }
        /** Constructor with member initializations */
        __tds__GetStorageConfigurations() : tds__GetStorageConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47504 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration
#define SOAP_TYPE___tds__CreateStorageConfiguration (2413)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateStorageConfiguration {
      public:
        /** Optional element 'tds:CreateStorageConfiguration' of XSD type 'tds:CreateStorageConfiguration' */
        _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__CreateStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__CreateStorageConfiguration() : tds__CreateStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47575 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration
#define SOAP_TYPE___tds__GetStorageConfiguration (2417)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfiguration {
      public:
        /** Optional element 'tds:GetStorageConfiguration' of XSD type 'tds:GetStorageConfiguration' */
        _tds__GetStorageConfiguration *tds__GetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__GetStorageConfiguration() : tds__GetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47645 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration
#define SOAP_TYPE___tds__SetStorageConfiguration (2421)
/* Wrapper: */
struct SOAP_CMAC __tds__SetStorageConfiguration {
      public:
        /** Optional element 'tds:SetStorageConfiguration' of XSD type 'tds:SetStorageConfiguration' */
        _tds__SetStorageConfiguration *tds__SetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__SetStorageConfiguration() : tds__SetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47716 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration
#define SOAP_TYPE___tds__DeleteStorageConfiguration (2425)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteStorageConfiguration {
      public:
        /** Optional element 'tds:DeleteStorageConfiguration' of XSD type 'tds:DeleteStorageConfiguration' */
        _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__DeleteStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__DeleteStorageConfiguration() : tds__DeleteStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47787 */
#ifndef SOAP_TYPE___tds__GetGeoLocation
#define SOAP_TYPE___tds__GetGeoLocation (2429)
/* Wrapper: */
struct SOAP_CMAC __tds__GetGeoLocation {
      public:
        /** Optional element 'tds:GetGeoLocation' of XSD type 'tds:GetGeoLocation' */
        _tds__GetGeoLocation *tds__GetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__GetGeoLocation; }
        /** Constructor with member initializations */
        __tds__GetGeoLocation() : tds__GetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47858 */
#ifndef SOAP_TYPE___tds__SetGeoLocation
#define SOAP_TYPE___tds__SetGeoLocation (2433)
/* Wrapper: */
struct SOAP_CMAC __tds__SetGeoLocation {
      public:
        /** Optional element 'tds:SetGeoLocation' of XSD type 'tds:SetGeoLocation' */
        _tds__SetGeoLocation *tds__SetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__SetGeoLocation; }
        /** Constructor with member initializations */
        __tds__SetGeoLocation() : tds__SetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47928 */
#ifndef SOAP_TYPE___tds__DeleteGeoLocation
#define SOAP_TYPE___tds__DeleteGeoLocation (2437)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteGeoLocation {
      public:
        /** Optional element 'tds:DeleteGeoLocation' of XSD type 'tds:DeleteGeoLocation' */
        _tds__DeleteGeoLocation *tds__DeleteGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__DeleteGeoLocation; }
        /** Constructor with member initializations */
        __tds__DeleteGeoLocation() : tds__DeleteGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:47996 */
#ifndef SOAP_TYPE___tds__GetServices_
#define SOAP_TYPE___tds__GetServices_ (2439)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServices_ {
      public:
        /** Optional element 'tds:GetServices' of XSD type 'tds:GetServices' */
        _tds__GetServices *tds__GetServices;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServices_ */
        long soap_type() const { return SOAP_TYPE___tds__GetServices_; }
        /** Constructor with member initializations */
        __tds__GetServices_() : tds__GetServices() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServices_ * SOAP_FMAC2 soap_instantiate___tds__GetServices_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48065 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities_
#define SOAP_TYPE___tds__GetServiceCapabilities_ (2441)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServiceCapabilities_ {
      public:
        /** Optional element 'tds:GetServiceCapabilities' of XSD type 'tds:GetServiceCapabilities' */
        _tds__GetServiceCapabilities *tds__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServiceCapabilities_ */
        long soap_type() const { return SOAP_TYPE___tds__GetServiceCapabilities_; }
        /** Constructor with member initializations */
        __tds__GetServiceCapabilities_() : tds__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServiceCapabilities_ * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48133 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation_
#define SOAP_TYPE___tds__GetDeviceInformation_ (2443)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDeviceInformation_ {
      public:
        /** Optional element 'tds:GetDeviceInformation' of XSD type 'tds:GetDeviceInformation' */
        _tds__GetDeviceInformation *tds__GetDeviceInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDeviceInformation_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDeviceInformation_; }
        /** Constructor with member initializations */
        __tds__GetDeviceInformation_() : tds__GetDeviceInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDeviceInformation_ * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48215 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime_
#define SOAP_TYPE___tds__SetSystemDateAndTime_ (2445)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemDateAndTime_ {
      public:
        /** Optional element 'tds:SetSystemDateAndTime' of XSD type 'tds:SetSystemDateAndTime' */
        _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemDateAndTime_ */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemDateAndTime_; }
        /** Constructor with member initializations */
        __tds__SetSystemDateAndTime_() : tds__SetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemDateAndTime_ * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48289 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime_
#define SOAP_TYPE___tds__GetSystemDateAndTime_ (2447)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemDateAndTime_ {
      public:
        /** Optional element 'tds:GetSystemDateAndTime' of XSD type 'tds:GetSystemDateAndTime' */
        _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemDateAndTime_ */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemDateAndTime_; }
        /** Constructor with member initializations */
        __tds__GetSystemDateAndTime_() : tds__GetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemDateAndTime_ * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48357 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault_
#define SOAP_TYPE___tds__SetSystemFactoryDefault_ (2449)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemFactoryDefault_ {
      public:
        /** Optional element 'tds:SetSystemFactoryDefault' of XSD type 'tds:SetSystemFactoryDefault' */
        _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemFactoryDefault_ */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemFactoryDefault_; }
        /** Constructor with member initializations */
        __tds__SetSystemFactoryDefault_() : tds__SetSystemFactoryDefault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemFactoryDefault_ * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48431 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware_
#define SOAP_TYPE___tds__UpgradeSystemFirmware_ (2451)
/* Wrapper: */
struct SOAP_CMAC __tds__UpgradeSystemFirmware_ {
      public:
        /** Optional element 'tds:UpgradeSystemFirmware' of XSD type 'tds:UpgradeSystemFirmware' */
        _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;
      public:
        /** Return unique type id SOAP_TYPE___tds__UpgradeSystemFirmware_ */
        long soap_type() const { return SOAP_TYPE___tds__UpgradeSystemFirmware_; }
        /** Constructor with member initializations */
        __tds__UpgradeSystemFirmware_() : tds__UpgradeSystemFirmware() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__UpgradeSystemFirmware_ * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48499 */
#ifndef SOAP_TYPE___tds__SystemReboot_
#define SOAP_TYPE___tds__SystemReboot_ (2453)
/* Wrapper: */
struct SOAP_CMAC __tds__SystemReboot_ {
      public:
        /** Optional element 'tds:SystemReboot' of XSD type 'tds:SystemReboot' */
        _tds__SystemReboot *tds__SystemReboot;
      public:
        /** Return unique type id SOAP_TYPE___tds__SystemReboot_ */
        long soap_type() const { return SOAP_TYPE___tds__SystemReboot_; }
        /** Constructor with member initializations */
        __tds__SystemReboot_() : tds__SystemReboot() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SystemReboot_ * SOAP_FMAC2 soap_instantiate___tds__SystemReboot_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48575 */
#ifndef SOAP_TYPE___tds__RestoreSystem_
#define SOAP_TYPE___tds__RestoreSystem_ (2455)
/* Wrapper: */
struct SOAP_CMAC __tds__RestoreSystem_ {
      public:
        /** Optional element 'tds:RestoreSystem' of XSD type 'tds:RestoreSystem' */
        _tds__RestoreSystem *tds__RestoreSystem;
      public:
        /** Return unique type id SOAP_TYPE___tds__RestoreSystem_ */
        long soap_type() const { return SOAP_TYPE___tds__RestoreSystem_; }
        /** Constructor with member initializations */
        __tds__RestoreSystem_() : tds__RestoreSystem() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RestoreSystem_ * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48650 */
#ifndef SOAP_TYPE___tds__GetSystemBackup_
#define SOAP_TYPE___tds__GetSystemBackup_ (2457)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemBackup_ {
      public:
        /** Optional element 'tds:GetSystemBackup' of XSD type 'tds:GetSystemBackup' */
        _tds__GetSystemBackup *tds__GetSystemBackup;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemBackup_ */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemBackup_; }
        /** Constructor with member initializations */
        __tds__GetSystemBackup_() : tds__GetSystemBackup() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemBackup_ * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48719 */
#ifndef SOAP_TYPE___tds__GetSystemLog_
#define SOAP_TYPE___tds__GetSystemLog_ (2459)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemLog_ {
      public:
        /** Optional element 'tds:GetSystemLog' of XSD type 'tds:GetSystemLog' */
        _tds__GetSystemLog *tds__GetSystemLog;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemLog_ */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemLog_; }
        /** Constructor with member initializations */
        __tds__GetSystemLog_() : tds__GetSystemLog() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemLog_ * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48787 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation_
#define SOAP_TYPE___tds__GetSystemSupportInformation_ (2461)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemSupportInformation_ {
      public:
        /** Optional element 'tds:GetSystemSupportInformation' of XSD type 'tds:GetSystemSupportInformation' */
        _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemSupportInformation_ */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemSupportInformation_; }
        /** Constructor with member initializations */
        __tds__GetSystemSupportInformation_() : tds__GetSystemSupportInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemSupportInformation_ * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48870 */
#ifndef SOAP_TYPE___tds__GetScopes_
#define SOAP_TYPE___tds__GetScopes_ (2463)
/* Wrapper: */
struct SOAP_CMAC __tds__GetScopes_ {
      public:
        /** Optional element 'tds:GetScopes' of XSD type 'tds:GetScopes' */
        _tds__GetScopes *tds__GetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetScopes_ */
        long soap_type() const { return SOAP_TYPE___tds__GetScopes_; }
        /** Constructor with member initializations */
        __tds__GetScopes_() : tds__GetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetScopes_ * SOAP_FMAC2 soap_instantiate___tds__GetScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:48946 */
#ifndef SOAP_TYPE___tds__SetScopes_
#define SOAP_TYPE___tds__SetScopes_ (2465)
/* Wrapper: */
struct SOAP_CMAC __tds__SetScopes_ {
      public:
        /** Optional element 'tds:SetScopes' of XSD type 'tds:SetScopes' */
        _tds__SetScopes *tds__SetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetScopes_ */
        long soap_type() const { return SOAP_TYPE___tds__SetScopes_; }
        /** Constructor with member initializations */
        __tds__SetScopes_() : tds__SetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetScopes_ * SOAP_FMAC2 soap_instantiate___tds__SetScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49018 */
#ifndef SOAP_TYPE___tds__AddScopes_
#define SOAP_TYPE___tds__AddScopes_ (2467)
/* Wrapper: */
struct SOAP_CMAC __tds__AddScopes_ {
      public:
        /** Optional element 'tds:AddScopes' of XSD type 'tds:AddScopes' */
        _tds__AddScopes *tds__AddScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddScopes_ */
        long soap_type() const { return SOAP_TYPE___tds__AddScopes_; }
        /** Constructor with member initializations */
        __tds__AddScopes_() : tds__AddScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddScopes_ * SOAP_FMAC2 soap_instantiate___tds__AddScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49092 */
#ifndef SOAP_TYPE___tds__RemoveScopes_
#define SOAP_TYPE___tds__RemoveScopes_ (2469)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveScopes_ {
      public:
        /** Optional element 'tds:RemoveScopes' of XSD type 'tds:RemoveScopes' */
        _tds__RemoveScopes *tds__RemoveScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveScopes_ */
        long soap_type() const { return SOAP_TYPE___tds__RemoveScopes_; }
        /** Constructor with member initializations */
        __tds__RemoveScopes_() : tds__RemoveScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveScopes_ * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49164 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode_
#define SOAP_TYPE___tds__GetDiscoveryMode_ (2471)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDiscoveryMode_ {
      public:
        /** Optional element 'tds:GetDiscoveryMode' of XSD type 'tds:GetDiscoveryMode' */
        _tds__GetDiscoveryMode *tds__GetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDiscoveryMode_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDiscoveryMode_; }
        /** Constructor with member initializations */
        __tds__GetDiscoveryMode_() : tds__GetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDiscoveryMode_ * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49237 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode_
#define SOAP_TYPE___tds__SetDiscoveryMode_ (2473)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDiscoveryMode_ {
      public:
        /** Optional element 'tds:SetDiscoveryMode' of XSD type 'tds:SetDiscoveryMode' */
        _tds__SetDiscoveryMode *tds__SetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDiscoveryMode_ */
        long soap_type() const { return SOAP_TYPE___tds__SetDiscoveryMode_; }
        /** Constructor with member initializations */
        __tds__SetDiscoveryMode_() : tds__SetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDiscoveryMode_ * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49311 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode_
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode_ (2475)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteDiscoveryMode_ {
      public:
        /** Optional element 'tds:GetRemoteDiscoveryMode' of XSD type 'tds:GetRemoteDiscoveryMode' */
        _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode_ */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteDiscoveryMode_; }
        /** Constructor with member initializations */
        __tds__GetRemoteDiscoveryMode_() : tds__GetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode_ * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49385 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode_
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode_ (2477)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteDiscoveryMode_ {
      public:
        /** Optional element 'tds:SetRemoteDiscoveryMode' of XSD type 'tds:SetRemoteDiscoveryMode' */
        _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode_ */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteDiscoveryMode_; }
        /** Constructor with member initializations */
        __tds__SetRemoteDiscoveryMode_() : tds__SetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode_ * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49457 */
#ifndef SOAP_TYPE___tds__GetDPAddresses_
#define SOAP_TYPE___tds__GetDPAddresses_ (2479)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDPAddresses_ {
      public:
        /** Optional element 'tds:GetDPAddresses' of XSD type 'tds:GetDPAddresses' */
        _tds__GetDPAddresses *tds__GetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDPAddresses_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDPAddresses_; }
        /** Constructor with member initializations */
        __tds__GetDPAddresses_() : tds__GetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDPAddresses_ * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49531 */
#ifndef SOAP_TYPE___tds__GetEndpointReference_
#define SOAP_TYPE___tds__GetEndpointReference_ (2481)
/* Wrapper: */
struct SOAP_CMAC __tds__GetEndpointReference_ {
      public:
        /** Optional element 'tds:GetEndpointReference' of XSD type 'tds:GetEndpointReference' */
        _tds__GetEndpointReference *tds__GetEndpointReference;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetEndpointReference_ */
        long soap_type() const { return SOAP_TYPE___tds__GetEndpointReference_; }
        /** Constructor with member initializations */
        __tds__GetEndpointReference_() : tds__GetEndpointReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetEndpointReference_ * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49605 */
#ifndef SOAP_TYPE___tds__GetRemoteUser_
#define SOAP_TYPE___tds__GetRemoteUser_ (2483)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteUser_ {
      public:
        /** Optional element 'tds:GetRemoteUser' of XSD type 'tds:GetRemoteUser' */
        _tds__GetRemoteUser *tds__GetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteUser_ */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteUser_; }
        /** Constructor with member initializations */
        __tds__GetRemoteUser_() : tds__GetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteUser_ * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49684 */
#ifndef SOAP_TYPE___tds__SetRemoteUser_
#define SOAP_TYPE___tds__SetRemoteUser_ (2485)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteUser_ {
      public:
        /** Optional element 'tds:SetRemoteUser' of XSD type 'tds:SetRemoteUser' */
        _tds__SetRemoteUser *tds__SetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteUser_ */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteUser_; }
        /** Constructor with member initializations */
        __tds__SetRemoteUser_() : tds__SetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteUser_ * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49756 */
#ifndef SOAP_TYPE___tds__GetUsers_
#define SOAP_TYPE___tds__GetUsers_ (2487)
/* Wrapper: */
struct SOAP_CMAC __tds__GetUsers_ {
      public:
        /** Optional element 'tds:GetUsers' of XSD type 'tds:GetUsers' */
        _tds__GetUsers *tds__GetUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetUsers_ */
        long soap_type() const { return SOAP_TYPE___tds__GetUsers_; }
        /** Constructor with member initializations */
        __tds__GetUsers_() : tds__GetUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetUsers_ * SOAP_FMAC2 soap_instantiate___tds__GetUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49836 */
#ifndef SOAP_TYPE___tds__CreateUsers_
#define SOAP_TYPE___tds__CreateUsers_ (2489)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateUsers_ {
      public:
        /** Optional element 'tds:CreateUsers' of XSD type 'tds:CreateUsers' */
        _tds__CreateUsers *tds__CreateUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateUsers_ */
        long soap_type() const { return SOAP_TYPE___tds__CreateUsers_; }
        /** Constructor with member initializations */
        __tds__CreateUsers_() : tds__CreateUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateUsers_ * SOAP_FMAC2 soap_instantiate___tds__CreateUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49911 */
#ifndef SOAP_TYPE___tds__DeleteUsers_
#define SOAP_TYPE___tds__DeleteUsers_ (2491)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteUsers_ {
      public:
        /** Optional element 'tds:DeleteUsers' of XSD type 'tds:DeleteUsers' */
        _tds__DeleteUsers *tds__DeleteUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteUsers_ */
        long soap_type() const { return SOAP_TYPE___tds__DeleteUsers_; }
        /** Constructor with member initializations */
        __tds__DeleteUsers_() : tds__DeleteUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteUsers_ * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:49984 */
#ifndef SOAP_TYPE___tds__SetUser_
#define SOAP_TYPE___tds__SetUser_ (2493)
/* Wrapper: */
struct SOAP_CMAC __tds__SetUser_ {
      public:
        /** Optional element 'tds:SetUser' of XSD type 'tds:SetUser' */
        _tds__SetUser *tds__SetUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetUser_ */
        long soap_type() const { return SOAP_TYPE___tds__SetUser_; }
        /** Constructor with member initializations */
        __tds__SetUser_() : tds__SetUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetUser_ * SOAP_FMAC2 soap_instantiate___tds__SetUser_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50059 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl_
#define SOAP_TYPE___tds__GetWsdlUrl_ (2495)
/* Wrapper: */
struct SOAP_CMAC __tds__GetWsdlUrl_ {
      public:
        /** Optional element 'tds:GetWsdlUrl' of XSD type 'tds:GetWsdlUrl' */
        _tds__GetWsdlUrl *tds__GetWsdlUrl;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetWsdlUrl_ */
        long soap_type() const { return SOAP_TYPE___tds__GetWsdlUrl_; }
        /** Constructor with member initializations */
        __tds__GetWsdlUrl_() : tds__GetWsdlUrl() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetWsdlUrl_ * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50129 */
#ifndef SOAP_TYPE___tds__GetCapabilities_
#define SOAP_TYPE___tds__GetCapabilities_ (2497)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCapabilities_ {
      public:
        /** Optional element 'tds:GetCapabilities' of XSD type 'tds:GetCapabilities' */
        _tds__GetCapabilities *tds__GetCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCapabilities_ */
        long soap_type() const { return SOAP_TYPE___tds__GetCapabilities_; }
        /** Constructor with member initializations */
        __tds__GetCapabilities_() : tds__GetCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCapabilities_ * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50202 */
#ifndef SOAP_TYPE___tds__SetDPAddresses_
#define SOAP_TYPE___tds__SetDPAddresses_ (2499)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDPAddresses_ {
      public:
        /** Optional element 'tds:SetDPAddresses' of XSD type 'tds:SetDPAddresses' */
        _tds__SetDPAddresses *tds__SetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDPAddresses_ */
        long soap_type() const { return SOAP_TYPE___tds__SetDPAddresses_; }
        /** Constructor with member initializations */
        __tds__SetDPAddresses_() : tds__SetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDPAddresses_ * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50273 */
#ifndef SOAP_TYPE___tds__GetHostname_
#define SOAP_TYPE___tds__GetHostname_ (2501)
/* Wrapper: */
struct SOAP_CMAC __tds__GetHostname_ {
      public:
        /** Optional element 'tds:GetHostname' of XSD type 'tds:GetHostname' */
        _tds__GetHostname *tds__GetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetHostname_ */
        long soap_type() const { return SOAP_TYPE___tds__GetHostname_; }
        /** Constructor with member initializations */
        __tds__GetHostname_() : tds__GetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetHostname_ * SOAP_FMAC2 soap_instantiate___tds__GetHostname_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50348 */
#ifndef SOAP_TYPE___tds__SetHostname_
#define SOAP_TYPE___tds__SetHostname_ (2503)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostname_ {
      public:
        /** Optional element 'tds:SetHostname' of XSD type 'tds:SetHostname' */
        _tds__SetHostname *tds__SetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostname_ */
        long soap_type() const { return SOAP_TYPE___tds__SetHostname_; }
        /** Constructor with member initializations */
        __tds__SetHostname_() : tds__SetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostname_ * SOAP_FMAC2 soap_instantiate___tds__SetHostname_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50416 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP_
#define SOAP_TYPE___tds__SetHostnameFromDHCP_ (2505)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostnameFromDHCP_ {
      public:
        /** Optional element 'tds:SetHostnameFromDHCP' of XSD type 'tds:SetHostnameFromDHCP' */
        _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostnameFromDHCP_ */
        long soap_type() const { return SOAP_TYPE___tds__SetHostnameFromDHCP_; }
        /** Constructor with member initializations */
        __tds__SetHostnameFromDHCP_() : tds__SetHostnameFromDHCP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostnameFromDHCP_ * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50486 */
#ifndef SOAP_TYPE___tds__GetDNS_
#define SOAP_TYPE___tds__GetDNS_ (2507)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDNS_ {
      public:
        /** Optional element 'tds:GetDNS' of XSD type 'tds:GetDNS' */
        _tds__GetDNS *tds__GetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDNS_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDNS_; }
        /** Constructor with member initializations */
        __tds__GetDNS_() : tds__GetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDNS_ * SOAP_FMAC2 soap_instantiate___tds__GetDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50556 */
#ifndef SOAP_TYPE___tds__SetDNS_
#define SOAP_TYPE___tds__SetDNS_ (2509)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDNS_ {
      public:
        /** Optional element 'tds:SetDNS' of XSD type 'tds:SetDNS' */
        _tds__SetDNS *tds__SetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDNS_ */
        long soap_type() const { return SOAP_TYPE___tds__SetDNS_; }
        /** Constructor with member initializations */
        __tds__SetDNS_() : tds__SetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDNS_ * SOAP_FMAC2 soap_instantiate___tds__SetDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50627 */
#ifndef SOAP_TYPE___tds__GetNTP_
#define SOAP_TYPE___tds__GetNTP_ (2511)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNTP_ {
      public:
        /** Optional element 'tds:GetNTP' of XSD type 'tds:GetNTP' */
        _tds__GetNTP *tds__GetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNTP_ */
        long soap_type() const { return SOAP_TYPE___tds__GetNTP_; }
        /** Constructor with member initializations */
        __tds__GetNTP_() : tds__GetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNTP_ * SOAP_FMAC2 soap_instantiate___tds__GetNTP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50705 */
#ifndef SOAP_TYPE___tds__SetNTP_
#define SOAP_TYPE___tds__SetNTP_ (2513)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNTP_ {
      public:
        /** Optional element 'tds:SetNTP' of XSD type 'tds:SetNTP' */
        _tds__SetNTP *tds__SetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNTP_ */
        long soap_type() const { return SOAP_TYPE___tds__SetNTP_; }
        /** Constructor with member initializations */
        __tds__SetNTP_() : tds__SetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNTP_ * SOAP_FMAC2 soap_instantiate___tds__SetNTP_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50777 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS_
#define SOAP_TYPE___tds__GetDynamicDNS_ (2515)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDynamicDNS_ {
      public:
        /** Optional element 'tds:GetDynamicDNS' of XSD type 'tds:GetDynamicDNS' */
        _tds__GetDynamicDNS *tds__GetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDynamicDNS_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDynamicDNS_; }
        /** Constructor with member initializations */
        __tds__GetDynamicDNS_() : tds__GetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDynamicDNS_ * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50849 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS_
#define SOAP_TYPE___tds__SetDynamicDNS_ (2517)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDynamicDNS_ {
      public:
        /** Optional element 'tds:SetDynamicDNS' of XSD type 'tds:SetDynamicDNS' */
        _tds__SetDynamicDNS *tds__SetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDynamicDNS_ */
        long soap_type() const { return SOAP_TYPE___tds__SetDynamicDNS_; }
        /** Constructor with member initializations */
        __tds__SetDynamicDNS_() : tds__SetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDynamicDNS_ * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50921 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces_
#define SOAP_TYPE___tds__GetNetworkInterfaces_ (2519)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkInterfaces_ {
      public:
        /** Optional element 'tds:GetNetworkInterfaces' of XSD type 'tds:GetNetworkInterfaces' */
        _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkInterfaces_ */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkInterfaces_; }
        /** Constructor with member initializations */
        __tds__GetNetworkInterfaces_() : tds__GetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkInterfaces_ * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:50998 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces_
#define SOAP_TYPE___tds__SetNetworkInterfaces_ (2521)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkInterfaces_ {
      public:
        /** Optional element 'tds:SetNetworkInterfaces' of XSD type 'tds:SetNetworkInterfaces' */
        _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkInterfaces_ */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkInterfaces_; }
        /** Constructor with member initializations */
        __tds__SetNetworkInterfaces_() : tds__SetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkInterfaces_ * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51069 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols_
#define SOAP_TYPE___tds__GetNetworkProtocols_ (2523)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkProtocols_ {
      public:
        /** Optional element 'tds:GetNetworkProtocols' of XSD type 'tds:GetNetworkProtocols' */
        _tds__GetNetworkProtocols *tds__GetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkProtocols_ */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkProtocols_; }
        /** Constructor with member initializations */
        __tds__GetNetworkProtocols_() : tds__GetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkProtocols_ * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51140 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols_
#define SOAP_TYPE___tds__SetNetworkProtocols_ (2525)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkProtocols_ {
      public:
        /** Optional element 'tds:SetNetworkProtocols' of XSD type 'tds:SetNetworkProtocols' */
        _tds__SetNetworkProtocols *tds__SetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkProtocols_ */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkProtocols_; }
        /** Constructor with member initializations */
        __tds__SetNetworkProtocols_() : tds__SetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkProtocols_ * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51211 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway_
#define SOAP_TYPE___tds__GetNetworkDefaultGateway_ (2527)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkDefaultGateway_ {
      public:
        /** Optional element 'tds:GetNetworkDefaultGateway' of XSD type 'tds:GetNetworkDefaultGateway' */
        _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway_ */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkDefaultGateway_; }
        /** Constructor with member initializations */
        __tds__GetNetworkDefaultGateway_() : tds__GetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway_ * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51281 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway_
#define SOAP_TYPE___tds__SetNetworkDefaultGateway_ (2529)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkDefaultGateway_ {
      public:
        /** Optional element 'tds:SetNetworkDefaultGateway' of XSD type 'tds:SetNetworkDefaultGateway' */
        _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway_ */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkDefaultGateway_; }
        /** Constructor with member initializations */
        __tds__SetNetworkDefaultGateway_() : tds__SetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway_ * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51356 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration_
#define SOAP_TYPE___tds__GetZeroConfiguration_ (2531)
/* Wrapper: */
struct SOAP_CMAC __tds__GetZeroConfiguration_ {
      public:
        /** Optional element 'tds:GetZeroConfiguration' of XSD type 'tds:GetZeroConfiguration' */
        _tds__GetZeroConfiguration *tds__GetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetZeroConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__GetZeroConfiguration_; }
        /** Constructor with member initializations */
        __tds__GetZeroConfiguration_() : tds__GetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetZeroConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51425 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration_
#define SOAP_TYPE___tds__SetZeroConfiguration_ (2533)
/* Wrapper: */
struct SOAP_CMAC __tds__SetZeroConfiguration_ {
      public:
        /** Optional element 'tds:SetZeroConfiguration' of XSD type 'tds:SetZeroConfiguration' */
        _tds__SetZeroConfiguration *tds__SetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetZeroConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__SetZeroConfiguration_; }
        /** Constructor with member initializations */
        __tds__SetZeroConfiguration_() : tds__SetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetZeroConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51497 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter_
#define SOAP_TYPE___tds__GetIPAddressFilter_ (2535)
/* Wrapper: */
struct SOAP_CMAC __tds__GetIPAddressFilter_ {
      public:
        /** Optional element 'tds:GetIPAddressFilter' of XSD type 'tds:GetIPAddressFilter' */
        _tds__GetIPAddressFilter *tds__GetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetIPAddressFilter_ */
        long soap_type() const { return SOAP_TYPE___tds__GetIPAddressFilter_; }
        /** Constructor with member initializations */
        __tds__GetIPAddressFilter_() : tds__GetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetIPAddressFilter_ * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51571 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter_
#define SOAP_TYPE___tds__SetIPAddressFilter_ (2537)
/* Wrapper: */
struct SOAP_CMAC __tds__SetIPAddressFilter_ {
      public:
        /** Optional element 'tds:SetIPAddressFilter' of XSD type 'tds:SetIPAddressFilter' */
        _tds__SetIPAddressFilter *tds__SetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetIPAddressFilter_ */
        long soap_type() const { return SOAP_TYPE___tds__SetIPAddressFilter_; }
        /** Constructor with member initializations */
        __tds__SetIPAddressFilter_() : tds__SetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetIPAddressFilter_ * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51644 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter_
#define SOAP_TYPE___tds__AddIPAddressFilter_ (2539)
/* Wrapper: */
struct SOAP_CMAC __tds__AddIPAddressFilter_ {
      public:
        /** Optional element 'tds:AddIPAddressFilter' of XSD type 'tds:AddIPAddressFilter' */
        _tds__AddIPAddressFilter *tds__AddIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddIPAddressFilter_ */
        long soap_type() const { return SOAP_TYPE___tds__AddIPAddressFilter_; }
        /** Constructor with member initializations */
        __tds__AddIPAddressFilter_() : tds__AddIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddIPAddressFilter_ * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51717 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter_
#define SOAP_TYPE___tds__RemoveIPAddressFilter_ (2541)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveIPAddressFilter_ {
      public:
        /** Optional element 'tds:RemoveIPAddressFilter' of XSD type 'tds:RemoveIPAddressFilter' */
        _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveIPAddressFilter_ */
        long soap_type() const { return SOAP_TYPE___tds__RemoveIPAddressFilter_; }
        /** Constructor with member initializations */
        __tds__RemoveIPAddressFilter_() : tds__RemoveIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveIPAddressFilter_ * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51799 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy_
#define SOAP_TYPE___tds__GetAccessPolicy_ (2543)
/* Wrapper: */
struct SOAP_CMAC __tds__GetAccessPolicy_ {
      public:
        /** Optional element 'tds:GetAccessPolicy' of XSD type 'tds:GetAccessPolicy' */
        _tds__GetAccessPolicy *tds__GetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetAccessPolicy_ */
        long soap_type() const { return SOAP_TYPE___tds__GetAccessPolicy_; }
        /** Constructor with member initializations */
        __tds__GetAccessPolicy_() : tds__GetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetAccessPolicy_ * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51872 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy_
#define SOAP_TYPE___tds__SetAccessPolicy_ (2545)
/* Wrapper: */
struct SOAP_CMAC __tds__SetAccessPolicy_ {
      public:
        /** Optional element 'tds:SetAccessPolicy' of XSD type 'tds:SetAccessPolicy' */
        _tds__SetAccessPolicy *tds__SetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetAccessPolicy_ */
        long soap_type() const { return SOAP_TYPE___tds__SetAccessPolicy_; }
        /** Constructor with member initializations */
        __tds__SetAccessPolicy_() : tds__SetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetAccessPolicy_ * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:51955 */
#ifndef SOAP_TYPE___tds__CreateCertificate_
#define SOAP_TYPE___tds__CreateCertificate_ (2547)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateCertificate_ {
      public:
        /** Optional element 'tds:CreateCertificate' of XSD type 'tds:CreateCertificate' */
        _tds__CreateCertificate *tds__CreateCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateCertificate_ */
        long soap_type() const { return SOAP_TYPE___tds__CreateCertificate_; }
        /** Constructor with member initializations */
        __tds__CreateCertificate_() : tds__CreateCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateCertificate_ * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52035 */
#ifndef SOAP_TYPE___tds__GetCertificates_
#define SOAP_TYPE___tds__GetCertificates_ (2549)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificates_ {
      public:
        /** Optional element 'tds:GetCertificates' of XSD type 'tds:GetCertificates' */
        _tds__GetCertificates *tds__GetCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificates_ */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificates_; }
        /** Constructor with member initializations */
        __tds__GetCertificates_() : tds__GetCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificates_ * SOAP_FMAC2 soap_instantiate___tds__GetCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52106 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus_
#define SOAP_TYPE___tds__GetCertificatesStatus_ (2551)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificatesStatus_ {
      public:
        /** Optional element 'tds:GetCertificatesStatus' of XSD type 'tds:GetCertificatesStatus' */
        _tds__GetCertificatesStatus *tds__GetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificatesStatus_ */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificatesStatus_; }
        /** Constructor with member initializations */
        __tds__GetCertificatesStatus_() : tds__GetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificatesStatus_ * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52179 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus_
#define SOAP_TYPE___tds__SetCertificatesStatus_ (2553)
/* Wrapper: */
struct SOAP_CMAC __tds__SetCertificatesStatus_ {
      public:
        /** Optional element 'tds:SetCertificatesStatus' of XSD type 'tds:SetCertificatesStatus' */
        _tds__SetCertificatesStatus *tds__SetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetCertificatesStatus_ */
        long soap_type() const { return SOAP_TYPE___tds__SetCertificatesStatus_; }
        /** Constructor with member initializations */
        __tds__SetCertificatesStatus_() : tds__SetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetCertificatesStatus_ * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52255 */
#ifndef SOAP_TYPE___tds__DeleteCertificates_
#define SOAP_TYPE___tds__DeleteCertificates_ (2555)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteCertificates_ {
      public:
        /** Optional element 'tds:DeleteCertificates' of XSD type 'tds:DeleteCertificates' */
        _tds__DeleteCertificates *tds__DeleteCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteCertificates_ */
        long soap_type() const { return SOAP_TYPE___tds__DeleteCertificates_; }
        /** Constructor with member initializations */
        __tds__DeleteCertificates_() : tds__DeleteCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteCertificates_ * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52336 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request_
#define SOAP_TYPE___tds__GetPkcs10Request_ (2557)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPkcs10Request_ {
      public:
        /** Optional element 'tds:GetPkcs10Request' of XSD type 'tds:GetPkcs10Request' */
        _tds__GetPkcs10Request *tds__GetPkcs10Request;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPkcs10Request_ */
        long soap_type() const { return SOAP_TYPE___tds__GetPkcs10Request_; }
        /** Constructor with member initializations */
        __tds__GetPkcs10Request_() : tds__GetPkcs10Request() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPkcs10Request_ * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52427 */
#ifndef SOAP_TYPE___tds__LoadCertificates_
#define SOAP_TYPE___tds__LoadCertificates_ (2559)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificates_ {
      public:
        /** Optional element 'tds:LoadCertificates' of XSD type 'tds:LoadCertificates' */
        _tds__LoadCertificates *tds__LoadCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificates_ */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificates_; }
        /** Constructor with member initializations */
        __tds__LoadCertificates_() : tds__LoadCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificates_ * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52498 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode_
#define SOAP_TYPE___tds__GetClientCertificateMode_ (2561)
/* Wrapper: */
struct SOAP_CMAC __tds__GetClientCertificateMode_ {
      public:
        /** Optional element 'tds:GetClientCertificateMode' of XSD type 'tds:GetClientCertificateMode' */
        _tds__GetClientCertificateMode *tds__GetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetClientCertificateMode_ */
        long soap_type() const { return SOAP_TYPE___tds__GetClientCertificateMode_; }
        /** Constructor with member initializations */
        __tds__GetClientCertificateMode_() : tds__GetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetClientCertificateMode_ * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52569 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode_
#define SOAP_TYPE___tds__SetClientCertificateMode_ (2563)
/* Wrapper: */
struct SOAP_CMAC __tds__SetClientCertificateMode_ {
      public:
        /** Optional element 'tds:SetClientCertificateMode' of XSD type 'tds:SetClientCertificateMode' */
        _tds__SetClientCertificateMode *tds__SetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetClientCertificateMode_ */
        long soap_type() const { return SOAP_TYPE___tds__SetClientCertificateMode_; }
        /** Constructor with member initializations */
        __tds__SetClientCertificateMode_() : tds__SetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetClientCertificateMode_ * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52639 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs_
#define SOAP_TYPE___tds__GetRelayOutputs_ (2565)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRelayOutputs_ {
      public:
        /** Optional element 'tds:GetRelayOutputs' of XSD type 'tds:GetRelayOutputs' */
        _tds__GetRelayOutputs *tds__GetRelayOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRelayOutputs_ */
        long soap_type() const { return SOAP_TYPE___tds__GetRelayOutputs_; }
        /** Constructor with member initializations */
        __tds__GetRelayOutputs_() : tds__GetRelayOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRelayOutputs_ * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52709 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings_
#define SOAP_TYPE___tds__SetRelayOutputSettings_ (2567)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputSettings_ {
      public:
        /** Optional element 'tds:SetRelayOutputSettings' of XSD type 'tds:SetRelayOutputSettings' */
        _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputSettings_ */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputSettings_; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputSettings_() : tds__SetRelayOutputSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputSettings_ * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52779 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState_
#define SOAP_TYPE___tds__SetRelayOutputState_ (2569)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputState_ {
      public:
        /** Optional element 'tds:SetRelayOutputState' of XSD type 'tds:SetRelayOutputState' */
        _tds__SetRelayOutputState *tds__SetRelayOutputState;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputState_ */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputState_; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputState_() : tds__SetRelayOutputState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputState_ * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52878 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand_
#define SOAP_TYPE___tds__SendAuxiliaryCommand_ (2571)
/* Wrapper: */
struct SOAP_CMAC __tds__SendAuxiliaryCommand_ {
      public:
        /** Optional element 'tds:SendAuxiliaryCommand' of XSD type 'tds:SendAuxiliaryCommand' */
        _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___tds__SendAuxiliaryCommand_ */
        long soap_type() const { return SOAP_TYPE___tds__SendAuxiliaryCommand_; }
        /** Constructor with member initializations */
        __tds__SendAuxiliaryCommand_() : tds__SendAuxiliaryCommand() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SendAuxiliaryCommand_ * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:52957 */
#ifndef SOAP_TYPE___tds__GetCACertificates_
#define SOAP_TYPE___tds__GetCACertificates_ (2573)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCACertificates_ {
      public:
        /** Optional element 'tds:GetCACertificates' of XSD type 'tds:GetCACertificates' */
        _tds__GetCACertificates *tds__GetCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCACertificates_ */
        long soap_type() const { return SOAP_TYPE___tds__GetCACertificates_; }
        /** Constructor with member initializations */
        __tds__GetCACertificates_() : tds__GetCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCACertificates_ * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53048 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey_
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey_ (2575)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificateWithPrivateKey_ {
      public:
        /** Optional element 'tds:LoadCertificateWithPrivateKey' of XSD type 'tds:LoadCertificateWithPrivateKey' */
        _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey_ */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificateWithPrivateKey_; }
        /** Constructor with member initializations */
        __tds__LoadCertificateWithPrivateKey_() : tds__LoadCertificateWithPrivateKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey_ * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53126 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation_
#define SOAP_TYPE___tds__GetCertificateInformation_ (2577)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificateInformation_ {
      public:
        /** Optional element 'tds:GetCertificateInformation' of XSD type 'tds:GetCertificateInformation' */
        _tds__GetCertificateInformation *tds__GetCertificateInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificateInformation_ */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificateInformation_; }
        /** Constructor with member initializations */
        __tds__GetCertificateInformation_() : tds__GetCertificateInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificateInformation_ * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53211 */
#ifndef SOAP_TYPE___tds__LoadCACertificates_
#define SOAP_TYPE___tds__LoadCACertificates_ (2579)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCACertificates_ {
      public:
        /** Optional element 'tds:LoadCACertificates' of XSD type 'tds:LoadCACertificates' */
        _tds__LoadCACertificates *tds__LoadCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCACertificates_ */
        long soap_type() const { return SOAP_TYPE___tds__LoadCACertificates_; }
        /** Constructor with member initializations */
        __tds__LoadCACertificates_() : tds__LoadCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCACertificates_ * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53287 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration_
#define SOAP_TYPE___tds__CreateDot1XConfiguration_ (2581)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateDot1XConfiguration_ {
      public:
        /** Optional element 'tds:CreateDot1XConfiguration' of XSD type 'tds:CreateDot1XConfiguration' */
        _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateDot1XConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__CreateDot1XConfiguration_; }
        /** Constructor with member initializations */
        __tds__CreateDot1XConfiguration_() : tds__CreateDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateDot1XConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53359 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration_
#define SOAP_TYPE___tds__SetDot1XConfiguration_ (2583)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDot1XConfiguration_ {
      public:
        /** Optional element 'tds:SetDot1XConfiguration' of XSD type 'tds:SetDot1XConfiguration' */
        _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDot1XConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__SetDot1XConfiguration_; }
        /** Constructor with member initializations */
        __tds__SetDot1XConfiguration_() : tds__SetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDot1XConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53435 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration_
#define SOAP_TYPE___tds__GetDot1XConfiguration_ (2585)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfiguration_ {
      public:
        /** Optional element 'tds:GetDot1XConfiguration' of XSD type 'tds:GetDot1XConfiguration' */
        _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfiguration_; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfiguration_() : tds__GetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53514 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations_
#define SOAP_TYPE___tds__GetDot1XConfigurations_ (2587)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfigurations_ {
      public:
        /** Optional element 'tds:GetDot1XConfigurations' of XSD type 'tds:GetDot1XConfigurations' */
        _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfigurations_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfigurations_; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfigurations_() : tds__GetDot1XConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfigurations_ * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53587 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration_
#define SOAP_TYPE___tds__DeleteDot1XConfiguration_ (2589)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteDot1XConfiguration_ {
      public:
        /** Optional element 'tds:DeleteDot1XConfiguration' of XSD type 'tds:DeleteDot1XConfiguration' */
        _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__DeleteDot1XConfiguration_; }
        /** Constructor with member initializations */
        __tds__DeleteDot1XConfiguration_() : tds__DeleteDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53656 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities_
#define SOAP_TYPE___tds__GetDot11Capabilities_ (2591)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Capabilities_ {
      public:
        /** Optional element 'tds:GetDot11Capabilities' of XSD type 'tds:GetDot11Capabilities' */
        _tds__GetDot11Capabilities *tds__GetDot11Capabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Capabilities_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Capabilities_; }
        /** Constructor with member initializations */
        __tds__GetDot11Capabilities_() : tds__GetDot11Capabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Capabilities_ * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53726 */
#ifndef SOAP_TYPE___tds__GetDot11Status_
#define SOAP_TYPE___tds__GetDot11Status_ (2593)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Status_ {
      public:
        /** Optional element 'tds:GetDot11Status' of XSD type 'tds:GetDot11Status' */
        _tds__GetDot11Status *tds__GetDot11Status;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Status_ */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Status_; }
        /** Constructor with member initializations */
        __tds__GetDot11Status_() : tds__GetDot11Status() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Status_ * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53796 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks_
#define SOAP_TYPE___tds__ScanAvailableDot11Networks_ (2595)
/* Wrapper: */
struct SOAP_CMAC __tds__ScanAvailableDot11Networks_ {
      public:
        /** Optional element 'tds:ScanAvailableDot11Networks' of XSD type 'tds:ScanAvailableDot11Networks' */
        _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;
      public:
        /** Return unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks_ */
        long soap_type() const { return SOAP_TYPE___tds__ScanAvailableDot11Networks_; }
        /** Constructor with member initializations */
        __tds__ScanAvailableDot11Networks_() : tds__ScanAvailableDot11Networks() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks_ * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53883 */
#ifndef SOAP_TYPE___tds__GetSystemUris_
#define SOAP_TYPE___tds__GetSystemUris_ (2597)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemUris_ {
      public:
        /** Optional element 'tds:GetSystemUris' of XSD type 'tds:GetSystemUris' */
        _tds__GetSystemUris *tds__GetSystemUris;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemUris_ */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemUris_; }
        /** Constructor with member initializations */
        __tds__GetSystemUris_() : tds__GetSystemUris() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemUris_ * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:53979 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade_
#define SOAP_TYPE___tds__StartFirmwareUpgrade_ (2599)
/* Wrapper: */
struct SOAP_CMAC __tds__StartFirmwareUpgrade_ {
      public:
        /** Optional element 'tds:StartFirmwareUpgrade' of XSD type 'tds:StartFirmwareUpgrade' */
        _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartFirmwareUpgrade_ */
        long soap_type() const { return SOAP_TYPE___tds__StartFirmwareUpgrade_; }
        /** Constructor with member initializations */
        __tds__StartFirmwareUpgrade_() : tds__StartFirmwareUpgrade() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartFirmwareUpgrade_ * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54074 */
#ifndef SOAP_TYPE___tds__StartSystemRestore_
#define SOAP_TYPE___tds__StartSystemRestore_ (2601)
/* Wrapper: */
struct SOAP_CMAC __tds__StartSystemRestore_ {
      public:
        /** Optional element 'tds:StartSystemRestore' of XSD type 'tds:StartSystemRestore' */
        _tds__StartSystemRestore *tds__StartSystemRestore;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartSystemRestore_ */
        long soap_type() const { return SOAP_TYPE___tds__StartSystemRestore_; }
        /** Constructor with member initializations */
        __tds__StartSystemRestore_() : tds__StartSystemRestore() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartSystemRestore_ * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54145 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations_
#define SOAP_TYPE___tds__GetStorageConfigurations_ (2603)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfigurations_ {
      public:
        /** Optional element 'tds:GetStorageConfigurations' of XSD type 'tds:GetStorageConfigurations' */
        _tds__GetStorageConfigurations *tds__GetStorageConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfigurations_ */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfigurations_; }
        /** Constructor with member initializations */
        __tds__GetStorageConfigurations_() : tds__GetStorageConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfigurations_ * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54217 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration_
#define SOAP_TYPE___tds__CreateStorageConfiguration_ (2605)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateStorageConfiguration_ {
      public:
        /** Optional element 'tds:CreateStorageConfiguration' of XSD type 'tds:CreateStorageConfiguration' */
        _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateStorageConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__CreateStorageConfiguration_; }
        /** Constructor with member initializations */
        __tds__CreateStorageConfiguration_() : tds__CreateStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateStorageConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54288 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration_
#define SOAP_TYPE___tds__GetStorageConfiguration_ (2607)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfiguration_ {
      public:
        /** Optional element 'tds:GetStorageConfiguration' of XSD type 'tds:GetStorageConfiguration' */
        _tds__GetStorageConfiguration *tds__GetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfiguration_; }
        /** Constructor with member initializations */
        __tds__GetStorageConfiguration_() : tds__GetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54358 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration_
#define SOAP_TYPE___tds__SetStorageConfiguration_ (2609)
/* Wrapper: */
struct SOAP_CMAC __tds__SetStorageConfiguration_ {
      public:
        /** Optional element 'tds:SetStorageConfiguration' of XSD type 'tds:SetStorageConfiguration' */
        _tds__SetStorageConfiguration *tds__SetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetStorageConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__SetStorageConfiguration_; }
        /** Constructor with member initializations */
        __tds__SetStorageConfiguration_() : tds__SetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetStorageConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54429 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration_
#define SOAP_TYPE___tds__DeleteStorageConfiguration_ (2611)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteStorageConfiguration_ {
      public:
        /** Optional element 'tds:DeleteStorageConfiguration' of XSD type 'tds:DeleteStorageConfiguration' */
        _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteStorageConfiguration_ */
        long soap_type() const { return SOAP_TYPE___tds__DeleteStorageConfiguration_; }
        /** Constructor with member initializations */
        __tds__DeleteStorageConfiguration_() : tds__DeleteStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteStorageConfiguration_ * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54500 */
#ifndef SOAP_TYPE___tds__GetGeoLocation_
#define SOAP_TYPE___tds__GetGeoLocation_ (2613)
/* Wrapper: */
struct SOAP_CMAC __tds__GetGeoLocation_ {
      public:
        /** Optional element 'tds:GetGeoLocation' of XSD type 'tds:GetGeoLocation' */
        _tds__GetGeoLocation *tds__GetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetGeoLocation_ */
        long soap_type() const { return SOAP_TYPE___tds__GetGeoLocation_; }
        /** Constructor with member initializations */
        __tds__GetGeoLocation_() : tds__GetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetGeoLocation_ * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54571 */
#ifndef SOAP_TYPE___tds__SetGeoLocation_
#define SOAP_TYPE___tds__SetGeoLocation_ (2615)
/* Wrapper: */
struct SOAP_CMAC __tds__SetGeoLocation_ {
      public:
        /** Optional element 'tds:SetGeoLocation' of XSD type 'tds:SetGeoLocation' */
        _tds__SetGeoLocation *tds__SetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetGeoLocation_ */
        long soap_type() const { return SOAP_TYPE___tds__SetGeoLocation_; }
        /** Constructor with member initializations */
        __tds__SetGeoLocation_() : tds__SetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetGeoLocation_ * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54641 */
#ifndef SOAP_TYPE___tds__DeleteGeoLocation_
#define SOAP_TYPE___tds__DeleteGeoLocation_ (2617)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteGeoLocation_ {
      public:
        /** Optional element 'tds:DeleteGeoLocation' of XSD type 'tds:DeleteGeoLocation' */
        _tds__DeleteGeoLocation *tds__DeleteGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteGeoLocation_ */
        long soap_type() const { return SOAP_TYPE___tds__DeleteGeoLocation_; }
        /** Constructor with member initializations */
        __tds__DeleteGeoLocation_() : tds__DeleteGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteGeoLocation_ * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54741 */
#ifndef SOAP_TYPE___tev__PullMessages
#define SOAP_TYPE___tev__PullMessages (2621)
/* Wrapper: */
struct SOAP_CMAC __tev__PullMessages {
      public:
        /** Optional element 'tev:PullMessages' of XSD type 'tev:PullMessages' */
        _tev__PullMessages *tev__PullMessages;
      public:
        /** Return unique type id SOAP_TYPE___tev__PullMessages */
        long soap_type() const { return SOAP_TYPE___tev__PullMessages; }
        /** Constructor with member initializations */
        __tev__PullMessages() : tev__PullMessages() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__PullMessages * SOAP_FMAC2 soap_instantiate___tev__PullMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54823 */
#ifndef SOAP_TYPE___tev__Seek
#define SOAP_TYPE___tev__Seek (2625)
/* Wrapper: */
struct SOAP_CMAC __tev__Seek {
      public:
        /** Optional element 'tev:Seek' of XSD type 'tev:Seek' */
        _tev__Seek *tev__Seek;
      public:
        /** Return unique type id SOAP_TYPE___tev__Seek */
        long soap_type() const { return SOAP_TYPE___tev__Seek; }
        /** Constructor with member initializations */
        __tev__Seek() : tev__Seek() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Seek * SOAP_FMAC2 soap_instantiate___tev__Seek(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54906 */
#ifndef SOAP_TYPE___tev__SetSynchronizationPoint
#define SOAP_TYPE___tev__SetSynchronizationPoint (2629)
/* Wrapper: */
struct SOAP_CMAC __tev__SetSynchronizationPoint {
      public:
        /** Optional element 'tev:SetSynchronizationPoint' of XSD type 'tev:SetSynchronizationPoint' */
        _tev__SetSynchronizationPoint *tev__SetSynchronizationPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__SetSynchronizationPoint */
        long soap_type() const { return SOAP_TYPE___tev__SetSynchronizationPoint; }
        /** Constructor with member initializations */
        __tev__SetSynchronizationPoint() : tev__SetSynchronizationPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___tev__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:54984 */
#ifndef SOAP_TYPE___tev__Unsubscribe
#define SOAP_TYPE___tev__Unsubscribe (2633)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XSD type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe; }
        /** Constructor with member initializations */
        __tev__Unsubscribe() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55053 */
#ifndef SOAP_TYPE___tev__GetServiceCapabilities
#define SOAP_TYPE___tev__GetServiceCapabilities (2637)
/* Wrapper: */
struct SOAP_CMAC __tev__GetServiceCapabilities {
      public:
        /** Optional element 'tev:GetServiceCapabilities' of XSD type 'tev:GetServiceCapabilities' */
        _tev__GetServiceCapabilities *tev__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tev__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tev__GetServiceCapabilities() : tev__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tev__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55163 */
#ifndef SOAP_TYPE___tev__CreatePullPointSubscription
#define SOAP_TYPE___tev__CreatePullPointSubscription (2641)
/* Wrapper: */
struct SOAP_CMAC __tev__CreatePullPointSubscription {
      public:
        /** Optional element 'tev:CreatePullPointSubscription' of XSD type 'tev:CreatePullPointSubscription' */
        _tev__CreatePullPointSubscription *tev__CreatePullPointSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__CreatePullPointSubscription */
        long soap_type() const { return SOAP_TYPE___tev__CreatePullPointSubscription; }
        /** Constructor with member initializations */
        __tev__CreatePullPointSubscription() : tev__CreatePullPointSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__CreatePullPointSubscription * SOAP_FMAC2 soap_instantiate___tev__CreatePullPointSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55238 */
#ifndef SOAP_TYPE___tev__GetEventProperties
#define SOAP_TYPE___tev__GetEventProperties (2645)
/* Wrapper: */
struct SOAP_CMAC __tev__GetEventProperties {
      public:
        /** Optional element 'tev:GetEventProperties' of XSD type 'tev:GetEventProperties' */
        _tev__GetEventProperties *tev__GetEventProperties;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetEventProperties */
        long soap_type() const { return SOAP_TYPE___tev__GetEventProperties; }
        /** Constructor with member initializations */
        __tev__GetEventProperties() : tev__GetEventProperties() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetEventProperties * SOAP_FMAC2 soap_instantiate___tev__GetEventProperties(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55311 */
#ifndef SOAP_TYPE___tev__Renew
#define SOAP_TYPE___tev__Renew (2649)
/* Wrapper: */
struct SOAP_CMAC __tev__Renew {
      public:
        /** Optional element 'wsnt:Renew' of XSD type 'wsnt:Renew' */
        _wsnt__Renew *wsnt__Renew;
      public:
        /** Return unique type id SOAP_TYPE___tev__Renew */
        long soap_type() const { return SOAP_TYPE___tev__Renew; }
        /** Constructor with member initializations */
        __tev__Renew() : wsnt__Renew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Renew * SOAP_FMAC2 soap_instantiate___tev__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55384 */
#ifndef SOAP_TYPE___tev__Unsubscribe_
#define SOAP_TYPE___tev__Unsubscribe_ (2651)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe_ {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XSD type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe_ */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe_; }
        /** Constructor with member initializations */
        __tev__Unsubscribe_() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe_ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55487 */
#ifndef SOAP_TYPE___tev__Subscribe
#define SOAP_TYPE___tev__Subscribe (2655)
/* Wrapper: */
struct SOAP_CMAC __tev__Subscribe {
      public:
        /** Optional element 'wsnt:Subscribe' of XSD type 'wsnt:Subscribe' */
        _wsnt__Subscribe *wsnt__Subscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Subscribe */
        long soap_type() const { return SOAP_TYPE___tev__Subscribe; }
        /** Constructor with member initializations */
        __tev__Subscribe() : wsnt__Subscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Subscribe * SOAP_FMAC2 soap_instantiate___tev__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55572 */
#ifndef SOAP_TYPE___tev__GetCurrentMessage
#define SOAP_TYPE___tev__GetCurrentMessage (2659)
/* Wrapper: */
struct SOAP_CMAC __tev__GetCurrentMessage {
      public:
        /** Optional element 'wsnt:GetCurrentMessage' of XSD type 'wsnt:GetCurrentMessage' */
        _wsnt__GetCurrentMessage *wsnt__GetCurrentMessage;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetCurrentMessage */
        long soap_type() const { return SOAP_TYPE___tev__GetCurrentMessage; }
        /** Constructor with member initializations */
        __tev__GetCurrentMessage() : wsnt__GetCurrentMessage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetCurrentMessage * SOAP_FMAC2 soap_instantiate___tev__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55635 */
#ifndef SOAP_TYPE___tev__Notify
#define SOAP_TYPE___tev__Notify (2662)
/* Wrapper: */
struct SOAP_CMAC __tev__Notify {
      public:
        /** Optional element 'wsnt:Notify' of XSD type 'wsnt:Notify' */
        _wsnt__Notify *wsnt__Notify;
      public:
        /** Return unique type id SOAP_TYPE___tev__Notify */
        long soap_type() const { return SOAP_TYPE___tev__Notify; }
        /** Constructor with member initializations */
        __tev__Notify() : wsnt__Notify() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Notify * SOAP_FMAC2 soap_instantiate___tev__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55708 */
#ifndef SOAP_TYPE___tev__GetMessages
#define SOAP_TYPE___tev__GetMessages (2666)
/* Wrapper: */
struct SOAP_CMAC __tev__GetMessages {
      public:
        /** Optional element 'wsnt:GetMessages' of XSD type 'wsnt:GetMessages' */
        _wsnt__GetMessages *wsnt__GetMessages;
      public:
        /** Return unique type id SOAP_TYPE___tev__GetMessages */
        long soap_type() const { return SOAP_TYPE___tev__GetMessages; }
        /** Constructor with member initializations */
        __tev__GetMessages() : wsnt__GetMessages() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__GetMessages * SOAP_FMAC2 soap_instantiate___tev__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55781 */
#ifndef SOAP_TYPE___tev__DestroyPullPoint
#define SOAP_TYPE___tev__DestroyPullPoint (2670)
/* Wrapper: */
struct SOAP_CMAC __tev__DestroyPullPoint {
      public:
        /** Optional element 'wsnt:DestroyPullPoint' of XSD type 'wsnt:DestroyPullPoint' */
        _wsnt__DestroyPullPoint *wsnt__DestroyPullPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__DestroyPullPoint */
        long soap_type() const { return SOAP_TYPE___tev__DestroyPullPoint; }
        /** Constructor with member initializations */
        __tev__DestroyPullPoint() : wsnt__DestroyPullPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__DestroyPullPoint * SOAP_FMAC2 soap_instantiate___tev__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55844 */
#ifndef SOAP_TYPE___tev__Notify_
#define SOAP_TYPE___tev__Notify_ (2672)
/* Wrapper: */
struct SOAP_CMAC __tev__Notify_ {
      public:
        /** Optional element 'wsnt:Notify' of XSD type 'wsnt:Notify' */
        _wsnt__Notify *wsnt__Notify;
      public:
        /** Return unique type id SOAP_TYPE___tev__Notify_ */
        long soap_type() const { return SOAP_TYPE___tev__Notify_; }
        /** Constructor with member initializations */
        __tev__Notify_() : wsnt__Notify() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Notify_ * SOAP_FMAC2 soap_instantiate___tev__Notify_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55914 */
#ifndef SOAP_TYPE___tev__CreatePullPoint
#define SOAP_TYPE___tev__CreatePullPoint (2676)
/* Wrapper: */
struct SOAP_CMAC __tev__CreatePullPoint {
      public:
        /** Optional element 'wsnt:CreatePullPoint' of XSD type 'wsnt:CreatePullPoint' */
        _wsnt__CreatePullPoint *wsnt__CreatePullPoint;
      public:
        /** Return unique type id SOAP_TYPE___tev__CreatePullPoint */
        long soap_type() const { return SOAP_TYPE___tev__CreatePullPoint; }
        /** Constructor with member initializations */
        __tev__CreatePullPoint() : wsnt__CreatePullPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__CreatePullPoint * SOAP_FMAC2 soap_instantiate___tev__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:55987 */
#ifndef SOAP_TYPE___tev__Renew_
#define SOAP_TYPE___tev__Renew_ (2678)
/* Wrapper: */
struct SOAP_CMAC __tev__Renew_ {
      public:
        /** Optional element 'wsnt:Renew' of XSD type 'wsnt:Renew' */
        _wsnt__Renew *wsnt__Renew;
      public:
        /** Return unique type id SOAP_TYPE___tev__Renew_ */
        long soap_type() const { return SOAP_TYPE___tev__Renew_; }
        /** Constructor with member initializations */
        __tev__Renew_() : wsnt__Renew() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Renew_ * SOAP_FMAC2 soap_instantiate___tev__Renew_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56060 */
#ifndef SOAP_TYPE___tev__Unsubscribe__
#define SOAP_TYPE___tev__Unsubscribe__ (2680)
/* Wrapper: */
struct SOAP_CMAC __tev__Unsubscribe__ {
      public:
        /** Optional element 'wsnt:Unsubscribe' of XSD type 'wsnt:Unsubscribe' */
        _wsnt__Unsubscribe *wsnt__Unsubscribe;
      public:
        /** Return unique type id SOAP_TYPE___tev__Unsubscribe__ */
        long soap_type() const { return SOAP_TYPE___tev__Unsubscribe__; }
        /** Constructor with member initializations */
        __tev__Unsubscribe__() : wsnt__Unsubscribe() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__Unsubscribe__ * SOAP_FMAC2 soap_instantiate___tev__Unsubscribe__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56133 */
#ifndef SOAP_TYPE___tev__PauseSubscription
#define SOAP_TYPE___tev__PauseSubscription (2684)
/* Wrapper: */
struct SOAP_CMAC __tev__PauseSubscription {
      public:
        /** Optional element 'wsnt:PauseSubscription' of XSD type 'wsnt:PauseSubscription' */
        _wsnt__PauseSubscription *wsnt__PauseSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__PauseSubscription */
        long soap_type() const { return SOAP_TYPE___tev__PauseSubscription; }
        /** Constructor with member initializations */
        __tev__PauseSubscription() : wsnt__PauseSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__PauseSubscription * SOAP_FMAC2 soap_instantiate___tev__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56206 */
#ifndef SOAP_TYPE___tev__ResumeSubscription
#define SOAP_TYPE___tev__ResumeSubscription (2688)
/* Wrapper: */
struct SOAP_CMAC __tev__ResumeSubscription {
      public:
        /** Optional element 'wsnt:ResumeSubscription' of XSD type 'wsnt:ResumeSubscription' */
        _wsnt__ResumeSubscription *wsnt__ResumeSubscription;
      public:
        /** Return unique type id SOAP_TYPE___tev__ResumeSubscription */
        long soap_type() const { return SOAP_TYPE___tev__ResumeSubscription; }
        /** Constructor with member initializations */
        __tev__ResumeSubscription() : wsnt__ResumeSubscription() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tev__ResumeSubscription * SOAP_FMAC2 soap_instantiate___tev__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56293 */
#ifndef SOAP_TYPE___timg__GetServiceCapabilities
#define SOAP_TYPE___timg__GetServiceCapabilities (2692)
/* Wrapper: */
struct SOAP_CMAC __timg__GetServiceCapabilities {
      public:
        /** Optional element 'timg:GetServiceCapabilities' of XSD type 'timg:GetServiceCapabilities' */
        _timg__GetServiceCapabilities *timg__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___timg__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __timg__GetServiceCapabilities() : timg__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___timg__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56361 */
#ifndef SOAP_TYPE___timg__GetImagingSettings
#define SOAP_TYPE___timg__GetImagingSettings (2696)
/* Wrapper: */
struct SOAP_CMAC __timg__GetImagingSettings {
      public:
        /** Optional element 'timg:GetImagingSettings' of XSD type 'timg:GetImagingSettings' */
        _timg__GetImagingSettings *timg__GetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetImagingSettings */
        long soap_type() const { return SOAP_TYPE___timg__GetImagingSettings; }
        /** Constructor with member initializations */
        __timg__GetImagingSettings() : timg__GetImagingSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__GetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56429 */
#ifndef SOAP_TYPE___timg__SetImagingSettings
#define SOAP_TYPE___timg__SetImagingSettings (2700)
/* Wrapper: */
struct SOAP_CMAC __timg__SetImagingSettings {
      public:
        /** Optional element 'timg:SetImagingSettings' of XSD type 'timg:SetImagingSettings' */
        _timg__SetImagingSettings *timg__SetImagingSettings;
      public:
        /** Return unique type id SOAP_TYPE___timg__SetImagingSettings */
        long soap_type() const { return SOAP_TYPE___timg__SetImagingSettings; }
        /** Constructor with member initializations */
        __timg__SetImagingSettings() : timg__SetImagingSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__SetImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56507 */
#ifndef SOAP_TYPE___timg__GetOptions
#define SOAP_TYPE___timg__GetOptions (2704)
/* Wrapper: */
struct SOAP_CMAC __timg__GetOptions {
      public:
        /** Optional element 'timg:GetOptions' of XSD type 'timg:GetOptions' */
        _timg__GetOptions *timg__GetOptions;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetOptions */
        long soap_type() const { return SOAP_TYPE___timg__GetOptions; }
        /** Constructor with member initializations */
        __timg__GetOptions() : timg__GetOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetOptions * SOAP_FMAC2 soap_instantiate___timg__GetOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56597 */
#ifndef SOAP_TYPE___timg__Move
#define SOAP_TYPE___timg__Move (2708)
/* Wrapper: */
struct SOAP_CMAC __timg__Move {
      public:
        /** Optional element 'timg:Move' of XSD type 'timg:Move' */
        _timg__Move *timg__Move;
      public:
        /** Return unique type id SOAP_TYPE___timg__Move */
        long soap_type() const { return SOAP_TYPE___timg__Move; }
        /** Constructor with member initializations */
        __timg__Move() : timg__Move() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__Move * SOAP_FMAC2 soap_instantiate___timg__Move(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56668 */
#ifndef SOAP_TYPE___timg__Stop
#define SOAP_TYPE___timg__Stop (2712)
/* Wrapper: */
struct SOAP_CMAC __timg__Stop {
      public:
        /** Optional element 'timg:Stop' of XSD type 'timg:Stop' */
        _timg__Stop *timg__Stop;
      public:
        /** Return unique type id SOAP_TYPE___timg__Stop */
        long soap_type() const { return SOAP_TYPE___timg__Stop; }
        /** Constructor with member initializations */
        __timg__Stop() : timg__Stop() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__Stop * SOAP_FMAC2 soap_instantiate___timg__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56738 */
#ifndef SOAP_TYPE___timg__GetStatus
#define SOAP_TYPE___timg__GetStatus (2716)
/* Wrapper: */
struct SOAP_CMAC __timg__GetStatus {
      public:
        /** Optional element 'timg:GetStatus' of XSD type 'timg:GetStatus' */
        _timg__GetStatus *timg__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetStatus */
        long soap_type() const { return SOAP_TYPE___timg__GetStatus; }
        /** Constructor with member initializations */
        __timg__GetStatus() : timg__GetStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetStatus * SOAP_FMAC2 soap_instantiate___timg__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56806 */
#ifndef SOAP_TYPE___timg__GetMoveOptions
#define SOAP_TYPE___timg__GetMoveOptions (2720)
/* Wrapper: */
struct SOAP_CMAC __timg__GetMoveOptions {
      public:
        /** Optional element 'timg:GetMoveOptions' of XSD type 'timg:GetMoveOptions' */
        _timg__GetMoveOptions *timg__GetMoveOptions;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetMoveOptions */
        long soap_type() const { return SOAP_TYPE___timg__GetMoveOptions; }
        /** Constructor with member initializations */
        __timg__GetMoveOptions() : timg__GetMoveOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate___timg__GetMoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56874 */
#ifndef SOAP_TYPE___timg__GetPresets
#define SOAP_TYPE___timg__GetPresets (2724)
/* Wrapper: */
struct SOAP_CMAC __timg__GetPresets {
      public:
        /** Optional element 'timg:GetPresets' of XSD type 'timg:GetPresets' */
        _timg__GetPresets *timg__GetPresets;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetPresets */
        long soap_type() const { return SOAP_TYPE___timg__GetPresets; }
        /** Constructor with member initializations */
        __timg__GetPresets() : timg__GetPresets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetPresets * SOAP_FMAC2 soap_instantiate___timg__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:56946 */
#ifndef SOAP_TYPE___timg__GetCurrentPreset
#define SOAP_TYPE___timg__GetCurrentPreset (2728)
/* Wrapper: */
struct SOAP_CMAC __timg__GetCurrentPreset {
      public:
        /** Optional element 'timg:GetCurrentPreset' of XSD type 'timg:GetCurrentPreset' */
        _timg__GetCurrentPreset *timg__GetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___timg__GetCurrentPreset */
        long soap_type() const { return SOAP_TYPE___timg__GetCurrentPreset; }
        /** Constructor with member initializations */
        __timg__GetCurrentPreset() : timg__GetCurrentPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__GetCurrentPreset * SOAP_FMAC2 soap_instantiate___timg__GetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57022 */
#ifndef SOAP_TYPE___timg__SetCurrentPreset
#define SOAP_TYPE___timg__SetCurrentPreset (2732)
/* Wrapper: */
struct SOAP_CMAC __timg__SetCurrentPreset {
      public:
        /** Optional element 'timg:SetCurrentPreset' of XSD type 'timg:SetCurrentPreset' */
        _timg__SetCurrentPreset *timg__SetCurrentPreset;
      public:
        /** Return unique type id SOAP_TYPE___timg__SetCurrentPreset */
        long soap_type() const { return SOAP_TYPE___timg__SetCurrentPreset; }
        /** Constructor with member initializations */
        __timg__SetCurrentPreset() : timg__SetCurrentPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __timg__SetCurrentPreset * SOAP_FMAC2 soap_instantiate___timg__SetCurrentPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57109 */
#ifndef SOAP_TYPE___tmd__GetServiceCapabilities
#define SOAP_TYPE___tmd__GetServiceCapabilities (2736)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetServiceCapabilities {
      public:
        /** Optional element 'tmd:GetServiceCapabilities' of XSD type 'tmd:GetServiceCapabilities' */
        _tmd__GetServiceCapabilities *tmd__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tmd__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tmd__GetServiceCapabilities() : tmd__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tmd__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57202 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputOptions
#define SOAP_TYPE___tmd__GetRelayOutputOptions (2740)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetRelayOutputOptions {
      public:
        /** Optional element 'tmd:GetRelayOutputOptions' of XSD type 'tmd:GetRelayOutputOptions' */
        _tmd__GetRelayOutputOptions *tmd__GetRelayOutputOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetRelayOutputOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetRelayOutputOptions; }
        /** Constructor with member initializations */
        __tmd__GetRelayOutputOptions() : tmd__GetRelayOutputOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetRelayOutputOptions * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57272 */
#ifndef SOAP_TYPE___tmd__GetAudioSources
#define SOAP_TYPE___tmd__GetAudioSources (2744)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioSources {
      public:
        /** Optional element 'tmd:GetAudioSources' of XSD type 'tmd:Get' */
        tmd__Get *tmd__GetAudioSources;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioSources */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioSources; }
        /** Constructor with member initializations */
        __tmd__GetAudioSources() : tmd__GetAudioSources() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioSources * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57342 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputs
#define SOAP_TYPE___tmd__GetAudioOutputs (2746)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioOutputs {
      public:
        /** Optional element 'tmd:GetAudioOutputs' of XSD type 'tmd:Get' */
        tmd__Get *tmd__GetAudioOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioOutputs */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioOutputs; }
        /** Constructor with member initializations */
        __tmd__GetAudioOutputs() : tmd__GetAudioOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57412 */
#ifndef SOAP_TYPE___tmd__GetVideoSources
#define SOAP_TYPE___tmd__GetVideoSources (2748)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoSources {
      public:
        /** Optional element 'tmd:GetVideoSources' of XSD type 'tmd:Get' */
        tmd__Get *tmd__GetVideoSources;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoSources */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoSources; }
        /** Constructor with member initializations */
        __tmd__GetVideoSources() : tmd__GetVideoSources() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoSources * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57482 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputs
#define SOAP_TYPE___tmd__GetVideoOutputs (2752)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoOutputs {
      public:
        /** Optional element 'tmd:GetVideoOutputs' of XSD type 'tmd:GetVideoOutputs' */
        _tmd__GetVideoOutputs *tmd__GetVideoOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoOutputs */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoOutputs; }
        /** Constructor with member initializations */
        __tmd__GetVideoOutputs() : tmd__GetVideoOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57552 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfiguration
#define SOAP_TYPE___tmd__GetVideoSourceConfiguration (2756)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoSourceConfiguration {
      public:
        /** Optional element 'tmd:GetVideoSourceConfiguration' of XSD type 'tmd:GetVideoSourceConfiguration' */
        _tmd__GetVideoSourceConfiguration *tmd__GetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __tmd__GetVideoSourceConfiguration() : tmd__GetVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57621 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfiguration
#define SOAP_TYPE___tmd__GetVideoOutputConfiguration (2760)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoOutputConfiguration {
      public:
        /** Optional element 'tmd:GetVideoOutputConfiguration' of XSD type 'tmd:GetVideoOutputConfiguration' */
        _tmd__GetVideoOutputConfiguration *tmd__GetVideoOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoOutputConfiguration; }
        /** Constructor with member initializations */
        __tmd__GetVideoOutputConfiguration() : tmd__GetVideoOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57690 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfiguration
#define SOAP_TYPE___tmd__GetAudioSourceConfiguration (2764)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioSourceConfiguration {
      public:
        /** Optional element 'tmd:GetAudioSourceConfiguration' of XSD type 'tmd:GetAudioSourceConfiguration' */
        _tmd__GetAudioSourceConfiguration *tmd__GetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __tmd__GetAudioSourceConfiguration() : tmd__GetAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57760 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfiguration
#define SOAP_TYPE___tmd__GetAudioOutputConfiguration (2768)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioOutputConfiguration {
      public:
        /** Optional element 'tmd:GetAudioOutputConfiguration' of XSD type 'tmd:GetAudioOutputConfiguration' */
        _tmd__GetAudioOutputConfiguration *tmd__GetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __tmd__GetAudioOutputConfiguration() : tmd__GetAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57830 */
#ifndef SOAP_TYPE___tmd__SetVideoSourceConfiguration
#define SOAP_TYPE___tmd__SetVideoSourceConfiguration (2772)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetVideoSourceConfiguration {
      public:
        /** Optional element 'tmd:SetVideoSourceConfiguration' of XSD type 'tmd:SetVideoSourceConfiguration' */
        _tmd__SetVideoSourceConfiguration *tmd__SetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__SetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __tmd__SetVideoSourceConfiguration() : tmd__SetVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57899 */
#ifndef SOAP_TYPE___tmd__SetVideoOutputConfiguration
#define SOAP_TYPE___tmd__SetVideoOutputConfiguration (2776)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetVideoOutputConfiguration {
      public:
        /** Optional element 'tmd:SetVideoOutputConfiguration' of XSD type 'tmd:SetVideoOutputConfiguration' */
        _tmd__SetVideoOutputConfiguration *tmd__SetVideoOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetVideoOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__SetVideoOutputConfiguration; }
        /** Constructor with member initializations */
        __tmd__SetVideoOutputConfiguration() : tmd__SetVideoOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetVideoOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetVideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:57969 */
#ifndef SOAP_TYPE___tmd__SetAudioSourceConfiguration
#define SOAP_TYPE___tmd__SetAudioSourceConfiguration (2780)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetAudioSourceConfiguration {
      public:
        /** Optional element 'tmd:SetAudioSourceConfiguration' of XSD type 'tmd:SetAudioSourceConfiguration' */
        _tmd__SetAudioSourceConfiguration *tmd__SetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__SetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __tmd__SetAudioSourceConfiguration() : tmd__SetAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58039 */
#ifndef SOAP_TYPE___tmd__SetAudioOutputConfiguration
#define SOAP_TYPE___tmd__SetAudioOutputConfiguration (2784)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetAudioOutputConfiguration {
      public:
        /** Optional element 'tmd:SetAudioOutputConfiguration' of XSD type 'tmd:SetAudioOutputConfiguration' */
        _tmd__SetAudioOutputConfiguration *tmd__SetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__SetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __tmd__SetAudioOutputConfiguration() : tmd__SetAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58108 */
#ifndef SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions (2788)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoSourceConfigurationOptions {
      public:
        /** Optional element 'tmd:GetVideoSourceConfigurationOptions' of XSD type 'tmd:GetVideoSourceConfigurationOptions' */
        _tmd__GetVideoSourceConfigurationOptions *tmd__GetVideoSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetVideoSourceConfigurationOptions() : tmd__GetVideoSourceConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58178 */
#ifndef SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions (2792)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetVideoOutputConfigurationOptions {
      public:
        /** Optional element 'tmd:GetVideoOutputConfigurationOptions' of XSD type 'tmd:GetVideoOutputConfigurationOptions' */
        _tmd__GetVideoOutputConfigurationOptions *tmd__GetVideoOutputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetVideoOutputConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetVideoOutputConfigurationOptions() : tmd__GetVideoOutputConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetVideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetVideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58247 */
#ifndef SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions (2796)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioSourceConfigurationOptions {
      public:
        /** Optional element 'tmd:GetAudioSourceConfigurationOptions' of XSD type 'tmd:GetAudioSourceConfigurationOptions' */
        _tmd__GetAudioSourceConfigurationOptions *tmd__GetAudioSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetAudioSourceConfigurationOptions() : tmd__GetAudioSourceConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58317 */
#ifndef SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions (2800)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetAudioOutputConfigurationOptions {
      public:
        /** Optional element 'tmd:GetAudioOutputConfigurationOptions' of XSD type 'tmd:GetAudioOutputConfigurationOptions' */
        _tmd__GetAudioOutputConfigurationOptions *tmd__GetAudioOutputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetAudioOutputConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetAudioOutputConfigurationOptions() : tmd__GetAudioOutputConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58385 */
#ifndef SOAP_TYPE___tmd__GetRelayOutputs
#define SOAP_TYPE___tmd__GetRelayOutputs (2802)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetRelayOutputs {
      public:
        /** Optional element 'tds:GetRelayOutputs' of XSD type 'tds:GetRelayOutputs' */
        _tds__GetRelayOutputs *tds__GetRelayOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetRelayOutputs */
        long soap_type() const { return SOAP_TYPE___tmd__GetRelayOutputs; }
        /** Constructor with member initializations */
        __tmd__GetRelayOutputs() : tds__GetRelayOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tmd__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58475 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputSettings
#define SOAP_TYPE___tmd__SetRelayOutputSettings (2806)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetRelayOutputSettings {
      public:
        /** Optional element 'tmd:SetRelayOutputSettings' of XSD type 'tmd:SetRelayOutputSettings' */
        _tmd__SetRelayOutputSettings *tmd__SetRelayOutputSettings;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetRelayOutputSettings */
        long soap_type() const { return SOAP_TYPE___tmd__SetRelayOutputSettings; }
        /** Constructor with member initializations */
        __tmd__SetRelayOutputSettings() : tmd__SetRelayOutputSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58543 */
#ifndef SOAP_TYPE___tmd__SetRelayOutputState
#define SOAP_TYPE___tmd__SetRelayOutputState (2808)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetRelayOutputState {
      public:
        /** Optional element 'tds:SetRelayOutputState' of XSD type 'tds:SetRelayOutputState' */
        _tds__SetRelayOutputState *tds__SetRelayOutputState;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetRelayOutputState */
        long soap_type() const { return SOAP_TYPE___tmd__SetRelayOutputState; }
        /** Constructor with member initializations */
        __tmd__SetRelayOutputState() : tds__SetRelayOutputState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tmd__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58611 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputs
#define SOAP_TYPE___tmd__GetDigitalInputs (2812)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetDigitalInputs {
      public:
        /** Optional element 'tmd:GetDigitalInputs' of XSD type 'tmd:GetDigitalInputs' */
        _tmd__GetDigitalInputs *tmd__GetDigitalInputs;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetDigitalInputs */
        long soap_type() const { return SOAP_TYPE___tmd__GetDigitalInputs; }
        /** Constructor with member initializations */
        __tmd__GetDigitalInputs() : tmd__GetDigitalInputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetDigitalInputs * SOAP_FMAC2 soap_instantiate___tmd__GetDigitalInputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58679 */
#ifndef SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions (2816)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetDigitalInputConfigurationOptions {
      public:
        /** Optional element 'tmd:GetDigitalInputConfigurationOptions' of XSD type 'tmd:GetDigitalInputConfigurationOptions' */
        _tmd__GetDigitalInputConfigurationOptions *tmd__GetDigitalInputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetDigitalInputConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetDigitalInputConfigurationOptions() : tmd__GetDigitalInputConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetDigitalInputConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetDigitalInputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58747 */
#ifndef SOAP_TYPE___tmd__SetDigitalInputConfigurations
#define SOAP_TYPE___tmd__SetDigitalInputConfigurations (2820)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetDigitalInputConfigurations {
      public:
        /** Optional element 'tmd:SetDigitalInputConfigurations' of XSD type 'tmd:SetDigitalInputConfigurations' */
        _tmd__SetDigitalInputConfigurations *tmd__SetDigitalInputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetDigitalInputConfigurations */
        long soap_type() const { return SOAP_TYPE___tmd__SetDigitalInputConfigurations; }
        /** Constructor with member initializations */
        __tmd__SetDigitalInputConfigurations() : tmd__SetDigitalInputConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetDigitalInputConfigurations * SOAP_FMAC2 soap_instantiate___tmd__SetDigitalInputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58814 */
#ifndef SOAP_TYPE___tmd__GetSerialPorts
#define SOAP_TYPE___tmd__GetSerialPorts (2824)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetSerialPorts {
      public:
        /** Optional element 'tmd:GetSerialPorts' of XSD type 'tmd:GetSerialPorts' */
        _tmd__GetSerialPorts *tmd__GetSerialPorts;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetSerialPorts */
        long soap_type() const { return SOAP_TYPE___tmd__GetSerialPorts; }
        /** Constructor with member initializations */
        __tmd__GetSerialPorts() : tmd__GetSerialPorts() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetSerialPorts * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPorts(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58881 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfiguration
#define SOAP_TYPE___tmd__GetSerialPortConfiguration (2828)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetSerialPortConfiguration {
      public:
        /** Optional element 'tmd:GetSerialPortConfiguration' of XSD type 'tmd:GetSerialPortConfiguration' */
        _tmd__GetSerialPortConfiguration *tmd__GetSerialPortConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetSerialPortConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__GetSerialPortConfiguration; }
        /** Constructor with member initializations */
        __tmd__GetSerialPortConfiguration() : tmd__GetSerialPortConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:58948 */
#ifndef SOAP_TYPE___tmd__SetSerialPortConfiguration
#define SOAP_TYPE___tmd__SetSerialPortConfiguration (2832)
/* Wrapper: */
struct SOAP_CMAC __tmd__SetSerialPortConfiguration {
      public:
        /** Optional element 'tmd:SetSerialPortConfiguration' of XSD type 'tmd:SetSerialPortConfiguration' */
        _tmd__SetSerialPortConfiguration *tmd__SetSerialPortConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SetSerialPortConfiguration */
        long soap_type() const { return SOAP_TYPE___tmd__SetSerialPortConfiguration; }
        /** Constructor with member initializations */
        __tmd__SetSerialPortConfiguration() : tmd__SetSerialPortConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SetSerialPortConfiguration * SOAP_FMAC2 soap_instantiate___tmd__SetSerialPortConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59015 */
#ifndef SOAP_TYPE___tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE___tmd__GetSerialPortConfigurationOptions (2836)
/* Wrapper: */
struct SOAP_CMAC __tmd__GetSerialPortConfigurationOptions {
      public:
        /** Optional element 'tmd:GetSerialPortConfigurationOptions' of XSD type 'tmd:GetSerialPortConfigurationOptions' */
        _tmd__GetSerialPortConfigurationOptions *tmd__GetSerialPortConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tmd__GetSerialPortConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tmd__GetSerialPortConfigurationOptions; }
        /** Constructor with member initializations */
        __tmd__GetSerialPortConfigurationOptions() : tmd__GetSerialPortConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__GetSerialPortConfigurationOptions * SOAP_FMAC2 soap_instantiate___tmd__GetSerialPortConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59082 */
#ifndef SOAP_TYPE___tmd__SendReceiveSerialCommand
#define SOAP_TYPE___tmd__SendReceiveSerialCommand (2840)
/* Wrapper: */
struct SOAP_CMAC __tmd__SendReceiveSerialCommand {
      public:
        /** Optional element 'tmd:SendReceiveSerialCommand' of XSD type 'tmd:SendReceiveSerialCommand' */
        _tmd__SendReceiveSerialCommand *tmd__SendReceiveSerialCommand;
      public:
        /** Return unique type id SOAP_TYPE___tmd__SendReceiveSerialCommand */
        long soap_type() const { return SOAP_TYPE___tmd__SendReceiveSerialCommand; }
        /** Constructor with member initializations */
        __tmd__SendReceiveSerialCommand() : tmd__SendReceiveSerialCommand() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tmd__SendReceiveSerialCommand * SOAP_FMAC2 soap_instantiate___tmd__SendReceiveSerialCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59168 */
#ifndef SOAP_TYPE___tptz__GetServiceCapabilities
#define SOAP_TYPE___tptz__GetServiceCapabilities (2844)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetServiceCapabilities {
      public:
        /** Optional element 'tptz:GetServiceCapabilities' of XSD type 'tptz:GetServiceCapabilities' */
        _tptz__GetServiceCapabilities *tptz__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tptz__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tptz__GetServiceCapabilities() : tptz__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tptz__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59265 */
#ifndef SOAP_TYPE___tptz__GetConfigurations
#define SOAP_TYPE___tptz__GetConfigurations (2848)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetConfigurations {
      public:
        /** Optional element 'tptz:GetConfigurations' of XSD type 'tptz:GetConfigurations' */
        _tptz__GetConfigurations *tptz__GetConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetConfigurations */
        long soap_type() const { return SOAP_TYPE___tptz__GetConfigurations; }
        /** Constructor with member initializations */
        __tptz__GetConfigurations() : tptz__GetConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59336 */
#ifndef SOAP_TYPE___tptz__GetPresets
#define SOAP_TYPE___tptz__GetPresets (2852)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetPresets {
      public:
        /** Optional element 'tptz:GetPresets' of XSD type 'tptz:GetPresets' */
        _tptz__GetPresets *tptz__GetPresets;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetPresets */
        long soap_type() const { return SOAP_TYPE___tptz__GetPresets; }
        /** Constructor with member initializations */
        __tptz__GetPresets() : tptz__GetPresets() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetPresets * SOAP_FMAC2 soap_instantiate___tptz__GetPresets(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59422 */
#ifndef SOAP_TYPE___tptz__SetPreset
#define SOAP_TYPE___tptz__SetPreset (2856)
/* Wrapper: */
struct SOAP_CMAC __tptz__SetPreset {
      public:
        /** Optional element 'tptz:SetPreset' of XSD type 'tptz:SetPreset' */
        _tptz__SetPreset *tptz__SetPreset;
      public:
        /** Return unique type id SOAP_TYPE___tptz__SetPreset */
        long soap_type() const { return SOAP_TYPE___tptz__SetPreset; }
        /** Constructor with member initializations */
        __tptz__SetPreset() : tptz__SetPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__SetPreset * SOAP_FMAC2 soap_instantiate___tptz__SetPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59497 */
#ifndef SOAP_TYPE___tptz__RemovePreset
#define SOAP_TYPE___tptz__RemovePreset (2860)
/* Wrapper: */
struct SOAP_CMAC __tptz__RemovePreset {
      public:
        /** Optional element 'tptz:RemovePreset' of XSD type 'tptz:RemovePreset' */
        _tptz__RemovePreset *tptz__RemovePreset;
      public:
        /** Return unique type id SOAP_TYPE___tptz__RemovePreset */
        long soap_type() const { return SOAP_TYPE___tptz__RemovePreset; }
        /** Constructor with member initializations */
        __tptz__RemovePreset() : tptz__RemovePreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__RemovePreset * SOAP_FMAC2 soap_instantiate___tptz__RemovePreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59568 */
#ifndef SOAP_TYPE___tptz__GotoPreset
#define SOAP_TYPE___tptz__GotoPreset (2864)
/* Wrapper: */
struct SOAP_CMAC __tptz__GotoPreset {
      public:
        /** Optional element 'tptz:GotoPreset' of XSD type 'tptz:GotoPreset' */
        _tptz__GotoPreset *tptz__GotoPreset;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GotoPreset */
        long soap_type() const { return SOAP_TYPE___tptz__GotoPreset; }
        /** Constructor with member initializations */
        __tptz__GotoPreset() : tptz__GotoPreset() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GotoPreset * SOAP_FMAC2 soap_instantiate___tptz__GotoPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59639 */
#ifndef SOAP_TYPE___tptz__GetStatus
#define SOAP_TYPE___tptz__GetStatus (2868)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetStatus {
      public:
        /** Optional element 'tptz:GetStatus' of XSD type 'tptz:GetStatus' */
        _tptz__GetStatus *tptz__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetStatus */
        long soap_type() const { return SOAP_TYPE___tptz__GetStatus; }
        /** Constructor with member initializations */
        __tptz__GetStatus() : tptz__GetStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetStatus * SOAP_FMAC2 soap_instantiate___tptz__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59736 */
#ifndef SOAP_TYPE___tptz__GetConfiguration
#define SOAP_TYPE___tptz__GetConfiguration (2872)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetConfiguration {
      public:
        /** Optional element 'tptz:GetConfiguration' of XSD type 'tptz:GetConfiguration' */
        _tptz__GetConfiguration *tptz__GetConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetConfiguration */
        long soap_type() const { return SOAP_TYPE___tptz__GetConfiguration; }
        /** Constructor with member initializations */
        __tptz__GetConfiguration() : tptz__GetConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__GetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59815 */
#ifndef SOAP_TYPE___tptz__GetNodes
#define SOAP_TYPE___tptz__GetNodes (2876)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetNodes {
      public:
        /** Optional element 'tptz:GetNodes' of XSD type 'tptz:GetNodes' */
        _tptz__GetNodes *tptz__GetNodes;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetNodes */
        long soap_type() const { return SOAP_TYPE___tptz__GetNodes; }
        /** Constructor with member initializations */
        __tptz__GetNodes() : tptz__GetNodes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetNodes * SOAP_FMAC2 soap_instantiate___tptz__GetNodes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59885 */
#ifndef SOAP_TYPE___tptz__GetNode
#define SOAP_TYPE___tptz__GetNode (2880)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetNode {
      public:
        /** Optional element 'tptz:GetNode' of XSD type 'tptz:GetNode' */
        _tptz__GetNode *tptz__GetNode;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetNode */
        long soap_type() const { return SOAP_TYPE___tptz__GetNode; }
        /** Constructor with member initializations */
        __tptz__GetNode() : tptz__GetNode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetNode * SOAP_FMAC2 soap_instantiate___tptz__GetNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:59955 */
#ifndef SOAP_TYPE___tptz__SetConfiguration
#define SOAP_TYPE___tptz__SetConfiguration (2884)
/* Wrapper: */
struct SOAP_CMAC __tptz__SetConfiguration {
      public:
        /** Optional element 'tptz:SetConfiguration' of XSD type 'tptz:SetConfiguration' */
        _tptz__SetConfiguration *tptz__SetConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tptz__SetConfiguration */
        long soap_type() const { return SOAP_TYPE___tptz__SetConfiguration; }
        /** Constructor with member initializations */
        __tptz__SetConfiguration() : tptz__SetConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__SetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60035 */
#ifndef SOAP_TYPE___tptz__GetConfigurationOptions
#define SOAP_TYPE___tptz__GetConfigurationOptions (2888)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetConfigurationOptions {
      public:
        /** Optional element 'tptz:GetConfigurationOptions' of XSD type 'tptz:GetConfigurationOptions' */
        _tptz__GetConfigurationOptions *tptz__GetConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___tptz__GetConfigurationOptions; }
        /** Constructor with member initializations */
        __tptz__GetConfigurationOptions() : tptz__GetConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60105 */
#ifndef SOAP_TYPE___tptz__GotoHomePosition
#define SOAP_TYPE___tptz__GotoHomePosition (2892)
/* Wrapper: */
struct SOAP_CMAC __tptz__GotoHomePosition {
      public:
        /** Optional element 'tptz:GotoHomePosition' of XSD type 'tptz:GotoHomePosition' */
        _tptz__GotoHomePosition *tptz__GotoHomePosition;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GotoHomePosition */
        long soap_type() const { return SOAP_TYPE___tptz__GotoHomePosition; }
        /** Constructor with member initializations */
        __tptz__GotoHomePosition() : tptz__GotoHomePosition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate___tptz__GotoHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60178 */
#ifndef SOAP_TYPE___tptz__SetHomePosition
#define SOAP_TYPE___tptz__SetHomePosition (2896)
/* Wrapper: */
struct SOAP_CMAC __tptz__SetHomePosition {
      public:
        /** Optional element 'tptz:SetHomePosition' of XSD type 'tptz:SetHomePosition' */
        _tptz__SetHomePosition *tptz__SetHomePosition;
      public:
        /** Return unique type id SOAP_TYPE___tptz__SetHomePosition */
        long soap_type() const { return SOAP_TYPE___tptz__SetHomePosition; }
        /** Constructor with member initializations */
        __tptz__SetHomePosition() : tptz__SetHomePosition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate___tptz__SetHomePosition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60249 */
#ifndef SOAP_TYPE___tptz__ContinuousMove
#define SOAP_TYPE___tptz__ContinuousMove (2900)
/* Wrapper: */
struct SOAP_CMAC __tptz__ContinuousMove {
      public:
        /** Optional element 'tptz:ContinuousMove' of XSD type 'tptz:ContinuousMove' */
        _tptz__ContinuousMove *tptz__ContinuousMove;
      public:
        /** Return unique type id SOAP_TYPE___tptz__ContinuousMove */
        long soap_type() const { return SOAP_TYPE___tptz__ContinuousMove; }
        /** Constructor with member initializations */
        __tptz__ContinuousMove() : tptz__ContinuousMove() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate___tptz__ContinuousMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60325 */
#ifndef SOAP_TYPE___tptz__RelativeMove
#define SOAP_TYPE___tptz__RelativeMove (2904)
/* Wrapper: */
struct SOAP_CMAC __tptz__RelativeMove {
      public:
        /** Optional element 'tptz:RelativeMove' of XSD type 'tptz:RelativeMove' */
        _tptz__RelativeMove *tptz__RelativeMove;
      public:
        /** Return unique type id SOAP_TYPE___tptz__RelativeMove */
        long soap_type() const { return SOAP_TYPE___tptz__RelativeMove; }
        /** Constructor with member initializations */
        __tptz__RelativeMove() : tptz__RelativeMove() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__RelativeMove * SOAP_FMAC2 soap_instantiate___tptz__RelativeMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60398 */
#ifndef SOAP_TYPE___tptz__SendAuxiliaryCommand
#define SOAP_TYPE___tptz__SendAuxiliaryCommand (2908)
/* Wrapper: */
struct SOAP_CMAC __tptz__SendAuxiliaryCommand {
      public:
        /** Optional element 'tptz:SendAuxiliaryCommand' of XSD type 'tptz:SendAuxiliaryCommand' */
        _tptz__SendAuxiliaryCommand *tptz__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___tptz__SendAuxiliaryCommand */
        long soap_type() const { return SOAP_TYPE___tptz__SendAuxiliaryCommand; }
        /** Constructor with member initializations */
        __tptz__SendAuxiliaryCommand() : tptz__SendAuxiliaryCommand() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tptz__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60473 */
#ifndef SOAP_TYPE___tptz__AbsoluteMove
#define SOAP_TYPE___tptz__AbsoluteMove (2912)
/* Wrapper: */
struct SOAP_CMAC __tptz__AbsoluteMove {
      public:
        /** Optional element 'tptz:AbsoluteMove' of XSD type 'tptz:AbsoluteMove' */
        _tptz__AbsoluteMove *tptz__AbsoluteMove;
      public:
        /** Return unique type id SOAP_TYPE___tptz__AbsoluteMove */
        long soap_type() const { return SOAP_TYPE___tptz__AbsoluteMove; }
        /** Constructor with member initializations */
        __tptz__AbsoluteMove() : tptz__AbsoluteMove() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate___tptz__AbsoluteMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60553 */
#ifndef SOAP_TYPE___tptz__GeoMove
#define SOAP_TYPE___tptz__GeoMove (2916)
/* Wrapper: */
struct SOAP_CMAC __tptz__GeoMove {
      public:
        /** Optional element 'tptz:GeoMove' of XSD type 'tptz:GeoMove' */
        _tptz__GeoMove *tptz__GeoMove;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GeoMove */
        long soap_type() const { return SOAP_TYPE___tptz__GeoMove; }
        /** Constructor with member initializations */
        __tptz__GeoMove() : tptz__GeoMove() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GeoMove * SOAP_FMAC2 soap_instantiate___tptz__GeoMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60624 */
#ifndef SOAP_TYPE___tptz__Stop
#define SOAP_TYPE___tptz__Stop (2920)
/* Wrapper: */
struct SOAP_CMAC __tptz__Stop {
      public:
        /** Optional element 'tptz:Stop' of XSD type 'tptz:Stop' */
        _tptz__Stop *tptz__Stop;
      public:
        /** Return unique type id SOAP_TYPE___tptz__Stop */
        long soap_type() const { return SOAP_TYPE___tptz__Stop; }
        /** Constructor with member initializations */
        __tptz__Stop() : tptz__Stop() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__Stop * SOAP_FMAC2 soap_instantiate___tptz__Stop(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60692 */
#ifndef SOAP_TYPE___tptz__GetPresetTours
#define SOAP_TYPE___tptz__GetPresetTours (2924)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetPresetTours {
      public:
        /** Optional element 'tptz:GetPresetTours' of XSD type 'tptz:GetPresetTours' */
        _tptz__GetPresetTours *tptz__GetPresetTours;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetPresetTours */
        long soap_type() const { return SOAP_TYPE___tptz__GetPresetTours; }
        /** Constructor with member initializations */
        __tptz__GetPresetTours() : tptz__GetPresetTours() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTours(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60760 */
#ifndef SOAP_TYPE___tptz__GetPresetTour
#define SOAP_TYPE___tptz__GetPresetTour (2928)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetPresetTour {
      public:
        /** Optional element 'tptz:GetPresetTour' of XSD type 'tptz:GetPresetTour' */
        _tptz__GetPresetTour *tptz__GetPresetTour;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetPresetTour */
        long soap_type() const { return SOAP_TYPE___tptz__GetPresetTour; }
        /** Constructor with member initializations */
        __tptz__GetPresetTour() : tptz__GetPresetTour() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60828 */
#ifndef SOAP_TYPE___tptz__GetPresetTourOptions
#define SOAP_TYPE___tptz__GetPresetTourOptions (2932)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetPresetTourOptions {
      public:
        /** Optional element 'tptz:GetPresetTourOptions' of XSD type 'tptz:GetPresetTourOptions' */
        _tptz__GetPresetTourOptions *tptz__GetPresetTourOptions;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetPresetTourOptions */
        long soap_type() const { return SOAP_TYPE___tptz__GetPresetTourOptions; }
        /** Constructor with member initializations */
        __tptz__GetPresetTourOptions() : tptz__GetPresetTourOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60896 */
#ifndef SOAP_TYPE___tptz__CreatePresetTour
#define SOAP_TYPE___tptz__CreatePresetTour (2936)
/* Wrapper: */
struct SOAP_CMAC __tptz__CreatePresetTour {
      public:
        /** Optional element 'tptz:CreatePresetTour' of XSD type 'tptz:CreatePresetTour' */
        _tptz__CreatePresetTour *tptz__CreatePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___tptz__CreatePresetTour */
        long soap_type() const { return SOAP_TYPE___tptz__CreatePresetTour; }
        /** Constructor with member initializations */
        __tptz__CreatePresetTour() : tptz__CreatePresetTour() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__CreatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:60964 */
#ifndef SOAP_TYPE___tptz__ModifyPresetTour
#define SOAP_TYPE___tptz__ModifyPresetTour (2940)
/* Wrapper: */
struct SOAP_CMAC __tptz__ModifyPresetTour {
      public:
        /** Optional element 'tptz:ModifyPresetTour' of XSD type 'tptz:ModifyPresetTour' */
        _tptz__ModifyPresetTour *tptz__ModifyPresetTour;
      public:
        /** Return unique type id SOAP_TYPE___tptz__ModifyPresetTour */
        long soap_type() const { return SOAP_TYPE___tptz__ModifyPresetTour; }
        /** Constructor with member initializations */
        __tptz__ModifyPresetTour() : tptz__ModifyPresetTour() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate___tptz__ModifyPresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61032 */
#ifndef SOAP_TYPE___tptz__OperatePresetTour
#define SOAP_TYPE___tptz__OperatePresetTour (2944)
/* Wrapper: */
struct SOAP_CMAC __tptz__OperatePresetTour {
      public:
        /** Optional element 'tptz:OperatePresetTour' of XSD type 'tptz:OperatePresetTour' */
        _tptz__OperatePresetTour *tptz__OperatePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___tptz__OperatePresetTour */
        long soap_type() const { return SOAP_TYPE___tptz__OperatePresetTour; }
        /** Constructor with member initializations */
        __tptz__OperatePresetTour() : tptz__OperatePresetTour() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__OperatePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61100 */
#ifndef SOAP_TYPE___tptz__RemovePresetTour
#define SOAP_TYPE___tptz__RemovePresetTour (2948)
/* Wrapper: */
struct SOAP_CMAC __tptz__RemovePresetTour {
      public:
        /** Optional element 'tptz:RemovePresetTour' of XSD type 'tptz:RemovePresetTour' */
        _tptz__RemovePresetTour *tptz__RemovePresetTour;
      public:
        /** Return unique type id SOAP_TYPE___tptz__RemovePresetTour */
        long soap_type() const { return SOAP_TYPE___tptz__RemovePresetTour; }
        /** Constructor with member initializations */
        __tptz__RemovePresetTour() : tptz__RemovePresetTour() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate___tptz__RemovePresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61176 */
#ifndef SOAP_TYPE___tptz__GetCompatibleConfigurations
#define SOAP_TYPE___tptz__GetCompatibleConfigurations (2952)
/* Wrapper: */
struct SOAP_CMAC __tptz__GetCompatibleConfigurations {
      public:
        /** Optional element 'tptz:GetCompatibleConfigurations' of XSD type 'tptz:GetCompatibleConfigurations' */
        _tptz__GetCompatibleConfigurations *tptz__GetCompatibleConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tptz__GetCompatibleConfigurations */
        long soap_type() const { return SOAP_TYPE___tptz__GetCompatibleConfigurations; }
        /** Constructor with member initializations */
        __tptz__GetCompatibleConfigurations() : tptz__GetCompatibleConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tptz__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetCompatibleConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61263 */
#ifndef SOAP_TYPE___trt__GetServiceCapabilities
#define SOAP_TYPE___trt__GetServiceCapabilities (2956)
/* Wrapper: */
struct SOAP_CMAC __trt__GetServiceCapabilities {
      public:
        /** Optional element 'trt:GetServiceCapabilities' of XSD type 'trt:GetServiceCapabilities' */
        _trt__GetServiceCapabilities *trt__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___trt__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __trt__GetServiceCapabilities() : trt__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trt__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61331 */
#ifndef SOAP_TYPE___trt__GetVideoSources
#define SOAP_TYPE___trt__GetVideoSources (2960)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoSources {
      public:
        /** Optional element 'trt:GetVideoSources' of XSD type 'trt:GetVideoSources' */
        _trt__GetVideoSources *trt__GetVideoSources;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoSources */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoSources; }
        /** Constructor with member initializations */
        __trt__GetVideoSources() : trt__GetVideoSources() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoSources * SOAP_FMAC2 soap_instantiate___trt__GetVideoSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61399 */
#ifndef SOAP_TYPE___trt__GetAudioSources
#define SOAP_TYPE___trt__GetAudioSources (2964)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioSources {
      public:
        /** Optional element 'trt:GetAudioSources' of XSD type 'trt:GetAudioSources' */
        _trt__GetAudioSources *trt__GetAudioSources;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioSources */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioSources; }
        /** Constructor with member initializations */
        __trt__GetAudioSources() : trt__GetAudioSources() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioSources * SOAP_FMAC2 soap_instantiate___trt__GetAudioSources(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61467 */
#ifndef SOAP_TYPE___trt__GetAudioOutputs
#define SOAP_TYPE___trt__GetAudioOutputs (2968)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioOutputs {
      public:
        /** Optional element 'trt:GetAudioOutputs' of XSD type 'trt:GetAudioOutputs' */
        _trt__GetAudioOutputs *trt__GetAudioOutputs;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioOutputs */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioOutputs; }
        /** Constructor with member initializations */
        __trt__GetAudioOutputs() : trt__GetAudioOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61539 */
#ifndef SOAP_TYPE___trt__CreateProfile
#define SOAP_TYPE___trt__CreateProfile (2972)
/* Wrapper: */
struct SOAP_CMAC __trt__CreateProfile {
      public:
        /** Optional element 'trt:CreateProfile' of XSD type 'trt:CreateProfile' */
        _trt__CreateProfile *trt__CreateProfile;
      public:
        /** Return unique type id SOAP_TYPE___trt__CreateProfile */
        long soap_type() const { return SOAP_TYPE___trt__CreateProfile; }
        /** Constructor with member initializations */
        __trt__CreateProfile() : trt__CreateProfile() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__CreateProfile * SOAP_FMAC2 soap_instantiate___trt__CreateProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61608 */
#ifndef SOAP_TYPE___trt__GetProfile
#define SOAP_TYPE___trt__GetProfile (2976)
/* Wrapper: */
struct SOAP_CMAC __trt__GetProfile {
      public:
        /** Optional element 'trt:GetProfile' of XSD type 'trt:GetProfile' */
        _trt__GetProfile *trt__GetProfile;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetProfile */
        long soap_type() const { return SOAP_TYPE___trt__GetProfile; }
        /** Constructor with member initializations */
        __trt__GetProfile() : trt__GetProfile() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetProfile * SOAP_FMAC2 soap_instantiate___trt__GetProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61681 */
#ifndef SOAP_TYPE___trt__GetProfiles
#define SOAP_TYPE___trt__GetProfiles (2980)
/* Wrapper: */
struct SOAP_CMAC __trt__GetProfiles {
      public:
        /** Optional element 'trt:GetProfiles' of XSD type 'trt:GetProfiles' */
        _trt__GetProfiles *trt__GetProfiles;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetProfiles */
        long soap_type() const { return SOAP_TYPE___trt__GetProfiles; }
        /** Constructor with member initializations */
        __trt__GetProfiles() : trt__GetProfiles() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetProfiles * SOAP_FMAC2 soap_instantiate___trt__GetProfiles(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61756 */
#ifndef SOAP_TYPE___trt__AddVideoEncoderConfiguration
#define SOAP_TYPE___trt__AddVideoEncoderConfiguration (2984)
/* Wrapper: */
struct SOAP_CMAC __trt__AddVideoEncoderConfiguration {
      public:
        /** Optional element 'trt:AddVideoEncoderConfiguration' of XSD type 'trt:AddVideoEncoderConfiguration' */
        _trt__AddVideoEncoderConfiguration *trt__AddVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddVideoEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__AddVideoEncoderConfiguration() : trt__AddVideoEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61827 */
#ifndef SOAP_TYPE___trt__AddVideoSourceConfiguration
#define SOAP_TYPE___trt__AddVideoSourceConfiguration (2988)
/* Wrapper: */
struct SOAP_CMAC __trt__AddVideoSourceConfiguration {
      public:
        /** Optional element 'trt:AddVideoSourceConfiguration' of XSD type 'trt:AddVideoSourceConfiguration' */
        _trt__AddVideoSourceConfiguration *trt__AddVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__AddVideoSourceConfiguration() : trt__AddVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61902 */
#ifndef SOAP_TYPE___trt__AddAudioEncoderConfiguration
#define SOAP_TYPE___trt__AddAudioEncoderConfiguration (2992)
/* Wrapper: */
struct SOAP_CMAC __trt__AddAudioEncoderConfiguration {
      public:
        /** Optional element 'trt:AddAudioEncoderConfiguration' of XSD type 'trt:AddAudioEncoderConfiguration' */
        _trt__AddAudioEncoderConfiguration *trt__AddAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddAudioEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__AddAudioEncoderConfiguration() : trt__AddAudioEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:61973 */
#ifndef SOAP_TYPE___trt__AddAudioSourceConfiguration
#define SOAP_TYPE___trt__AddAudioSourceConfiguration (2996)
/* Wrapper: */
struct SOAP_CMAC __trt__AddAudioSourceConfiguration {
      public:
        /** Optional element 'trt:AddAudioSourceConfiguration' of XSD type 'trt:AddAudioSourceConfiguration' */
        _trt__AddAudioSourceConfiguration *trt__AddAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__AddAudioSourceConfiguration() : trt__AddAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62048 */
#ifndef SOAP_TYPE___trt__AddPTZConfiguration
#define SOAP_TYPE___trt__AddPTZConfiguration (3000)
/* Wrapper: */
struct SOAP_CMAC __trt__AddPTZConfiguration {
      public:
        /** Optional element 'trt:AddPTZConfiguration' of XSD type 'trt:AddPTZConfiguration' */
        _trt__AddPTZConfiguration *trt__AddPTZConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddPTZConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddPTZConfiguration; }
        /** Constructor with member initializations */
        __trt__AddPTZConfiguration() : trt__AddPTZConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddPTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62126 */
#ifndef SOAP_TYPE___trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__AddVideoAnalyticsConfiguration (3004)
/* Wrapper: */
struct SOAP_CMAC __trt__AddVideoAnalyticsConfiguration {
      public:
        /** Optional element 'trt:AddVideoAnalyticsConfiguration' of XSD type 'trt:AddVideoAnalyticsConfiguration' */
        _trt__AddVideoAnalyticsConfiguration *trt__AddVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddVideoAnalyticsConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __trt__AddVideoAnalyticsConfiguration() : trt__AddVideoAnalyticsConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62198 */
#ifndef SOAP_TYPE___trt__AddMetadataConfiguration
#define SOAP_TYPE___trt__AddMetadataConfiguration (3008)
/* Wrapper: */
struct SOAP_CMAC __trt__AddMetadataConfiguration {
      public:
        /** Optional element 'trt:AddMetadataConfiguration' of XSD type 'trt:AddMetadataConfiguration' */
        _trt__AddMetadataConfiguration *trt__AddMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddMetadataConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddMetadataConfiguration; }
        /** Constructor with member initializations */
        __trt__AddMetadataConfiguration() : trt__AddMetadataConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62268 */
#ifndef SOAP_TYPE___trt__AddAudioOutputConfiguration
#define SOAP_TYPE___trt__AddAudioOutputConfiguration (3012)
/* Wrapper: */
struct SOAP_CMAC __trt__AddAudioOutputConfiguration {
      public:
        /** Optional element 'trt:AddAudioOutputConfiguration' of XSD type 'trt:AddAudioOutputConfiguration' */
        _trt__AddAudioOutputConfiguration *trt__AddAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __trt__AddAudioOutputConfiguration() : trt__AddAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62338 */
#ifndef SOAP_TYPE___trt__AddAudioDecoderConfiguration
#define SOAP_TYPE___trt__AddAudioDecoderConfiguration (3016)
/* Wrapper: */
struct SOAP_CMAC __trt__AddAudioDecoderConfiguration {
      public:
        /** Optional element 'trt:AddAudioDecoderConfiguration' of XSD type 'trt:AddAudioDecoderConfiguration' */
        _trt__AddAudioDecoderConfiguration *trt__AddAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__AddAudioDecoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__AddAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __trt__AddAudioDecoderConfiguration() : trt__AddAudioDecoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62409 */
#ifndef SOAP_TYPE___trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___trt__RemoveVideoEncoderConfiguration (3020)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveVideoEncoderConfiguration {
      public:
        /** Optional element 'trt:RemoveVideoEncoderConfiguration' of XSD type 'trt:RemoveVideoEncoderConfiguration' */
        _trt__RemoveVideoEncoderConfiguration *trt__RemoveVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveVideoEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveVideoEncoderConfiguration() : trt__RemoveVideoEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62482 */
#ifndef SOAP_TYPE___trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE___trt__RemoveVideoSourceConfiguration (3024)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveVideoSourceConfiguration {
      public:
        /** Optional element 'trt:RemoveVideoSourceConfiguration' of XSD type 'trt:RemoveVideoSourceConfiguration' */
        _trt__RemoveVideoSourceConfiguration *trt__RemoveVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveVideoSourceConfiguration() : trt__RemoveVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62554 */
#ifndef SOAP_TYPE___trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioEncoderConfiguration (3028)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveAudioEncoderConfiguration {
      public:
        /** Optional element 'trt:RemoveAudioEncoderConfiguration' of XSD type 'trt:RemoveAudioEncoderConfiguration' */
        _trt__RemoveAudioEncoderConfiguration *trt__RemoveAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveAudioEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveAudioEncoderConfiguration() : trt__RemoveAudioEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62628 */
#ifndef SOAP_TYPE___trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE___trt__RemoveAudioSourceConfiguration (3032)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveAudioSourceConfiguration {
      public:
        /** Optional element 'trt:RemoveAudioSourceConfiguration' of XSD type 'trt:RemoveAudioSourceConfiguration' */
        _trt__RemoveAudioSourceConfiguration *trt__RemoveAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveAudioSourceConfiguration() : trt__RemoveAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62699 */
#ifndef SOAP_TYPE___trt__RemovePTZConfiguration
#define SOAP_TYPE___trt__RemovePTZConfiguration (3036)
/* Wrapper: */
struct SOAP_CMAC __trt__RemovePTZConfiguration {
      public:
        /** Optional element 'trt:RemovePTZConfiguration' of XSD type 'trt:RemovePTZConfiguration' */
        _trt__RemovePTZConfiguration *trt__RemovePTZConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemovePTZConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemovePTZConfiguration; }
        /** Constructor with member initializations */
        __trt__RemovePTZConfiguration() : trt__RemovePTZConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemovePTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62770 */
#ifndef SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration (3040)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveVideoAnalyticsConfiguration {
      public:
        /** Optional element 'trt:RemoveVideoAnalyticsConfiguration' of XSD type 'trt:RemoveVideoAnalyticsConfiguration' */
        _trt__RemoveVideoAnalyticsConfiguration *trt__RemoveVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveVideoAnalyticsConfiguration() : trt__RemoveVideoAnalyticsConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62840 */
#ifndef SOAP_TYPE___trt__RemoveMetadataConfiguration
#define SOAP_TYPE___trt__RemoveMetadataConfiguration (3044)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveMetadataConfiguration {
      public:
        /** Optional element 'trt:RemoveMetadataConfiguration' of XSD type 'trt:RemoveMetadataConfiguration' */
        _trt__RemoveMetadataConfiguration *trt__RemoveMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveMetadataConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveMetadataConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveMetadataConfiguration() : trt__RemoveMetadataConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62910 */
#ifndef SOAP_TYPE___trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE___trt__RemoveAudioOutputConfiguration (3048)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveAudioOutputConfiguration {
      public:
        /** Optional element 'trt:RemoveAudioOutputConfiguration' of XSD type 'trt:RemoveAudioOutputConfiguration' */
        _trt__RemoveAudioOutputConfiguration *trt__RemoveAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveAudioOutputConfiguration() : trt__RemoveAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:62980 */
#ifndef SOAP_TYPE___trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___trt__RemoveAudioDecoderConfiguration (3052)
/* Wrapper: */
struct SOAP_CMAC __trt__RemoveAudioDecoderConfiguration {
      public:
        /** Optional element 'trt:RemoveAudioDecoderConfiguration' of XSD type 'trt:RemoveAudioDecoderConfiguration' */
        _trt__RemoveAudioDecoderConfiguration *trt__RemoveAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__RemoveAudioDecoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__RemoveAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __trt__RemoveAudioDecoderConfiguration() : trt__RemoveAudioDecoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63049 */
#ifndef SOAP_TYPE___trt__DeleteProfile
#define SOAP_TYPE___trt__DeleteProfile (3056)
/* Wrapper: */
struct SOAP_CMAC __trt__DeleteProfile {
      public:
        /** Optional element 'trt:DeleteProfile' of XSD type 'trt:DeleteProfile' */
        _trt__DeleteProfile *trt__DeleteProfile;
      public:
        /** Return unique type id SOAP_TYPE___trt__DeleteProfile */
        long soap_type() const { return SOAP_TYPE___trt__DeleteProfile; }
        /** Constructor with member initializations */
        __trt__DeleteProfile() : trt__DeleteProfile() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__DeleteProfile * SOAP_FMAC2 soap_instantiate___trt__DeleteProfile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63119 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurations
#define SOAP_TYPE___trt__GetVideoSourceConfigurations (3060)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoSourceConfigurations {
      public:
        /** Optional element 'trt:GetVideoSourceConfigurations' of XSD type 'trt:GetVideoSourceConfigurations' */
        _trt__GetVideoSourceConfigurations *trt__GetVideoSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoSourceConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoSourceConfigurations; }
        /** Constructor with member initializations */
        __trt__GetVideoSourceConfigurations() : trt__GetVideoSourceConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63190 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetVideoEncoderConfigurations (3064)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoEncoderConfigurations {
      public:
        /** Optional element 'trt:GetVideoEncoderConfigurations' of XSD type 'trt:GetVideoEncoderConfigurations' */
        _trt__GetVideoEncoderConfigurations *trt__GetVideoEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoEncoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetVideoEncoderConfigurations() : trt__GetVideoEncoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63261 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurations
#define SOAP_TYPE___trt__GetAudioSourceConfigurations (3068)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioSourceConfigurations {
      public:
        /** Optional element 'trt:GetAudioSourceConfigurations' of XSD type 'trt:GetAudioSourceConfigurations' */
        _trt__GetAudioSourceConfigurations *trt__GetAudioSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioSourceConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioSourceConfigurations; }
        /** Constructor with member initializations */
        __trt__GetAudioSourceConfigurations() : trt__GetAudioSourceConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63331 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetAudioEncoderConfigurations (3072)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioEncoderConfigurations {
      public:
        /** Optional element 'trt:GetAudioEncoderConfigurations' of XSD type 'trt:GetAudioEncoderConfigurations' */
        _trt__GetAudioEncoderConfigurations *trt__GetAudioEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioEncoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetAudioEncoderConfigurations() : trt__GetAudioEncoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63401 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetVideoAnalyticsConfigurations (3076)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoAnalyticsConfigurations {
      public:
        /** Optional element 'trt:GetVideoAnalyticsConfigurations' of XSD type 'trt:GetVideoAnalyticsConfigurations' */
        _trt__GetVideoAnalyticsConfigurations *trt__GetVideoAnalyticsConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoAnalyticsConfigurations; }
        /** Constructor with member initializations */
        __trt__GetVideoAnalyticsConfigurations() : trt__GetVideoAnalyticsConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63470 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurations
#define SOAP_TYPE___trt__GetMetadataConfigurations (3080)
/* Wrapper: */
struct SOAP_CMAC __trt__GetMetadataConfigurations {
      public:
        /** Optional element 'trt:GetMetadataConfigurations' of XSD type 'trt:GetMetadataConfigurations' */
        _trt__GetMetadataConfigurations *trt__GetMetadataConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetMetadataConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetMetadataConfigurations; }
        /** Constructor with member initializations */
        __trt__GetMetadataConfigurations() : trt__GetMetadataConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63539 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurations
#define SOAP_TYPE___trt__GetAudioOutputConfigurations (3084)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioOutputConfigurations {
      public:
        /** Optional element 'trt:GetAudioOutputConfigurations' of XSD type 'trt:GetAudioOutputConfigurations' */
        _trt__GetAudioOutputConfigurations *trt__GetAudioOutputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioOutputConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioOutputConfigurations; }
        /** Constructor with member initializations */
        __trt__GetAudioOutputConfigurations() : trt__GetAudioOutputConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63610 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetAudioDecoderConfigurations (3088)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioDecoderConfigurations {
      public:
        /** Optional element 'trt:GetAudioDecoderConfigurations' of XSD type 'trt:GetAudioDecoderConfigurations' */
        _trt__GetAudioDecoderConfigurations *trt__GetAudioDecoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioDecoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetAudioDecoderConfigurations() : trt__GetAudioDecoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63679 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfiguration
#define SOAP_TYPE___trt__GetVideoSourceConfiguration (3092)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoSourceConfiguration {
      public:
        /** Optional element 'trt:GetVideoSourceConfiguration' of XSD type 'trt:GetVideoSourceConfiguration' */
        _trt__GetVideoSourceConfiguration *trt__GetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__GetVideoSourceConfiguration() : trt__GetVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63748 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfiguration
#define SOAP_TYPE___trt__GetVideoEncoderConfiguration (3096)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoEncoderConfiguration {
      public:
        /** Optional element 'trt:GetVideoEncoderConfiguration' of XSD type 'trt:GetVideoEncoderConfiguration' */
        _trt__GetVideoEncoderConfiguration *trt__GetVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__GetVideoEncoderConfiguration() : trt__GetVideoEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63817 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfiguration
#define SOAP_TYPE___trt__GetAudioSourceConfiguration (3100)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioSourceConfiguration {
      public:
        /** Optional element 'trt:GetAudioSourceConfiguration' of XSD type 'trt:GetAudioSourceConfiguration' */
        _trt__GetAudioSourceConfiguration *trt__GetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__GetAudioSourceConfiguration() : trt__GetAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63886 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfiguration
#define SOAP_TYPE___trt__GetAudioEncoderConfiguration (3104)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioEncoderConfiguration {
      public:
        /** Optional element 'trt:GetAudioEncoderConfiguration' of XSD type 'trt:GetAudioEncoderConfiguration' */
        _trt__GetAudioEncoderConfiguration *trt__GetAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__GetAudioEncoderConfiguration() : trt__GetAudioEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:63955 */
#ifndef SOAP_TYPE___trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__GetVideoAnalyticsConfiguration (3108)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoAnalyticsConfiguration {
      public:
        /** Optional element 'trt:GetVideoAnalyticsConfiguration' of XSD type 'trt:GetVideoAnalyticsConfiguration' */
        _trt__GetVideoAnalyticsConfiguration *trt__GetVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoAnalyticsConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __trt__GetVideoAnalyticsConfiguration() : trt__GetVideoAnalyticsConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64024 */
#ifndef SOAP_TYPE___trt__GetMetadataConfiguration
#define SOAP_TYPE___trt__GetMetadataConfiguration (3112)
/* Wrapper: */
struct SOAP_CMAC __trt__GetMetadataConfiguration {
      public:
        /** Optional element 'trt:GetMetadataConfiguration' of XSD type 'trt:GetMetadataConfiguration' */
        _trt__GetMetadataConfiguration *trt__GetMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetMetadataConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetMetadataConfiguration; }
        /** Constructor with member initializations */
        __trt__GetMetadataConfiguration() : trt__GetMetadataConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64093 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfiguration
#define SOAP_TYPE___trt__GetAudioOutputConfiguration (3116)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioOutputConfiguration {
      public:
        /** Optional element 'trt:GetAudioOutputConfiguration' of XSD type 'trt:GetAudioOutputConfiguration' */
        _trt__GetAudioOutputConfiguration *trt__GetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __trt__GetAudioOutputConfiguration() : trt__GetAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64162 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfiguration
#define SOAP_TYPE___trt__GetAudioDecoderConfiguration (3120)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioDecoderConfiguration {
      public:
        /** Optional element 'trt:GetAudioDecoderConfiguration' of XSD type 'trt:GetAudioDecoderConfiguration' */
        _trt__GetAudioDecoderConfiguration *trt__GetAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioDecoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __trt__GetAudioDecoderConfiguration() : trt__GetAudioDecoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64234 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations (3124)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleVideoEncoderConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleVideoEncoderConfigurations' of XSD type 'trt:GetCompatibleVideoEncoderConfigurations' */
        _trt__GetCompatibleVideoEncoderConfigurations *trt__GetCompatibleVideoEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleVideoEncoderConfigurations() : trt__GetCompatibleVideoEncoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64308 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations (3128)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleVideoSourceConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleVideoSourceConfigurations' of XSD type 'trt:GetCompatibleVideoSourceConfigurations' */
        _trt__GetCompatibleVideoSourceConfigurations *trt__GetCompatibleVideoSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleVideoSourceConfigurations() : trt__GetCompatibleVideoSourceConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64380 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations (3132)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleAudioEncoderConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleAudioEncoderConfigurations' of XSD type 'trt:GetCompatibleAudioEncoderConfigurations' */
        _trt__GetCompatibleAudioEncoderConfigurations *trt__GetCompatibleAudioEncoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleAudioEncoderConfigurations() : trt__GetCompatibleAudioEncoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64452 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations (3136)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleAudioSourceConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleAudioSourceConfigurations' of XSD type 'trt:GetCompatibleAudioSourceConfigurations' */
        _trt__GetCompatibleAudioSourceConfigurations *trt__GetCompatibleAudioSourceConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleAudioSourceConfigurations() : trt__GetCompatibleAudioSourceConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64524 */
#ifndef SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations (3140)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleVideoAnalyticsConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleVideoAnalyticsConfigurations' of XSD type 'trt:GetCompatibleVideoAnalyticsConfigurations' */
        _trt__GetCompatibleVideoAnalyticsConfigurations *trt__GetCompatibleVideoAnalyticsConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleVideoAnalyticsConfigurations() : trt__GetCompatibleVideoAnalyticsConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64596 */
#ifndef SOAP_TYPE___trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___trt__GetCompatibleMetadataConfigurations (3144)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleMetadataConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleMetadataConfigurations' of XSD type 'trt:GetCompatibleMetadataConfigurations' */
        _trt__GetCompatibleMetadataConfigurations *trt__GetCompatibleMetadataConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleMetadataConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleMetadataConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleMetadataConfigurations() : trt__GetCompatibleMetadataConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64667 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations (3148)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleAudioOutputConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleAudioOutputConfigurations' of XSD type 'trt:GetCompatibleAudioOutputConfigurations' */
        _trt__GetCompatibleAudioOutputConfigurations *trt__GetCompatibleAudioOutputConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleAudioOutputConfigurations() : trt__GetCompatibleAudioOutputConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64738 */
#ifndef SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations (3152)
/* Wrapper: */
struct SOAP_CMAC __trt__GetCompatibleAudioDecoderConfigurations {
      public:
        /** Optional element 'trt:GetCompatibleAudioDecoderConfigurations' of XSD type 'trt:GetCompatibleAudioDecoderConfigurations' */
        _trt__GetCompatibleAudioDecoderConfigurations *trt__GetCompatibleAudioDecoderConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations */
        long soap_type() const { return SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations; }
        /** Constructor with member initializations */
        __trt__GetCompatibleAudioDecoderConfigurations() : trt__GetCompatibleAudioDecoderConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64811 */
#ifndef SOAP_TYPE___trt__SetVideoSourceConfiguration
#define SOAP_TYPE___trt__SetVideoSourceConfiguration (3156)
/* Wrapper: */
struct SOAP_CMAC __trt__SetVideoSourceConfiguration {
      public:
        /** Optional element 'trt:SetVideoSourceConfiguration' of XSD type 'trt:SetVideoSourceConfiguration' */
        _trt__SetVideoSourceConfiguration *trt__SetVideoSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetVideoSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetVideoSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__SetVideoSourceConfiguration() : trt__SetVideoSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64888 */
#ifndef SOAP_TYPE___trt__SetVideoEncoderConfiguration
#define SOAP_TYPE___trt__SetVideoEncoderConfiguration (3160)
/* Wrapper: */
struct SOAP_CMAC __trt__SetVideoEncoderConfiguration {
      public:
        /** Optional element 'trt:SetVideoEncoderConfiguration' of XSD type 'trt:SetVideoEncoderConfiguration' */
        _trt__SetVideoEncoderConfiguration *trt__SetVideoEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetVideoEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetVideoEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__SetVideoEncoderConfiguration() : trt__SetVideoEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:64963 */
#ifndef SOAP_TYPE___trt__SetAudioSourceConfiguration
#define SOAP_TYPE___trt__SetAudioSourceConfiguration (3164)
/* Wrapper: */
struct SOAP_CMAC __trt__SetAudioSourceConfiguration {
      public:
        /** Optional element 'trt:SetAudioSourceConfiguration' of XSD type 'trt:SetAudioSourceConfiguration' */
        _trt__SetAudioSourceConfiguration *trt__SetAudioSourceConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetAudioSourceConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetAudioSourceConfiguration; }
        /** Constructor with member initializations */
        __trt__SetAudioSourceConfiguration() : trt__SetAudioSourceConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65039 */
#ifndef SOAP_TYPE___trt__SetAudioEncoderConfiguration
#define SOAP_TYPE___trt__SetAudioEncoderConfiguration (3168)
/* Wrapper: */
struct SOAP_CMAC __trt__SetAudioEncoderConfiguration {
      public:
        /** Optional element 'trt:SetAudioEncoderConfiguration' of XSD type 'trt:SetAudioEncoderConfiguration' */
        _trt__SetAudioEncoderConfiguration *trt__SetAudioEncoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetAudioEncoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetAudioEncoderConfiguration; }
        /** Constructor with member initializations */
        __trt__SetAudioEncoderConfiguration() : trt__SetAudioEncoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65117 */
#ifndef SOAP_TYPE___trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___trt__SetVideoAnalyticsConfiguration (3172)
/* Wrapper: */
struct SOAP_CMAC __trt__SetVideoAnalyticsConfiguration {
      public:
        /** Optional element 'trt:SetVideoAnalyticsConfiguration' of XSD type 'trt:SetVideoAnalyticsConfiguration' */
        _trt__SetVideoAnalyticsConfiguration *trt__SetVideoAnalyticsConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetVideoAnalyticsConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetVideoAnalyticsConfiguration; }
        /** Constructor with member initializations */
        __trt__SetVideoAnalyticsConfiguration() : trt__SetVideoAnalyticsConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65194 */
#ifndef SOAP_TYPE___trt__SetMetadataConfiguration
#define SOAP_TYPE___trt__SetMetadataConfiguration (3176)
/* Wrapper: */
struct SOAP_CMAC __trt__SetMetadataConfiguration {
      public:
        /** Optional element 'trt:SetMetadataConfiguration' of XSD type 'trt:SetMetadataConfiguration' */
        _trt__SetMetadataConfiguration *trt__SetMetadataConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetMetadataConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetMetadataConfiguration; }
        /** Constructor with member initializations */
        __trt__SetMetadataConfiguration() : trt__SetMetadataConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetMetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65264 */
#ifndef SOAP_TYPE___trt__SetAudioOutputConfiguration
#define SOAP_TYPE___trt__SetAudioOutputConfiguration (3180)
/* Wrapper: */
struct SOAP_CMAC __trt__SetAudioOutputConfiguration {
      public:
        /** Optional element 'trt:SetAudioOutputConfiguration' of XSD type 'trt:SetAudioOutputConfiguration' */
        _trt__SetAudioOutputConfiguration *trt__SetAudioOutputConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetAudioOutputConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetAudioOutputConfiguration; }
        /** Constructor with member initializations */
        __trt__SetAudioOutputConfiguration() : trt__SetAudioOutputConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65334 */
#ifndef SOAP_TYPE___trt__SetAudioDecoderConfiguration
#define SOAP_TYPE___trt__SetAudioDecoderConfiguration (3184)
/* Wrapper: */
struct SOAP_CMAC __trt__SetAudioDecoderConfiguration {
      public:
        /** Optional element 'trt:SetAudioDecoderConfiguration' of XSD type 'trt:SetAudioDecoderConfiguration' */
        _trt__SetAudioDecoderConfiguration *trt__SetAudioDecoderConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetAudioDecoderConfiguration */
        long soap_type() const { return SOAP_TYPE___trt__SetAudioDecoderConfiguration; }
        /** Constructor with member initializations */
        __trt__SetAudioDecoderConfiguration() : trt__SetAudioDecoderConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65408 */
#ifndef SOAP_TYPE___trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___trt__GetVideoSourceConfigurationOptions (3188)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoSourceConfigurationOptions {
      public:
        /** Optional element 'trt:GetVideoSourceConfigurationOptions' of XSD type 'trt:GetVideoSourceConfigurationOptions' */
        _trt__GetVideoSourceConfigurationOptions *trt__GetVideoSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoSourceConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetVideoSourceConfigurationOptions() : trt__GetVideoSourceConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65490 */
#ifndef SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions (3192)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoEncoderConfigurationOptions {
      public:
        /** Optional element 'trt:GetVideoEncoderConfigurationOptions' of XSD type 'trt:GetVideoEncoderConfigurationOptions' */
        _trt__GetVideoEncoderConfigurationOptions *trt__GetVideoEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetVideoEncoderConfigurationOptions() : trt__GetVideoEncoderConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65564 */
#ifndef SOAP_TYPE___trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___trt__GetAudioSourceConfigurationOptions (3196)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioSourceConfigurationOptions {
      public:
        /** Optional element 'trt:GetAudioSourceConfigurationOptions' of XSD type 'trt:GetAudioSourceConfigurationOptions' */
        _trt__GetAudioSourceConfigurationOptions *trt__GetAudioSourceConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioSourceConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioSourceConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetAudioSourceConfigurationOptions() : trt__GetAudioSourceConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65634 */
#ifndef SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions (3200)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioEncoderConfigurationOptions {
      public:
        /** Optional element 'trt:GetAudioEncoderConfigurationOptions' of XSD type 'trt:GetAudioEncoderConfigurationOptions' */
        _trt__GetAudioEncoderConfigurationOptions *trt__GetAudioEncoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetAudioEncoderConfigurationOptions() : trt__GetAudioEncoderConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65703 */
#ifndef SOAP_TYPE___trt__GetMetadataConfigurationOptions
#define SOAP_TYPE___trt__GetMetadataConfigurationOptions (3204)
/* Wrapper: */
struct SOAP_CMAC __trt__GetMetadataConfigurationOptions {
      public:
        /** Optional element 'trt:GetMetadataConfigurationOptions' of XSD type 'trt:GetMetadataConfigurationOptions' */
        _trt__GetMetadataConfigurationOptions *trt__GetMetadataConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetMetadataConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetMetadataConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetMetadataConfigurationOptions() : trt__GetMetadataConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetMetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65772 */
#ifndef SOAP_TYPE___trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___trt__GetAudioOutputConfigurationOptions (3208)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioOutputConfigurationOptions {
      public:
        /** Optional element 'trt:GetAudioOutputConfigurationOptions' of XSD type 'trt:GetAudioOutputConfigurationOptions' */
        _trt__GetAudioOutputConfigurationOptions *trt__GetAudioOutputConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioOutputConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioOutputConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetAudioOutputConfigurationOptions() : trt__GetAudioOutputConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65842 */
#ifndef SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions (3212)
/* Wrapper: */
struct SOAP_CMAC __trt__GetAudioDecoderConfigurationOptions {
      public:
        /** Optional element 'trt:GetAudioDecoderConfigurationOptions' of XSD type 'trt:GetAudioDecoderConfigurationOptions' */
        _trt__GetAudioDecoderConfigurationOptions *trt__GetAudioDecoderConfigurationOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetAudioDecoderConfigurationOptions; }
        /** Constructor with member initializations */
        __trt__GetAudioDecoderConfigurationOptions() : trt__GetAudioDecoderConfigurationOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetAudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:65912 */
#ifndef SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances (3216)
/* Wrapper: */
struct SOAP_CMAC __trt__GetGuaranteedNumberOfVideoEncoderInstances {
      public:
        /** Optional element 'trt:GetGuaranteedNumberOfVideoEncoderInstances' of XSD type 'trt:GetGuaranteedNumberOfVideoEncoderInstances' */
        _trt__GetGuaranteedNumberOfVideoEncoderInstances *trt__GetGuaranteedNumberOfVideoEncoderInstances;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances */
        long soap_type() const { return SOAP_TYPE___trt__GetGuaranteedNumberOfVideoEncoderInstances; }
        /** Constructor with member initializations */
        __trt__GetGuaranteedNumberOfVideoEncoderInstances() : trt__GetGuaranteedNumberOfVideoEncoderInstances() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetGuaranteedNumberOfVideoEncoderInstances * SOAP_FMAC2 soap_instantiate___trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66003 */
#ifndef SOAP_TYPE___trt__GetStreamUri
#define SOAP_TYPE___trt__GetStreamUri (3220)
/* Wrapper: */
struct SOAP_CMAC __trt__GetStreamUri {
      public:
        /** Optional element 'trt:GetStreamUri' of XSD type 'trt:GetStreamUri' */
        _trt__GetStreamUri *trt__GetStreamUri;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetStreamUri */
        long soap_type() const { return SOAP_TYPE___trt__GetStreamUri; }
        /** Constructor with member initializations */
        __trt__GetStreamUri() : trt__GetStreamUri() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetStreamUri * SOAP_FMAC2 soap_instantiate___trt__GetStreamUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66078 */
#ifndef SOAP_TYPE___trt__StartMulticastStreaming
#define SOAP_TYPE___trt__StartMulticastStreaming (3224)
/* Wrapper: */
struct SOAP_CMAC __trt__StartMulticastStreaming {
      public:
        /** Optional element 'trt:StartMulticastStreaming' of XSD type 'trt:StartMulticastStreaming' */
        _trt__StartMulticastStreaming *trt__StartMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___trt__StartMulticastStreaming */
        long soap_type() const { return SOAP_TYPE___trt__StartMulticastStreaming; }
        /** Constructor with member initializations */
        __trt__StartMulticastStreaming() : trt__StartMulticastStreaming() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__StartMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StartMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66146 */
#ifndef SOAP_TYPE___trt__StopMulticastStreaming
#define SOAP_TYPE___trt__StopMulticastStreaming (3228)
/* Wrapper: */
struct SOAP_CMAC __trt__StopMulticastStreaming {
      public:
        /** Optional element 'trt:StopMulticastStreaming' of XSD type 'trt:StopMulticastStreaming' */
        _trt__StopMulticastStreaming *trt__StopMulticastStreaming;
      public:
        /** Return unique type id SOAP_TYPE___trt__StopMulticastStreaming */
        long soap_type() const { return SOAP_TYPE___trt__StopMulticastStreaming; }
        /** Constructor with member initializations */
        __trt__StopMulticastStreaming() : trt__StopMulticastStreaming() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__StopMulticastStreaming * SOAP_FMAC2 soap_instantiate___trt__StopMulticastStreaming(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66231 */
#ifndef SOAP_TYPE___trt__SetSynchronizationPoint
#define SOAP_TYPE___trt__SetSynchronizationPoint (3232)
/* Wrapper: */
struct SOAP_CMAC __trt__SetSynchronizationPoint {
      public:
        /** Optional element 'trt:SetSynchronizationPoint' of XSD type 'trt:SetSynchronizationPoint' */
        _trt__SetSynchronizationPoint *trt__SetSynchronizationPoint;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetSynchronizationPoint */
        long soap_type() const { return SOAP_TYPE___trt__SetSynchronizationPoint; }
        /** Constructor with member initializations */
        __trt__SetSynchronizationPoint() : trt__SetSynchronizationPoint() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetSynchronizationPoint * SOAP_FMAC2 soap_instantiate___trt__SetSynchronizationPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66309 */
#ifndef SOAP_TYPE___trt__GetSnapshotUri
#define SOAP_TYPE___trt__GetSnapshotUri (3236)
/* Wrapper: */
struct SOAP_CMAC __trt__GetSnapshotUri {
      public:
        /** Optional element 'trt:GetSnapshotUri' of XSD type 'trt:GetSnapshotUri' */
        _trt__GetSnapshotUri *trt__GetSnapshotUri;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetSnapshotUri */
        long soap_type() const { return SOAP_TYPE___trt__GetSnapshotUri; }
        /** Constructor with member initializations */
        __trt__GetSnapshotUri() : trt__GetSnapshotUri() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetSnapshotUri * SOAP_FMAC2 soap_instantiate___trt__GetSnapshotUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66379 */
#ifndef SOAP_TYPE___trt__GetVideoSourceModes
#define SOAP_TYPE___trt__GetVideoSourceModes (3240)
/* Wrapper: */
struct SOAP_CMAC __trt__GetVideoSourceModes {
      public:
        /** Optional element 'trt:GetVideoSourceModes' of XSD type 'trt:GetVideoSourceModes' */
        _trt__GetVideoSourceModes *trt__GetVideoSourceModes;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetVideoSourceModes */
        long soap_type() const { return SOAP_TYPE___trt__GetVideoSourceModes; }
        /** Constructor with member initializations */
        __trt__GetVideoSourceModes() : trt__GetVideoSourceModes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetVideoSourceModes * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceModes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66450 */
#ifndef SOAP_TYPE___trt__SetVideoSourceMode
#define SOAP_TYPE___trt__SetVideoSourceMode (3244)
/* Wrapper: */
struct SOAP_CMAC __trt__SetVideoSourceMode {
      public:
        /** Optional element 'trt:SetVideoSourceMode' of XSD type 'trt:SetVideoSourceMode' */
        _trt__SetVideoSourceMode *trt__SetVideoSourceMode;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetVideoSourceMode */
        long soap_type() const { return SOAP_TYPE___trt__SetVideoSourceMode; }
        /** Constructor with member initializations */
        __trt__SetVideoSourceMode() : trt__SetVideoSourceMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetVideoSourceMode * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66518 */
#ifndef SOAP_TYPE___trt__GetOSDs
#define SOAP_TYPE___trt__GetOSDs (3248)
/* Wrapper: */
struct SOAP_CMAC __trt__GetOSDs {
      public:
        /** Optional element 'trt:GetOSDs' of XSD type 'trt:GetOSDs' */
        _trt__GetOSDs *trt__GetOSDs;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetOSDs */
        long soap_type() const { return SOAP_TYPE___trt__GetOSDs; }
        /** Constructor with member initializations */
        __trt__GetOSDs() : trt__GetOSDs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetOSDs * SOAP_FMAC2 soap_instantiate___trt__GetOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66586 */
#ifndef SOAP_TYPE___trt__GetOSD
#define SOAP_TYPE___trt__GetOSD (3252)
/* Wrapper: */
struct SOAP_CMAC __trt__GetOSD {
      public:
        /** Optional element 'trt:GetOSD' of XSD type 'trt:GetOSD' */
        _trt__GetOSD *trt__GetOSD;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetOSD */
        long soap_type() const { return SOAP_TYPE___trt__GetOSD; }
        /** Constructor with member initializations */
        __trt__GetOSD() : trt__GetOSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetOSD * SOAP_FMAC2 soap_instantiate___trt__GetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66654 */
#ifndef SOAP_TYPE___trt__GetOSDOptions
#define SOAP_TYPE___trt__GetOSDOptions (3256)
/* Wrapper: */
struct SOAP_CMAC __trt__GetOSDOptions {
      public:
        /** Optional element 'trt:GetOSDOptions' of XSD type 'trt:GetOSDOptions' */
        _trt__GetOSDOptions *trt__GetOSDOptions;
      public:
        /** Return unique type id SOAP_TYPE___trt__GetOSDOptions */
        long soap_type() const { return SOAP_TYPE___trt__GetOSDOptions; }
        /** Constructor with member initializations */
        __trt__GetOSDOptions() : trt__GetOSDOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__GetOSDOptions * SOAP_FMAC2 soap_instantiate___trt__GetOSDOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66722 */
#ifndef SOAP_TYPE___trt__SetOSD
#define SOAP_TYPE___trt__SetOSD (3260)
/* Wrapper: */
struct SOAP_CMAC __trt__SetOSD {
      public:
        /** Optional element 'trt:SetOSD' of XSD type 'trt:SetOSD' */
        _trt__SetOSD *trt__SetOSD;
      public:
        /** Return unique type id SOAP_TYPE___trt__SetOSD */
        long soap_type() const { return SOAP_TYPE___trt__SetOSD; }
        /** Constructor with member initializations */
        __trt__SetOSD() : trt__SetOSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__SetOSD * SOAP_FMAC2 soap_instantiate___trt__SetOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66790 */
#ifndef SOAP_TYPE___trt__CreateOSD
#define SOAP_TYPE___trt__CreateOSD (3264)
/* Wrapper: */
struct SOAP_CMAC __trt__CreateOSD {
      public:
        /** Optional element 'trt:CreateOSD' of XSD type 'trt:CreateOSD' */
        _trt__CreateOSD *trt__CreateOSD;
      public:
        /** Return unique type id SOAP_TYPE___trt__CreateOSD */
        long soap_type() const { return SOAP_TYPE___trt__CreateOSD; }
        /** Constructor with member initializations */
        __trt__CreateOSD() : trt__CreateOSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__CreateOSD * SOAP_FMAC2 soap_instantiate___trt__CreateOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:66858 */
#ifndef SOAP_TYPE___trt__DeleteOSD
#define SOAP_TYPE___trt__DeleteOSD (3268)
/* Wrapper: */
struct SOAP_CMAC __trt__DeleteOSD {
      public:
        /** Optional element 'trt:DeleteOSD' of XSD type 'trt:DeleteOSD' */
        _trt__DeleteOSD *trt__DeleteOSD;
      public:
        /** Return unique type id SOAP_TYPE___trt__DeleteOSD */
        long soap_type() const { return SOAP_TYPE___trt__DeleteOSD; }
        /** Constructor with member initializations */
        __trt__DeleteOSD() : trt__DeleteOSD() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __trt__DeleteOSD * SOAP_FMAC2 soap_instantiate___trt__DeleteOSD(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (3270)
/* complex XSD type 'wsu:Timestamp': */
struct SOAP_CMAC _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XSD type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        long soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp() : wsu__Id(), Created(), Expires() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:57 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (3271)
/* simple XSD type 'wsse:EncodedString': */
struct SOAP_CMAC wsse__EncodedString {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        long soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString() : __item(), EncodingType(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:128 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (3273)
/* complex XSD type 'wsse:UsernameToken': */
struct SOAP_CMAC _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XSD type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XSD type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XSD type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        long soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken() : Username(), Password(), Nonce(), wsu__Created(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:139 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (3277)
/* simple XSD type 'wsse:BinarySecurityToken': */
struct SOAP_CMAC _wsse__BinarySecurityToken {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        long soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:149 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (3278)
/* complex XSD type 'wsse:Reference': */
struct SOAP_CMAC _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        long soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference() : URI(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:157 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (3279)
/* complex XSD type 'wsse:Embedded': */
struct SOAP_CMAC _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        long soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded() : wsu__Id(), ValueType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:166 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (3280)
/* simple XSD type 'wsse:KeyIdentifier': */
struct SOAP_CMAC _wsse__KeyIdentifier {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        long soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier() : __item(), wsu__Id(), ValueType(), EncodingType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (3281)
/* complex XSD type 'wsse:SecurityTokenReference': */
struct SOAP_CMAC _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XSD type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XSD type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XSD type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XSD type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XSD type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        long soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference() : Reference(), KeyIdentifier(), Embedded(), ds__X509Data(), wsu__Id(), wsc__Instance(), Usage() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (3288)
/* complex XSD type 'ds:SignatureType': */
struct SOAP_CMAC ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XSD type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XSD type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType() : SignedInfo(), SignatureValue(), KeyInfo(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (3298)
/* complex XSD type 'c14n:InclusiveNamespaces': */
struct SOAP_CMAC _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XSD type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        long soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces() : PrefixList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:73 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (3299)
/* complex XSD type 'ds:TransformType': */
struct SOAP_CMAC ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        long soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType() : c14n__InclusiveNamespaces(), __any(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (3291)
/* complex XSD type 'ds:KeyInfoType': */
struct SOAP_CMAC ds__KeyInfoType {
      public:
        /** Optional element 'ds:KeyName' of XSD type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XSD type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XSD type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        long soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType() : KeyName(), KeyValue(), RetrievalMethod(), X509Data(), wsse__SecurityTokenReference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (3289)
/* complex XSD type 'ds:SignedInfoType': */
struct SOAP_CMAC ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XSD type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XSD type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XSD type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        long soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType() : CanonicalizationMethod(), SignatureMethod(), __sizeReference(), Reference(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:59 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (3294)
/* complex XSD type 'ds:CanonicalizationMethodType': */
struct SOAP_CMAC ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        long soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType() : Algorithm(), c14n__InclusiveNamespaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:62 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (3295)
/* complex XSD type 'ds:SignatureMethodType': */
struct SOAP_CMAC ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XSD type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        long soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType() : HMACOutputLength(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:65 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (3296)
/* complex XSD type 'ds:ReferenceType': */
struct SOAP_CMAC ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XSD type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        long soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType() : Transforms(), DigestMethod(), DigestValue(), Id(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:68 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (3297)
/* complex XSD type 'ds:TransformsType': */
struct SOAP_CMAC ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XSD type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        long soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType() : __sizeTransform(), Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:79 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (3302)
/* complex XSD type 'ds:DigestMethodType': */
struct SOAP_CMAC ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        long soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType() : Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:84 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (3303)
/* complex XSD type 'ds:KeyValueType': */
struct SOAP_CMAC ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XSD type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XSD type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType() : DSAKeyValue(), RSAKeyValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:85 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (3305)
/* complex XSD type 'ds:RetrievalMethodType': */
struct SOAP_CMAC ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        long soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType() : Transforms(), URI(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:179 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (3285)
/* complex XSD type 'ds:X509DataType': */
struct SOAP_CMAC ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XSD type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XSD type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XSD type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XSD type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XSD type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        long soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType() : X509IssuerSerial(), X509SKI(), X509SubjectName(), X509Certificate(), X509CRL() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:102 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (3309)
/* complex XSD type 'ds:X509IssuerSerialType': */
struct SOAP_CMAC ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XSD type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XSD type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        long soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType() : X509IssuerName(), X509SerialNumber() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:123 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (3310)
/* complex XSD type 'ds:DSAKeyValueType': */
struct SOAP_CMAC ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XSD type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XSD type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XSD type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XSD type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XSD type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XSD type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XSD type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType() : G(), Y(), J(), P(), Q(), Seed(), PgenCounter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:126 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (3311)
/* complex XSD type 'ds:RSAKeyValueType': */
struct SOAP_CMAC ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XSD type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XSD type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        long soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType() : Modulus(), Exponent() { }
        /** Friend allocator */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (3332)
/* complex XSD type 'xenc:EncryptionPropertyType': */
struct SOAP_CMAC xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XSD type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType() : Target(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (3322)
/* complex XSD type 'xenc:EncryptedType': */
struct SOAP_CMAC xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (3323)
/* complex XSD type 'xenc:EncryptionMethodType': */
struct SOAP_CMAC xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XSD type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XSD type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType() : KeySize(), OAEPparams(), Algorithm(), ds__DigestMethod(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (3324)
/* complex XSD type 'xenc:CipherDataType': */
struct SOAP_CMAC xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XSD type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XSD type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType() : CipherValue(), CipherReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (3325)
/* complex XSD type 'xenc:CipherReferenceType': */
struct SOAP_CMAC xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XSD type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType() : Transforms(), URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (3326)
/* complex XSD type 'xenc:TransformsType': */
struct SOAP_CMAC xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XSD type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        long soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType() : ds__Transform() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (3329)
/* complex XSD type 'xenc:AgreementMethodType': */
struct SOAP_CMAC xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XSD type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        long soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType() : KA_Nonce(), OriginatorKeyInfo(), RecipientKeyInfo(), Algorithm(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (3330)
/* complex XSD type 'xenc:ReferenceType': */
struct SOAP_CMAC xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        long soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType() : URI() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (3331)
/* complex XSD type 'xenc:EncryptionPropertiesType': */
struct SOAP_CMAC xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XSD type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType() : __sizeEncryptionProperty(), EncryptionProperty(), Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (3341)
/* Wrapper: */
struct SOAP_CMAC __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        long soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList() : DataReference(), KeyReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (3333)
/* complex XSD type 'xenc:ReferenceList': */
struct SOAP_CMAC _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XSD type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        long soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList() : __size_ReferenceList(), __union_ReferenceList() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (3327)
/* complex XSD type 'xenc:EncryptedDataType': */
struct SOAP_CMAC xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (3328)
/* complex XSD type 'xenc:EncryptedKeyType': */
struct SOAP_CMAC xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XSD type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        long soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType() : EncryptionMethod(), ds__KeyInfo(), CipherData(), EncryptionProperties(), Id(), Type(), MimeType(), Encoding(), ReferenceList(), CarriedKeyName(), Recipient() { }
        /** Friend allocator */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (3347)
/* complex XSD type 'wsc:SecurityContextTokenType': */
struct SOAP_CMAC wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XSD type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XSD type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType() : wsu__Id(), Identifier(), Instance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (3352)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (3351)
/* Wrapper: */
struct SOAP_CMAC __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XSD type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        long soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence() : __union_DerivedKeyTokenType(), Length() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (3348)
/* complex XSD type 'wsc:DerivedKeyTokenType': */
struct SOAP_CMAC wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XSD type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XSD type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XSD type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        long soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType() : wsse__SecurityTokenReference(), Properties(), __DerivedKeyTokenType_sequence(), Label(), Nonce(), wsu__Id(), Algorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (3349)
/* complex XSD type 'wsc:PropertiesType': */
struct SOAP_CMAC wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        long soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:147 */
#ifndef SOAP_TYPE___saml1__union_AssertionType
#define SOAP_TYPE___saml1__union_AssertionType (3378)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AssertionType {
      public:
        /** Optional element 'saml1:Statement' of XSD type 'saml1:StatementAbstractType' */
        struct saml1__StatementAbstractType *saml1__Statement;
        /** Optional element 'saml1:SubjectStatement' of XSD type 'saml1:SubjectStatementAbstractType' */
        struct saml1__SubjectStatementAbstractType *saml1__SubjectStatement;
        /** Optional element 'saml1:AuthenticationStatement' of XSD type 'saml1:AuthenticationStatementType' */
        struct saml1__AuthenticationStatementType *saml1__AuthenticationStatement;
        /** Optional element 'saml1:AuthorizationDecisionStatement' of XSD type 'saml1:AuthorizationDecisionStatementType' */
        struct saml1__AuthorizationDecisionStatementType *saml1__AuthorizationDecisionStatement;
        /** Optional element 'saml1:AttributeStatement' of XSD type 'saml1:AttributeStatementType' */
        struct saml1__AttributeStatementType *saml1__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AssertionType; }
        /** Constructor with member initializations */
        __saml1__union_AssertionType() : saml1__Statement(), saml1__SubjectStatement(), saml1__AuthenticationStatement(), saml1__AuthorizationDecisionStatement(), saml1__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml1__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:62 */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (3355)
/* Type saml1__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml1:AssertionType': */
struct SOAP_CMAC saml1__AssertionType {
      public:
        /** Optional element 'saml1:Conditions' of XSD type 'saml1:ConditionsType' */
        struct saml1__ConditionsType *saml1__Conditions;
        /** Optional element 'saml1:Advice' of XSD type 'saml1:AdviceType' */
        struct saml1__AdviceType *saml1__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml1:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml1__union_AssertionType *__union_AssertionType;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Required attribute 'MajorVersion' of XSD type 'xsd:string' */
        char *MajorVersion;
        /** Required attribute 'MinorVersion' of XSD type 'xsd:string' */
        char *MinorVersion;
        /** Required attribute 'AssertionID' of XSD type 'xsd:string' */
        char *AssertionID;
        /** Required attribute 'Issuer' of XSD type 'xsd:string' */
        char *Issuer;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml1__AssertionType; }
        /** Constructor with member initializations */
        saml1__AssertionType() : saml1__Conditions(), saml1__Advice(), __size_AssertionType(), __union_AssertionType(), ds__Signature(), MajorVersion(), MinorVersion(), AssertionID(), Issuer(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AssertionType * SOAP_FMAC2 soap_instantiate_saml1__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:190 */
#ifndef SOAP_TYPE___saml1__union_ConditionsType
#define SOAP_TYPE___saml1__union_ConditionsType (3386)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_ConditionsType {
      public:
        /** Optional element 'saml1:AudienceRestrictionCondition' of XSD type 'saml1:AudienceRestrictionConditionType' */
        struct saml1__AudienceRestrictionConditionType *saml1__AudienceRestrictionCondition;
        /** Optional element 'saml1:DoNotCacheCondition' of XSD type 'saml1:DoNotCacheConditionType' */
        struct saml1__DoNotCacheConditionType *saml1__DoNotCacheCondition;
        /** Optional element 'saml1:Condition' of XSD type 'saml1:ConditionAbstractType' */
        struct saml1__ConditionAbstractType *saml1__Condition;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml1__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml1__union_ConditionsType() : saml1__AudienceRestrictionCondition(), saml1__DoNotCacheCondition(), saml1__Condition() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml1__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:64 */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (3356)
/* complex XSD type 'saml1:ConditionsType': */
struct SOAP_CMAC saml1__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml1:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml1__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionsType; }
        /** Constructor with member initializations */
        saml1__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionsType * SOAP_FMAC2 soap_instantiate_saml1__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:66 */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (3357)
/* complex XSD type 'saml1:ConditionAbstractType': */
struct SOAP_CMAC saml1__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml1__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml1__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:232 */
#ifndef SOAP_TYPE___saml1__union_AdviceType
#define SOAP_TYPE___saml1__union_AdviceType (3391)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_AdviceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_AdviceType; }
        /** Constructor with member initializations */
        __saml1__union_AdviceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml1__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:72 */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (3360)
/* complex XSD type 'saml1:AdviceType': */
struct SOAP_CMAC saml1__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml1:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml1__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml1__AdviceType; }
        /** Constructor with member initializations */
        saml1__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AdviceType * SOAP_FMAC2 soap_instantiate_saml1__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:74 */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (3361)
/* complex XSD type 'saml1:StatementAbstractType': */
struct SOAP_CMAC saml1__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__StatementAbstractType; }
        /** Constructor with member initializations */
        saml1__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:78 */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (3363)
/* complex XSD type 'saml1:SubjectType': */
struct SOAP_CMAC saml1__SubjectType {
      public:
        /** Optional element 'saml1:NameIdentifier' of XSD type 'saml1:NameIdentifierType' */
        struct saml1__NameIdentifierType *saml1__NameIdentifier;
        /** Optional element 'saml1:SubjectConfirmation' of XSD type 'saml1:SubjectConfirmationType' */
        struct saml1__SubjectConfirmationType *saml1__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectType; }
        /** Constructor with member initializations */
        saml1__SubjectType() : saml1__NameIdentifier(), saml1__SubjectConfirmation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectType * SOAP_FMAC2 soap_instantiate_saml1__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:82 */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (3365)
/* complex XSD type 'saml1:SubjectConfirmationType': */
struct SOAP_CMAC saml1__SubjectConfirmationType {
      public:
        /** Sequence of at least 1 elements 'saml1:ConfirmationMethod' of XSD type 'xsd:string' stored in dynamic array saml1__ConfirmationMethod of length __sizeConfirmationMethod */
        int __sizeConfirmationMethod;
        char **saml1__ConfirmationMethod;
        /** Optional element 'saml1:SubjectConfirmationData' of XSD type 'xsd:anyType' */
        char *saml1__SubjectConfirmationData;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml1__SubjectConfirmationType() : __sizeConfirmationMethod(), saml1__ConfirmationMethod(), saml1__SubjectConfirmationData(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml1__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:86 */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (3367)
/* complex XSD type 'saml1:SubjectLocalityType': */
struct SOAP_CMAC saml1__SubjectLocalityType {
      public:
        /** Optional attribute 'IPAddress' of XSD type 'xsd:string' */
        char *IPAddress;
        /** Optional attribute 'DNSAddress' of XSD type 'xsd:string' */
        char *DNSAddress;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml1__SubjectLocalityType() : IPAddress(), DNSAddress() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml1__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:88 */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (3368)
/* complex XSD type 'saml1:AuthorityBindingType': */
struct SOAP_CMAC saml1__AuthorityBindingType {
      public:
        /** Required attribute 'AuthorityKind' of XSD type 'xsd:QName' */
        char *AuthorityKind;
        /** Required attribute 'Location' of XSD type 'xsd:string' */
        char *Location;
        /** Required attribute 'Binding' of XSD type 'xsd:string' */
        char *Binding;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorityBindingType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorityBindingType; }
        /** Constructor with member initializations */
        saml1__AuthorityBindingType() : AuthorityKind(), Location(), Binding() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorityBindingType * SOAP_FMAC2 soap_instantiate_saml1__AuthorityBindingType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:354 */
#ifndef SOAP_TYPE___saml1__union_EvidenceType
#define SOAP_TYPE___saml1__union_EvidenceType (3397)
/* Wrapper: */
struct SOAP_CMAC __saml1__union_EvidenceType {
      public:
        /** Optional element 'saml1:AssertionIDReference' of XSD type 'xsd:string' */
        char *saml1__AssertionIDReference;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
      public:
        /** Return unique type id SOAP_TYPE___saml1__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml1__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml1__union_EvidenceType() : saml1__AssertionIDReference(), saml1__Assertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml1__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml1__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:94 */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (3371)
/* complex XSD type 'saml1:EvidenceType': */
struct SOAP_CMAC saml1__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml1:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml1__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml1__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml1__EvidenceType; }
        /** Constructor with member initializations */
        saml1__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__EvidenceType * SOAP_FMAC2 soap_instantiate_saml1__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:98 */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (3373)
/* complex XSD type 'saml1:AttributeDesignatorType': */
struct SOAP_CMAC saml1__AttributeDesignatorType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeDesignatorType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeDesignatorType; }
        /** Constructor with member initializations */
        saml1__AttributeDesignatorType() : AttributeName(), AttributeNamespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeDesignatorType * SOAP_FMAC2 soap_instantiate_saml1__AttributeDesignatorType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:68 */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (3358)
/* complex XSD type 'saml1:AudienceRestrictionConditionType': */
struct SOAP_CMAC saml1__AudienceRestrictionConditionType {
      public:
        /** Sequence of at least 1 elements 'saml1:Audience' of XSD type 'xsd:string' stored in dynamic array saml1__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml1__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AudienceRestrictionConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__AudienceRestrictionConditionType; }
        /** Constructor with member initializations */
        saml1__AudienceRestrictionConditionType() : __sizeAudience(), saml1__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AudienceRestrictionConditionType * SOAP_FMAC2 soap_instantiate_saml1__AudienceRestrictionConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:70 */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (3359)
/* complex XSD type 'saml1:DoNotCacheConditionType': */
struct SOAP_CMAC saml1__DoNotCacheConditionType {
      public:
        /** Return unique type id SOAP_TYPE_saml1__DoNotCacheConditionType */
        long soap_type() const { return SOAP_TYPE_saml1__DoNotCacheConditionType; }
        /** Constructor with member initializations */
        saml1__DoNotCacheConditionType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__DoNotCacheConditionType * SOAP_FMAC2 soap_instantiate_saml1__DoNotCacheConditionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:76 */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (3362)
/* complex XSD type 'saml1:SubjectStatementAbstractType': */
struct SOAP_CMAC saml1__SubjectStatementAbstractType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
      public:
        /** Return unique type id SOAP_TYPE_saml1__SubjectStatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml1__SubjectStatementAbstractType; }
        /** Constructor with member initializations */
        saml1__SubjectStatementAbstractType() : saml1__Subject() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__SubjectStatementAbstractType * SOAP_FMAC2 soap_instantiate_saml1__SubjectStatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:80 */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (3364)
/* simple XSD type 'saml1:NameIdentifierType': */
struct SOAP_CMAC saml1__NameIdentifierType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
      public:
        /** Return unique type id SOAP_TYPE_saml1__NameIdentifierType */
        long soap_type() const { return SOAP_TYPE_saml1__NameIdentifierType; }
        /** Constructor with member initializations */
        saml1__NameIdentifierType() : __item(), NameQualifier(), Format() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__NameIdentifierType * SOAP_FMAC2 soap_instantiate_saml1__NameIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:92 */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (3370)
/* simple XSD type 'saml1:ActionType': */
struct SOAP_CMAC saml1__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml1__ActionType */
        long soap_type() const { return SOAP_TYPE_saml1__ActionType; }
        /** Constructor with member initializations */
        saml1__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__ActionType * SOAP_FMAC2 soap_instantiate_saml1__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:100 */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (3374)
/* complex XSD type 'saml1:AttributeType': */
struct SOAP_CMAC saml1__AttributeType {
      public:
        /** Required attribute 'AttributeName' of XSD type 'xsd:string' */
        char *AttributeName;
        /** Required attribute 'AttributeNamespace' of XSD type 'xsd:string' */
        char *AttributeNamespace;
        /** Sequence of at least 1 elements 'saml1:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml1__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml1__AttributeValue;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeType; }
        /** Constructor with member initializations */
        saml1__AttributeType() : AttributeName(), AttributeNamespace(), __sizeAttributeValue(), saml1__AttributeValue() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeType * SOAP_FMAC2 soap_instantiate_saml1__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:84 */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (3366)
/* complex XSD type 'saml1:AuthenticationStatementType': */
struct SOAP_CMAC saml1__AuthenticationStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Optional element 'saml1:SubjectLocality' of XSD type 'saml1:SubjectLocalityType' */
        struct saml1__SubjectLocalityType *saml1__SubjectLocality;
        /** Sequence of elements 'saml1:AuthorityBinding' of XSD type 'saml1:AuthorityBindingType' stored in dynamic array saml1__AuthorityBinding of length __sizeAuthorityBinding */
        int __sizeAuthorityBinding;
        struct saml1__AuthorityBindingType *saml1__AuthorityBinding;
        /** Required attribute 'AuthenticationMethod' of XSD type 'xsd:string' */
        char *AuthenticationMethod;
        /** Required attribute 'AuthenticationInstant' of XSD type 'xsd:dateTime' */
        time_t AuthenticationInstant;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthenticationStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthenticationStatementType; }
        /** Constructor with member initializations */
        saml1__AuthenticationStatementType() : saml1__Subject(), saml1__SubjectLocality(), __sizeAuthorityBinding(), saml1__AuthorityBinding(), AuthenticationMethod(), AuthenticationInstant() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthenticationStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthenticationStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:90 */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (3369)
/* complex XSD type 'saml1:AuthorizationDecisionStatementType': */
struct SOAP_CMAC saml1__AuthorizationDecisionStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Action' of XSD type 'saml1:ActionType' stored in dynamic array saml1__Action of length __sizeAction */
        int __sizeAction;
        struct saml1__ActionType *saml1__Action;
        /** Optional element 'saml1:Evidence' of XSD type 'saml1:EvidenceType' */
        struct saml1__EvidenceType *saml1__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml1:DecisionType' */
        enum saml1__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AuthorizationDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AuthorizationDecisionStatementType; }
        /** Constructor with member initializations */
        saml1__AuthorizationDecisionStatementType() : saml1__Subject(), __sizeAction(), saml1__Action(), saml1__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AuthorizationDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml1__AuthorizationDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml1.h:96 */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (3372)
/* complex XSD type 'saml1:AttributeStatementType': */
struct SOAP_CMAC saml1__AttributeStatementType {
      public:
        /** Required element 'saml1:Subject' of XSD type 'saml1:SubjectType' */
        struct saml1__SubjectType *saml1__Subject;
        /** Sequence of at least 1 elements 'saml1:Attribute' of XSD type 'saml1:AttributeType' stored in dynamic array saml1__Attribute of length __sizeAttribute */
        int __sizeAttribute;
        struct saml1__AttributeType *saml1__Attribute;
      public:
        /** Return unique type id SOAP_TYPE_saml1__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml1__AttributeStatementType; }
        /** Constructor with member initializations */
        saml1__AttributeStatementType() : saml1__Subject(), __sizeAttribute(), saml1__Attribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml1__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml1__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:62 */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (3430)
/* complex XSD type 'saml2:BaseIDAbstractType': */
struct SOAP_CMAC saml2__BaseIDAbstractType {
      public:
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__BaseIDAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__BaseIDAbstractType; }
        /** Constructor with member initializations */
        saml2__BaseIDAbstractType() : NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__BaseIDAbstractType * SOAP_FMAC2 soap_instantiate_saml2__BaseIDAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:66 */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (3432)
/* complex XSD type 'saml2:EncryptedElementType': */
struct SOAP_CMAC saml2__EncryptedElementType {
      public:
        /** Required element 'xenc:EncryptedData' of XSD type 'xenc:EncryptedDataType' */
        struct xenc__EncryptedDataType xenc__EncryptedData;
        /** Sequence of elements 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' stored in dynamic array xenc__EncryptedKey of length __sizexenc__EncryptedKey */
        int __sizexenc__EncryptedKey;
        struct xenc__EncryptedKeyType **xenc__EncryptedKey;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EncryptedElementType */
        long soap_type() const { return SOAP_TYPE_saml2__EncryptedElementType; }
        /** Constructor with member initializations */
        saml2__EncryptedElementType() : xenc__EncryptedData(), __sizexenc__EncryptedKey(), xenc__EncryptedKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EncryptedElementType * SOAP_FMAC2 soap_instantiate_saml2__EncryptedElementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:197 */
#ifndef SOAP_TYPE___saml2__union_AssertionType
#define SOAP_TYPE___saml2__union_AssertionType (3460)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AssertionType {
      public:
        /** Optional element 'saml2:Statement' of XSD type 'saml2:StatementAbstractType' */
        struct saml2__StatementAbstractType *saml2__Statement;
        /** Optional element 'saml2:AuthnStatement' of XSD type 'saml2:AuthnStatementType' */
        struct saml2__AuthnStatementType *saml2__AuthnStatement;
        /** Optional element 'saml2:AuthzDecisionStatement' of XSD type 'saml2:AuthzDecisionStatementType' */
        struct saml2__AuthzDecisionStatementType *saml2__AuthzDecisionStatement;
        /** Optional element 'saml2:AttributeStatement' of XSD type 'saml2:AttributeStatementType' */
        struct saml2__AttributeStatementType *saml2__AttributeStatement;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AssertionType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AssertionType; }
        /** Constructor with member initializations */
        __saml2__union_AssertionType() : saml2__Statement(), saml2__AuthnStatement(), saml2__AuthzDecisionStatement(), saml2__AttributeStatement() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AssertionType * SOAP_FMAC2 soap_instantiate___saml2__union_AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:68 */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (3433)
/* Type saml2__AssertionType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'saml2:AssertionType': */
struct SOAP_CMAC saml2__AssertionType {
      public:
        /** Required element 'saml2:Issuer' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__Issuer;
        /** Optional element 'ds:Signature' of XSD type 'ds:Signature' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml2:Subject' of XSD type 'saml2:SubjectType' */
        struct saml2__SubjectType *saml2__Subject;
        /** Optional element 'saml2:Conditions' of XSD type 'saml2:ConditionsType' */
        struct saml2__ConditionsType *saml2__Conditions;
        /** Optional element 'saml2:Advice' of XSD type 'saml2:AdviceType' */
        struct saml2__AdviceType *saml2__Advice;
        /** Sequence of elements '-union-AssertionType' of XSD type '-saml2:union-AssertionType' stored in dynamic array __union_AssertionType of length __size_AssertionType */
        int __size_AssertionType;
        struct __saml2__union_AssertionType *__union_AssertionType;
        /** Required attribute 'Version' of XSD type 'xsd:string' */
        char *Version;
        /** Required attribute 'ID' of XSD type 'xsd:string' */
        char *ID;
        /** Required attribute 'IssueInstant' of XSD type 'xsd:dateTime' */
        time_t IssueInstant;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AssertionType */
        long soap_type() const { return SOAP_TYPE_saml2__AssertionType; }
        /** Constructor with member initializations */
        saml2__AssertionType() : saml2__Issuer(), ds__Signature(), saml2__Subject(), saml2__Conditions(), saml2__Advice(), __size_AssertionType(), __union_AssertionType(), Version(), ID(), IssueInstant(), wsu__Id() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AssertionType * SOAP_FMAC2 soap_instantiate_saml2__AssertionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:70 */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (3434)
/* complex XSD type 'saml2:SubjectType': */
struct SOAP_CMAC saml2__SubjectType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Sequence of elements 'saml2:SubjectConfirmation' of XSD type 'saml2:SubjectConfirmationType' stored in dynamic array saml2__SubjectConfirmation of length __sizeSubjectConfirmation */
        int __sizeSubjectConfirmation;
        struct saml2__SubjectConfirmationType *saml2__SubjectConfirmation;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectType; }
        /** Constructor with member initializations */
        saml2__SubjectType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), __sizeSubjectConfirmation(), saml2__SubjectConfirmation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectType * SOAP_FMAC2 soap_instantiate_saml2__SubjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:72 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (3435)
/* complex XSD type 'saml2:SubjectConfirmationType': */
struct SOAP_CMAC saml2__SubjectConfirmationType {
      public:
        /** Optional element 'saml2:BaseID' of XSD type 'saml2:BaseIDAbstractType' */
        struct saml2__BaseIDAbstractType *saml2__BaseID;
        /** Optional element 'saml2:NameID' of XSD type 'saml2:NameIDType' */
        struct saml2__NameIDType *saml2__NameID;
        /** Optional element 'saml2:EncryptedID' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedID;
        /** Optional element 'saml2:SubjectConfirmationData' of XSD type 'saml2:SubjectConfirmationDataType' */
        struct saml2__SubjectConfirmationDataType *saml2__SubjectConfirmationData;
        /** Required attribute 'Method' of XSD type 'xsd:string' */
        char *Method;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationType() : saml2__BaseID(), saml2__NameID(), saml2__EncryptedID(), saml2__SubjectConfirmationData(), Method() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:290 */
#ifndef SOAP_TYPE___saml2__union_ConditionsType
#define SOAP_TYPE___saml2__union_ConditionsType (3470)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_ConditionsType {
      public:
        /** Optional element 'saml2:Condition' of XSD type 'saml2:ConditionAbstractType' */
        struct saml2__ConditionAbstractType *saml2__Condition;
        /** Optional element 'saml2:AudienceRestriction' of XSD type 'saml2:AudienceRestrictionType' */
        struct saml2__AudienceRestrictionType *saml2__AudienceRestriction;
        /** Optional element 'saml2:OneTimeUse' of XSD type 'saml2:OneTimeUseType' */
        struct saml2__OneTimeUseType *saml2__OneTimeUse;
        /** Optional element 'saml2:ProxyRestriction' of XSD type 'saml2:ProxyRestrictionType' */
        struct saml2__ProxyRestrictionType *saml2__ProxyRestriction;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_ConditionsType */
        long soap_type() const { return SOAP_TYPE___saml2__union_ConditionsType; }
        /** Constructor with member initializations */
        __saml2__union_ConditionsType() : saml2__Condition(), saml2__AudienceRestriction(), saml2__OneTimeUse(), saml2__ProxyRestriction() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_ConditionsType * SOAP_FMAC2 soap_instantiate___saml2__union_ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:78 */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (3438)
/* complex XSD type 'saml2:ConditionsType': */
struct SOAP_CMAC saml2__ConditionsType {
      public:
        /** Sequence of elements '-union-ConditionsType' of XSD type '-saml2:union-ConditionsType' stored in dynamic array __union_ConditionsType of length __size_ConditionsType */
        int __size_ConditionsType;
        struct __saml2__union_ConditionsType *__union_ConditionsType;
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionsType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionsType; }
        /** Constructor with member initializations */
        saml2__ConditionsType() : __size_ConditionsType(), __union_ConditionsType(), NotBefore(), NotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionsType * SOAP_FMAC2 soap_instantiate_saml2__ConditionsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:80 */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (3439)
/* complex XSD type 'saml2:ConditionAbstractType': */
struct SOAP_CMAC saml2__ConditionAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__ConditionAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__ConditionAbstractType; }
        /** Constructor with member initializations */
        saml2__ConditionAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ConditionAbstractType * SOAP_FMAC2 soap_instantiate_saml2__ConditionAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:334 */
#ifndef SOAP_TYPE___saml2__union_AdviceType
#define SOAP_TYPE___saml2__union_AdviceType (3476)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AdviceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AdviceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AdviceType; }
        /** Constructor with member initializations */
        __saml2__union_AdviceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AdviceType * SOAP_FMAC2 soap_instantiate___saml2__union_AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:88 */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (3443)
/* complex XSD type 'saml2:AdviceType': */
struct SOAP_CMAC saml2__AdviceType {
      public:
        /** Sequence of elements '-union-AdviceType' of XSD type '-saml2:union-AdviceType' stored in dynamic array __union_AdviceType of length __size_AdviceType */
        int __size_AdviceType;
        struct __saml2__union_AdviceType *__union_AdviceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AdviceType */
        long soap_type() const { return SOAP_TYPE_saml2__AdviceType; }
        /** Constructor with member initializations */
        saml2__AdviceType() : __size_AdviceType(), __union_AdviceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AdviceType * SOAP_FMAC2 soap_instantiate_saml2__AdviceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:90 */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (3444)
/* complex XSD type 'saml2:StatementAbstractType': */
struct SOAP_CMAC saml2__StatementAbstractType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__StatementAbstractType */
        long soap_type() const { return SOAP_TYPE_saml2__StatementAbstractType; }
        /** Constructor with member initializations */
        saml2__StatementAbstractType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__StatementAbstractType * SOAP_FMAC2 soap_instantiate_saml2__StatementAbstractType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:94 */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (3446)
/* complex XSD type 'saml2:SubjectLocalityType': */
struct SOAP_CMAC saml2__SubjectLocalityType {
      public:
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        /** Optional attribute 'DNSName' of XSD type 'xsd:string' */
        char *DNSName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectLocalityType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectLocalityType; }
        /** Constructor with member initializations */
        saml2__SubjectLocalityType() : Address(), DNSName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectLocalityType * SOAP_FMAC2 soap_instantiate_saml2__SubjectLocalityType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:96 */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (3447)
/* complex XSD type 'saml2:AuthnContextType': */
struct SOAP_CMAC saml2__AuthnContextType {
      public:
        /** Optional element 'saml2:AuthnContextClassRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextClassRef;
        /** Optional element 'saml2:AuthnContextDecl' of XSD type 'xsd:anyType' */
        char *saml2__AuthnContextDecl;
        /** Optional element 'saml2:AuthnContextDeclRef' of XSD type 'xsd:string' */
        char *saml2__AuthnContextDeclRef;
        /** Sequence of elements 'saml2:AuthenticatingAuthority' of XSD type 'xsd:string' stored in dynamic array saml2__AuthenticatingAuthority of length __sizeAuthenticatingAuthority */
        int __sizeAuthenticatingAuthority;
        char **saml2__AuthenticatingAuthority;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnContextType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnContextType; }
        /** Constructor with member initializations */
        saml2__AuthnContextType() : saml2__AuthnContextClassRef(), saml2__AuthnContextDecl(), saml2__AuthnContextDeclRef(), __sizeAuthenticatingAuthority(), saml2__AuthenticatingAuthority() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnContextType * SOAP_FMAC2 soap_instantiate_saml2__AuthnContextType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:432 */
#ifndef SOAP_TYPE___saml2__union_EvidenceType
#define SOAP_TYPE___saml2__union_EvidenceType (3479)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_EvidenceType {
      public:
        /** Optional element 'saml2:AssertionIDRef' of XSD type 'xsd:string' */
        char *saml2__AssertionIDRef;
        /** Optional element 'saml2:AssertionURIRef' of XSD type 'xsd:string' */
        char *saml2__AssertionURIRef;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional element 'saml2:EncryptedAssertion' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAssertion;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_EvidenceType */
        long soap_type() const { return SOAP_TYPE___saml2__union_EvidenceType; }
        /** Constructor with member initializations */
        __saml2__union_EvidenceType() : saml2__AssertionIDRef(), saml2__AssertionURIRef(), saml2__Assertion(), saml2__EncryptedAssertion() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_EvidenceType * SOAP_FMAC2 soap_instantiate___saml2__union_EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:102 */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (3450)
/* complex XSD type 'saml2:EvidenceType': */
struct SOAP_CMAC saml2__EvidenceType {
      public:
        /** Sequence of elements '-union-EvidenceType' of XSD type '-saml2:union-EvidenceType' stored in dynamic array __union_EvidenceType of length __size_EvidenceType */
        int __size_EvidenceType;
        struct __saml2__union_EvidenceType *__union_EvidenceType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__EvidenceType */
        long soap_type() const { return SOAP_TYPE_saml2__EvidenceType; }
        /** Constructor with member initializations */
        saml2__EvidenceType() : __size_EvidenceType(), __union_EvidenceType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__EvidenceType * SOAP_FMAC2 soap_instantiate_saml2__EvidenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:106 */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (3452)
/* complex XSD type 'saml2:AttributeType': */
struct SOAP_CMAC saml2__AttributeType {
      public:
        /** Sequence of elements 'saml2:AttributeValue' of XSD type 'xsd:anyType' stored in dynamic array saml2__AttributeValue of length __sizeAttributeValue */
        int __sizeAttributeValue;
        char **saml2__AttributeValue;
        /** Required attribute 'Name' of XSD type 'xsd:string' */
        char *Name;
        /** Optional attribute 'NameFormat' of XSD type 'xsd:string' */
        char *NameFormat;
        /** Optional attribute 'FriendlyName' of XSD type 'xsd:string' */
        char *FriendlyName;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeType; }
        /** Constructor with member initializations */
        saml2__AttributeType() : __sizeAttributeValue(), saml2__AttributeValue(), Name(), NameFormat(), FriendlyName() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeType * SOAP_FMAC2 soap_instantiate_saml2__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:64 */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (3431)
/* simple XSD type 'saml2:NameIDType': */
struct SOAP_CMAC saml2__NameIDType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Format' of XSD type 'xsd:string' */
        char *Format;
        /** Optional attribute 'SPProvidedID' of XSD type 'xsd:string' */
        char *SPProvidedID;
        /** Optional attribute 'NameQualifier' of XSD type 'xsd:string' */
        char *NameQualifier;
        /** Optional attribute 'SPNameQualifier' of XSD type 'xsd:string' */
        char *SPNameQualifier;
      public:
        /** Return unique type id SOAP_TYPE_saml2__NameIDType */
        long soap_type() const { return SOAP_TYPE_saml2__NameIDType; }
        /** Constructor with member initializations */
        saml2__NameIDType() : __item(), Format(), SPProvidedID(), NameQualifier(), SPNameQualifier() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__NameIDType * SOAP_FMAC2 soap_instantiate_saml2__NameIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:74 */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (3436)
/* complex XSD type 'saml2:SubjectConfirmationDataType': */
struct SOAP_CMAC saml2__SubjectConfirmationDataType {
      public:
        /** Optional attribute 'NotBefore' of XSD type 'xsd:dateTime' */
        time_t *NotBefore;
        /** Optional attribute 'NotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *NotOnOrAfter;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
        /** Optional attribute 'InResponseTo' of XSD type 'xsd:string' */
        char *InResponseTo;
        /** Optional attribute 'Address' of XSD type 'xsd:string' */
        char *Address;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_saml2__SubjectConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__SubjectConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__SubjectConfirmationDataType() : NotBefore(), NotOnOrAfter(), Recipient(), InResponseTo(), Address(), __mixed() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__SubjectConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__SubjectConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:82 */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (3440)
/* complex XSD type 'saml2:AudienceRestrictionType': */
struct SOAP_CMAC saml2__AudienceRestrictionType {
      public:
        /** Sequence of at least 1 elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AudienceRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__AudienceRestrictionType; }
        /** Constructor with member initializations */
        saml2__AudienceRestrictionType() : __sizeAudience(), saml2__Audience() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AudienceRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__AudienceRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:84 */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (3441)
/* complex XSD type 'saml2:OneTimeUseType': */
struct SOAP_CMAC saml2__OneTimeUseType {
      public:
        /** Return unique type id SOAP_TYPE_saml2__OneTimeUseType */
        long soap_type() const { return SOAP_TYPE_saml2__OneTimeUseType; }
        /** Constructor with member initializations */
        saml2__OneTimeUseType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__OneTimeUseType * SOAP_FMAC2 soap_instantiate_saml2__OneTimeUseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:86 */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (3442)
/* complex XSD type 'saml2:ProxyRestrictionType': */
struct SOAP_CMAC saml2__ProxyRestrictionType {
      public:
        /** Sequence of elements 'saml2:Audience' of XSD type 'xsd:string' stored in dynamic array saml2__Audience of length __sizeAudience */
        int __sizeAudience;
        char **saml2__Audience;
        /** Optional attribute 'Count' of XSD type 'xsd:string' */
        char *Count;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ProxyRestrictionType */
        long soap_type() const { return SOAP_TYPE_saml2__ProxyRestrictionType; }
        /** Constructor with member initializations */
        saml2__ProxyRestrictionType() : __sizeAudience(), saml2__Audience(), Count() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ProxyRestrictionType * SOAP_FMAC2 soap_instantiate_saml2__ProxyRestrictionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:92 */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (3445)
/* complex XSD type 'saml2:AuthnStatementType': */
struct SOAP_CMAC saml2__AuthnStatementType {
      public:
        /** Optional element 'saml2:SubjectLocality' of XSD type 'saml2:SubjectLocalityType' */
        struct saml2__SubjectLocalityType *saml2__SubjectLocality;
        /** Required element 'saml2:AuthnContext' of XSD type 'saml2:AuthnContextType' */
        struct saml2__AuthnContextType *saml2__AuthnContext;
        /** Required attribute 'AuthnInstant' of XSD type 'xsd:dateTime' */
        time_t AuthnInstant;
        /** Optional attribute 'SessionIndex' of XSD type 'xsd:string' */
        char *SessionIndex;
        /** Optional attribute 'SessionNotOnOrAfter' of XSD type 'xsd:dateTime' */
        time_t *SessionNotOnOrAfter;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthnStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthnStatementType; }
        /** Constructor with member initializations */
        saml2__AuthnStatementType() : saml2__SubjectLocality(), saml2__AuthnContext(), AuthnInstant(), SessionIndex(), SessionNotOnOrAfter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthnStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthnStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:98 */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (3448)
/* complex XSD type 'saml2:AuthzDecisionStatementType': */
struct SOAP_CMAC saml2__AuthzDecisionStatementType {
      public:
        /** Sequence of at least 1 elements 'saml2:Action' of XSD type 'saml2:ActionType' stored in dynamic array saml2__Action of length __sizeAction */
        int __sizeAction;
        struct saml2__ActionType *saml2__Action;
        /** Optional element 'saml2:Evidence' of XSD type 'saml2:EvidenceType' */
        struct saml2__EvidenceType *saml2__Evidence;
        /** Required attribute 'Resource' of XSD type 'xsd:string' */
        char *Resource;
        /** Required attribute 'Decision' of XSD type 'saml2:DecisionType' */
        enum saml2__DecisionType Decision;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AuthzDecisionStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AuthzDecisionStatementType; }
        /** Constructor with member initializations */
        saml2__AuthzDecisionStatementType() : __sizeAction(), saml2__Action(), saml2__Evidence(), Resource(), Decision() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AuthzDecisionStatementType * SOAP_FMAC2 soap_instantiate_saml2__AuthzDecisionStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:100 */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (3449)
/* simple XSD type 'saml2:ActionType': */
struct SOAP_CMAC saml2__ActionType {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Required attribute 'Namespace' of XSD type 'xsd:string' */
        char *Namespace;
      public:
        /** Return unique type id SOAP_TYPE_saml2__ActionType */
        long soap_type() const { return SOAP_TYPE_saml2__ActionType; }
        /** Constructor with member initializations */
        saml2__ActionType() : __item(), Namespace() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__ActionType * SOAP_FMAC2 soap_instantiate_saml2__ActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:674 */
#ifndef SOAP_TYPE___saml2__union_AttributeStatementType
#define SOAP_TYPE___saml2__union_AttributeStatementType (3485)
/* Wrapper: */
struct SOAP_CMAC __saml2__union_AttributeStatementType {
      public:
        /** Optional element 'saml2:Attribute' of XSD type 'saml2:AttributeType' */
        struct saml2__AttributeType *saml2__Attribute;
        /** Optional element 'saml2:EncryptedAttribute' of XSD type 'saml2:EncryptedElementType' */
        struct saml2__EncryptedElementType *saml2__EncryptedAttribute;
      public:
        /** Return unique type id SOAP_TYPE___saml2__union_AttributeStatementType */
        long soap_type() const { return SOAP_TYPE___saml2__union_AttributeStatementType; }
        /** Constructor with member initializations */
        __saml2__union_AttributeStatementType() : saml2__Attribute(), saml2__EncryptedAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __saml2__union_AttributeStatementType * SOAP_FMAC2 soap_instantiate___saml2__union_AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:104 */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (3451)
/* complex XSD type 'saml2:AttributeStatementType': */
struct SOAP_CMAC saml2__AttributeStatementType {
      public:
        /** Sequence of elements '-union-AttributeStatementType' of XSD type '-saml2:union-AttributeStatementType' stored in dynamic array __union_AttributeStatementType of length __size_AttributeStatementType */
        int __size_AttributeStatementType;
        struct __saml2__union_AttributeStatementType *__union_AttributeStatementType;
      public:
        /** Return unique type id SOAP_TYPE_saml2__AttributeStatementType */
        long soap_type() const { return SOAP_TYPE_saml2__AttributeStatementType; }
        /** Constructor with member initializations */
        saml2__AttributeStatementType() : __size_AttributeStatementType(), __union_AttributeStatementType() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__AttributeStatementType * SOAP_FMAC2 soap_instantiate_saml2__AttributeStatementType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* saml2.h:76 */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (3437)
/* complex XSD type 'saml2:KeyInfoConfirmationDataType': */
struct SOAP_CMAC saml2__KeyInfoConfirmationDataType {
      public:
        /** Sequence of at least 1 elements 'ds:KeyInfo' of XSD type 'ds:KeyInfo' stored in dynamic array ds__KeyInfo of length __sizeds__KeyInfo */
        int __sizeds__KeyInfo;
        struct ds__KeyInfoType **ds__KeyInfo;
      public:
        /** Return unique type id SOAP_TYPE_saml2__KeyInfoConfirmationDataType */
        long soap_type() const { return SOAP_TYPE_saml2__KeyInfoConfirmationDataType; }
        /** Constructor with member initializations */
        saml2__KeyInfoConfirmationDataType() : __sizeds__KeyInfo(), ds__KeyInfo() { }
        /** Friend allocator */
        friend SOAP_FMAC1 saml2__KeyInfoConfirmationDataType * SOAP_FMAC2 soap_instantiate_saml2__KeyInfoConfirmationDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:193 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (3522)
/* complex XSD type 'wsse:Security': */
struct SOAP_CMAC _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XSD type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XSD type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XSD type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XSD type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XSD type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional element 'saml1:Assertion' of XSD type 'saml1:AssertionType' */
        struct saml1__AssertionType *saml1__Assertion;
        /** Optional element 'saml2:Assertion' of XSD type 'saml2:AssertionType' */
        struct saml2__AssertionType *saml2__Assertion;
        /** Optional attribute 'SOAP-ENV:actor' of XSD type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XSD type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        long soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security() : wsu__Timestamp(), UsernameToken(), BinarySecurityToken(), xenc__EncryptedKey(), xenc__ReferenceList(), wsc__SecurityContextToken(), ds__Signature(), saml1__Assertion(), saml2__Assertion(), SOAP_ENV__actor(), SOAP_ENV__role() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:129 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (3274)
/* simple XSD type 'wsse:Password': */
struct SOAP_CMAC _wsse__Password {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        long soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password() : __item(), Type() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* wsa5.h:87 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (13)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:90 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (14)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:209 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (21)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:212 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (22)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:215 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (23)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:218 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (24)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:221 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (25)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:224 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (26)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:227 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (27)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:230 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (28)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:233 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (29)
typedef char *_wsa5__To;
#endif

/* wsa5.h:236 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (30)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:239 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (32)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:242 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (33)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:245 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (34)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:248 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (35)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* wsdd5.h:88 */
#ifndef SOAP_TYPE_wsdd__QNameListType
#define SOAP_TYPE_wsdd__QNameListType (65)
typedef _QName wsdd__QNameListType;
#endif

/* wsdd5.h:92 */
#ifndef SOAP_TYPE_wsdd__UriListType
#define SOAP_TYPE_wsdd__UriListType (66)
typedef char *wsdd__UriListType;
#endif

/* wsdd5.h:95 */
#ifndef SOAP_TYPE_wsdd__FaultCodeOpenType
#define SOAP_TYPE_wsdd__FaultCodeOpenType (67)
typedef char *wsdd__FaultCodeOpenType;
#endif

/* wsdd5.h:465 */
#ifndef SOAP_TYPE__wsdd__Hello
#define SOAP_TYPE__wsdd__Hello (75)
typedef struct wsdd__HelloType _wsdd__Hello;
#endif

/* wsdd5.h:468 */
#ifndef SOAP_TYPE__wsdd__Bye
#define SOAP_TYPE__wsdd__Bye (76)
typedef struct wsdd__ByeType _wsdd__Bye;
#endif

/* wsdd5.h:471 */
#ifndef SOAP_TYPE__wsdd__Probe
#define SOAP_TYPE__wsdd__Probe (77)
typedef struct wsdd__ProbeType _wsdd__Probe;
#endif

/* wsdd5.h:474 */
#ifndef SOAP_TYPE__wsdd__ProbeMatches
#define SOAP_TYPE__wsdd__ProbeMatches (78)
typedef struct wsdd__ProbeMatchesType _wsdd__ProbeMatches;
#endif

/* wsdd5.h:477 */
#ifndef SOAP_TYPE__wsdd__Resolve
#define SOAP_TYPE__wsdd__Resolve (79)
typedef struct wsdd__ResolveType _wsdd__Resolve;
#endif

/* wsdd5.h:480 */
#ifndef SOAP_TYPE__wsdd__ResolveMatches
#define SOAP_TYPE__wsdd__ResolveMatches (80)
typedef struct wsdd__ResolveMatchesType _wsdd__ResolveMatches;
#endif

/* wsdd5.h:483 */
#ifndef SOAP_TYPE__wsdd__Types
#define SOAP_TYPE__wsdd__Types (81)
typedef wsdd__QNameListType _wsdd__Types;
#endif

/* wsdd5.h:486 */
#ifndef SOAP_TYPE__wsdd__Scopes
#define SOAP_TYPE__wsdd__Scopes (82)
typedef struct wsdd__ScopesType _wsdd__Scopes;
#endif

/* wsdd5.h:489 */
#ifndef SOAP_TYPE__wsdd__XAddrs
#define SOAP_TYPE__wsdd__XAddrs (83)
typedef wsdd__UriListType _wsdd__XAddrs;
#endif

/* wsdd5.h:492 */
#ifndef SOAP_TYPE__wsdd__MetadataVersion
#define SOAP_TYPE__wsdd__MetadataVersion (84)
typedef unsigned int _wsdd__MetadataVersion;
#endif

/* wsdd5.h:495 */
#ifndef SOAP_TYPE__wsdd__SupportedMatchingRules
#define SOAP_TYPE__wsdd__SupportedMatchingRules (85)
typedef wsdd__UriListType _wsdd__SupportedMatchingRules;
#endif

/* wsdd5.h:498 */
#ifndef SOAP_TYPE__wsdd__Security
#define SOAP_TYPE__wsdd__Security (86)
typedef struct wsdd__SecurityType _wsdd__Security;
#endif

/* wsdd5.h:501 */
#ifndef SOAP_TYPE__wsdd__Sig
#define SOAP_TYPE__wsdd__Sig (87)
typedef struct wsdd__SigType _wsdd__Sig;
#endif

/* wsdd5.h:504 */
#ifndef SOAP_TYPE__wsdd__AppSequence
#define SOAP_TYPE__wsdd__AppSequence (88)
typedef struct wsdd__AppSequenceType _wsdd__AppSequence;
#endif

/* wsdd5.h:515 */
#ifndef SOAP_TYPE__wsdd__Id
#define SOAP_TYPE__wsdd__Id (89)
typedef char *_wsdd__Id;
#endif

/* onvif.h:241 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (120)
typedef std::string xsd__NCName;
#endif

/* onvif.h:244 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (121)
typedef std::string xsd__anySimpleType;
#endif

/* onvif.h:247 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (122)
typedef std::string xsd__anyURI;
#endif

/* onvif.h:250 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (123)
typedef std::string xsd__duration;
#endif

/* onvif.h:253 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (124)
typedef std::string xsd__integer;
#endif

/* onvif.h:256 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (125)
typedef std::string xsd__nonNegativeInteger;
#endif

/* onvif.h:259 */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (126)
typedef std::string xsd__positiveInteger;
#endif

/* onvif.h:262 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (127)
typedef std::string xsd__token;
#endif

/* onvif.h:266 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (128)
typedef std::string _xml__lang;
#endif

/* onvif.h:3361 */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (1153)
typedef std::string tds__EAPMethodTypes;
#endif

/* onvif.h:3373 */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (1154)
typedef std::string tt__IntAttrList;
#endif

/* onvif.h:3377 */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (1155)
typedef std::string tt__FloatAttrList;
#endif

/* onvif.h:3381 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (1156)
typedef std::string tt__StringAttrList;
#endif

/* onvif.h:3394 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (1157)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* onvif.h:3454 */
#ifndef SOAP_TYPE_tmd__DelayTimes
#define SOAP_TYPE_tmd__DelayTimes (1158)
typedef std::string tmd__DelayTimes;
#endif

/* onvif.h:3477 */
#ifndef SOAP_TYPE_trt__EncodingTypes
#define SOAP_TYPE_trt__EncodingTypes (1159)
typedef std::string trt__EncodingTypes;
#endif

/* onvif.h:3508 */
#ifndef SOAP_TYPE_tas__Dot1XMethods
#define SOAP_TYPE_tas__Dot1XMethods (1160)
typedef std::string tas__Dot1XMethods;
#endif

/* onvif.h:3515 */
#ifndef SOAP_TYPE_tas__RSAKeyLengths
#define SOAP_TYPE_tas__RSAKeyLengths (1161)
typedef std::string tas__RSAKeyLengths;
#endif

/* onvif.h:3522 */
#ifndef SOAP_TYPE_tas__X509Versions
#define SOAP_TYPE_tas__X509Versions (1162)
typedef std::string tas__X509Versions;
#endif

/* onvif.h:3529 */
#ifndef SOAP_TYPE_tas__TLSVersions
#define SOAP_TYPE_tas__TLSVersions (1163)
typedef std::string tas__TLSVersions;
#endif

/* onvif.h:3536 */
#ifndef SOAP_TYPE_tas__PasswordBasedEncryptionAlgorithms
#define SOAP_TYPE_tas__PasswordBasedEncryptionAlgorithms (1164)
typedef std::string tas__PasswordBasedEncryptionAlgorithms;
#endif

/* onvif.h:3543 */
#ifndef SOAP_TYPE_tas__PasswordBasedMACAlgorithms
#define SOAP_TYPE_tas__PasswordBasedMACAlgorithms (1165)
typedef std::string tas__PasswordBasedMACAlgorithms;
#endif

/* onvif.h:3563 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (1166)
typedef std::string tt__Name;
#endif

/* onvif.h:3689 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (1177)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* onvif.h:3705 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (1179)
typedef int tt__IANA_IfTypes;
#endif

/* onvif.h:3740 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (1183)
typedef xsd__token tt__IPv4Address;
#endif

/* onvif.h:3744 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (1184)
typedef xsd__token tt__IPv6Address;
#endif

/* onvif.h:3748 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (1185)
typedef xsd__token tt__HwAddress;
#endif

/* onvif.h:3761 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (1187)
typedef xsd__token tt__DNSName;
#endif

/* onvif.h:3787 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (1190)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* onvif.h:3825 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (1194)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* onvif.h:3830 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (1195)
typedef std::string tt__Dot11PSKPassphrase;
#endif

/* onvif.h:3993 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (1209)
typedef std::string tt__AuxiliaryData;
#endif

/* onvif.h:4141 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (1222)
typedef std::string tt__Description;
#endif

/* onvif.h:4177 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (1224)
typedef std::string tt__ReferenceToken;
#endif

/* onvif.h:4224 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1226)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/* onvif.h:4348 */
#ifndef SOAP_TYPE_tas__KeyID
#define SOAP_TYPE_tas__KeyID (1229)
typedef std::string tas__KeyID;
#endif

/* onvif.h:4356 */
#ifndef SOAP_TYPE_tas__CertificateID
#define SOAP_TYPE_tas__CertificateID (1230)
typedef std::string tas__CertificateID;
#endif

/* onvif.h:4364 */
#ifndef SOAP_TYPE_tas__CertificationPathID
#define SOAP_TYPE_tas__CertificationPathID (1231)
typedef std::string tas__CertificationPathID;
#endif

/* onvif.h:4372 */
#ifndef SOAP_TYPE_tas__PassphraseID
#define SOAP_TYPE_tas__PassphraseID (1232)
typedef std::string tas__PassphraseID;
#endif

/* onvif.h:4380 */
#ifndef SOAP_TYPE_tas__Dot1XID
#define SOAP_TYPE_tas__Dot1XID (1233)
typedef std::string tas__Dot1XID;
#endif

/* onvif.h:4390 */
#ifndef SOAP_TYPE_tas__DotDecimalOID
#define SOAP_TYPE_tas__DotDecimalOID (1234)
typedef std::string tas__DotDecimalOID;
#endif

/* onvif.h:4397 */
#ifndef SOAP_TYPE_tas__DNAttributeType
#define SOAP_TYPE_tas__DNAttributeType (1235)
typedef std::string tas__DNAttributeType;
#endif

/* onvif.h:4404 */
#ifndef SOAP_TYPE_tas__DNAttributeValue
#define SOAP_TYPE_tas__DNAttributeValue (1236)
typedef std::string tas__DNAttributeValue;
#endif

/* onvif.h:4411 */
#ifndef SOAP_TYPE_tas__Base64DERencodedASN1Value
#define SOAP_TYPE_tas__Base64DERencodedASN1Value (1237)
typedef xsd__base64Binary tas__Base64DERencodedASN1Value;
#endif

/* onvif.h:4416 */
#ifndef SOAP_TYPE_tas__CRLID
#define SOAP_TYPE_tas__CRLID (1238)
typedef std::string tas__CRLID;
#endif

/* onvif.h:4421 */
#ifndef SOAP_TYPE_tas__CertPathValidationPolicyID
#define SOAP_TYPE_tas__CertPathValidationPolicyID (1239)
typedef std::string tas__CertPathValidationPolicyID;
#endif

/* ds.h:44 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (3287)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (3293)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:76 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (3301)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:89 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (3308)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (3345)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* saml1.h:580 */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (3405)
typedef char *_saml1__AssertionIDReference;
#endif

/* saml1.h:583 */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (3406)
typedef struct saml1__AssertionType _saml1__Assertion;
#endif

/* saml1.h:586 */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (3407)
typedef struct saml1__ConditionsType _saml1__Conditions;
#endif

/* saml1.h:589 */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (3408)
typedef struct saml1__ConditionAbstractType _saml1__Condition;
#endif

/* saml1.h:592 */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (3409)
typedef struct saml1__AudienceRestrictionConditionType _saml1__AudienceRestrictionCondition;
#endif

/* saml1.h:595 */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (3410)
typedef char *_saml1__Audience;
#endif

/* saml1.h:598 */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (3411)
typedef struct saml1__DoNotCacheConditionType _saml1__DoNotCacheCondition;
#endif

/* saml1.h:601 */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (3412)
typedef struct saml1__AdviceType _saml1__Advice;
#endif

/* saml1.h:604 */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (3413)
typedef struct saml1__StatementAbstractType _saml1__Statement;
#endif

/* saml1.h:607 */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (3414)
typedef struct saml1__SubjectStatementAbstractType _saml1__SubjectStatement;
#endif

/* saml1.h:610 */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (3415)
typedef struct saml1__SubjectType _saml1__Subject;
#endif

/* saml1.h:613 */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (3416)
typedef struct saml1__NameIdentifierType _saml1__NameIdentifier;
#endif

/* saml1.h:616 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (3417)
typedef struct saml1__SubjectConfirmationType _saml1__SubjectConfirmation;
#endif

/* saml1.h:619 */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (3418)
typedef _XML _saml1__SubjectConfirmationData;
#endif

/* saml1.h:622 */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (3419)
typedef char *_saml1__ConfirmationMethod;
#endif

/* saml1.h:625 */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (3420)
typedef struct saml1__AuthenticationStatementType _saml1__AuthenticationStatement;
#endif

/* saml1.h:628 */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (3421)
typedef struct saml1__SubjectLocalityType _saml1__SubjectLocality;
#endif

/* saml1.h:631 */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (3422)
typedef struct saml1__AuthorityBindingType _saml1__AuthorityBinding;
#endif

/* saml1.h:634 */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (3423)
typedef struct saml1__AuthorizationDecisionStatementType _saml1__AuthorizationDecisionStatement;
#endif

/* saml1.h:637 */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (3424)
typedef struct saml1__ActionType _saml1__Action;
#endif

/* saml1.h:640 */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (3425)
typedef struct saml1__EvidenceType _saml1__Evidence;
#endif

/* saml1.h:643 */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (3426)
typedef struct saml1__AttributeStatementType _saml1__AttributeStatement;
#endif

/* saml1.h:646 */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (3427)
typedef struct saml1__AttributeDesignatorType _saml1__AttributeDesignator;
#endif

/* saml1.h:649 */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (3428)
typedef struct saml1__AttributeType _saml1__Attribute;
#endif

/* saml1.h:652 */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (3429)
typedef _XML _saml1__AttributeValue;
#endif

/* saml2.h:726 */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (3489)
typedef struct saml2__BaseIDAbstractType _saml2__BaseID;
#endif

/* saml2.h:729 */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (3490)
typedef struct saml2__NameIDType _saml2__NameID;
#endif

/* saml2.h:732 */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (3491)
typedef struct saml2__EncryptedElementType _saml2__EncryptedID;
#endif

/* saml2.h:735 */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (3492)
typedef struct saml2__NameIDType _saml2__Issuer;
#endif

/* saml2.h:738 */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (3493)
typedef char *_saml2__AssertionIDRef;
#endif

/* saml2.h:741 */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (3494)
typedef char *_saml2__AssertionURIRef;
#endif

/* saml2.h:744 */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (3495)
typedef struct saml2__AssertionType _saml2__Assertion;
#endif

/* saml2.h:747 */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (3496)
typedef struct saml2__SubjectType _saml2__Subject;
#endif

/* saml2.h:750 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (3497)
typedef struct saml2__SubjectConfirmationType _saml2__SubjectConfirmation;
#endif

/* saml2.h:753 */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (3498)
typedef struct saml2__SubjectConfirmationDataType _saml2__SubjectConfirmationData;
#endif

/* saml2.h:756 */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (3499)
typedef struct saml2__ConditionsType _saml2__Conditions;
#endif

/* saml2.h:759 */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (3500)
typedef struct saml2__ConditionAbstractType _saml2__Condition;
#endif

/* saml2.h:762 */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (3501)
typedef struct saml2__AudienceRestrictionType _saml2__AudienceRestriction;
#endif

/* saml2.h:765 */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (3502)
typedef char *_saml2__Audience;
#endif

/* saml2.h:768 */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (3503)
typedef struct saml2__OneTimeUseType _saml2__OneTimeUse;
#endif

/* saml2.h:771 */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (3504)
typedef struct saml2__ProxyRestrictionType _saml2__ProxyRestriction;
#endif

/* saml2.h:774 */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (3505)
typedef struct saml2__AdviceType _saml2__Advice;
#endif

/* saml2.h:777 */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (3506)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAssertion;
#endif

/* saml2.h:780 */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (3507)
typedef struct saml2__StatementAbstractType _saml2__Statement;
#endif

/* saml2.h:783 */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (3508)
typedef struct saml2__AuthnStatementType _saml2__AuthnStatement;
#endif

/* saml2.h:786 */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (3509)
typedef struct saml2__SubjectLocalityType _saml2__SubjectLocality;
#endif

/* saml2.h:789 */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (3510)
typedef struct saml2__AuthnContextType _saml2__AuthnContext;
#endif

/* saml2.h:792 */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (3511)
typedef char *_saml2__AuthnContextClassRef;
#endif

/* saml2.h:795 */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (3512)
typedef char *_saml2__AuthnContextDeclRef;
#endif

/* saml2.h:798 */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (3513)
typedef _XML _saml2__AuthnContextDecl;
#endif

/* saml2.h:801 */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (3514)
typedef char *_saml2__AuthenticatingAuthority;
#endif

/* saml2.h:804 */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (3515)
typedef struct saml2__AuthzDecisionStatementType _saml2__AuthzDecisionStatement;
#endif

/* saml2.h:807 */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (3516)
typedef struct saml2__ActionType _saml2__Action;
#endif

/* saml2.h:810 */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (3517)
typedef struct saml2__EvidenceType _saml2__Evidence;
#endif

/* saml2.h:813 */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (3518)
typedef struct saml2__AttributeStatementType _saml2__AttributeStatement;
#endif

/* saml2.h:816 */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (3519)
typedef struct saml2__AttributeType _saml2__Attribute;
#endif

/* saml2.h:819 */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (3520)
typedef _XML _saml2__AttributeValue;
#endif

/* saml2.h:822 */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (3521)
typedef struct saml2__EncryptedElementType _saml2__EncryptedAttribute;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* tt__IANA_IfTypes has binding name 'tt__IANA_IfTypes' for type 'tt:IANA-IfTypes' */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (1179)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (1330)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (1634)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (110)
#endif

/* _wsdd__MetadataVersion has binding name '_wsdd__MetadataVersion' for type '' */
#ifndef SOAP_TYPE__wsdd__MetadataVersion
#define SOAP_TYPE__wsdd__MetadataVersion (84)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (70)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (32)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (31)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (1301)
#endif

/* enum saml2__DecisionType has binding name 'saml2__DecisionType' for type 'saml2:DecisionType' */
#ifndef SOAP_TYPE_saml2__DecisionType
#define SOAP_TYPE_saml2__DecisionType (3453)
#endif

/* enum saml1__DecisionType has binding name 'saml1__DecisionType' for type 'saml1:DecisionType' */
#ifndef SOAP_TYPE_saml1__DecisionType
#define SOAP_TYPE_saml1__DecisionType (3375)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (3346)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (3272)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (3269)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (1247)
#endif

/* enum tmd__ParityBit has binding name 'tmd__ParityBit' for type 'tmd:ParityBit' */
#ifndef SOAP_TYPE_tmd__ParityBit
#define SOAP_TYPE_tmd__ParityBit (1228)
#endif

/* enum tmd__SerialPortType has binding name 'tmd__SerialPortType' for type 'tmd:SerialPortType' */
#ifndef SOAP_TYPE_tmd__SerialPortType
#define SOAP_TYPE_tmd__SerialPortType (1227)
#endif

/* enum tt__MoveStatus has binding name 'tt__MoveStatus' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1225)
#endif

/* enum tt__OSDType has binding name 'tt__OSDType' for type 'tt:OSDType' */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (1223)
#endif

/* enum tt__PropertyOperation has binding name 'tt__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (1221)
#endif

/* enum tt__ImageStabilizationMode has binding name 'tt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (1220)
#endif

/* enum tt__IrCutFilterMode has binding name 'tt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (1219)
#endif

/* enum tt__WhiteBalanceMode has binding name 'tt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (1218)
#endif

/* enum tt__ExposureMode has binding name 'tt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (1217)
#endif

/* enum tt__ExposurePriority has binding name 'tt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (1216)
#endif

/* enum tt__BacklightCompensationMode has binding name 'tt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (1215)
#endif

/* enum tt__WideDynamicMode has binding name 'tt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (1214)
#endif

/* enum tt__AutoFocusMode has binding name 'tt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (1213)
#endif

/* enum tt__PTZPresetTourOperation has binding name 'tt__PTZPresetTourOperation' for type 'tt:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (1212)
#endif

/* enum tt__PTZPresetTourDirection has binding name 'tt__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (1211)
#endif

/* enum tt__PTZPresetTourState has binding name 'tt__PTZPresetTourState' for type 'tt:PTZPresetTourState' */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (1210)
#endif

/* enum tt__ReverseMode has binding name 'tt__ReverseMode' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (1208)
#endif

/* enum tt__EFlipMode has binding name 'tt__EFlipMode' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (1207)
#endif

/* enum tt__DigitalIdleState has binding name 'tt__DigitalIdleState' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (1206)
#endif

/* enum tt__RelayMode has binding name 'tt__RelayMode' for type 'tt:RelayMode' */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (1205)
#endif

/* enum tt__RelayIdleState has binding name 'tt__RelayIdleState' for type 'tt:RelayIdleState' */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (1204)
#endif

/* enum tt__RelayLogicalState has binding name 'tt__RelayLogicalState' for type 'tt:RelayLogicalState' */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (1203)
#endif

/* enum tt__UserLevel has binding name 'tt__UserLevel' for type 'tt:UserLevel' */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (1202)
#endif

/* enum tt__SetDateTimeType has binding name 'tt__SetDateTimeType' for type 'tt:SetDateTimeType' */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (1201)
#endif

/* enum tt__FactoryDefaultType has binding name 'tt__FactoryDefaultType' for type 'tt:FactoryDefaultType' */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (1200)
#endif

/* enum tt__SystemLogType has binding name 'tt__SystemLogType' for type 'tt:SystemLogType' */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (1199)
#endif

/* enum tt__CapabilityCategory has binding name 'tt__CapabilityCategory' for type 'tt:CapabilityCategory' */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (1198)
#endif

/* enum tt__Dot11AuthAndMangementSuite has binding name 'tt__Dot11AuthAndMangementSuite' for type 'tt:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (1197)
#endif

/* enum tt__Dot11SignalStrength has binding name 'tt__Dot11SignalStrength' for type 'tt:Dot11SignalStrength' */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (1196)
#endif

/* enum tt__Dot11Cipher has binding name 'tt__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (1193)
#endif

/* enum tt__Dot11SecurityMode has binding name 'tt__Dot11SecurityMode' for type 'tt:Dot11SecurityMode' */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (1192)
#endif

/* enum tt__Dot11StationMode has binding name 'tt__Dot11StationMode' for type 'tt:Dot11StationMode' */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (1191)
#endif

/* enum tt__DynamicDNSType has binding name 'tt__DynamicDNSType' for type 'tt:DynamicDNSType' */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (1189)
#endif

/* enum tt__IPAddressFilterType has binding name 'tt__IPAddressFilterType' for type 'tt:IPAddressFilterType' */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (1188)
#endif

/* enum tt__IPType has binding name 'tt__IPType' for type 'tt:IPType' */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (1186)
#endif

/* enum tt__NetworkHostType has binding name 'tt__NetworkHostType' for type 'tt:NetworkHostType' */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (1182)
#endif

/* enum tt__NetworkProtocolType has binding name 'tt__NetworkProtocolType' for type 'tt:NetworkProtocolType' */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (1181)
#endif

/* enum tt__IPv6DHCPConfiguration has binding name 'tt__IPv6DHCPConfiguration' for type 'tt:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (1180)
#endif

/* enum tt__Duplex has binding name 'tt__Duplex' for type 'tt:Duplex' */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (1178)
#endif

/* enum tt__DiscoveryMode has binding name 'tt__DiscoveryMode' for type 'tt:DiscoveryMode' */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (1176)
#endif

/* enum tt__ScopeDefinition has binding name 'tt__ScopeDefinition' for type 'tt:ScopeDefinition' */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (1175)
#endif

/* enum tt__TransportProtocol has binding name 'tt__TransportProtocol' for type 'tt:TransportProtocol' */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (1174)
#endif

/* enum tt__StreamType has binding name 'tt__StreamType' for type 'tt:StreamType' */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (1173)
#endif

/* enum tt__AudioEncoding has binding name 'tt__AudioEncoding' for type 'tt:AudioEncoding' */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (1172)
#endif

/* enum tt__H264Profile has binding name 'tt__H264Profile' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (1171)
#endif

/* enum tt__Mpeg4Profile has binding name 'tt__Mpeg4Profile' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (1170)
#endif

/* enum tt__VideoEncoding has binding name 'tt__VideoEncoding' for type 'tt:VideoEncoding' */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (1169)
#endif

/* enum tt__SceneOrientationMode has binding name 'tt__SceneOrientationMode' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (1168)
#endif

/* enum tt__RotateMode has binding name 'tt__RotateMode' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (1167)
#endif

/* enum wsdd__FaultCodeType has binding name 'wsdd__FaultCodeType' for type 'wsdd:FaultCodeType' */
#ifndef SOAP_TYPE_wsdd__FaultCodeType
#define SOAP_TYPE_wsdd__FaultCodeType (68)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (36)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (16)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (15)
#endif

/* _wstop__TopicNamespaceType_Topic has binding name '_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1847)
#endif

/* _tas__CreateCertPathValidationPolicy_anyParameters has binding name '_tas__CreateCertPathValidationPolicy_anyParameters' for type '' */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters
#define SOAP_TYPE__tas__CreateCertPathValidationPolicy_anyParameters (1809)
#endif

/* _tas__UploadCRL_anyParameters has binding name '_tas__UploadCRL_anyParameters' for type '' */
#ifndef SOAP_TYPE__tas__UploadCRL_anyParameters
#define SOAP_TYPE__tas__UploadCRL_anyParameters (1805)
#endif

/* _tas__KeystoreCapabilities_anyElement has binding name '_tas__KeystoreCapabilities_anyElement' for type '' */
#ifndef SOAP_TYPE__tas__KeystoreCapabilities_anyElement
#define SOAP_TYPE__tas__KeystoreCapabilities_anyElement (1781)
#endif

/* _tas__CertPathValidationPolicy_anyParameters has binding name '_tas__CertPathValidationPolicy_anyParameters' for type '' */
#ifndef SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters
#define SOAP_TYPE__tas__CertPathValidationPolicy_anyParameters (1777)
#endif

/* _tas__CertPathValidationParameters_anyParameters has binding name '_tas__CertPathValidationParameters_anyParameters' for type '' */
#ifndef SOAP_TYPE__tas__CertPathValidationParameters_anyParameters
#define SOAP_TYPE__tas__CertPathValidationParameters_anyParameters (1772)
#endif

/* _tas__CertificationPath_anyElement has binding name '_tas__CertificationPath_anyElement' for type '' */
#ifndef SOAP_TYPE__tas__CertificationPath_anyElement
#define SOAP_TYPE__tas__CertificationPath_anyElement (1763)
#endif

/* _tas__CSRAttribute_anyAttribute has binding name '_tas__CSRAttribute_anyAttribute' for type '' */
#ifndef SOAP_TYPE__tas__CSRAttribute_anyAttribute
#define SOAP_TYPE__tas__CSRAttribute_anyAttribute (1759)
#endif

/* _tas__AlgorithmIdentifier_anyParameters has binding name '_tas__AlgorithmIdentifier_anyParameters' for type '' */
#ifndef SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters
#define SOAP_TYPE__tas__AlgorithmIdentifier_anyParameters (1755)
#endif

/* _tas__DistinguishedName_anyAttribute has binding name '_tas__DistinguishedName_anyAttribute' for type '' */
#ifndef SOAP_TYPE__tas__DistinguishedName_anyAttribute
#define SOAP_TYPE__tas__DistinguishedName_anyAttribute (1752)
#endif

/* _tas__KeyAttribute_Extension has binding name '_tas__KeyAttribute_Extension' for type '' */
#ifndef SOAP_TYPE__tas__KeyAttribute_Extension
#define SOAP_TYPE__tas__KeyAttribute_Extension (1745)
#endif

/* _tev__CreatePullPointSubscription_SubscriptionPolicy has binding name '_tev__CreatePullPointSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy (1663)
#endif

/* _wsrfbf__BaseFaultType_FaultCause has binding name '_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1659)
#endif

/* _wsrfbf__BaseFaultType_Description has binding name '_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1656)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode has binding name '_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1654)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy has binding name '_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1651)
#endif

/* _wsnt__NotificationMessageHolderType_Message has binding name '_wsnt__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1644)
#endif

/* _tt__ItemList_ElementItem has binding name '_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1598)
#endif

/* _tt__ItemList_SimpleItem has binding name '_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1596)
#endif

/* _tt__EventSubscription_SubscriptionPolicy has binding name '_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1380)
#endif

/* _tds__GetSystemUrisResponse_Extension has binding name '_tds__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1322)
#endif

/* _tds__StorageConfigurationData_Extension has binding name '_tds__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1256)
#endif

/* _tds__UserCredential_Extension has binding name '_tds__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1252)
#endif

/* _tds__Service_Capabilities has binding name '_tds__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1240)
#endif

/* tas__CertPathValidationPolicyID has binding name 'tas__CertPathValidationPolicyID' for type 'tas:CertPathValidationPolicyID' */
#ifndef SOAP_TYPE_tas__CertPathValidationPolicyID
#define SOAP_TYPE_tas__CertPathValidationPolicyID (1239)
#endif

/* tas__CRLID has binding name 'tas__CRLID' for type 'tas:CRLID' */
#ifndef SOAP_TYPE_tas__CRLID
#define SOAP_TYPE_tas__CRLID (1238)
#endif

/* tas__Base64DERencodedASN1Value has binding name 'tas__Base64DERencodedASN1Value' for type 'tas:Base64DERencodedASN1Value' */
#ifndef SOAP_TYPE_tas__Base64DERencodedASN1Value
#define SOAP_TYPE_tas__Base64DERencodedASN1Value (1237)
#endif

/* tas__DNAttributeValue has binding name 'tas__DNAttributeValue' for type 'tas:DNAttributeValue' */
#ifndef SOAP_TYPE_tas__DNAttributeValue
#define SOAP_TYPE_tas__DNAttributeValue (1236)
#endif

/* tas__DNAttributeType has binding name 'tas__DNAttributeType' for type 'tas:DNAttributeType' */
#ifndef SOAP_TYPE_tas__DNAttributeType
#define SOAP_TYPE_tas__DNAttributeType (1235)
#endif

/* tas__DotDecimalOID has binding name 'tas__DotDecimalOID' for type 'tas:DotDecimalOID' */
#ifndef SOAP_TYPE_tas__DotDecimalOID
#define SOAP_TYPE_tas__DotDecimalOID (1234)
#endif

/* tas__Dot1XID has binding name 'tas__Dot1XID' for type 'tas:Dot1XID' */
#ifndef SOAP_TYPE_tas__Dot1XID
#define SOAP_TYPE_tas__Dot1XID (1233)
#endif

/* tas__PassphraseID has binding name 'tas__PassphraseID' for type 'tas:PassphraseID' */
#ifndef SOAP_TYPE_tas__PassphraseID
#define SOAP_TYPE_tas__PassphraseID (1232)
#endif

/* tas__CertificationPathID has binding name 'tas__CertificationPathID' for type 'tas:CertificationPathID' */
#ifndef SOAP_TYPE_tas__CertificationPathID
#define SOAP_TYPE_tas__CertificationPathID (1231)
#endif

/* tas__CertificateID has binding name 'tas__CertificateID' for type 'tas:CertificateID' */
#ifndef SOAP_TYPE_tas__CertificateID
#define SOAP_TYPE_tas__CertificateID (1230)
#endif

/* tas__KeyID has binding name 'tas__KeyID' for type 'tas:KeyID' */
#ifndef SOAP_TYPE_tas__KeyID
#define SOAP_TYPE_tas__KeyID (1229)
#endif

/* wstop__ConcreteTopicExpression has binding name 'wstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1226)
#endif

/* tt__ReferenceToken has binding name 'tt__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (1224)
#endif

/* tt__Description has binding name 'tt__Description' for type 'tt:Description' */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (1222)
#endif

/* tt__AuxiliaryData has binding name 'tt__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (1209)
#endif

/* tt__Dot11PSKPassphrase has binding name 'tt__Dot11PSKPassphrase' for type 'tt:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (1195)
#endif

/* tt__Dot11PSK has binding name 'tt__Dot11PSK' for type 'tt:Dot11PSK' */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (1194)
#endif

/* tt__Dot11SSIDType has binding name 'tt__Dot11SSIDType' for type 'tt:Dot11SSIDType' */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (1190)
#endif

/* tt__DNSName has binding name 'tt__DNSName' for type 'tt:DNSName' */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (1187)
#endif

/* tt__HwAddress has binding name 'tt__HwAddress' for type 'tt:HwAddress' */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (1185)
#endif

/* tt__IPv6Address has binding name 'tt__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (1184)
#endif

/* tt__IPv4Address has binding name 'tt__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (1183)
#endif

/* tt__NetworkInterfaceConfigPriority has binding name 'tt__NetworkInterfaceConfigPriority' for type 'tt:NetworkInterfaceConfigPriority' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (1177)
#endif

/* tt__Name has binding name 'tt__Name' for type 'tt:Name' */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (1166)
#endif

/* tas__PasswordBasedMACAlgorithms has binding name 'tas__PasswordBasedMACAlgorithms' for type 'tas:PasswordBasedMACAlgorithms' */
#ifndef SOAP_TYPE_tas__PasswordBasedMACAlgorithms
#define SOAP_TYPE_tas__PasswordBasedMACAlgorithms (1165)
#endif

/* tas__PasswordBasedEncryptionAlgorithms has binding name 'tas__PasswordBasedEncryptionAlgorithms' for type 'tas:PasswordBasedEncryptionAlgorithms' */
#ifndef SOAP_TYPE_tas__PasswordBasedEncryptionAlgorithms
#define SOAP_TYPE_tas__PasswordBasedEncryptionAlgorithms (1164)
#endif

/* tas__TLSVersions has binding name 'tas__TLSVersions' for type 'tas:TLSVersions' */
#ifndef SOAP_TYPE_tas__TLSVersions
#define SOAP_TYPE_tas__TLSVersions (1163)
#endif

/* tas__X509Versions has binding name 'tas__X509Versions' for type 'tas:X509Versions' */
#ifndef SOAP_TYPE_tas__X509Versions
#define SOAP_TYPE_tas__X509Versions (1162)
#endif

/* tas__RSAKeyLengths has binding name 'tas__RSAKeyLengths' for type 'tas:RSAKeyLengths' */
#ifndef SOAP_TYPE_tas__RSAKeyLengths
#define SOAP_TYPE_tas__RSAKeyLengths (1161)
#endif

/* tas__Dot1XMethods has binding name 'tas__Dot1XMethods' for type 'tas:Dot1XMethods' */
#ifndef SOAP_TYPE_tas__Dot1XMethods
#define SOAP_TYPE_tas__Dot1XMethods (1160)
#endif

/* trt__EncodingTypes has binding name 'trt__EncodingTypes' for type 'trt:EncodingTypes' */
#ifndef SOAP_TYPE_trt__EncodingTypes
#define SOAP_TYPE_trt__EncodingTypes (1159)
#endif

/* tmd__DelayTimes has binding name 'tmd__DelayTimes' for type 'tmd:DelayTimes' */
#ifndef SOAP_TYPE_tmd__DelayTimes
#define SOAP_TYPE_tmd__DelayTimes (1158)
#endif

/* wsnt__AbsoluteOrRelativeTimeType has binding name 'wsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (1157)
#endif

/* tt__StringAttrList has binding name 'tt__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (1156)
#endif

/* tt__FloatAttrList has binding name 'tt__FloatAttrList' for type 'tt:FloatAttrList' */
#ifndef SOAP_TYPE_tt__FloatAttrList
#define SOAP_TYPE_tt__FloatAttrList (1155)
#endif

/* tt__IntAttrList has binding name 'tt__IntAttrList' for type 'tt:IntAttrList' */
#ifndef SOAP_TYPE_tt__IntAttrList
#define SOAP_TYPE_tt__IntAttrList (1154)
#endif

/* tds__EAPMethodTypes has binding name 'tds__EAPMethodTypes' for type 'tds:EAPMethodTypes' */
#ifndef SOAP_TYPE_tds__EAPMethodTypes
#define SOAP_TYPE_tds__EAPMethodTypes (1153)
#endif

/* _tas__DeleteNetworkInterfaceDot1XConfigurationResponse has binding name '_tas__DeleteNetworkInterfaceDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfigurationResponse (1152)
#endif

/* _tas__DeleteNetworkInterfaceDot1XConfiguration has binding name '_tas__DeleteNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__DeleteNetworkInterfaceDot1XConfiguration (1151)
#endif

/* _tas__GetNetworkInterfaceDot1XConfigurationResponse has binding name '_tas__GetNetworkInterfaceDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfigurationResponse (1150)
#endif

/* _tas__GetNetworkInterfaceDot1XConfiguration has binding name '_tas__GetNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__GetNetworkInterfaceDot1XConfiguration (1149)
#endif

/* _tas__SetNetworkInterfaceDot1XConfigurationResponse has binding name '_tas__SetNetworkInterfaceDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse
#define SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfigurationResponse (1148)
#endif

/* _tas__SetNetworkInterfaceDot1XConfiguration has binding name '_tas__SetNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE__tas__SetNetworkInterfaceDot1XConfiguration (1147)
#endif

/* _tas__DeleteDot1XConfigurationResponse has binding name '_tas__DeleteDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tas__DeleteDot1XConfigurationResponse (1146)
#endif

/* _tas__DeleteDot1XConfiguration has binding name '_tas__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__DeleteDot1XConfiguration
#define SOAP_TYPE__tas__DeleteDot1XConfiguration (1145)
#endif

/* _tas__GetDot1XConfigurationResponse has binding name '_tas__GetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetDot1XConfigurationResponse
#define SOAP_TYPE__tas__GetDot1XConfigurationResponse (1144)
#endif

/* _tas__GetDot1XConfiguration has binding name '_tas__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__GetDot1XConfiguration
#define SOAP_TYPE__tas__GetDot1XConfiguration (1143)
#endif

/* _tas__GetAllDot1XConfigurationsResponse has binding name '_tas__GetAllDot1XConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse
#define SOAP_TYPE__tas__GetAllDot1XConfigurationsResponse (1142)
#endif

/* _tas__GetAllDot1XConfigurations has binding name '_tas__GetAllDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE__tas__GetAllDot1XConfigurations
#define SOAP_TYPE__tas__GetAllDot1XConfigurations (1141)
#endif

/* _tas__AddDot1XConfigurationResponse has binding name '_tas__AddDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tas__AddDot1XConfigurationResponse
#define SOAP_TYPE__tas__AddDot1XConfigurationResponse (1140)
#endif

/* _tas__AddDot1XConfiguration has binding name '_tas__AddDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tas__AddDot1XConfiguration
#define SOAP_TYPE__tas__AddDot1XConfiguration (1139)
#endif

/* _tas__GetAssignedCertPathValidationPoliciesResponse has binding name '_tas__GetAssignedCertPathValidationPoliciesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse
#define SOAP_TYPE__tas__GetAssignedCertPathValidationPoliciesResponse (1138)
#endif

/* _tas__GetAssignedCertPathValidationPolicies has binding name '_tas__GetAssignedCertPathValidationPolicies' for type '' */
#ifndef SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies
#define SOAP_TYPE__tas__GetAssignedCertPathValidationPolicies (1137)
#endif

/* _tas__ReplaceCertPathValidationPolicyAssignmentResponse has binding name '_tas__ReplaceCertPathValidationPolicyAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignmentResponse (1136)
#endif

/* _tas__ReplaceCertPathValidationPolicyAssignment has binding name '_tas__ReplaceCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__ReplaceCertPathValidationPolicyAssignment (1135)
#endif

/* _tas__RemoveCertPathValidationPolicyAssignmentResponse has binding name '_tas__RemoveCertPathValidationPolicyAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignmentResponse (1134)
#endif

/* _tas__RemoveCertPathValidationPolicyAssignment has binding name '_tas__RemoveCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__RemoveCertPathValidationPolicyAssignment (1133)
#endif

/* _tas__AddCertPathValidationPolicyAssignmentResponse has binding name '_tas__AddCertPathValidationPolicyAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse
#define SOAP_TYPE__tas__AddCertPathValidationPolicyAssignmentResponse (1132)
#endif

/* _tas__AddCertPathValidationPolicyAssignment has binding name '_tas__AddCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment
#define SOAP_TYPE__tas__AddCertPathValidationPolicyAssignment (1131)
#endif

/* _tas__GetClientAuthenticationRequiredResponse has binding name '_tas__GetClientAuthenticationRequiredResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse
#define SOAP_TYPE__tas__GetClientAuthenticationRequiredResponse (1130)
#endif

/* _tas__GetClientAuthenticationRequired has binding name '_tas__GetClientAuthenticationRequired' for type '' */
#ifndef SOAP_TYPE__tas__GetClientAuthenticationRequired
#define SOAP_TYPE__tas__GetClientAuthenticationRequired (1129)
#endif

/* _tas__SetClientAuthenticationRequiredResponse has binding name '_tas__SetClientAuthenticationRequiredResponse' for type '' */
#ifndef SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse
#define SOAP_TYPE__tas__SetClientAuthenticationRequiredResponse (1128)
#endif

/* _tas__SetClientAuthenticationRequired has binding name '_tas__SetClientAuthenticationRequired' for type '' */
#ifndef SOAP_TYPE__tas__SetClientAuthenticationRequired
#define SOAP_TYPE__tas__SetClientAuthenticationRequired (1127)
#endif

/* _tas__DeleteCertPathValidationPolicyResponse has binding name '_tas__DeleteCertPathValidationPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__DeleteCertPathValidationPolicyResponse (1126)
#endif

/* _tas__DeleteCertPathValidationPolicy has binding name '_tas__DeleteCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertPathValidationPolicy
#define SOAP_TYPE__tas__DeleteCertPathValidationPolicy (1125)
#endif

/* _tas__GetAllCertPathValidationPoliciesResponse has binding name '_tas__GetAllCertPathValidationPoliciesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse
#define SOAP_TYPE__tas__GetAllCertPathValidationPoliciesResponse (1124)
#endif

/* _tas__GetAllCertPathValidationPolicies has binding name '_tas__GetAllCertPathValidationPolicies' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertPathValidationPolicies
#define SOAP_TYPE__tas__GetAllCertPathValidationPolicies (1123)
#endif

/* _tas__GetCertPathValidationPolicyResponse has binding name '_tas__GetCertPathValidationPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__GetCertPathValidationPolicyResponse (1122)
#endif

/* _tas__GetCertPathValidationPolicy has binding name '_tas__GetCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE__tas__GetCertPathValidationPolicy
#define SOAP_TYPE__tas__GetCertPathValidationPolicy (1121)
#endif

/* _tas__CreateCertPathValidationPolicyResponse has binding name '_tas__CreateCertPathValidationPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse
#define SOAP_TYPE__tas__CreateCertPathValidationPolicyResponse (1120)
#endif

/* _tas__CreateCertPathValidationPolicy has binding name '_tas__CreateCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE__tas__CreateCertPathValidationPolicy
#define SOAP_TYPE__tas__CreateCertPathValidationPolicy (1119)
#endif

/* _tas__DeleteCRLResponse has binding name '_tas__DeleteCRLResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCRLResponse
#define SOAP_TYPE__tas__DeleteCRLResponse (1118)
#endif

/* _tas__DeleteCRL has binding name '_tas__DeleteCRL' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCRL
#define SOAP_TYPE__tas__DeleteCRL (1117)
#endif

/* _tas__GetAllCRLsResponse has binding name '_tas__GetAllCRLsResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCRLsResponse
#define SOAP_TYPE__tas__GetAllCRLsResponse (1116)
#endif

/* _tas__GetAllCRLs has binding name '_tas__GetAllCRLs' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCRLs
#define SOAP_TYPE__tas__GetAllCRLs (1115)
#endif

/* _tas__GetCRLResponse has binding name '_tas__GetCRLResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetCRLResponse
#define SOAP_TYPE__tas__GetCRLResponse (1114)
#endif

/* _tas__GetCRL has binding name '_tas__GetCRL' for type '' */
#ifndef SOAP_TYPE__tas__GetCRL
#define SOAP_TYPE__tas__GetCRL (1113)
#endif

/* _tas__UploadCRLResponse has binding name '_tas__UploadCRLResponse' for type '' */
#ifndef SOAP_TYPE__tas__UploadCRLResponse
#define SOAP_TYPE__tas__UploadCRLResponse (1112)
#endif

/* _tas__UploadCRL has binding name '_tas__UploadCRL' for type '' */
#ifndef SOAP_TYPE__tas__UploadCRL
#define SOAP_TYPE__tas__UploadCRL (1111)
#endif

/* _tas__GetEnabledTLSVersionsResponse has binding name '_tas__GetEnabledTLSVersionsResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetEnabledTLSVersionsResponse
#define SOAP_TYPE__tas__GetEnabledTLSVersionsResponse (1110)
#endif

/* _tas__GetEnabledTLSVersions has binding name '_tas__GetEnabledTLSVersions' for type '' */
#ifndef SOAP_TYPE__tas__GetEnabledTLSVersions
#define SOAP_TYPE__tas__GetEnabledTLSVersions (1109)
#endif

/* _tas__SetEnabledTLSVersionsResponse has binding name '_tas__SetEnabledTLSVersionsResponse' for type '' */
#ifndef SOAP_TYPE__tas__SetEnabledTLSVersionsResponse
#define SOAP_TYPE__tas__SetEnabledTLSVersionsResponse (1108)
#endif

/* _tas__SetEnabledTLSVersions has binding name '_tas__SetEnabledTLSVersions' for type '' */
#ifndef SOAP_TYPE__tas__SetEnabledTLSVersions
#define SOAP_TYPE__tas__SetEnabledTLSVersions (1107)
#endif

/* _tas__GetAssignedServerCertificatesResponse has binding name '_tas__GetAssignedServerCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAssignedServerCertificatesResponse
#define SOAP_TYPE__tas__GetAssignedServerCertificatesResponse (1106)
#endif

/* _tas__GetAssignedServerCertificates has binding name '_tas__GetAssignedServerCertificates' for type '' */
#ifndef SOAP_TYPE__tas__GetAssignedServerCertificates
#define SOAP_TYPE__tas__GetAssignedServerCertificates (1105)
#endif

/* _tas__ReplaceServerCertificateAssignmentResponse has binding name '_tas__ReplaceServerCertificateAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__ReplaceServerCertificateAssignmentResponse (1104)
#endif

/* _tas__ReplaceServerCertificateAssignment has binding name '_tas__ReplaceServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE__tas__ReplaceServerCertificateAssignment
#define SOAP_TYPE__tas__ReplaceServerCertificateAssignment (1103)
#endif

/* _tas__RemoveServerCertificateAssignmentResponse has binding name '_tas__RemoveServerCertificateAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__RemoveServerCertificateAssignmentResponse (1102)
#endif

/* _tas__RemoveServerCertificateAssignment has binding name '_tas__RemoveServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE__tas__RemoveServerCertificateAssignment
#define SOAP_TYPE__tas__RemoveServerCertificateAssignment (1101)
#endif

/* _tas__AddServerCertificateAssignmentResponse has binding name '_tas__AddServerCertificateAssignmentResponse' for type '' */
#ifndef SOAP_TYPE__tas__AddServerCertificateAssignmentResponse
#define SOAP_TYPE__tas__AddServerCertificateAssignmentResponse (1100)
#endif

/* _tas__AddServerCertificateAssignment has binding name '_tas__AddServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE__tas__AddServerCertificateAssignment
#define SOAP_TYPE__tas__AddServerCertificateAssignment (1099)
#endif

/* _tas__DeletePassphraseResponse has binding name '_tas__DeletePassphraseResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeletePassphraseResponse
#define SOAP_TYPE__tas__DeletePassphraseResponse (1098)
#endif

/* _tas__DeletePassphrase has binding name '_tas__DeletePassphrase' for type '' */
#ifndef SOAP_TYPE__tas__DeletePassphrase
#define SOAP_TYPE__tas__DeletePassphrase (1097)
#endif

/* _tas__GetAllPassphrasesResponse has binding name '_tas__GetAllPassphrasesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllPassphrasesResponse
#define SOAP_TYPE__tas__GetAllPassphrasesResponse (1096)
#endif

/* _tas__GetAllPassphrases has binding name '_tas__GetAllPassphrases' for type '' */
#ifndef SOAP_TYPE__tas__GetAllPassphrases
#define SOAP_TYPE__tas__GetAllPassphrases (1095)
#endif

/* _tas__UploadPassphraseResponse has binding name '_tas__UploadPassphraseResponse' for type '' */
#ifndef SOAP_TYPE__tas__UploadPassphraseResponse
#define SOAP_TYPE__tas__UploadPassphraseResponse (1094)
#endif

/* _tas__UploadPassphrase has binding name '_tas__UploadPassphrase' for type '' */
#ifndef SOAP_TYPE__tas__UploadPassphrase
#define SOAP_TYPE__tas__UploadPassphrase (1093)
#endif

/* _tas__DeleteCertificationPathResponse has binding name '_tas__DeleteCertificationPathResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertificationPathResponse
#define SOAP_TYPE__tas__DeleteCertificationPathResponse (1092)
#endif

/* _tas__DeleteCertificationPath has binding name '_tas__DeleteCertificationPath' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertificationPath
#define SOAP_TYPE__tas__DeleteCertificationPath (1091)
#endif

/* _tas__GetAllCertificationPathsResponse has binding name '_tas__GetAllCertificationPathsResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertificationPathsResponse
#define SOAP_TYPE__tas__GetAllCertificationPathsResponse (1090)
#endif

/* _tas__GetAllCertificationPaths has binding name '_tas__GetAllCertificationPaths' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertificationPaths
#define SOAP_TYPE__tas__GetAllCertificationPaths (1089)
#endif

/* _tas__GetCertificationPathResponse has binding name '_tas__GetCertificationPathResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetCertificationPathResponse
#define SOAP_TYPE__tas__GetCertificationPathResponse (1088)
#endif

/* _tas__GetCertificationPath has binding name '_tas__GetCertificationPath' for type '' */
#ifndef SOAP_TYPE__tas__GetCertificationPath
#define SOAP_TYPE__tas__GetCertificationPath (1087)
#endif

/* _tas__CreateCertificationPathResponse has binding name '_tas__CreateCertificationPathResponse' for type '' */
#ifndef SOAP_TYPE__tas__CreateCertificationPathResponse
#define SOAP_TYPE__tas__CreateCertificationPathResponse (1086)
#endif

/* _tas__CreateCertificationPath has binding name '_tas__CreateCertificationPath' for type '' */
#ifndef SOAP_TYPE__tas__CreateCertificationPath
#define SOAP_TYPE__tas__CreateCertificationPath (1085)
#endif

/* _tas__DeleteCertificateResponse has binding name '_tas__DeleteCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertificateResponse
#define SOAP_TYPE__tas__DeleteCertificateResponse (1084)
#endif

/* _tas__DeleteCertificate has binding name '_tas__DeleteCertificate' for type '' */
#ifndef SOAP_TYPE__tas__DeleteCertificate
#define SOAP_TYPE__tas__DeleteCertificate (1083)
#endif

/* _tas__GetAllCertificatesResponse has binding name '_tas__GetAllCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertificatesResponse
#define SOAP_TYPE__tas__GetAllCertificatesResponse (1082)
#endif

/* _tas__GetAllCertificates has binding name '_tas__GetAllCertificates' for type '' */
#ifndef SOAP_TYPE__tas__GetAllCertificates
#define SOAP_TYPE__tas__GetAllCertificates (1081)
#endif

/* _tas__GetCertificateResponse has binding name '_tas__GetCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetCertificateResponse
#define SOAP_TYPE__tas__GetCertificateResponse (1080)
#endif

/* _tas__GetCertificate has binding name '_tas__GetCertificate' for type '' */
#ifndef SOAP_TYPE__tas__GetCertificate
#define SOAP_TYPE__tas__GetCertificate (1079)
#endif

/* _tas__UploadCertificateResponse has binding name '_tas__UploadCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tas__UploadCertificateResponse
#define SOAP_TYPE__tas__UploadCertificateResponse (1078)
#endif

/* _tas__UploadCertificate has binding name '_tas__UploadCertificate' for type '' */
#ifndef SOAP_TYPE__tas__UploadCertificate
#define SOAP_TYPE__tas__UploadCertificate (1077)
#endif

/* _tas__CreateSelfSignedCertificateResponse has binding name '_tas__CreateSelfSignedCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tas__CreateSelfSignedCertificateResponse
#define SOAP_TYPE__tas__CreateSelfSignedCertificateResponse (1076)
#endif

/* _tas__CreateSelfSignedCertificate has binding name '_tas__CreateSelfSignedCertificate' for type '' */
#ifndef SOAP_TYPE__tas__CreateSelfSignedCertificate
#define SOAP_TYPE__tas__CreateSelfSignedCertificate (1075)
#endif

/* _tas__CreatePKCS10CSRResponse has binding name '_tas__CreatePKCS10CSRResponse' for type '' */
#ifndef SOAP_TYPE__tas__CreatePKCS10CSRResponse
#define SOAP_TYPE__tas__CreatePKCS10CSRResponse (1074)
#endif

/* _tas__CreatePKCS10CSR has binding name '_tas__CreatePKCS10CSR' for type '' */
#ifndef SOAP_TYPE__tas__CreatePKCS10CSR
#define SOAP_TYPE__tas__CreatePKCS10CSR (1073)
#endif

/* _tas__DeleteKeyResponse has binding name '_tas__DeleteKeyResponse' for type '' */
#ifndef SOAP_TYPE__tas__DeleteKeyResponse
#define SOAP_TYPE__tas__DeleteKeyResponse (1072)
#endif

/* _tas__DeleteKey has binding name '_tas__DeleteKey' for type '' */
#ifndef SOAP_TYPE__tas__DeleteKey
#define SOAP_TYPE__tas__DeleteKey (1071)
#endif

/* _tas__GetAllKeysResponse has binding name '_tas__GetAllKeysResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetAllKeysResponse
#define SOAP_TYPE__tas__GetAllKeysResponse (1070)
#endif

/* _tas__GetAllKeys has binding name '_tas__GetAllKeys' for type '' */
#ifndef SOAP_TYPE__tas__GetAllKeys
#define SOAP_TYPE__tas__GetAllKeys (1069)
#endif

/* _tas__GetPrivateKeyStatusResponse has binding name '_tas__GetPrivateKeyStatusResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetPrivateKeyStatusResponse
#define SOAP_TYPE__tas__GetPrivateKeyStatusResponse (1068)
#endif

/* _tas__GetPrivateKeyStatus has binding name '_tas__GetPrivateKeyStatus' for type '' */
#ifndef SOAP_TYPE__tas__GetPrivateKeyStatus
#define SOAP_TYPE__tas__GetPrivateKeyStatus (1067)
#endif

/* _tas__GetKeyStatusResponse has binding name '_tas__GetKeyStatusResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetKeyStatusResponse
#define SOAP_TYPE__tas__GetKeyStatusResponse (1066)
#endif

/* _tas__GetKeyStatus has binding name '_tas__GetKeyStatus' for type '' */
#ifndef SOAP_TYPE__tas__GetKeyStatus
#define SOAP_TYPE__tas__GetKeyStatus (1065)
#endif

/* _tas__UploadCertificateWithPrivateKeyInPKCS12Response has binding name '_tas__UploadCertificateWithPrivateKeyInPKCS12Response' for type '' */
#ifndef SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response
#define SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12Response (1064)
#endif

/* _tas__UploadCertificateWithPrivateKeyInPKCS12 has binding name '_tas__UploadCertificateWithPrivateKeyInPKCS12' for type '' */
#ifndef SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12
#define SOAP_TYPE__tas__UploadCertificateWithPrivateKeyInPKCS12 (1063)
#endif

/* _tas__UploadKeyPairInPKCS8Response has binding name '_tas__UploadKeyPairInPKCS8Response' for type '' */
#ifndef SOAP_TYPE__tas__UploadKeyPairInPKCS8Response
#define SOAP_TYPE__tas__UploadKeyPairInPKCS8Response (1062)
#endif

/* _tas__UploadKeyPairInPKCS8 has binding name '_tas__UploadKeyPairInPKCS8' for type '' */
#ifndef SOAP_TYPE__tas__UploadKeyPairInPKCS8
#define SOAP_TYPE__tas__UploadKeyPairInPKCS8 (1061)
#endif

/* _tas__CreateRSAKeyPairResponse has binding name '_tas__CreateRSAKeyPairResponse' for type '' */
#ifndef SOAP_TYPE__tas__CreateRSAKeyPairResponse
#define SOAP_TYPE__tas__CreateRSAKeyPairResponse (1060)
#endif

/* _tas__CreateRSAKeyPair has binding name '_tas__CreateRSAKeyPair' for type '' */
#ifndef SOAP_TYPE__tas__CreateRSAKeyPair
#define SOAP_TYPE__tas__CreateRSAKeyPair (1059)
#endif

/* _tas__GetServiceCapabilitiesResponse has binding name '_tas__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tas__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tas__GetServiceCapabilitiesResponse (1058)
#endif

/* _tas__GetServiceCapabilities has binding name '_tas__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tas__GetServiceCapabilities
#define SOAP_TYPE__tas__GetServiceCapabilities (1057)
#endif

/* tas__Capabilities has binding name 'tas__Capabilities' for type 'tas:Capabilities' */
#ifndef SOAP_TYPE_tas__Capabilities
#define SOAP_TYPE_tas__Capabilities (1056)
#endif

/* tas__TLSServerCapabilities has binding name 'tas__TLSServerCapabilities' for type 'tas:TLSServerCapabilities' */
#ifndef SOAP_TYPE_tas__TLSServerCapabilities
#define SOAP_TYPE_tas__TLSServerCapabilities (1055)
#endif

/* tas__KeystoreCapabilities has binding name 'tas__KeystoreCapabilities' for type 'tas:KeystoreCapabilities' */
#ifndef SOAP_TYPE_tas__KeystoreCapabilities
#define SOAP_TYPE_tas__KeystoreCapabilities (1054)
#endif

/* tas__CertPathValidationPolicy has binding name 'tas__CertPathValidationPolicy' for type 'tas:CertPathValidationPolicy' */
#ifndef SOAP_TYPE_tas__CertPathValidationPolicy
#define SOAP_TYPE_tas__CertPathValidationPolicy (1053)
#endif

/* tas__TrustAnchor has binding name 'tas__TrustAnchor' for type 'tas:TrustAnchor' */
#ifndef SOAP_TYPE_tas__TrustAnchor
#define SOAP_TYPE_tas__TrustAnchor (1052)
#endif

/* tas__CertPathValidationParameters has binding name 'tas__CertPathValidationParameters' for type 'tas:CertPathValidationParameters' */
#ifndef SOAP_TYPE_tas__CertPathValidationParameters
#define SOAP_TYPE_tas__CertPathValidationParameters (1051)
#endif

/* tas__CRL has binding name 'tas__CRL' for type 'tas:CRL' */
#ifndef SOAP_TYPE_tas__CRL
#define SOAP_TYPE_tas__CRL (1050)
#endif

/* tas__Dot1XConfiguration has binding name 'tas__Dot1XConfiguration' for type 'tas:Dot1XConfiguration' */
#ifndef SOAP_TYPE_tas__Dot1XConfiguration
#define SOAP_TYPE_tas__Dot1XConfiguration (1049)
#endif

/* tas__Dot1XStageExtension has binding name 'tas__Dot1XStageExtension' for type 'tas:Dot1XStageExtension' */
#ifndef SOAP_TYPE_tas__Dot1XStageExtension
#define SOAP_TYPE_tas__Dot1XStageExtension (1048)
#endif

/* tas__Dot1XStage has binding name 'tas__Dot1XStage' for type 'tas:Dot1XStage' */
#ifndef SOAP_TYPE_tas__Dot1XStage
#define SOAP_TYPE_tas__Dot1XStage (1047)
#endif

/* tas__Dot1XCapabilities has binding name 'tas__Dot1XCapabilities' for type 'tas:Dot1XCapabilities' */
#ifndef SOAP_TYPE_tas__Dot1XCapabilities
#define SOAP_TYPE_tas__Dot1XCapabilities (1046)
#endif

/* tas__PassphraseAttribute has binding name 'tas__PassphraseAttribute' for type 'tas:PassphraseAttribute' */
#ifndef SOAP_TYPE_tas__PassphraseAttribute
#define SOAP_TYPE_tas__PassphraseAttribute (1045)
#endif

/* tas__CertificationPath has binding name 'tas__CertificationPath' for type 'tas:CertificationPath' */
#ifndef SOAP_TYPE_tas__CertificationPath
#define SOAP_TYPE_tas__CertificationPath (1044)
#endif

/* tas__CertificateIDs has binding name 'tas__CertificateIDs' for type 'tas:CertificateIDs' */
#ifndef SOAP_TYPE_tas__CertificateIDs
#define SOAP_TYPE_tas__CertificateIDs (1043)
#endif

/* tas__X509Certificate has binding name 'tas__X509Certificate' for type 'tas:X509Certificate' */
#ifndef SOAP_TYPE_tas__X509Certificate
#define SOAP_TYPE_tas__X509Certificate (1042)
#endif

/* tas__X509v3Extension has binding name 'tas__X509v3Extension' for type 'tas:X509v3Extension' */
#ifndef SOAP_TYPE_tas__X509v3Extension
#define SOAP_TYPE_tas__X509v3Extension (1041)
#endif

/* tas__CSRAttribute has binding name 'tas__CSRAttribute' for type 'tas:CSRAttribute' */
#ifndef SOAP_TYPE_tas__CSRAttribute
#define SOAP_TYPE_tas__CSRAttribute (1040)
#endif

/* tas__BasicRequestAttribute has binding name 'tas__BasicRequestAttribute' for type 'tas:BasicRequestAttribute' */
#ifndef SOAP_TYPE_tas__BasicRequestAttribute
#define SOAP_TYPE_tas__BasicRequestAttribute (1039)
#endif

/* tas__AlgorithmIdentifier has binding name 'tas__AlgorithmIdentifier' for type 'tas:AlgorithmIdentifier' */
#ifndef SOAP_TYPE_tas__AlgorithmIdentifier
#define SOAP_TYPE_tas__AlgorithmIdentifier (1038)
#endif

/* tas__DistinguishedName has binding name 'tas__DistinguishedName' for type 'tas:DistinguishedName' */
#ifndef SOAP_TYPE_tas__DistinguishedName
#define SOAP_TYPE_tas__DistinguishedName (1037)
#endif

/* tas__MultiValuedRDN has binding name 'tas__MultiValuedRDN' for type 'tas:MultiValuedRDN' */
#ifndef SOAP_TYPE_tas__MultiValuedRDN
#define SOAP_TYPE_tas__MultiValuedRDN (1036)
#endif

/* tas__DNAttributeTypeAndValue has binding name 'tas__DNAttributeTypeAndValue' for type 'tas:DNAttributeTypeAndValue' */
#ifndef SOAP_TYPE_tas__DNAttributeTypeAndValue
#define SOAP_TYPE_tas__DNAttributeTypeAndValue (1035)
#endif

/* tas__KeyAttribute has binding name 'tas__KeyAttribute' for type 'tas:KeyAttribute' */
#ifndef SOAP_TYPE_tas__KeyAttribute
#define SOAP_TYPE_tas__KeyAttribute (1034)
#endif

/* _tptz__GetCompatibleConfigurationsResponse has binding name '_tptz__GetCompatibleConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse
#define SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse (1033)
#endif

/* _tptz__GetCompatibleConfigurations has binding name '_tptz__GetCompatibleConfigurations' for type '' */
#ifndef SOAP_TYPE__tptz__GetCompatibleConfigurations
#define SOAP_TYPE__tptz__GetCompatibleConfigurations (1032)
#endif

/* _tptz__RemovePresetTourResponse has binding name '_tptz__RemovePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__tptz__RemovePresetTourResponse
#define SOAP_TYPE__tptz__RemovePresetTourResponse (1031)
#endif

/* _tptz__RemovePresetTour has binding name '_tptz__RemovePresetTour' for type '' */
#ifndef SOAP_TYPE__tptz__RemovePresetTour
#define SOAP_TYPE__tptz__RemovePresetTour (1030)
#endif

/* _tptz__OperatePresetTourResponse has binding name '_tptz__OperatePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__tptz__OperatePresetTourResponse
#define SOAP_TYPE__tptz__OperatePresetTourResponse (1029)
#endif

/* _tptz__OperatePresetTour has binding name '_tptz__OperatePresetTour' for type '' */
#ifndef SOAP_TYPE__tptz__OperatePresetTour
#define SOAP_TYPE__tptz__OperatePresetTour (1028)
#endif

/* _tptz__ModifyPresetTourResponse has binding name '_tptz__ModifyPresetTourResponse' for type '' */
#ifndef SOAP_TYPE__tptz__ModifyPresetTourResponse
#define SOAP_TYPE__tptz__ModifyPresetTourResponse (1027)
#endif

/* _tptz__ModifyPresetTour has binding name '_tptz__ModifyPresetTour' for type '' */
#ifndef SOAP_TYPE__tptz__ModifyPresetTour
#define SOAP_TYPE__tptz__ModifyPresetTour (1026)
#endif

/* _tptz__CreatePresetTourResponse has binding name '_tptz__CreatePresetTourResponse' for type '' */
#ifndef SOAP_TYPE__tptz__CreatePresetTourResponse
#define SOAP_TYPE__tptz__CreatePresetTourResponse (1025)
#endif

/* _tptz__CreatePresetTour has binding name '_tptz__CreatePresetTour' for type '' */
#ifndef SOAP_TYPE__tptz__CreatePresetTour
#define SOAP_TYPE__tptz__CreatePresetTour (1024)
#endif

/* _tptz__GetPresetTourOptionsResponse has binding name '_tptz__GetPresetTourOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptionsResponse
#define SOAP_TYPE__tptz__GetPresetTourOptionsResponse (1023)
#endif

/* _tptz__GetPresetTourOptions has binding name '_tptz__GetPresetTourOptions' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetTourOptions
#define SOAP_TYPE__tptz__GetPresetTourOptions (1022)
#endif

/* _tptz__GetPresetTourResponse has binding name '_tptz__GetPresetTourResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetTourResponse
#define SOAP_TYPE__tptz__GetPresetTourResponse (1021)
#endif

/* _tptz__GetPresetTour has binding name '_tptz__GetPresetTour' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetTour
#define SOAP_TYPE__tptz__GetPresetTour (1020)
#endif

/* _tptz__GetPresetToursResponse has binding name '_tptz__GetPresetToursResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetToursResponse
#define SOAP_TYPE__tptz__GetPresetToursResponse (1019)
#endif

/* _tptz__GetPresetTours has binding name '_tptz__GetPresetTours' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetTours
#define SOAP_TYPE__tptz__GetPresetTours (1018)
#endif

/* _tptz__StopResponse has binding name '_tptz__StopResponse' for type '' */
#ifndef SOAP_TYPE__tptz__StopResponse
#define SOAP_TYPE__tptz__StopResponse (1017)
#endif

/* _tptz__Stop has binding name '_tptz__Stop' for type '' */
#ifndef SOAP_TYPE__tptz__Stop
#define SOAP_TYPE__tptz__Stop (1016)
#endif

/* _tptz__GeoMoveResponse has binding name '_tptz__GeoMoveResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GeoMoveResponse
#define SOAP_TYPE__tptz__GeoMoveResponse (1015)
#endif

/* _tptz__GeoMove has binding name '_tptz__GeoMove' for type '' */
#ifndef SOAP_TYPE__tptz__GeoMove
#define SOAP_TYPE__tptz__GeoMove (1014)
#endif

/* _tptz__AbsoluteMoveResponse has binding name '_tptz__AbsoluteMoveResponse' for type '' */
#ifndef SOAP_TYPE__tptz__AbsoluteMoveResponse
#define SOAP_TYPE__tptz__AbsoluteMoveResponse (1013)
#endif

/* _tptz__AbsoluteMove has binding name '_tptz__AbsoluteMove' for type '' */
#ifndef SOAP_TYPE__tptz__AbsoluteMove
#define SOAP_TYPE__tptz__AbsoluteMove (1012)
#endif

/* _tptz__RelativeMoveResponse has binding name '_tptz__RelativeMoveResponse' for type '' */
#ifndef SOAP_TYPE__tptz__RelativeMoveResponse
#define SOAP_TYPE__tptz__RelativeMoveResponse (1011)
#endif

/* _tptz__RelativeMove has binding name '_tptz__RelativeMove' for type '' */
#ifndef SOAP_TYPE__tptz__RelativeMove
#define SOAP_TYPE__tptz__RelativeMove (1010)
#endif

/* _tptz__ContinuousMoveResponse has binding name '_tptz__ContinuousMoveResponse' for type '' */
#ifndef SOAP_TYPE__tptz__ContinuousMoveResponse
#define SOAP_TYPE__tptz__ContinuousMoveResponse (1009)
#endif

/* _tptz__ContinuousMove has binding name '_tptz__ContinuousMove' for type '' */
#ifndef SOAP_TYPE__tptz__ContinuousMove
#define SOAP_TYPE__tptz__ContinuousMove (1008)
#endif

/* _tptz__SetHomePositionResponse has binding name '_tptz__SetHomePositionResponse' for type '' */
#ifndef SOAP_TYPE__tptz__SetHomePositionResponse
#define SOAP_TYPE__tptz__SetHomePositionResponse (1007)
#endif

/* _tptz__SetHomePosition has binding name '_tptz__SetHomePosition' for type '' */
#ifndef SOAP_TYPE__tptz__SetHomePosition
#define SOAP_TYPE__tptz__SetHomePosition (1006)
#endif

/* _tptz__GotoHomePositionResponse has binding name '_tptz__GotoHomePositionResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GotoHomePositionResponse
#define SOAP_TYPE__tptz__GotoHomePositionResponse (1005)
#endif

/* _tptz__GotoHomePosition has binding name '_tptz__GotoHomePosition' for type '' */
#ifndef SOAP_TYPE__tptz__GotoHomePosition
#define SOAP_TYPE__tptz__GotoHomePosition (1004)
#endif

/* _tptz__GetStatusResponse has binding name '_tptz__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetStatusResponse
#define SOAP_TYPE__tptz__GetStatusResponse (1003)
#endif

/* _tptz__GetStatus has binding name '_tptz__GetStatus' for type '' */
#ifndef SOAP_TYPE__tptz__GetStatus
#define SOAP_TYPE__tptz__GetStatus (1002)
#endif

/* _tptz__GotoPresetResponse has binding name '_tptz__GotoPresetResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GotoPresetResponse
#define SOAP_TYPE__tptz__GotoPresetResponse (1001)
#endif

/* _tptz__GotoPreset has binding name '_tptz__GotoPreset' for type '' */
#ifndef SOAP_TYPE__tptz__GotoPreset
#define SOAP_TYPE__tptz__GotoPreset (1000)
#endif

/* _tptz__RemovePresetResponse has binding name '_tptz__RemovePresetResponse' for type '' */
#ifndef SOAP_TYPE__tptz__RemovePresetResponse
#define SOAP_TYPE__tptz__RemovePresetResponse (999)
#endif

/* _tptz__RemovePreset has binding name '_tptz__RemovePreset' for type '' */
#ifndef SOAP_TYPE__tptz__RemovePreset
#define SOAP_TYPE__tptz__RemovePreset (998)
#endif

/* _tptz__SetPresetResponse has binding name '_tptz__SetPresetResponse' for type '' */
#ifndef SOAP_TYPE__tptz__SetPresetResponse
#define SOAP_TYPE__tptz__SetPresetResponse (997)
#endif

/* _tptz__SetPreset has binding name '_tptz__SetPreset' for type '' */
#ifndef SOAP_TYPE__tptz__SetPreset
#define SOAP_TYPE__tptz__SetPreset (996)
#endif

/* _tptz__GetPresetsResponse has binding name '_tptz__GetPresetsResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresetsResponse
#define SOAP_TYPE__tptz__GetPresetsResponse (995)
#endif

/* _tptz__GetPresets has binding name '_tptz__GetPresets' for type '' */
#ifndef SOAP_TYPE__tptz__GetPresets
#define SOAP_TYPE__tptz__GetPresets (994)
#endif

/* _tptz__SendAuxiliaryCommandResponse has binding name '_tptz__SendAuxiliaryCommandResponse' for type '' */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tptz__SendAuxiliaryCommandResponse (993)
#endif

/* _tptz__SendAuxiliaryCommand has binding name '_tptz__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE__tptz__SendAuxiliaryCommand
#define SOAP_TYPE__tptz__SendAuxiliaryCommand (992)
#endif

/* _tptz__GetConfigurationOptionsResponse has binding name '_tptz__GetConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptionsResponse
#define SOAP_TYPE__tptz__GetConfigurationOptionsResponse (991)
#endif

/* _tptz__GetConfigurationOptions has binding name '_tptz__GetConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfigurationOptions
#define SOAP_TYPE__tptz__GetConfigurationOptions (990)
#endif

/* _tptz__SetConfigurationResponse has binding name '_tptz__SetConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tptz__SetConfigurationResponse
#define SOAP_TYPE__tptz__SetConfigurationResponse (989)
#endif

/* _tptz__SetConfiguration has binding name '_tptz__SetConfiguration' for type '' */
#ifndef SOAP_TYPE__tptz__SetConfiguration
#define SOAP_TYPE__tptz__SetConfiguration (988)
#endif

/* _tptz__GetConfigurationResponse has binding name '_tptz__GetConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfigurationResponse
#define SOAP_TYPE__tptz__GetConfigurationResponse (987)
#endif

/* _tptz__GetConfiguration has binding name '_tptz__GetConfiguration' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfiguration
#define SOAP_TYPE__tptz__GetConfiguration (986)
#endif

/* _tptz__GetConfigurationsResponse has binding name '_tptz__GetConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfigurationsResponse
#define SOAP_TYPE__tptz__GetConfigurationsResponse (985)
#endif

/* _tptz__GetConfigurations has binding name '_tptz__GetConfigurations' for type '' */
#ifndef SOAP_TYPE__tptz__GetConfigurations
#define SOAP_TYPE__tptz__GetConfigurations (984)
#endif

/* _tptz__GetNodeResponse has binding name '_tptz__GetNodeResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetNodeResponse
#define SOAP_TYPE__tptz__GetNodeResponse (983)
#endif

/* _tptz__GetNode has binding name '_tptz__GetNode' for type '' */
#ifndef SOAP_TYPE__tptz__GetNode
#define SOAP_TYPE__tptz__GetNode (982)
#endif

/* _tptz__GetNodesResponse has binding name '_tptz__GetNodesResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetNodesResponse
#define SOAP_TYPE__tptz__GetNodesResponse (981)
#endif

/* _tptz__GetNodes has binding name '_tptz__GetNodes' for type '' */
#ifndef SOAP_TYPE__tptz__GetNodes
#define SOAP_TYPE__tptz__GetNodes (980)
#endif

/* _tptz__GetServiceCapabilitiesResponse has binding name '_tptz__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tptz__GetServiceCapabilitiesResponse (979)
#endif

/* _tptz__GetServiceCapabilities has binding name '_tptz__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tptz__GetServiceCapabilities
#define SOAP_TYPE__tptz__GetServiceCapabilities (978)
#endif

/* tptz__Capabilities has binding name 'tptz__Capabilities' for type 'tptz:Capabilities' */
#ifndef SOAP_TYPE_tptz__Capabilities
#define SOAP_TYPE_tptz__Capabilities (977)
#endif

/* _trt__DeleteOSDResponse has binding name '_trt__DeleteOSDResponse' for type '' */
#ifndef SOAP_TYPE__trt__DeleteOSDResponse
#define SOAP_TYPE__trt__DeleteOSDResponse (976)
#endif

/* _trt__DeleteOSD has binding name '_trt__DeleteOSD' for type '' */
#ifndef SOAP_TYPE__trt__DeleteOSD
#define SOAP_TYPE__trt__DeleteOSD (975)
#endif

/* _trt__CreateOSDResponse has binding name '_trt__CreateOSDResponse' for type '' */
#ifndef SOAP_TYPE__trt__CreateOSDResponse
#define SOAP_TYPE__trt__CreateOSDResponse (974)
#endif

/* _trt__CreateOSD has binding name '_trt__CreateOSD' for type '' */
#ifndef SOAP_TYPE__trt__CreateOSD
#define SOAP_TYPE__trt__CreateOSD (973)
#endif

/* _trt__GetOSDOptionsResponse has binding name '_trt__GetOSDOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetOSDOptionsResponse
#define SOAP_TYPE__trt__GetOSDOptionsResponse (972)
#endif

/* _trt__GetOSDOptions has binding name '_trt__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetOSDOptions
#define SOAP_TYPE__trt__GetOSDOptions (971)
#endif

/* _trt__SetOSDResponse has binding name '_trt__SetOSDResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetOSDResponse
#define SOAP_TYPE__trt__SetOSDResponse (970)
#endif

/* _trt__SetOSD has binding name '_trt__SetOSD' for type '' */
#ifndef SOAP_TYPE__trt__SetOSD
#define SOAP_TYPE__trt__SetOSD (969)
#endif

/* _trt__GetOSDResponse has binding name '_trt__GetOSDResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetOSDResponse
#define SOAP_TYPE__trt__GetOSDResponse (968)
#endif

/* _trt__GetOSD has binding name '_trt__GetOSD' for type '' */
#ifndef SOAP_TYPE__trt__GetOSD
#define SOAP_TYPE__trt__GetOSD (967)
#endif

/* _trt__GetOSDsResponse has binding name '_trt__GetOSDsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetOSDsResponse
#define SOAP_TYPE__trt__GetOSDsResponse (966)
#endif

/* _trt__GetOSDs has binding name '_trt__GetOSDs' for type '' */
#ifndef SOAP_TYPE__trt__GetOSDs
#define SOAP_TYPE__trt__GetOSDs (965)
#endif

/* _trt__SetVideoSourceModeResponse has binding name '_trt__SetVideoSourceModeResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoSourceModeResponse
#define SOAP_TYPE__trt__SetVideoSourceModeResponse (964)
#endif

/* _trt__SetVideoSourceMode has binding name '_trt__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoSourceMode
#define SOAP_TYPE__trt__SetVideoSourceMode (963)
#endif

/* _trt__GetVideoSourceModesResponse has binding name '_trt__GetVideoSourceModesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceModesResponse
#define SOAP_TYPE__trt__GetVideoSourceModesResponse (962)
#endif

/* _trt__GetVideoSourceModes has binding name '_trt__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceModes
#define SOAP_TYPE__trt__GetVideoSourceModes (961)
#endif

/* _trt__GetSnapshotUriResponse has binding name '_trt__GetSnapshotUriResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetSnapshotUriResponse
#define SOAP_TYPE__trt__GetSnapshotUriResponse (960)
#endif

/* _trt__GetSnapshotUri has binding name '_trt__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE__trt__GetSnapshotUri
#define SOAP_TYPE__trt__GetSnapshotUri (959)
#endif

/* _trt__SetSynchronizationPointResponse has binding name '_trt__SetSynchronizationPointResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetSynchronizationPointResponse
#define SOAP_TYPE__trt__SetSynchronizationPointResponse (958)
#endif

/* _trt__SetSynchronizationPoint has binding name '_trt__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE__trt__SetSynchronizationPoint
#define SOAP_TYPE__trt__SetSynchronizationPoint (957)
#endif

/* _trt__StopMulticastStreamingResponse has binding name '_trt__StopMulticastStreamingResponse' for type '' */
#ifndef SOAP_TYPE__trt__StopMulticastStreamingResponse
#define SOAP_TYPE__trt__StopMulticastStreamingResponse (956)
#endif

/* _trt__StopMulticastStreaming has binding name '_trt__StopMulticastStreaming' for type '' */
#ifndef SOAP_TYPE__trt__StopMulticastStreaming
#define SOAP_TYPE__trt__StopMulticastStreaming (955)
#endif

/* _trt__StartMulticastStreamingResponse has binding name '_trt__StartMulticastStreamingResponse' for type '' */
#ifndef SOAP_TYPE__trt__StartMulticastStreamingResponse
#define SOAP_TYPE__trt__StartMulticastStreamingResponse (954)
#endif

/* _trt__StartMulticastStreaming has binding name '_trt__StartMulticastStreaming' for type '' */
#ifndef SOAP_TYPE__trt__StartMulticastStreaming
#define SOAP_TYPE__trt__StartMulticastStreaming (953)
#endif

/* _trt__GetStreamUriResponse has binding name '_trt__GetStreamUriResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetStreamUriResponse
#define SOAP_TYPE__trt__GetStreamUriResponse (952)
#endif

/* _trt__GetStreamUri has binding name '_trt__GetStreamUri' for type '' */
#ifndef SOAP_TYPE__trt__GetStreamUri
#define SOAP_TYPE__trt__GetStreamUri (951)
#endif

/* _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse has binding name '_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse (950)
#endif

/* _trt__GetGuaranteedNumberOfVideoEncoderInstances has binding name '_trt__GetGuaranteedNumberOfVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances (949)
#endif

/* _trt__GetAudioDecoderConfigurationOptionsResponse has binding name '_trt__GetAudioDecoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse (948)
#endif

/* _trt__GetAudioDecoderConfigurationOptions has binding name '_trt__GetAudioDecoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions (947)
#endif

/* _trt__GetAudioOutputConfigurationOptionsResponse has binding name '_trt__GetAudioOutputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse (946)
#endif

/* _trt__GetAudioOutputConfigurationOptions has binding name '_trt__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__trt__GetAudioOutputConfigurationOptions (945)
#endif

/* _trt__GetMetadataConfigurationOptionsResponse has binding name '_trt__GetMetadataConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse (944)
#endif

/* _trt__GetMetadataConfigurationOptions has binding name '_trt__GetMetadataConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationOptions
#define SOAP_TYPE__trt__GetMetadataConfigurationOptions (943)
#endif

/* _trt__GetAudioEncoderConfigurationOptionsResponse has binding name '_trt__GetAudioEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse (942)
#endif

/* _trt__GetAudioEncoderConfigurationOptions has binding name '_trt__GetAudioEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions (941)
#endif

/* _trt__GetAudioSourceConfigurationOptionsResponse has binding name '_trt__GetAudioSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse (940)
#endif

/* _trt__GetAudioSourceConfigurationOptions has binding name '_trt__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__trt__GetAudioSourceConfigurationOptions (939)
#endif

/* _trt__GetVideoEncoderConfigurationOptionsResponse has binding name '_trt__GetVideoEncoderConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse (938)
#endif

/* _trt__GetVideoEncoderConfigurationOptions has binding name '_trt__GetVideoEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions (937)
#endif

/* _trt__GetVideoSourceConfigurationOptionsResponse has binding name '_trt__GetVideoSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse (936)
#endif

/* _trt__GetVideoSourceConfigurationOptions has binding name '_trt__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__trt__GetVideoSourceConfigurationOptions (935)
#endif

/* _trt__SetAudioDecoderConfigurationResponse has binding name '_trt__SetAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse (934)
#endif

/* _trt__SetAudioDecoderConfiguration has binding name '_trt__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioDecoderConfiguration
#define SOAP_TYPE__trt__SetAudioDecoderConfiguration (933)
#endif

/* _trt__SetAudioOutputConfigurationResponse has binding name '_trt__SetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__SetAudioOutputConfigurationResponse (932)
#endif

/* _trt__SetAudioOutputConfiguration has binding name '_trt__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioOutputConfiguration
#define SOAP_TYPE__trt__SetAudioOutputConfiguration (931)
#endif

/* _trt__SetMetadataConfigurationResponse has binding name '_trt__SetMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetMetadataConfigurationResponse
#define SOAP_TYPE__trt__SetMetadataConfigurationResponse (930)
#endif

/* _trt__SetMetadataConfiguration has binding name '_trt__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetMetadataConfiguration
#define SOAP_TYPE__trt__SetMetadataConfiguration (929)
#endif

/* _trt__SetVideoAnalyticsConfigurationResponse has binding name '_trt__SetVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse (928)
#endif

/* _trt__SetVideoAnalyticsConfiguration has binding name '_trt__SetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__SetVideoAnalyticsConfiguration (927)
#endif

/* _trt__SetAudioSourceConfigurationResponse has binding name '_trt__SetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__SetAudioSourceConfigurationResponse (926)
#endif

/* _trt__SetAudioSourceConfiguration has binding name '_trt__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioSourceConfiguration
#define SOAP_TYPE__trt__SetAudioSourceConfiguration (925)
#endif

/* _trt__SetAudioEncoderConfigurationResponse has binding name '_trt__SetAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse (924)
#endif

/* _trt__SetAudioEncoderConfiguration has binding name '_trt__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetAudioEncoderConfiguration
#define SOAP_TYPE__trt__SetAudioEncoderConfiguration (923)
#endif

/* _trt__SetVideoSourceConfigurationResponse has binding name '_trt__SetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__SetVideoSourceConfigurationResponse (922)
#endif

/* _trt__SetVideoSourceConfiguration has binding name '_trt__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoSourceConfiguration
#define SOAP_TYPE__trt__SetVideoSourceConfiguration (921)
#endif

/* _trt__SetVideoEncoderConfigurationResponse has binding name '_trt__SetVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse (920)
#endif

/* _trt__SetVideoEncoderConfiguration has binding name '_trt__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__SetVideoEncoderConfiguration
#define SOAP_TYPE__trt__SetVideoEncoderConfiguration (919)
#endif

/* _trt__GetCompatibleAudioDecoderConfigurationsResponse has binding name '_trt__GetCompatibleAudioDecoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse (918)
#endif

/* _trt__GetCompatibleAudioDecoderConfigurations has binding name '_trt__GetCompatibleAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations (917)
#endif

/* _trt__GetCompatibleAudioOutputConfigurationsResponse has binding name '_trt__GetCompatibleAudioOutputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse (916)
#endif

/* _trt__GetCompatibleAudioOutputConfigurations has binding name '_trt__GetCompatibleAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations (915)
#endif

/* _trt__GetCompatibleMetadataConfigurationsResponse has binding name '_trt__GetCompatibleMetadataConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse (914)
#endif

/* _trt__GetCompatibleMetadataConfigurations has binding name '_trt__GetCompatibleMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__trt__GetCompatibleMetadataConfigurations (913)
#endif

/* _trt__GetCompatibleVideoAnalyticsConfigurationsResponse has binding name '_trt__GetCompatibleVideoAnalyticsConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse (912)
#endif

/* _trt__GetCompatibleVideoAnalyticsConfigurations has binding name '_trt__GetCompatibleVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations (911)
#endif

/* _trt__GetCompatibleAudioSourceConfigurationsResponse has binding name '_trt__GetCompatibleAudioSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse (910)
#endif

/* _trt__GetCompatibleAudioSourceConfigurations has binding name '_trt__GetCompatibleAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations (909)
#endif

/* _trt__GetCompatibleAudioEncoderConfigurationsResponse has binding name '_trt__GetCompatibleAudioEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse (908)
#endif

/* _trt__GetCompatibleAudioEncoderConfigurations has binding name '_trt__GetCompatibleAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations (907)
#endif

/* _trt__GetCompatibleVideoSourceConfigurationsResponse has binding name '_trt__GetCompatibleVideoSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse (906)
#endif

/* _trt__GetCompatibleVideoSourceConfigurations has binding name '_trt__GetCompatibleVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations (905)
#endif

/* _trt__GetCompatibleVideoEncoderConfigurationsResponse has binding name '_trt__GetCompatibleVideoEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse (904)
#endif

/* _trt__GetCompatibleVideoEncoderConfigurations has binding name '_trt__GetCompatibleVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations (903)
#endif

/* _trt__GetAudioDecoderConfigurationResponse has binding name '_trt__GetAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse (902)
#endif

/* _trt__GetAudioDecoderConfiguration has binding name '_trt__GetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfiguration
#define SOAP_TYPE__trt__GetAudioDecoderConfiguration (901)
#endif

/* _trt__GetAudioOutputConfigurationResponse has binding name '_trt__GetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationResponse (900)
#endif

/* _trt__GetAudioOutputConfiguration has binding name '_trt__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfiguration
#define SOAP_TYPE__trt__GetAudioOutputConfiguration (899)
#endif

/* _trt__GetMetadataConfigurationResponse has binding name '_trt__GetMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationResponse (898)
#endif

/* _trt__GetMetadataConfiguration has binding name '_trt__GetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfiguration
#define SOAP_TYPE__trt__GetMetadataConfiguration (897)
#endif

/* _trt__GetVideoAnalyticsConfigurationResponse has binding name '_trt__GetVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse (896)
#endif

/* _trt__GetVideoAnalyticsConfiguration has binding name '_trt__GetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__GetVideoAnalyticsConfiguration (895)
#endif

/* _trt__GetAudioEncoderConfigurationResponse has binding name '_trt__GetAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse (894)
#endif

/* _trt__GetAudioEncoderConfiguration has binding name '_trt__GetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfiguration
#define SOAP_TYPE__trt__GetAudioEncoderConfiguration (893)
#endif

/* _trt__GetAudioSourceConfigurationResponse has binding name '_trt__GetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationResponse (892)
#endif

/* _trt__GetAudioSourceConfiguration has binding name '_trt__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfiguration
#define SOAP_TYPE__trt__GetAudioSourceConfiguration (891)
#endif

/* _trt__GetVideoEncoderConfigurationResponse has binding name '_trt__GetVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse (890)
#endif

/* _trt__GetVideoEncoderConfiguration has binding name '_trt__GetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfiguration
#define SOAP_TYPE__trt__GetVideoEncoderConfiguration (889)
#endif

/* _trt__GetVideoSourceConfigurationResponse has binding name '_trt__GetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationResponse (888)
#endif

/* _trt__GetVideoSourceConfiguration has binding name '_trt__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfiguration
#define SOAP_TYPE__trt__GetVideoSourceConfiguration (887)
#endif

/* _trt__GetAudioDecoderConfigurationsResponse has binding name '_trt__GetAudioDecoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse (886)
#endif

/* _trt__GetAudioDecoderConfigurations has binding name '_trt__GetAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioDecoderConfigurations
#define SOAP_TYPE__trt__GetAudioDecoderConfigurations (885)
#endif

/* _trt__GetAudioOutputConfigurationsResponse has binding name '_trt__GetAudioOutputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse (884)
#endif

/* _trt__GetAudioOutputConfigurations has binding name '_trt__GetAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputConfigurations
#define SOAP_TYPE__trt__GetAudioOutputConfigurations (883)
#endif

/* _trt__GetMetadataConfigurationsResponse has binding name '_trt__GetMetadataConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurationsResponse
#define SOAP_TYPE__trt__GetMetadataConfigurationsResponse (882)
#endif

/* _trt__GetMetadataConfigurations has binding name '_trt__GetMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetMetadataConfigurations
#define SOAP_TYPE__trt__GetMetadataConfigurations (881)
#endif

/* _trt__GetVideoAnalyticsConfigurationsResponse has binding name '_trt__GetVideoAnalyticsConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse (880)
#endif

/* _trt__GetVideoAnalyticsConfigurations has binding name '_trt__GetVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__trt__GetVideoAnalyticsConfigurations (879)
#endif

/* _trt__GetAudioSourceConfigurationsResponse has binding name '_trt__GetAudioSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse (878)
#endif

/* _trt__GetAudioSourceConfigurations has binding name '_trt__GetAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourceConfigurations
#define SOAP_TYPE__trt__GetAudioSourceConfigurations (877)
#endif

/* _trt__GetAudioEncoderConfigurationsResponse has binding name '_trt__GetAudioEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse (876)
#endif

/* _trt__GetAudioEncoderConfigurations has binding name '_trt__GetAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioEncoderConfigurations
#define SOAP_TYPE__trt__GetAudioEncoderConfigurations (875)
#endif

/* _trt__GetVideoSourceConfigurationsResponse has binding name '_trt__GetVideoSourceConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse (874)
#endif

/* _trt__GetVideoSourceConfigurations has binding name '_trt__GetVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourceConfigurations
#define SOAP_TYPE__trt__GetVideoSourceConfigurations (873)
#endif

/* _trt__GetVideoEncoderConfigurationsResponse has binding name '_trt__GetVideoEncoderConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse (872)
#endif

/* _trt__GetVideoEncoderConfigurations has binding name '_trt__GetVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoEncoderConfigurations
#define SOAP_TYPE__trt__GetVideoEncoderConfigurations (871)
#endif

/* _trt__DeleteProfileResponse has binding name '_trt__DeleteProfileResponse' for type '' */
#ifndef SOAP_TYPE__trt__DeleteProfileResponse
#define SOAP_TYPE__trt__DeleteProfileResponse (870)
#endif

/* _trt__DeleteProfile has binding name '_trt__DeleteProfile' for type '' */
#ifndef SOAP_TYPE__trt__DeleteProfile
#define SOAP_TYPE__trt__DeleteProfile (869)
#endif

/* _trt__RemoveAudioDecoderConfigurationResponse has binding name '_trt__RemoveAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse (868)
#endif

/* _trt__RemoveAudioDecoderConfiguration has binding name '_trt__RemoveAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioDecoderConfiguration (867)
#endif

/* _trt__AddAudioDecoderConfigurationResponse has binding name '_trt__AddAudioDecoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse (866)
#endif

/* _trt__AddAudioDecoderConfiguration has binding name '_trt__AddAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioDecoderConfiguration
#define SOAP_TYPE__trt__AddAudioDecoderConfiguration (865)
#endif

/* _trt__RemoveAudioOutputConfigurationResponse has binding name '_trt__RemoveAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse (864)
#endif

/* _trt__RemoveAudioOutputConfiguration has binding name '_trt__RemoveAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE__trt__RemoveAudioOutputConfiguration (863)
#endif

/* _trt__AddAudioOutputConfigurationResponse has binding name '_trt__AddAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__trt__AddAudioOutputConfigurationResponse (862)
#endif

/* _trt__AddAudioOutputConfiguration has binding name '_trt__AddAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioOutputConfiguration
#define SOAP_TYPE__trt__AddAudioOutputConfiguration (861)
#endif

/* _trt__RemoveMetadataConfigurationResponse has binding name '_trt__RemoveMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__trt__RemoveMetadataConfigurationResponse (860)
#endif

/* _trt__RemoveMetadataConfiguration has binding name '_trt__RemoveMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveMetadataConfiguration
#define SOAP_TYPE__trt__RemoveMetadataConfiguration (859)
#endif

/* _trt__AddMetadataConfigurationResponse has binding name '_trt__AddMetadataConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddMetadataConfigurationResponse
#define SOAP_TYPE__trt__AddMetadataConfigurationResponse (858)
#endif

/* _trt__AddMetadataConfiguration has binding name '_trt__AddMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddMetadataConfiguration
#define SOAP_TYPE__trt__AddMetadataConfiguration (857)
#endif

/* _trt__RemoveVideoAnalyticsConfigurationResponse has binding name '_trt__RemoveVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse (856)
#endif

/* _trt__RemoveVideoAnalyticsConfiguration has binding name '_trt__RemoveVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration (855)
#endif

/* _trt__AddVideoAnalyticsConfigurationResponse has binding name '_trt__AddVideoAnalyticsConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse (854)
#endif

/* _trt__AddVideoAnalyticsConfiguration has binding name '_trt__AddVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__trt__AddVideoAnalyticsConfiguration (853)
#endif

/* _trt__RemovePTZConfigurationResponse has binding name '_trt__RemovePTZConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemovePTZConfigurationResponse
#define SOAP_TYPE__trt__RemovePTZConfigurationResponse (852)
#endif

/* _trt__RemovePTZConfiguration has binding name '_trt__RemovePTZConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemovePTZConfiguration
#define SOAP_TYPE__trt__RemovePTZConfiguration (851)
#endif

/* _trt__AddPTZConfigurationResponse has binding name '_trt__AddPTZConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddPTZConfigurationResponse
#define SOAP_TYPE__trt__AddPTZConfigurationResponse (850)
#endif

/* _trt__AddPTZConfiguration has binding name '_trt__AddPTZConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddPTZConfiguration
#define SOAP_TYPE__trt__AddPTZConfiguration (849)
#endif

/* _trt__RemoveAudioSourceConfigurationResponse has binding name '_trt__RemoveAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse (848)
#endif

/* _trt__RemoveAudioSourceConfiguration has binding name '_trt__RemoveAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE__trt__RemoveAudioSourceConfiguration (847)
#endif

/* _trt__AddAudioSourceConfigurationResponse has binding name '_trt__AddAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__trt__AddAudioSourceConfigurationResponse (846)
#endif

/* _trt__AddAudioSourceConfiguration has binding name '_trt__AddAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioSourceConfiguration
#define SOAP_TYPE__trt__AddAudioSourceConfiguration (845)
#endif

/* _trt__RemoveAudioEncoderConfigurationResponse has binding name '_trt__RemoveAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse (844)
#endif

/* _trt__RemoveAudioEncoderConfiguration has binding name '_trt__RemoveAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__trt__RemoveAudioEncoderConfiguration (843)
#endif

/* _trt__AddAudioEncoderConfigurationResponse has binding name '_trt__AddAudioEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse (842)
#endif

/* _trt__AddAudioEncoderConfiguration has binding name '_trt__AddAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddAudioEncoderConfiguration
#define SOAP_TYPE__trt__AddAudioEncoderConfiguration (841)
#endif

/* _trt__RemoveVideoSourceConfigurationResponse has binding name '_trt__RemoveVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse (840)
#endif

/* _trt__RemoveVideoSourceConfiguration has binding name '_trt__RemoveVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE__trt__RemoveVideoSourceConfiguration (839)
#endif

/* _trt__AddVideoSourceConfigurationResponse has binding name '_trt__AddVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__trt__AddVideoSourceConfigurationResponse (838)
#endif

/* _trt__AddVideoSourceConfiguration has binding name '_trt__AddVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoSourceConfiguration
#define SOAP_TYPE__trt__AddVideoSourceConfiguration (837)
#endif

/* _trt__RemoveVideoEncoderConfigurationResponse has binding name '_trt__RemoveVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse (836)
#endif

/* _trt__RemoveVideoEncoderConfiguration has binding name '_trt__RemoveVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__trt__RemoveVideoEncoderConfiguration (835)
#endif

/* _trt__AddVideoEncoderConfigurationResponse has binding name '_trt__AddVideoEncoderConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse (834)
#endif

/* _trt__AddVideoEncoderConfiguration has binding name '_trt__AddVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE__trt__AddVideoEncoderConfiguration
#define SOAP_TYPE__trt__AddVideoEncoderConfiguration (833)
#endif

/* _trt__GetProfilesResponse has binding name '_trt__GetProfilesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetProfilesResponse
#define SOAP_TYPE__trt__GetProfilesResponse (832)
#endif

/* _trt__GetProfiles has binding name '_trt__GetProfiles' for type '' */
#ifndef SOAP_TYPE__trt__GetProfiles
#define SOAP_TYPE__trt__GetProfiles (831)
#endif

/* _trt__GetProfileResponse has binding name '_trt__GetProfileResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetProfileResponse
#define SOAP_TYPE__trt__GetProfileResponse (830)
#endif

/* _trt__GetProfile has binding name '_trt__GetProfile' for type '' */
#ifndef SOAP_TYPE__trt__GetProfile
#define SOAP_TYPE__trt__GetProfile (829)
#endif

/* _trt__CreateProfileResponse has binding name '_trt__CreateProfileResponse' for type '' */
#ifndef SOAP_TYPE__trt__CreateProfileResponse
#define SOAP_TYPE__trt__CreateProfileResponse (828)
#endif

/* _trt__CreateProfile has binding name '_trt__CreateProfile' for type '' */
#ifndef SOAP_TYPE__trt__CreateProfile
#define SOAP_TYPE__trt__CreateProfile (827)
#endif

/* _trt__GetAudioOutputsResponse has binding name '_trt__GetAudioOutputsResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputsResponse
#define SOAP_TYPE__trt__GetAudioOutputsResponse (826)
#endif

/* _trt__GetAudioOutputs has binding name '_trt__GetAudioOutputs' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioOutputs
#define SOAP_TYPE__trt__GetAudioOutputs (825)
#endif

/* _trt__GetAudioSourcesResponse has binding name '_trt__GetAudioSourcesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSourcesResponse
#define SOAP_TYPE__trt__GetAudioSourcesResponse (824)
#endif

/* _trt__GetAudioSources has binding name '_trt__GetAudioSources' for type '' */
#ifndef SOAP_TYPE__trt__GetAudioSources
#define SOAP_TYPE__trt__GetAudioSources (823)
#endif

/* _trt__GetVideoSourcesResponse has binding name '_trt__GetVideoSourcesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSourcesResponse
#define SOAP_TYPE__trt__GetVideoSourcesResponse (822)
#endif

/* _trt__GetVideoSources has binding name '_trt__GetVideoSources' for type '' */
#ifndef SOAP_TYPE__trt__GetVideoSources
#define SOAP_TYPE__trt__GetVideoSources (821)
#endif

/* _trt__GetServiceCapabilitiesResponse has binding name '_trt__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__trt__GetServiceCapabilitiesResponse
#define SOAP_TYPE__trt__GetServiceCapabilitiesResponse (820)
#endif

/* _trt__GetServiceCapabilities has binding name '_trt__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__trt__GetServiceCapabilities
#define SOAP_TYPE__trt__GetServiceCapabilities (819)
#endif

/* trt__VideoSourceModeExtension has binding name 'trt__VideoSourceModeExtension' for type 'trt:VideoSourceModeExtension' */
#ifndef SOAP_TYPE_trt__VideoSourceModeExtension
#define SOAP_TYPE_trt__VideoSourceModeExtension (818)
#endif

/* trt__VideoSourceMode has binding name 'trt__VideoSourceMode' for type 'trt:VideoSourceMode' */
#ifndef SOAP_TYPE_trt__VideoSourceMode
#define SOAP_TYPE_trt__VideoSourceMode (817)
#endif

/* trt__StreamingCapabilities has binding name 'trt__StreamingCapabilities' for type 'trt:StreamingCapabilities' */
#ifndef SOAP_TYPE_trt__StreamingCapabilities
#define SOAP_TYPE_trt__StreamingCapabilities (816)
#endif

/* trt__ProfileCapabilities has binding name 'trt__ProfileCapabilities' for type 'trt:ProfileCapabilities' */
#ifndef SOAP_TYPE_trt__ProfileCapabilities
#define SOAP_TYPE_trt__ProfileCapabilities (815)
#endif

/* trt__Capabilities has binding name 'trt__Capabilities' for type 'trt:Capabilities' */
#ifndef SOAP_TYPE_trt__Capabilities
#define SOAP_TYPE_trt__Capabilities (814)
#endif

/* _timg__SetCurrentPresetResponse has binding name '_timg__SetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__timg__SetCurrentPresetResponse
#define SOAP_TYPE__timg__SetCurrentPresetResponse (813)
#endif

/* _timg__SetCurrentPreset has binding name '_timg__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__timg__SetCurrentPreset
#define SOAP_TYPE__timg__SetCurrentPreset (812)
#endif

/* _timg__GetCurrentPresetResponse has binding name '_timg__GetCurrentPresetResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetCurrentPresetResponse
#define SOAP_TYPE__timg__GetCurrentPresetResponse (811)
#endif

/* _timg__GetCurrentPreset has binding name '_timg__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE__timg__GetCurrentPreset
#define SOAP_TYPE__timg__GetCurrentPreset (810)
#endif

/* _timg__GetPresetsResponse has binding name '_timg__GetPresetsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetPresetsResponse
#define SOAP_TYPE__timg__GetPresetsResponse (809)
#endif

/* _timg__GetPresets has binding name '_timg__GetPresets' for type '' */
#ifndef SOAP_TYPE__timg__GetPresets
#define SOAP_TYPE__timg__GetPresets (808)
#endif

/* _timg__GetStatusResponse has binding name '_timg__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetStatusResponse
#define SOAP_TYPE__timg__GetStatusResponse (807)
#endif

/* _timg__GetStatus has binding name '_timg__GetStatus' for type '' */
#ifndef SOAP_TYPE__timg__GetStatus
#define SOAP_TYPE__timg__GetStatus (806)
#endif

/* _timg__StopResponse has binding name '_timg__StopResponse' for type '' */
#ifndef SOAP_TYPE__timg__StopResponse
#define SOAP_TYPE__timg__StopResponse (805)
#endif

/* _timg__Stop has binding name '_timg__Stop' for type '' */
#ifndef SOAP_TYPE__timg__Stop
#define SOAP_TYPE__timg__Stop (804)
#endif

/* _timg__GetMoveOptionsResponse has binding name '_timg__GetMoveOptionsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetMoveOptionsResponse
#define SOAP_TYPE__timg__GetMoveOptionsResponse (803)
#endif

/* _timg__GetMoveOptions has binding name '_timg__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE__timg__GetMoveOptions
#define SOAP_TYPE__timg__GetMoveOptions (802)
#endif

/* _timg__MoveResponse has binding name '_timg__MoveResponse' for type '' */
#ifndef SOAP_TYPE__timg__MoveResponse
#define SOAP_TYPE__timg__MoveResponse (801)
#endif

/* _timg__Move has binding name '_timg__Move' for type '' */
#ifndef SOAP_TYPE__timg__Move
#define SOAP_TYPE__timg__Move (800)
#endif

/* _timg__GetOptionsResponse has binding name '_timg__GetOptionsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetOptionsResponse
#define SOAP_TYPE__timg__GetOptionsResponse (799)
#endif

/* _timg__GetOptions has binding name '_timg__GetOptions' for type '' */
#ifndef SOAP_TYPE__timg__GetOptions
#define SOAP_TYPE__timg__GetOptions (798)
#endif

/* _timg__SetImagingSettingsResponse has binding name '_timg__SetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__timg__SetImagingSettingsResponse
#define SOAP_TYPE__timg__SetImagingSettingsResponse (797)
#endif

/* _timg__SetImagingSettings has binding name '_timg__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE__timg__SetImagingSettings
#define SOAP_TYPE__timg__SetImagingSettings (796)
#endif

/* _timg__GetImagingSettingsResponse has binding name '_timg__GetImagingSettingsResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetImagingSettingsResponse
#define SOAP_TYPE__timg__GetImagingSettingsResponse (795)
#endif

/* _timg__GetImagingSettings has binding name '_timg__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE__timg__GetImagingSettings
#define SOAP_TYPE__timg__GetImagingSettings (794)
#endif

/* _timg__GetServiceCapabilitiesResponse has binding name '_timg__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__timg__GetServiceCapabilitiesResponse
#define SOAP_TYPE__timg__GetServiceCapabilitiesResponse (793)
#endif

/* _timg__GetServiceCapabilities has binding name '_timg__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__timg__GetServiceCapabilities
#define SOAP_TYPE__timg__GetServiceCapabilities (792)
#endif

/* timg__ImagingPreset has binding name 'timg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_timg__ImagingPreset
#define SOAP_TYPE_timg__ImagingPreset (791)
#endif

/* timg__Capabilities has binding name 'timg__Capabilities' for type 'timg:Capabilities' */
#ifndef SOAP_TYPE_timg__Capabilities
#define SOAP_TYPE_timg__Capabilities (790)
#endif

/* _tmd__SendReceiveSerialCommandResponse has binding name '_tmd__SendReceiveSerialCommandResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommandResponse
#define SOAP_TYPE__tmd__SendReceiveSerialCommandResponse (789)
#endif

/* _tmd__SendReceiveSerialCommand has binding name '_tmd__SendReceiveSerialCommand' for type '' */
#ifndef SOAP_TYPE__tmd__SendReceiveSerialCommand
#define SOAP_TYPE__tmd__SendReceiveSerialCommand (788)
#endif

/* _tmd__GetSerialPortConfigurationOptionsResponse has binding name '_tmd__GetSerialPortConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse (787)
#endif

/* _tmd__GetSerialPortConfigurationOptions has binding name '_tmd__GetSerialPortConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE__tmd__GetSerialPortConfigurationOptions (786)
#endif

/* _tmd__SetSerialPortConfigurationResponse has binding name '_tmd__SetSerialPortConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__SetSerialPortConfigurationResponse (785)
#endif

/* _tmd__SetSerialPortConfiguration has binding name '_tmd__SetSerialPortConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__SetSerialPortConfiguration
#define SOAP_TYPE__tmd__SetSerialPortConfiguration (784)
#endif

/* _tmd__GetSerialPortConfigurationResponse has binding name '_tmd__GetSerialPortConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfigurationResponse
#define SOAP_TYPE__tmd__GetSerialPortConfigurationResponse (783)
#endif

/* _tmd__GetSerialPortConfiguration has binding name '_tmd__GetSerialPortConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPortConfiguration
#define SOAP_TYPE__tmd__GetSerialPortConfiguration (782)
#endif

/* _tmd__GetSerialPortsResponse has binding name '_tmd__GetSerialPortsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPortsResponse
#define SOAP_TYPE__tmd__GetSerialPortsResponse (781)
#endif

/* _tmd__GetSerialPorts has binding name '_tmd__GetSerialPorts' for type '' */
#ifndef SOAP_TYPE__tmd__GetSerialPorts
#define SOAP_TYPE__tmd__GetSerialPorts (780)
#endif

/* _tmd__SetDigitalInputConfigurationsResponse has binding name '_tmd__SetDigitalInputConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse
#define SOAP_TYPE__tmd__SetDigitalInputConfigurationsResponse (779)
#endif

/* _tmd__SetDigitalInputConfigurations has binding name '_tmd__SetDigitalInputConfigurations' for type '' */
#ifndef SOAP_TYPE__tmd__SetDigitalInputConfigurations
#define SOAP_TYPE__tmd__SetDigitalInputConfigurations (778)
#endif

/* _tmd__GetDigitalInputConfigurationOptionsResponse has binding name '_tmd__GetDigitalInputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptionsResponse (777)
#endif

/* _tmd__GetDigitalInputConfigurationOptions has binding name '_tmd__GetDigitalInputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE__tmd__GetDigitalInputConfigurationOptions (776)
#endif

/* _tmd__GetDigitalInputsResponse has binding name '_tmd__GetDigitalInputsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetDigitalInputsResponse
#define SOAP_TYPE__tmd__GetDigitalInputsResponse (775)
#endif

/* _tmd__GetDigitalInputs has binding name '_tmd__GetDigitalInputs' for type '' */
#ifndef SOAP_TYPE__tmd__GetDigitalInputs
#define SOAP_TYPE__tmd__GetDigitalInputs (774)
#endif

/* _tmd__SetRelayOutputSettingsResponse has binding name '_tmd__SetRelayOutputSettingsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tmd__SetRelayOutputSettingsResponse (773)
#endif

/* _tmd__SetRelayOutputSettings has binding name '_tmd__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE__tmd__SetRelayOutputSettings
#define SOAP_TYPE__tmd__SetRelayOutputSettings (772)
#endif

/* _tmd__GetAudioOutputConfigurationOptionsResponse has binding name '_tmd__GetAudioOutputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse (771)
#endif

/* _tmd__GetAudioOutputConfigurationOptions has binding name '_tmd__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions (770)
#endif

/* _tmd__GetAudioSourceConfigurationOptionsResponse has binding name '_tmd__GetAudioSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse (769)
#endif

/* _tmd__GetAudioSourceConfigurationOptions has binding name '_tmd__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions (768)
#endif

/* _tmd__GetVideoOutputConfigurationOptionsResponse has binding name '_tmd__GetVideoOutputConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse (767)
#endif

/* _tmd__GetVideoOutputConfigurationOptions has binding name '_tmd__GetVideoOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions (766)
#endif

/* _tmd__GetVideoSourceConfigurationOptionsResponse has binding name '_tmd__GetVideoSourceConfigurationOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse (765)
#endif

/* _tmd__GetVideoSourceConfigurationOptions has binding name '_tmd__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions (764)
#endif

/* _tmd__SetVideoOutputConfigurationResponse has binding name '_tmd__SetVideoOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse (763)
#endif

/* _tmd__SetVideoOutputConfiguration has binding name '_tmd__SetVideoOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__SetVideoOutputConfiguration
#define SOAP_TYPE__tmd__SetVideoOutputConfiguration (762)
#endif

/* _tmd__SetVideoSourceConfigurationResponse has binding name '_tmd__SetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse (761)
#endif

/* _tmd__SetVideoSourceConfiguration has binding name '_tmd__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__SetVideoSourceConfiguration
#define SOAP_TYPE__tmd__SetVideoSourceConfiguration (760)
#endif

/* _tmd__SetAudioOutputConfigurationResponse has binding name '_tmd__SetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse (759)
#endif

/* _tmd__SetAudioOutputConfiguration has binding name '_tmd__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__SetAudioOutputConfiguration
#define SOAP_TYPE__tmd__SetAudioOutputConfiguration (758)
#endif

/* _tmd__SetAudioSourceConfigurationResponse has binding name '_tmd__SetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse (757)
#endif

/* _tmd__SetAudioSourceConfiguration has binding name '_tmd__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__SetAudioSourceConfiguration
#define SOAP_TYPE__tmd__SetAudioSourceConfiguration (756)
#endif

/* _tmd__GetVideoOutputConfigurationResponse has binding name '_tmd__GetVideoOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse (755)
#endif

/* _tmd__GetVideoOutputConfiguration has binding name '_tmd__GetVideoOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputConfiguration
#define SOAP_TYPE__tmd__GetVideoOutputConfiguration (754)
#endif

/* _tmd__GetVideoSourceConfigurationResponse has binding name '_tmd__GetVideoSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse (753)
#endif

/* _tmd__GetVideoSourceConfiguration has binding name '_tmd__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoSourceConfiguration
#define SOAP_TYPE__tmd__GetVideoSourceConfiguration (752)
#endif

/* _tmd__GetAudioOutputConfigurationResponse has binding name '_tmd__GetAudioOutputConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse (751)
#endif

/* _tmd__GetAudioOutputConfiguration has binding name '_tmd__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioOutputConfiguration
#define SOAP_TYPE__tmd__GetAudioOutputConfiguration (750)
#endif

/* _tmd__GetAudioSourceConfigurationResponse has binding name '_tmd__GetAudioSourceConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse (749)
#endif

/* _tmd__GetAudioSourceConfiguration has binding name '_tmd__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE__tmd__GetAudioSourceConfiguration
#define SOAP_TYPE__tmd__GetAudioSourceConfiguration (748)
#endif

/* _tmd__GetVideoOutputsResponse has binding name '_tmd__GetVideoOutputsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputsResponse
#define SOAP_TYPE__tmd__GetVideoOutputsResponse (747)
#endif

/* _tmd__GetVideoOutputs has binding name '_tmd__GetVideoOutputs' for type '' */
#ifndef SOAP_TYPE__tmd__GetVideoOutputs
#define SOAP_TYPE__tmd__GetVideoOutputs (746)
#endif

/* _tmd__GetRelayOutputOptionsResponse has binding name '_tmd__GetRelayOutputOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptionsResponse
#define SOAP_TYPE__tmd__GetRelayOutputOptionsResponse (745)
#endif

/* _tmd__GetRelayOutputOptions has binding name '_tmd__GetRelayOutputOptions' for type '' */
#ifndef SOAP_TYPE__tmd__GetRelayOutputOptions
#define SOAP_TYPE__tmd__GetRelayOutputOptions (744)
#endif

/* _tmd__GetServiceCapabilitiesResponse has binding name '_tmd__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tmd__GetServiceCapabilitiesResponse (743)
#endif

/* _tmd__GetServiceCapabilities has binding name '_tmd__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tmd__GetServiceCapabilities
#define SOAP_TYPE__tmd__GetServiceCapabilities (742)
#endif

/* tmd__ParityBitList has binding name 'tmd__ParityBitList' for type 'tmd:ParityBitList' */
#ifndef SOAP_TYPE_tmd__ParityBitList
#define SOAP_TYPE_tmd__ParityBitList (741)
#endif

/* tmd__SerialPortConfigurationOptions has binding name 'tmd__SerialPortConfigurationOptions' for type 'tmd:SerialPortConfigurationOptions' */
#ifndef SOAP_TYPE_tmd__SerialPortConfigurationOptions
#define SOAP_TYPE_tmd__SerialPortConfigurationOptions (740)
#endif

/* tmd__SerialPortConfiguration has binding name 'tmd__SerialPortConfiguration' for type 'tmd:SerialPortConfiguration' */
#ifndef SOAP_TYPE_tmd__SerialPortConfiguration
#define SOAP_TYPE_tmd__SerialPortConfiguration (739)
#endif

/* tmd__SerialPort has binding name 'tmd__SerialPort' for type 'tmd:SerialPort' */
#ifndef SOAP_TYPE_tmd__SerialPort
#define SOAP_TYPE_tmd__SerialPort (738)
#endif

/* tmd__SerialData has binding name 'tmd__SerialData' for type 'tmd:SerialData' */
#ifndef SOAP_TYPE_tmd__SerialData
#define SOAP_TYPE_tmd__SerialData (737)
#endif

/* tmd__DigitalInputConfigurationOptions has binding name 'tmd__DigitalInputConfigurationOptions' for type 'tmd:DigitalInputConfigurationOptions' */
#ifndef SOAP_TYPE_tmd__DigitalInputConfigurationOptions
#define SOAP_TYPE_tmd__DigitalInputConfigurationOptions (736)
#endif

/* tmd__GetResponse has binding name 'tmd__GetResponse' for type 'tmd:GetResponse' */
#ifndef SOAP_TYPE_tmd__GetResponse
#define SOAP_TYPE_tmd__GetResponse (735)
#endif

/* tmd__Get has binding name 'tmd__Get' for type 'tmd:Get' */
#ifndef SOAP_TYPE_tmd__Get
#define SOAP_TYPE_tmd__Get (734)
#endif

/* tmd__RelayOutputOptionsExtension has binding name 'tmd__RelayOutputOptionsExtension' for type 'tmd:RelayOutputOptionsExtension' */
#ifndef SOAP_TYPE_tmd__RelayOutputOptionsExtension
#define SOAP_TYPE_tmd__RelayOutputOptionsExtension (733)
#endif

/* tmd__RelayOutputOptions has binding name 'tmd__RelayOutputOptions' for type 'tmd:RelayOutputOptions' */
#ifndef SOAP_TYPE_tmd__RelayOutputOptions
#define SOAP_TYPE_tmd__RelayOutputOptions (732)
#endif

/* tmd__Capabilities has binding name 'tmd__Capabilities' for type 'tmd:Capabilities' */
#ifndef SOAP_TYPE_tmd__Capabilities
#define SOAP_TYPE_tmd__Capabilities (731)
#endif

/* wsrfr__ResourceUnavailableFaultType has binding name 'wsrfr__ResourceUnavailableFaultType' for type 'wsrfr:ResourceUnavailableFaultType' */
#ifndef SOAP_TYPE_wsrfr__ResourceUnavailableFaultType
#define SOAP_TYPE_wsrfr__ResourceUnavailableFaultType (730)
#endif

/* wsrfr__ResourceUnknownFaultType has binding name 'wsrfr__ResourceUnknownFaultType' for type 'wsrfr:ResourceUnknownFaultType' */
#ifndef SOAP_TYPE_wsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_wsrfr__ResourceUnknownFaultType (729)
#endif

/* _tev__GetEventPropertiesResponse has binding name '_tev__GetEventPropertiesResponse' for type '' */
#ifndef SOAP_TYPE__tev__GetEventPropertiesResponse
#define SOAP_TYPE__tev__GetEventPropertiesResponse (728)
#endif

/* _tev__GetEventProperties has binding name '_tev__GetEventProperties' for type '' */
#ifndef SOAP_TYPE__tev__GetEventProperties
#define SOAP_TYPE__tev__GetEventProperties (727)
#endif

/* _tev__SetSynchronizationPointResponse has binding name '_tev__SetSynchronizationPointResponse' for type '' */
#ifndef SOAP_TYPE__tev__SetSynchronizationPointResponse
#define SOAP_TYPE__tev__SetSynchronizationPointResponse (726)
#endif

/* _tev__SetSynchronizationPoint has binding name '_tev__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE__tev__SetSynchronizationPoint
#define SOAP_TYPE__tev__SetSynchronizationPoint (725)
#endif

/* _tev__SeekResponse has binding name '_tev__SeekResponse' for type '' */
#ifndef SOAP_TYPE__tev__SeekResponse
#define SOAP_TYPE__tev__SeekResponse (724)
#endif

/* _tev__Seek has binding name '_tev__Seek' for type '' */
#ifndef SOAP_TYPE__tev__Seek
#define SOAP_TYPE__tev__Seek (723)
#endif

/* _tev__PullMessagesFaultResponse has binding name '_tev__PullMessagesFaultResponse' for type '' */
#ifndef SOAP_TYPE__tev__PullMessagesFaultResponse
#define SOAP_TYPE__tev__PullMessagesFaultResponse (722)
#endif

/* _tev__PullMessagesResponse has binding name '_tev__PullMessagesResponse' for type '' */
#ifndef SOAP_TYPE__tev__PullMessagesResponse
#define SOAP_TYPE__tev__PullMessagesResponse (721)
#endif

/* _tev__PullMessages has binding name '_tev__PullMessages' for type '' */
#ifndef SOAP_TYPE__tev__PullMessages
#define SOAP_TYPE__tev__PullMessages (720)
#endif

/* _tev__CreatePullPointSubscriptionResponse has binding name '_tev__CreatePullPointSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscriptionResponse
#define SOAP_TYPE__tev__CreatePullPointSubscriptionResponse (719)
#endif

/* _tev__CreatePullPointSubscription has binding name '_tev__CreatePullPointSubscription' for type '' */
#ifndef SOAP_TYPE__tev__CreatePullPointSubscription
#define SOAP_TYPE__tev__CreatePullPointSubscription (718)
#endif

/* _tev__GetServiceCapabilitiesResponse has binding name '_tev__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tev__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tev__GetServiceCapabilitiesResponse (717)
#endif

/* _tev__GetServiceCapabilities has binding name '_tev__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tev__GetServiceCapabilities
#define SOAP_TYPE__tev__GetServiceCapabilities (716)
#endif

/* tev__Capabilities has binding name 'tev__Capabilities' for type 'tev:Capabilities' */
#ifndef SOAP_TYPE_tev__Capabilities
#define SOAP_TYPE_tev__Capabilities (715)
#endif

/* wstop__TopicSetType has binding name 'wstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (714)
#endif

/* wstop__TopicType has binding name 'wstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (713)
#endif

/* wstop__TopicNamespaceType has binding name 'wstop__TopicNamespaceType' for type 'wstop:TopicNamespaceType' */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (712)
#endif

/* wstop__QueryExpressionType has binding name 'wstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (711)
#endif

/* wstop__ExtensibleDocumented has binding name 'wstop__ExtensibleDocumented' for type 'wstop:ExtensibleDocumented' */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (710)
#endif

/* wstop__Documentation has binding name 'wstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (709)
#endif

/* wsrfbf__BaseFaultType has binding name 'wsrfbf__BaseFaultType' for type 'wsrfbf:BaseFaultType' */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (708)
#endif

/* _wsnt__ResumeSubscriptionResponse has binding name '_wsnt__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (707)
#endif

/* _wsnt__ResumeSubscription has binding name '_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (706)
#endif

/* _wsnt__PauseSubscriptionResponse has binding name '_wsnt__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (705)
#endif

/* _wsnt__PauseSubscription has binding name '_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (704)
#endif

/* _wsnt__UnsubscribeResponse has binding name '_wsnt__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (703)
#endif

/* _wsnt__Unsubscribe has binding name '_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (702)
#endif

/* _wsnt__RenewResponse has binding name '_wsnt__RenewResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (701)
#endif

/* _wsnt__Renew has binding name '_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (700)
#endif

/* _wsnt__CreatePullPointResponse has binding name '_wsnt__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (699)
#endif

/* _wsnt__CreatePullPoint has binding name '_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (698)
#endif

/* _wsnt__DestroyPullPointResponse has binding name '_wsnt__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (697)
#endif

/* _wsnt__DestroyPullPoint has binding name '_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (696)
#endif

/* _wsnt__GetMessagesResponse has binding name '_wsnt__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (695)
#endif

/* _wsnt__GetMessages has binding name '_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (694)
#endif

/* _wsnt__GetCurrentMessageResponse has binding name '_wsnt__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (693)
#endif

/* _wsnt__GetCurrentMessage has binding name '_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (692)
#endif

/* _wsnt__SubscribeResponse has binding name '_wsnt__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (691)
#endif

/* _wsnt__Subscribe has binding name '_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (690)
#endif

/* _wsnt__UseRaw has binding name '_wsnt__UseRaw' for type '' */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (689)
#endif

/* _wsnt__Notify has binding name '_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (688)
#endif

/* _wsnt__SubscriptionManagerRP has binding name '_wsnt__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (687)
#endif

/* _wsnt__NotificationProducerRP has binding name '_wsnt__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (686)
#endif

/* wsnt__ResumeFailedFaultType has binding name 'wsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (685)
#endif

/* wsnt__PauseFailedFaultType has binding name 'wsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (684)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType has binding name 'wsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (683)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType has binding name 'wsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (682)
#endif

/* wsnt__UnableToCreatePullPointFaultType has binding name 'wsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (681)
#endif

/* wsnt__UnableToDestroyPullPointFaultType has binding name 'wsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (680)
#endif

/* wsnt__UnableToGetMessagesFaultType has binding name 'wsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (679)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType has binding name 'wsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (678)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType has binding name 'wsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (677)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType has binding name 'wsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (676)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType has binding name 'wsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (675)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType has binding name 'wsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (674)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType has binding name 'wsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (673)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType has binding name 'wsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (672)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType has binding name 'wsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (671)
#endif

/* wsnt__TopicNotSupportedFaultType has binding name 'wsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (670)
#endif

/* wsnt__InvalidTopicExpressionFaultType has binding name 'wsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (669)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType has binding name 'wsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (668)
#endif

/* wsnt__InvalidFilterFaultType has binding name 'wsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (667)
#endif

/* wsnt__SubscribeCreationFailedFaultType has binding name 'wsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (666)
#endif

/* wsnt__NotificationMessageHolderType has binding name 'wsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (665)
#endif

/* wsnt__SubscriptionPolicyType has binding name 'wsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (664)
#endif

/* wsnt__FilterType has binding name 'wsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (663)
#endif

/* wsnt__TopicExpressionType has binding name 'wsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (662)
#endif

/* wsnt__QueryExpressionType has binding name 'wsnt__QueryExpressionType' for type 'wsnt:QueryExpressionType' */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (661)
#endif

/* _tt__Message has binding name '_tt__Message' for type '' */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (660)
#endif

/* _tt__StringItems has binding name '_tt__StringItems' for type '' */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (659)
#endif

/* tt__LocationEntity has binding name 'tt__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (658)
#endif

/* tt__LocalOrientation has binding name 'tt__LocalOrientation' for type 'tt:LocalOrientation' */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (657)
#endif

/* tt__LocalLocation has binding name 'tt__LocalLocation' for type 'tt:LocalLocation' */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (656)
#endif

/* tt__GeoOrientation has binding name 'tt__GeoOrientation' for type 'tt:GeoOrientation' */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (655)
#endif

/* tt__GeoLocation has binding name 'tt__GeoLocation' for type 'tt:GeoLocation' */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (654)
#endif

/* tt__Color has binding name 'tt__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (653)
#endif

/* tt__Polygon has binding name 'tt__Polygon' for type 'tt:Polygon' */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (652)
#endif

/* tt__Rectangle has binding name 'tt__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (651)
#endif

/* tt__Vector has binding name 'tt__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (650)
#endif

/* tt__PTZMoveStatus has binding name 'tt__PTZMoveStatus' for type 'tt:PTZMoveStatus' */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (649)
#endif

/* tt__PTZStatus has binding name 'tt__PTZStatus' for type 'tt:PTZStatus' */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (648)
#endif

/* tt__PTZVector has binding name 'tt__PTZVector' for type 'tt:PTZVector' */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (647)
#endif

/* tt__Vector1D has binding name 'tt__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (646)
#endif

/* tt__Vector2D has binding name 'tt__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (645)
#endif

/* tt__IntRange has binding name 'tt__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (644)
#endif

/* tt__OSDConfigurationOptionsExtension has binding name 'tt__OSDConfigurationOptionsExtension' for type 'tt:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (643)
#endif

/* tt__OSDConfigurationOptions has binding name 'tt__OSDConfigurationOptions' for type 'tt:OSDConfigurationOptions' */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (642)
#endif

/* tt__MaximumNumberOfOSDs has binding name 'tt__MaximumNumberOfOSDs' for type 'tt:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (641)
#endif

/* tt__OSDConfigurationExtension has binding name 'tt__OSDConfigurationExtension' for type 'tt:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (640)
#endif

/* tt__OSDConfiguration has binding name 'tt__OSDConfiguration' for type 'tt:OSDConfiguration' */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (639)
#endif

/* tt__OSDImgOptionsExtension has binding name 'tt__OSDImgOptionsExtension' for type 'tt:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (638)
#endif

/* tt__OSDImgOptions has binding name 'tt__OSDImgOptions' for type 'tt:OSDImgOptions' */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (637)
#endif

/* tt__OSDTextOptionsExtension has binding name 'tt__OSDTextOptionsExtension' for type 'tt:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (636)
#endif

/* tt__OSDTextOptions has binding name 'tt__OSDTextOptions' for type 'tt:OSDTextOptions' */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (635)
#endif

/* tt__OSDColorOptionsExtension has binding name 'tt__OSDColorOptionsExtension' for type 'tt:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (634)
#endif

/* tt__OSDColorOptions has binding name 'tt__OSDColorOptions' for type 'tt:OSDColorOptions' */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (633)
#endif

/* tt__ColorOptions has binding name 'tt__ColorOptions' for type 'tt:ColorOptions' */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (632)
#endif

/* tt__ColorspaceRange has binding name 'tt__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (631)
#endif

/* tt__OSDImgConfigurationExtension has binding name 'tt__OSDImgConfigurationExtension' for type 'tt:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (630)
#endif

/* tt__OSDImgConfiguration has binding name 'tt__OSDImgConfiguration' for type 'tt:OSDImgConfiguration' */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (629)
#endif

/* tt__OSDTextConfigurationExtension has binding name 'tt__OSDTextConfigurationExtension' for type 'tt:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (628)
#endif

/* tt__OSDTextConfiguration has binding name 'tt__OSDTextConfiguration' for type 'tt:OSDTextConfiguration' */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (627)
#endif

/* tt__OSDColor has binding name 'tt__OSDColor' for type 'tt:OSDColor' */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (626)
#endif

/* tt__OSDPosConfigurationExtension has binding name 'tt__OSDPosConfigurationExtension' for type 'tt:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (625)
#endif

/* tt__OSDPosConfiguration has binding name 'tt__OSDPosConfiguration' for type 'tt:OSDPosConfiguration' */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (624)
#endif

/* tt__OSDReference has binding name 'tt__OSDReference' for type 'tt:OSDReference' */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (623)
#endif

/* tt__DateTimeRange has binding name 'tt__DateTimeRange' for type 'tt:DateTimeRange' */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (622)
#endif

/* tt__LayoutExtension has binding name 'tt__LayoutExtension' for type 'tt:LayoutExtension' */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (621)
#endif

/* tt__Layout has binding name 'tt__Layout' for type 'tt:Layout' */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (620)
#endif

/* tt__PaneLayout has binding name 'tt__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (619)
#endif

/* tt__Config has binding name 'tt__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (618)
#endif

/* tt__RuleEngineConfigurationExtension has binding name 'tt__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (617)
#endif

/* tt__RuleEngineConfiguration has binding name 'tt__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (616)
#endif

/* tt__AnalyticsEngineConfigurationExtension has binding name 'tt__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (615)
#endif

/* tt__AnalyticsEngineConfiguration has binding name 'tt__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (614)
#endif

/* tt__Polyline has binding name 'tt__Polyline' for type 'tt:Polyline' */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (613)
#endif

/* tt__ItemListExtension has binding name 'tt__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (612)
#endif

/* tt__ItemList has binding name 'tt__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (611)
#endif

/* tt__MessageExtension has binding name 'tt__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (610)
#endif

/* tt__NoiseReductionOptions has binding name 'tt__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (609)
#endif

/* tt__DefoggingOptions has binding name 'tt__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (608)
#endif

/* tt__ToneCompensationOptions has binding name 'tt__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (607)
#endif

/* tt__FocusOptions20Extension has binding name 'tt__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (606)
#endif

/* tt__FocusOptions20 has binding name 'tt__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (605)
#endif

/* tt__WhiteBalanceOptions20Extension has binding name 'tt__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (604)
#endif

/* tt__WhiteBalanceOptions20 has binding name 'tt__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (603)
#endif

/* tt__FocusConfiguration20Extension has binding name 'tt__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (602)
#endif

/* tt__FocusConfiguration20 has binding name 'tt__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (601)
#endif

/* tt__WhiteBalance20Extension has binding name 'tt__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (600)
#endif

/* tt__WhiteBalance20 has binding name 'tt__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (599)
#endif

/* tt__RelativeFocusOptions20 has binding name 'tt__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (598)
#endif

/* tt__MoveOptions20 has binding name 'tt__MoveOptions20' for type 'tt:MoveOptions20' */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (597)
#endif

/* tt__ExposureOptions20 has binding name 'tt__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (596)
#endif

/* tt__BacklightCompensationOptions20 has binding name 'tt__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (595)
#endif

/* tt__WideDynamicRangeOptions20 has binding name 'tt__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (594)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension has binding name 'tt__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (593)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions has binding name 'tt__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (592)
#endif

/* tt__ImageStabilizationOptionsExtension has binding name 'tt__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (591)
#endif

/* tt__ImageStabilizationOptions has binding name 'tt__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (590)
#endif

/* tt__ImagingOptions20Extension4 has binding name 'tt__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (589)
#endif

/* tt__ImagingOptions20Extension3 has binding name 'tt__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (588)
#endif

/* tt__ImagingOptions20Extension2 has binding name 'tt__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (587)
#endif

/* tt__ImagingOptions20Extension has binding name 'tt__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (586)
#endif

/* tt__ImagingOptions20 has binding name 'tt__ImagingOptions20' for type 'tt:ImagingOptions20' */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (585)
#endif

/* tt__NoiseReduction has binding name 'tt__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (584)
#endif

/* tt__DefoggingExtension has binding name 'tt__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (583)
#endif

/* tt__Defogging has binding name 'tt__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (582)
#endif

/* tt__ToneCompensationExtension has binding name 'tt__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (581)
#endif

/* tt__ToneCompensation has binding name 'tt__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (580)
#endif

/* tt__Exposure20 has binding name 'tt__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (579)
#endif

/* tt__BacklightCompensation20 has binding name 'tt__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (578)
#endif

/* tt__WideDynamicRange20 has binding name 'tt__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (577)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension has binding name 'tt__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (576)
#endif

/* tt__IrCutFilterAutoAdjustment has binding name 'tt__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (575)
#endif

/* tt__ImageStabilizationExtension has binding name 'tt__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (574)
#endif

/* tt__ImageStabilization has binding name 'tt__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (573)
#endif

/* tt__ImagingSettingsExtension204 has binding name 'tt__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (572)
#endif

/* tt__ImagingSettingsExtension203 has binding name 'tt__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (571)
#endif

/* tt__ImagingSettingsExtension202 has binding name 'tt__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (570)
#endif

/* tt__ImagingSettingsExtension20 has binding name 'tt__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (569)
#endif

/* tt__ImagingSettings20 has binding name 'tt__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (568)
#endif

/* tt__FocusStatus20Extension has binding name 'tt__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (567)
#endif

/* tt__FocusStatus20 has binding name 'tt__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (566)
#endif

/* tt__ImagingStatus20Extension has binding name 'tt__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (565)
#endif

/* tt__ImagingStatus20 has binding name 'tt__ImagingStatus20' for type 'tt:ImagingStatus20' */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (564)
#endif

/* tt__WhiteBalance has binding name 'tt__WhiteBalance' for type 'tt:WhiteBalance' */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (563)
#endif

/* tt__ContinuousFocusOptions has binding name 'tt__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (562)
#endif

/* tt__AbsoluteFocusOptions has binding name 'tt__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (561)
#endif

/* tt__ContinuousFocus has binding name 'tt__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (560)
#endif

/* tt__RelativeFocus has binding name 'tt__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (559)
#endif

/* tt__AbsoluteFocus has binding name 'tt__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (558)
#endif

/* tt__FocusMove has binding name 'tt__FocusMove' for type 'tt:FocusMove' */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (557)
#endif

/* tt__BacklightCompensation has binding name 'tt__BacklightCompensation' for type 'tt:BacklightCompensation' */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (556)
#endif

/* tt__WideDynamicRange has binding name 'tt__WideDynamicRange' for type 'tt:WideDynamicRange' */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (555)
#endif

/* tt__Exposure has binding name 'tt__Exposure' for type 'tt:Exposure' */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (554)
#endif

/* tt__ImagingSettingsExtension has binding name 'tt__ImagingSettingsExtension' for type 'tt:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (553)
#endif

/* tt__ImagingSettings has binding name 'tt__ImagingSettings' for type 'tt:ImagingSettings' */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (552)
#endif

/* tt__FocusConfiguration has binding name 'tt__FocusConfiguration' for type 'tt:FocusConfiguration' */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (551)
#endif

/* tt__PTZPresetTourStartingConditionOptionsExtension has binding name 'tt__PTZPresetTourStartingConditionOptionsExtension' for type 'tt:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (550)
#endif

/* tt__PTZPresetTourStartingConditionOptions has binding name 'tt__PTZPresetTourStartingConditionOptions' for type 'tt:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (549)
#endif

/* tt__PTZPresetTourPresetDetailOptionsExtension has binding name 'tt__PTZPresetTourPresetDetailOptionsExtension' for type 'tt:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (548)
#endif

/* tt__PTZPresetTourPresetDetailOptions has binding name 'tt__PTZPresetTourPresetDetailOptions' for type 'tt:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (547)
#endif

/* tt__PTZPresetTourSpotOptions has binding name 'tt__PTZPresetTourSpotOptions' for type 'tt:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (546)
#endif

/* tt__PTZPresetTourOptions has binding name 'tt__PTZPresetTourOptions' for type 'tt:PTZPresetTourOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (545)
#endif

/* tt__PTZPresetTourStartingConditionExtension has binding name 'tt__PTZPresetTourStartingConditionExtension' for type 'tt:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (544)
#endif

/* tt__PTZPresetTourStartingCondition has binding name 'tt__PTZPresetTourStartingCondition' for type 'tt:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (543)
#endif

/* tt__PTZPresetTourStatusExtension has binding name 'tt__PTZPresetTourStatusExtension' for type 'tt:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (542)
#endif

/* tt__PTZPresetTourStatus has binding name 'tt__PTZPresetTourStatus' for type 'tt:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (541)
#endif

/* tt__PTZPresetTourTypeExtension has binding name 'tt__PTZPresetTourTypeExtension' for type 'tt:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (540)
#endif

/* tt__PTZPresetTourPresetDetail has binding name 'tt__PTZPresetTourPresetDetail' for type 'tt:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (539)
#endif

/* tt__PTZPresetTourSpotExtension has binding name 'tt__PTZPresetTourSpotExtension' for type 'tt:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (538)
#endif

/* tt__PTZPresetTourSpot has binding name 'tt__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (537)
#endif

/* tt__PTZPresetTourExtension has binding name 'tt__PTZPresetTourExtension' for type 'tt:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (536)
#endif

/* tt__PresetTour has binding name 'tt__PresetTour' for type 'tt:PresetTour' */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (535)
#endif

/* tt__PTZPreset has binding name 'tt__PTZPreset' for type 'tt:PTZPreset' */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (534)
#endif

/* tt__PTZSpeed has binding name 'tt__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (533)
#endif

/* tt__Space1DDescription has binding name 'tt__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (532)
#endif

/* tt__Space2DDescription has binding name 'tt__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (531)
#endif

/* tt__PTZSpacesExtension has binding name 'tt__PTZSpacesExtension' for type 'tt:PTZSpacesExtension' */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (530)
#endif

/* tt__PTZSpaces has binding name 'tt__PTZSpaces' for type 'tt:PTZSpaces' */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (529)
#endif

/* tt__ZoomLimits has binding name 'tt__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (528)
#endif

/* tt__PanTiltLimits has binding name 'tt__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (527)
#endif

/* tt__ReverseOptionsExtension has binding name 'tt__ReverseOptionsExtension' for type 'tt:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (526)
#endif

/* tt__ReverseOptions has binding name 'tt__ReverseOptions' for type 'tt:ReverseOptions' */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (525)
#endif

/* tt__EFlipOptionsExtension has binding name 'tt__EFlipOptionsExtension' for type 'tt:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (524)
#endif

/* tt__EFlipOptions has binding name 'tt__EFlipOptions' for type 'tt:EFlipOptions' */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (523)
#endif

/* tt__PTControlDirectionOptionsExtension has binding name 'tt__PTControlDirectionOptionsExtension' for type 'tt:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (522)
#endif

/* tt__PTControlDirectionOptions has binding name 'tt__PTControlDirectionOptions' for type 'tt:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (521)
#endif

/* tt__PTZConfigurationOptions2 has binding name 'tt__PTZConfigurationOptions2' for type 'tt:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (520)
#endif

/* tt__PTZConfigurationOptions has binding name 'tt__PTZConfigurationOptions' for type 'tt:PTZConfigurationOptions' */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (519)
#endif

/* tt__Reverse has binding name 'tt__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (518)
#endif

/* tt__EFlip has binding name 'tt__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (517)
#endif

/* tt__PTControlDirectionExtension has binding name 'tt__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (516)
#endif

/* tt__PTControlDirection has binding name 'tt__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (515)
#endif

/* tt__PTZConfigurationExtension2 has binding name 'tt__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (514)
#endif

/* tt__PTZConfigurationExtension has binding name 'tt__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (513)
#endif

/* tt__PTZConfiguration has binding name 'tt__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (512)
#endif

/* tt__PTZPresetTourSupportedExtension has binding name 'tt__PTZPresetTourSupportedExtension' for type 'tt:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (511)
#endif

/* tt__PTZPresetTourSupported has binding name 'tt__PTZPresetTourSupported' for type 'tt:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (510)
#endif

/* tt__PTZNodeExtension2 has binding name 'tt__PTZNodeExtension2' for type 'tt:PTZNodeExtension2' */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (509)
#endif

/* tt__PTZNodeExtension has binding name 'tt__PTZNodeExtension' for type 'tt:PTZNodeExtension' */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (508)
#endif

/* tt__PTZNode has binding name 'tt__PTZNode' for type 'tt:PTZNode' */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (507)
#endif

/* tt__DigitalInput has binding name 'tt__DigitalInput' for type 'tt:DigitalInput' */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (506)
#endif

/* tt__RelayOutput has binding name 'tt__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (505)
#endif

/* tt__RelayOutputSettings has binding name 'tt__RelayOutputSettings' for type 'tt:RelayOutputSettings' */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (504)
#endif

/* tt__TLSConfiguration has binding name 'tt__TLSConfiguration' for type 'tt:TLSConfiguration' */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (503)
#endif

/* tt__EapMethodExtension has binding name 'tt__EapMethodExtension' for type 'tt:EapMethodExtension' */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (502)
#endif

/* tt__EAPMethodConfiguration has binding name 'tt__EAPMethodConfiguration' for type 'tt:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (501)
#endif

/* tt__Dot1XConfigurationExtension has binding name 'tt__Dot1XConfigurationExtension' for type 'tt:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (500)
#endif

/* tt__Dot1XConfiguration has binding name 'tt__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (499)
#endif

/* tt__CertificateInformationExtension has binding name 'tt__CertificateInformationExtension' for type 'tt:CertificateInformationExtension' */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (498)
#endif

/* tt__CertificateUsage has binding name 'tt__CertificateUsage' for type 'tt:CertificateUsage' */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (497)
#endif

/* tt__CertificateInformation has binding name 'tt__CertificateInformation' for type 'tt:CertificateInformation' */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (496)
#endif

/* tt__CertificateWithPrivateKey has binding name 'tt__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (495)
#endif

/* tt__CertificateStatus has binding name 'tt__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (494)
#endif

/* tt__Certificate has binding name 'tt__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (493)
#endif

/* tt__UserExtension has binding name 'tt__UserExtension' for type 'tt:UserExtension' */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (492)
#endif

/* tt__User has binding name 'tt__User' for type 'tt:User' */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (491)
#endif

/* tt__RemoteUser has binding name 'tt__RemoteUser' for type 'tt:RemoteUser' */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (490)
#endif

/* tt__TimeZone has binding name 'tt__TimeZone' for type 'tt:TimeZone' */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (489)
#endif

/* tt__Time has binding name 'tt__Time' for type 'tt:Time' */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (488)
#endif

/* tt__Date has binding name 'tt__Date' for type 'tt:Date' */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (487)
#endif

/* tt__DateTime has binding name 'tt__DateTime' for type 'tt:DateTime' */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (486)
#endif

/* tt__SystemDateTimeExtension has binding name 'tt__SystemDateTimeExtension' for type 'tt:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (485)
#endif

/* tt__SystemDateTime has binding name 'tt__SystemDateTime' for type 'tt:SystemDateTime' */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (484)
#endif

/* tt__SystemLogUri has binding name 'tt__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (483)
#endif

/* tt__SystemLogUriList has binding name 'tt__SystemLogUriList' for type 'tt:SystemLogUriList' */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (482)
#endif

/* tt__BackupFile has binding name 'tt__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (481)
#endif

/* tt__AttachmentData has binding name 'tt__AttachmentData' for type 'tt:AttachmentData' */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (480)
#endif

/* tt__BinaryData has binding name 'tt__BinaryData' for type 'tt:BinaryData' */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (479)
#endif

/* tt__SupportInformation has binding name 'tt__SupportInformation' for type 'tt:SupportInformation' */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (478)
#endif

/* tt__SystemLog has binding name 'tt__SystemLog' for type 'tt:SystemLog' */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (477)
#endif

/* tt__AnalyticsDeviceExtension has binding name 'tt__AnalyticsDeviceExtension' for type 'tt:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (476)
#endif

/* tt__AnalyticsDeviceCapabilities has binding name 'tt__AnalyticsDeviceCapabilities' for type 'tt:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (475)
#endif

/* tt__ReceiverCapabilities has binding name 'tt__ReceiverCapabilities' for type 'tt:ReceiverCapabilities' */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (474)
#endif

/* tt__ReplayCapabilities has binding name 'tt__ReplayCapabilities' for type 'tt:ReplayCapabilities' */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (473)
#endif

/* tt__SearchCapabilities has binding name 'tt__SearchCapabilities' for type 'tt:SearchCapabilities' */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (472)
#endif

/* tt__RecordingCapabilities has binding name 'tt__RecordingCapabilities' for type 'tt:RecordingCapabilities' */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (471)
#endif

/* tt__DisplayCapabilities has binding name 'tt__DisplayCapabilities' for type 'tt:DisplayCapabilities' */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (470)
#endif

/* tt__DeviceIOCapabilities has binding name 'tt__DeviceIOCapabilities' for type 'tt:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (469)
#endif

/* tt__PTZCapabilities has binding name 'tt__PTZCapabilities' for type 'tt:PTZCapabilities' */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (468)
#endif

/* tt__ImagingCapabilities has binding name 'tt__ImagingCapabilities' for type 'tt:ImagingCapabilities' */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (467)
#endif

/* tt__OnvifVersion has binding name 'tt__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (466)
#endif

/* tt__SystemCapabilitiesExtension2 has binding name 'tt__SystemCapabilitiesExtension2' for type 'tt:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (465)
#endif

/* tt__SystemCapabilitiesExtension has binding name 'tt__SystemCapabilitiesExtension' for type 'tt:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (464)
#endif

/* tt__SystemCapabilities has binding name 'tt__SystemCapabilities' for type 'tt:SystemCapabilities' */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (463)
#endif

/* tt__SecurityCapabilitiesExtension2 has binding name 'tt__SecurityCapabilitiesExtension2' for type 'tt:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (462)
#endif

/* tt__SecurityCapabilitiesExtension has binding name 'tt__SecurityCapabilitiesExtension' for type 'tt:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (461)
#endif

/* tt__SecurityCapabilities has binding name 'tt__SecurityCapabilities' for type 'tt:SecurityCapabilities' */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (460)
#endif

/* tt__NetworkCapabilitiesExtension2 has binding name 'tt__NetworkCapabilitiesExtension2' for type 'tt:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (459)
#endif

/* tt__NetworkCapabilitiesExtension has binding name 'tt__NetworkCapabilitiesExtension' for type 'tt:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (458)
#endif

/* tt__NetworkCapabilities has binding name 'tt__NetworkCapabilities' for type 'tt:NetworkCapabilities' */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (457)
#endif

/* tt__ProfileCapabilities has binding name 'tt__ProfileCapabilities' for type 'tt:ProfileCapabilities' */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (456)
#endif

/* tt__RealTimeStreamingCapabilitiesExtension has binding name 'tt__RealTimeStreamingCapabilitiesExtension' for type 'tt:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (455)
#endif

/* tt__RealTimeStreamingCapabilities has binding name 'tt__RealTimeStreamingCapabilities' for type 'tt:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (454)
#endif

/* tt__MediaCapabilitiesExtension has binding name 'tt__MediaCapabilitiesExtension' for type 'tt:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (453)
#endif

/* tt__MediaCapabilities has binding name 'tt__MediaCapabilities' for type 'tt:MediaCapabilities' */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (452)
#endif

/* tt__IOCapabilitiesExtension2 has binding name 'tt__IOCapabilitiesExtension2' for type 'tt:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (451)
#endif

/* tt__IOCapabilitiesExtension has binding name 'tt__IOCapabilitiesExtension' for type 'tt:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (450)
#endif

/* tt__IOCapabilities has binding name 'tt__IOCapabilities' for type 'tt:IOCapabilities' */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (449)
#endif

/* tt__EventCapabilities has binding name 'tt__EventCapabilities' for type 'tt:EventCapabilities' */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (448)
#endif

/* tt__DeviceCapabilitiesExtension has binding name 'tt__DeviceCapabilitiesExtension' for type 'tt:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (447)
#endif

/* tt__DeviceCapabilities has binding name 'tt__DeviceCapabilities' for type 'tt:DeviceCapabilities' */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (446)
#endif

/* tt__AnalyticsCapabilities has binding name 'tt__AnalyticsCapabilities' for type 'tt:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (445)
#endif

/* tt__CapabilitiesExtension2 has binding name 'tt__CapabilitiesExtension2' for type 'tt:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (444)
#endif

/* tt__CapabilitiesExtension has binding name 'tt__CapabilitiesExtension' for type 'tt:CapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (443)
#endif

/* tt__Capabilities has binding name 'tt__Capabilities' for type 'tt:Capabilities' */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (442)
#endif

/* tt__Dot11AvailableNetworksExtension has binding name 'tt__Dot11AvailableNetworksExtension' for type 'tt:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (441)
#endif

/* tt__Dot11AvailableNetworks has binding name 'tt__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (440)
#endif

/* tt__Dot11Status has binding name 'tt__Dot11Status' for type 'tt:Dot11Status' */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (439)
#endif

/* tt__Dot11Capabilities has binding name 'tt__Dot11Capabilities' for type 'tt:Dot11Capabilities' */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (438)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension2 has binding name 'tt__NetworkInterfaceSetConfigurationExtension2' for type 'tt:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (437)
#endif

/* tt__Dot11PSKSetExtension has binding name 'tt__Dot11PSKSetExtension' for type 'tt:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (436)
#endif

/* tt__Dot11PSKSet has binding name 'tt__Dot11PSKSet' for type 'tt:Dot11PSKSet' */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (435)
#endif

/* tt__Dot11SecurityConfigurationExtension has binding name 'tt__Dot11SecurityConfigurationExtension' for type 'tt:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (434)
#endif

/* tt__Dot11SecurityConfiguration has binding name 'tt__Dot11SecurityConfiguration' for type 'tt:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (433)
#endif

/* tt__Dot11Configuration has binding name 'tt__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (432)
#endif

/* tt__IPAddressFilterExtension has binding name 'tt__IPAddressFilterExtension' for type 'tt:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (431)
#endif

/* tt__IPAddressFilter has binding name 'tt__IPAddressFilter' for type 'tt:IPAddressFilter' */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (430)
#endif

/* tt__NetworkZeroConfigurationExtension2 has binding name 'tt__NetworkZeroConfigurationExtension2' for type 'tt:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (429)
#endif

/* tt__NetworkZeroConfigurationExtension has binding name 'tt__NetworkZeroConfigurationExtension' for type 'tt:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (428)
#endif

/* tt__NetworkZeroConfiguration has binding name 'tt__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (427)
#endif

/* tt__NetworkGateway has binding name 'tt__NetworkGateway' for type 'tt:NetworkGateway' */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (426)
#endif

/* tt__IPv4NetworkInterfaceSetConfiguration has binding name 'tt__IPv4NetworkInterfaceSetConfiguration' for type 'tt:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (425)
#endif

/* tt__IPv6NetworkInterfaceSetConfiguration has binding name 'tt__IPv6NetworkInterfaceSetConfiguration' for type 'tt:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (424)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension has binding name 'tt__NetworkInterfaceSetConfigurationExtension' for type 'tt:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (423)
#endif

/* tt__NetworkInterfaceSetConfiguration has binding name 'tt__NetworkInterfaceSetConfiguration' for type 'tt:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (422)
#endif

/* tt__DynamicDNSInformationExtension has binding name 'tt__DynamicDNSInformationExtension' for type 'tt:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (421)
#endif

/* tt__DynamicDNSInformation has binding name 'tt__DynamicDNSInformation' for type 'tt:DynamicDNSInformation' */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (420)
#endif

/* tt__NTPInformationExtension has binding name 'tt__NTPInformationExtension' for type 'tt:NTPInformationExtension' */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (419)
#endif

/* tt__NTPInformation has binding name 'tt__NTPInformation' for type 'tt:NTPInformation' */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (418)
#endif

/* tt__DNSInformationExtension has binding name 'tt__DNSInformationExtension' for type 'tt:DNSInformationExtension' */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (417)
#endif

/* tt__DNSInformation has binding name 'tt__DNSInformation' for type 'tt:DNSInformation' */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (416)
#endif

/* tt__HostnameInformationExtension has binding name 'tt__HostnameInformationExtension' for type 'tt:HostnameInformationExtension' */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (415)
#endif

/* tt__HostnameInformation has binding name 'tt__HostnameInformation' for type 'tt:HostnameInformation' */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (414)
#endif

/* tt__PrefixedIPv6Address has binding name 'tt__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (413)
#endif

/* tt__PrefixedIPv4Address has binding name 'tt__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (412)
#endif

/* tt__IPAddress has binding name 'tt__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (411)
#endif

/* tt__NetworkHostExtension has binding name 'tt__NetworkHostExtension' for type 'tt:NetworkHostExtension' */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (410)
#endif

/* tt__NetworkHost has binding name 'tt__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (409)
#endif

/* tt__NetworkProtocolExtension has binding name 'tt__NetworkProtocolExtension' for type 'tt:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (408)
#endif

/* tt__NetworkProtocol has binding name 'tt__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (407)
#endif

/* tt__IPv6ConfigurationExtension has binding name 'tt__IPv6ConfigurationExtension' for type 'tt:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (406)
#endif

/* tt__IPv6Configuration has binding name 'tt__IPv6Configuration' for type 'tt:IPv6Configuration' */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (405)
#endif

/* tt__IPv4Configuration has binding name 'tt__IPv4Configuration' for type 'tt:IPv4Configuration' */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (404)
#endif

/* tt__IPv4NetworkInterface has binding name 'tt__IPv4NetworkInterface' for type 'tt:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (403)
#endif

/* tt__IPv6NetworkInterface has binding name 'tt__IPv6NetworkInterface' for type 'tt:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (402)
#endif

/* tt__NetworkInterfaceInfo has binding name 'tt__NetworkInterfaceInfo' for type 'tt:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (401)
#endif

/* tt__NetworkInterfaceConnectionSetting has binding name 'tt__NetworkInterfaceConnectionSetting' for type 'tt:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (400)
#endif

/* tt__NetworkInterfaceLink has binding name 'tt__NetworkInterfaceLink' for type 'tt:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (399)
#endif

/* tt__NetworkInterfaceExtension2 has binding name 'tt__NetworkInterfaceExtension2' for type 'tt:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (398)
#endif

/* tt__Dot3Configuration has binding name 'tt__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (397)
#endif

/* tt__NetworkInterfaceExtension has binding name 'tt__NetworkInterfaceExtension' for type 'tt:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (396)
#endif

/* tt__NetworkInterface has binding name 'tt__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (395)
#endif

/* tt__Scope has binding name 'tt__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (394)
#endif

/* tt__MediaUri has binding name 'tt__MediaUri' for type 'tt:MediaUri' */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (393)
#endif

/* tt__Transport has binding name 'tt__Transport' for type 'tt:Transport' */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (392)
#endif

/* tt__StreamSetup has binding name 'tt__StreamSetup' for type 'tt:StreamSetup' */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (391)
#endif

/* tt__MulticastConfiguration has binding name 'tt__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (390)
#endif

/* tt__AudioDecoderConfigurationOptionsExtension has binding name 'tt__AudioDecoderConfigurationOptionsExtension' for type 'tt:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (389)
#endif

/* tt__G726DecOptions has binding name 'tt__G726DecOptions' for type 'tt:G726DecOptions' */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (388)
#endif

/* tt__AACDecOptions has binding name 'tt__AACDecOptions' for type 'tt:AACDecOptions' */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (387)
#endif

/* tt__G711DecOptions has binding name 'tt__G711DecOptions' for type 'tt:G711DecOptions' */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (386)
#endif

/* tt__AudioDecoderConfigurationOptions has binding name 'tt__AudioDecoderConfigurationOptions' for type 'tt:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (385)
#endif

/* tt__AudioDecoderConfiguration has binding name 'tt__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (384)
#endif

/* tt__AudioOutputConfigurationOptions has binding name 'tt__AudioOutputConfigurationOptions' for type 'tt:AudioOutputConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (383)
#endif

/* tt__AudioOutputConfiguration has binding name 'tt__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (382)
#endif

/* tt__AudioOutput has binding name 'tt__AudioOutput' for type 'tt:AudioOutput' */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (381)
#endif

/* tt__VideoOutputConfigurationOptions has binding name 'tt__VideoOutputConfigurationOptions' for type 'tt:VideoOutputConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (380)
#endif

/* tt__VideoOutputConfiguration has binding name 'tt__VideoOutputConfiguration' for type 'tt:VideoOutputConfiguration' */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (379)
#endif

/* tt__VideoOutputExtension has binding name 'tt__VideoOutputExtension' for type 'tt:VideoOutputExtension' */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (378)
#endif

/* tt__VideoOutput has binding name 'tt__VideoOutput' for type 'tt:VideoOutput' */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (377)
#endif

/* tt__PTZStatusFilterOptionsExtension has binding name 'tt__PTZStatusFilterOptionsExtension' for type 'tt:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (376)
#endif

/* tt__PTZStatusFilterOptions has binding name 'tt__PTZStatusFilterOptions' for type 'tt:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (375)
#endif

/* tt__MetadataConfigurationOptionsExtension2 has binding name 'tt__MetadataConfigurationOptionsExtension2' for type 'tt:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (374)
#endif

/* tt__MetadataConfigurationOptionsExtension has binding name 'tt__MetadataConfigurationOptionsExtension' for type 'tt:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (373)
#endif

/* tt__MetadataConfigurationOptions has binding name 'tt__MetadataConfigurationOptions' for type 'tt:MetadataConfigurationOptions' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (372)
#endif

/* tt__EventSubscription has binding name 'tt__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (371)
#endif

/* tt__PTZFilter has binding name 'tt__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (370)
#endif

/* tt__MetadataConfigurationExtension has binding name 'tt__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (369)
#endif

/* tt__MetadataConfiguration has binding name 'tt__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (368)
#endif

/* tt__VideoAnalyticsConfiguration has binding name 'tt__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (367)
#endif

/* tt__AudioEncoderConfigurationOption has binding name 'tt__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (366)
#endif

/* tt__AudioEncoderConfigurationOptions has binding name 'tt__AudioEncoderConfigurationOptions' for type 'tt:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (365)
#endif

/* tt__AudioEncoderConfiguration has binding name 'tt__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (364)
#endif

/* tt__AudioSourceOptionsExtension has binding name 'tt__AudioSourceOptionsExtension' for type 'tt:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (363)
#endif

/* tt__AudioSourceConfigurationOptions has binding name 'tt__AudioSourceConfigurationOptions' for type 'tt:AudioSourceConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (362)
#endif

/* tt__AudioSourceConfiguration has binding name 'tt__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (361)
#endif

/* tt__H264Options2 has binding name 'tt__H264Options2' for type 'tt:H264Options2' */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (360)
#endif

/* tt__H264Options has binding name 'tt__H264Options' for type 'tt:H264Options' */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (359)
#endif

/* tt__Mpeg4Options2 has binding name 'tt__Mpeg4Options2' for type 'tt:Mpeg4Options2' */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (358)
#endif

/* tt__Mpeg4Options has binding name 'tt__Mpeg4Options' for type 'tt:Mpeg4Options' */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (357)
#endif

/* tt__JpegOptions2 has binding name 'tt__JpegOptions2' for type 'tt:JpegOptions2' */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (356)
#endif

/* tt__JpegOptions has binding name 'tt__JpegOptions' for type 'tt:JpegOptions' */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (355)
#endif

/* tt__VideoEncoderOptionsExtension2 has binding name 'tt__VideoEncoderOptionsExtension2' for type 'tt:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (354)
#endif

/* tt__VideoEncoderOptionsExtension has binding name 'tt__VideoEncoderOptionsExtension' for type 'tt:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (353)
#endif

/* tt__VideoEncoderConfigurationOptions has binding name 'tt__VideoEncoderConfigurationOptions' for type 'tt:VideoEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (352)
#endif

/* tt__H264Configuration has binding name 'tt__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (351)
#endif

/* tt__Mpeg4Configuration has binding name 'tt__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (350)
#endif

/* tt__VideoRateControl has binding name 'tt__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (349)
#endif

/* tt__VideoResolution has binding name 'tt__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (348)
#endif

/* tt__VideoEncoderConfiguration has binding name 'tt__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (347)
#endif

/* tt__SceneOrientation has binding name 'tt__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (346)
#endif

/* tt__RotateOptionsExtension has binding name 'tt__RotateOptionsExtension' for type 'tt:RotateOptionsExtension' */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (345)
#endif

/* tt__RotateOptions has binding name 'tt__RotateOptions' for type 'tt:RotateOptions' */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (344)
#endif

/* tt__VideoSourceConfigurationOptionsExtension2 has binding name 'tt__VideoSourceConfigurationOptionsExtension2' for type 'tt:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (343)
#endif

/* tt__VideoSourceConfigurationOptionsExtension has binding name 'tt__VideoSourceConfigurationOptionsExtension' for type 'tt:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (342)
#endif

/* tt__VideoSourceConfigurationOptions has binding name 'tt__VideoSourceConfigurationOptions' for type 'tt:VideoSourceConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (341)
#endif

/* tt__LensDescription has binding name 'tt__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (340)
#endif

/* tt__LensOffset has binding name 'tt__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (339)
#endif

/* tt__LensProjection has binding name 'tt__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (338)
#endif

/* tt__RotateExtension has binding name 'tt__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (337)
#endif

/* tt__Rotate has binding name 'tt__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (336)
#endif

/* tt__VideoSourceConfigurationExtension2 has binding name 'tt__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (335)
#endif

/* tt__VideoSourceConfigurationExtension has binding name 'tt__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (334)
#endif

/* tt__VideoSourceConfiguration has binding name 'tt__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (333)
#endif

/* tt__ConfigurationEntity has binding name 'tt__ConfigurationEntity' for type 'tt:ConfigurationEntity' */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (332)
#endif

/* tt__ProfileExtension2 has binding name 'tt__ProfileExtension2' for type 'tt:ProfileExtension2' */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (331)
#endif

/* tt__ProfileExtension has binding name 'tt__ProfileExtension' for type 'tt:ProfileExtension' */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (330)
#endif

/* tt__Profile has binding name 'tt__Profile' for type 'tt:Profile' */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (329)
#endif

/* tt__AudioSource has binding name 'tt__AudioSource' for type 'tt:AudioSource' */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (328)
#endif

/* tt__VideoSourceExtension2 has binding name 'tt__VideoSourceExtension2' for type 'tt:VideoSourceExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (327)
#endif

/* tt__VideoSourceExtension has binding name 'tt__VideoSourceExtension' for type 'tt:VideoSourceExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (326)
#endif

/* tt__VideoSource has binding name 'tt__VideoSource' for type 'tt:VideoSource' */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (325)
#endif

/* tt__FloatList has binding name 'tt__FloatList' for type 'tt:FloatList' */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (324)
#endif

/* tt__IntList has binding name 'tt__IntList' for type 'tt:IntList' */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (323)
#endif

/* tt__DurationRange has binding name 'tt__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (322)
#endif

/* tt__FloatRange has binding name 'tt__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (321)
#endif

/* tt__IntRectangleRange has binding name 'tt__IntRectangleRange' for type 'tt:IntRectangleRange' */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (320)
#endif

/* tt__IntRectangle has binding name 'tt__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (319)
#endif

/* tt__DeviceEntity has binding name 'tt__DeviceEntity' for type 'tt:DeviceEntity' */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (318)
#endif

/* _tds__DeleteGeoLocationResponse has binding name '_tds__DeleteGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (317)
#endif

/* _tds__DeleteGeoLocation has binding name '_tds__DeleteGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (316)
#endif

/* _tds__SetGeoLocationResponse has binding name '_tds__SetGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (315)
#endif

/* _tds__SetGeoLocation has binding name '_tds__SetGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (314)
#endif

/* _tds__GetGeoLocationResponse has binding name '_tds__GetGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (313)
#endif

/* _tds__GetGeoLocation has binding name '_tds__GetGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (312)
#endif

/* _tds__DeleteStorageConfigurationResponse has binding name '_tds__DeleteStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (311)
#endif

/* _tds__DeleteStorageConfiguration has binding name '_tds__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (310)
#endif

/* _tds__SetStorageConfigurationResponse has binding name '_tds__SetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (309)
#endif

/* _tds__SetStorageConfiguration has binding name '_tds__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (308)
#endif

/* _tds__GetStorageConfigurationResponse has binding name '_tds__GetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (307)
#endif

/* _tds__GetStorageConfiguration has binding name '_tds__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (306)
#endif

/* _tds__CreateStorageConfigurationResponse has binding name '_tds__CreateStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (305)
#endif

/* _tds__CreateStorageConfiguration has binding name '_tds__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (304)
#endif

/* _tds__GetStorageConfigurationsResponse has binding name '_tds__GetStorageConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (303)
#endif

/* _tds__GetStorageConfigurations has binding name '_tds__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (302)
#endif

/* _tds__StartSystemRestoreResponse has binding name '_tds__StartSystemRestoreResponse' for type '' */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (301)
#endif

/* _tds__StartSystemRestore has binding name '_tds__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (300)
#endif

/* _tds__StartFirmwareUpgradeResponse has binding name '_tds__StartFirmwareUpgradeResponse' for type '' */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (299)
#endif

/* _tds__StartFirmwareUpgrade has binding name '_tds__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (298)
#endif

/* _tds__GetSystemUrisResponse has binding name '_tds__GetSystemUrisResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (297)
#endif

/* _tds__GetSystemUris has binding name '_tds__GetSystemUris' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (296)
#endif

/* _tds__ScanAvailableDot11NetworksResponse has binding name '_tds__ScanAvailableDot11NetworksResponse' for type '' */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (295)
#endif

/* _tds__ScanAvailableDot11Networks has binding name '_tds__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (294)
#endif

/* _tds__GetDot11StatusResponse has binding name '_tds__GetDot11StatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (293)
#endif

/* _tds__GetDot11Status has binding name '_tds__GetDot11Status' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (292)
#endif

/* _tds__GetDot11CapabilitiesResponse has binding name '_tds__GetDot11CapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (291)
#endif

/* _tds__GetDot11Capabilities has binding name '_tds__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (290)
#endif

/* _tds__SendAuxiliaryCommandResponse has binding name '_tds__SendAuxiliaryCommandResponse' for type '' */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (289)
#endif

/* _tds__SendAuxiliaryCommand has binding name '_tds__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (288)
#endif

/* _tds__SetRelayOutputStateResponse has binding name '_tds__SetRelayOutputStateResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (287)
#endif

/* _tds__SetRelayOutputState has binding name '_tds__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (286)
#endif

/* _tds__SetRelayOutputSettingsResponse has binding name '_tds__SetRelayOutputSettingsResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (285)
#endif

/* _tds__SetRelayOutputSettings has binding name '_tds__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (284)
#endif

/* _tds__GetRelayOutputsResponse has binding name '_tds__GetRelayOutputsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (283)
#endif

/* _tds__GetRelayOutputs has binding name '_tds__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (282)
#endif

/* _tds__DeleteDot1XConfigurationResponse has binding name '_tds__DeleteDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (281)
#endif

/* _tds__DeleteDot1XConfiguration has binding name '_tds__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (280)
#endif

/* _tds__GetDot1XConfigurationsResponse has binding name '_tds__GetDot1XConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (279)
#endif

/* _tds__GetDot1XConfigurations has binding name '_tds__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (278)
#endif

/* _tds__GetDot1XConfigurationResponse has binding name '_tds__GetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (277)
#endif

/* _tds__GetDot1XConfiguration has binding name '_tds__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (276)
#endif

/* _tds__SetDot1XConfigurationResponse has binding name '_tds__SetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (275)
#endif

/* _tds__SetDot1XConfiguration has binding name '_tds__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (274)
#endif

/* _tds__CreateDot1XConfigurationResponse has binding name '_tds__CreateDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (273)
#endif

/* _tds__CreateDot1XConfiguration has binding name '_tds__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (272)
#endif

/* _tds__LoadCACertificatesResponse has binding name '_tds__LoadCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (271)
#endif

/* _tds__LoadCACertificates has binding name '_tds__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (270)
#endif

/* _tds__GetCertificateInformationResponse has binding name '_tds__GetCertificateInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (269)
#endif

/* _tds__GetCertificateInformation has binding name '_tds__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (268)
#endif

/* _tds__LoadCertificateWithPrivateKeyResponse has binding name '_tds__LoadCertificateWithPrivateKeyResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (267)
#endif

/* _tds__LoadCertificateWithPrivateKey has binding name '_tds__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (266)
#endif

/* _tds__GetCACertificatesResponse has binding name '_tds__GetCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (265)
#endif

/* _tds__GetCACertificates has binding name '_tds__GetCACertificates' for type '' */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (264)
#endif

/* _tds__SetClientCertificateModeResponse has binding name '_tds__SetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (263)
#endif

/* _tds__SetClientCertificateMode has binding name '_tds__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (262)
#endif

/* _tds__GetClientCertificateModeResponse has binding name '_tds__GetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (261)
#endif

/* _tds__GetClientCertificateMode has binding name '_tds__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (260)
#endif

/* _tds__LoadCertificatesResponse has binding name '_tds__LoadCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (259)
#endif

/* _tds__LoadCertificates has binding name '_tds__LoadCertificates' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (258)
#endif

/* _tds__GetPkcs10RequestResponse has binding name '_tds__GetPkcs10RequestResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (257)
#endif

/* _tds__GetPkcs10Request has binding name '_tds__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (256)
#endif

/* _tds__DeleteCertificatesResponse has binding name '_tds__DeleteCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (255)
#endif

/* _tds__DeleteCertificates has binding name '_tds__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (254)
#endif

/* _tds__SetCertificatesStatusResponse has binding name '_tds__SetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (253)
#endif

/* _tds__SetCertificatesStatus has binding name '_tds__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (252)
#endif

/* _tds__GetCertificatesStatusResponse has binding name '_tds__GetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (251)
#endif

/* _tds__GetCertificatesStatus has binding name '_tds__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (250)
#endif

/* _tds__GetCertificatesResponse has binding name '_tds__GetCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (249)
#endif

/* _tds__GetCertificates has binding name '_tds__GetCertificates' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (248)
#endif

/* _tds__CreateCertificateResponse has binding name '_tds__CreateCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (247)
#endif

/* _tds__CreateCertificate has binding name '_tds__CreateCertificate' for type '' */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (246)
#endif

/* _tds__SetAccessPolicyResponse has binding name '_tds__SetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (245)
#endif

/* _tds__SetAccessPolicy has binding name '_tds__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (244)
#endif

/* _tds__GetAccessPolicyResponse has binding name '_tds__GetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (243)
#endif

/* _tds__GetAccessPolicy has binding name '_tds__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (242)
#endif

/* _tds__RemoveIPAddressFilterResponse has binding name '_tds__RemoveIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (241)
#endif

/* _tds__RemoveIPAddressFilter has binding name '_tds__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (240)
#endif

/* _tds__AddIPAddressFilterResponse has binding name '_tds__AddIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (239)
#endif

/* _tds__AddIPAddressFilter has binding name '_tds__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (238)
#endif

/* _tds__SetIPAddressFilterResponse has binding name '_tds__SetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (237)
#endif

/* _tds__SetIPAddressFilter has binding name '_tds__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (236)
#endif

/* _tds__GetIPAddressFilterResponse has binding name '_tds__GetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (235)
#endif

/* _tds__GetIPAddressFilter has binding name '_tds__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (234)
#endif

/* _tds__SetZeroConfigurationResponse has binding name '_tds__SetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (233)
#endif

/* _tds__SetZeroConfiguration has binding name '_tds__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (232)
#endif

/* _tds__GetZeroConfigurationResponse has binding name '_tds__GetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (231)
#endif

/* _tds__GetZeroConfiguration has binding name '_tds__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (230)
#endif

/* _tds__SetNetworkDefaultGatewayResponse has binding name '_tds__SetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (229)
#endif

/* _tds__SetNetworkDefaultGateway has binding name '_tds__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (228)
#endif

/* _tds__GetNetworkDefaultGatewayResponse has binding name '_tds__GetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (227)
#endif

/* _tds__GetNetworkDefaultGateway has binding name '_tds__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (226)
#endif

/* _tds__SetNetworkProtocolsResponse has binding name '_tds__SetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (225)
#endif

/* _tds__SetNetworkProtocols has binding name '_tds__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (224)
#endif

/* _tds__GetNetworkProtocolsResponse has binding name '_tds__GetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (223)
#endif

/* _tds__GetNetworkProtocols has binding name '_tds__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (222)
#endif

/* _tds__SetNetworkInterfacesResponse has binding name '_tds__SetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (221)
#endif

/* _tds__SetNetworkInterfaces has binding name '_tds__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (220)
#endif

/* _tds__GetNetworkInterfacesResponse has binding name '_tds__GetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (219)
#endif

/* _tds__GetNetworkInterfaces has binding name '_tds__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (218)
#endif

/* _tds__SetDynamicDNSResponse has binding name '_tds__SetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (217)
#endif

/* _tds__SetDynamicDNS has binding name '_tds__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (216)
#endif

/* _tds__GetDynamicDNSResponse has binding name '_tds__GetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (215)
#endif

/* _tds__GetDynamicDNS has binding name '_tds__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (214)
#endif

/* _tds__SetNTPResponse has binding name '_tds__SetNTPResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (213)
#endif

/* _tds__SetNTP has binding name '_tds__SetNTP' for type '' */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (212)
#endif

/* _tds__GetNTPResponse has binding name '_tds__GetNTPResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (211)
#endif

/* _tds__GetNTP has binding name '_tds__GetNTP' for type '' */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (210)
#endif

/* _tds__SetDNSResponse has binding name '_tds__SetDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (209)
#endif

/* _tds__SetDNS has binding name '_tds__SetDNS' for type '' */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (208)
#endif

/* _tds__GetDNSResponse has binding name '_tds__GetDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (207)
#endif

/* _tds__GetDNS has binding name '_tds__GetDNS' for type '' */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (206)
#endif

/* _tds__SetHostnameFromDHCPResponse has binding name '_tds__SetHostnameFromDHCPResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (205)
#endif

/* _tds__SetHostnameFromDHCP has binding name '_tds__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (204)
#endif

/* _tds__SetHostnameResponse has binding name '_tds__SetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (203)
#endif

/* _tds__SetHostname has binding name '_tds__SetHostname' for type '' */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (202)
#endif

/* _tds__GetHostnameResponse has binding name '_tds__GetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (201)
#endif

/* _tds__GetHostname has binding name '_tds__GetHostname' for type '' */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (200)
#endif

/* _tds__GetCapabilitiesResponse has binding name '_tds__GetCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (199)
#endif

/* _tds__GetCapabilities has binding name '_tds__GetCapabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (198)
#endif

/* _tds__GetWsdlUrlResponse has binding name '_tds__GetWsdlUrlResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (197)
#endif

/* _tds__GetWsdlUrl has binding name '_tds__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (196)
#endif

/* _tds__SetUserResponse has binding name '_tds__SetUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (195)
#endif

/* _tds__SetUser has binding name '_tds__SetUser' for type '' */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (194)
#endif

/* _tds__DeleteUsersResponse has binding name '_tds__DeleteUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (193)
#endif

/* _tds__DeleteUsers has binding name '_tds__DeleteUsers' for type '' */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (192)
#endif

/* _tds__CreateUsersResponse has binding name '_tds__CreateUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (191)
#endif

/* _tds__CreateUsers has binding name '_tds__CreateUsers' for type '' */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (190)
#endif

/* _tds__GetUsersResponse has binding name '_tds__GetUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (189)
#endif

/* _tds__GetUsers has binding name '_tds__GetUsers' for type '' */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (188)
#endif

/* _tds__SetRemoteUserResponse has binding name '_tds__SetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (187)
#endif

/* _tds__SetRemoteUser has binding name '_tds__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (186)
#endif

/* _tds__GetRemoteUserResponse has binding name '_tds__GetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (185)
#endif

/* _tds__GetRemoteUser has binding name '_tds__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (184)
#endif

/* _tds__GetEndpointReferenceResponse has binding name '_tds__GetEndpointReferenceResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (183)
#endif

/* _tds__GetEndpointReference has binding name '_tds__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (182)
#endif

/* _tds__SetDPAddressesResponse has binding name '_tds__SetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (181)
#endif

/* _tds__SetDPAddresses has binding name '_tds__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (180)
#endif

/* _tds__GetDPAddressesResponse has binding name '_tds__GetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (179)
#endif

/* _tds__GetDPAddresses has binding name '_tds__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (178)
#endif

/* _tds__SetRemoteDiscoveryModeResponse has binding name '_tds__SetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (177)
#endif

/* _tds__SetRemoteDiscoveryMode has binding name '_tds__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (176)
#endif

/* _tds__GetRemoteDiscoveryModeResponse has binding name '_tds__GetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (175)
#endif

/* _tds__GetRemoteDiscoveryMode has binding name '_tds__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (174)
#endif

/* _tds__SetDiscoveryModeResponse has binding name '_tds__SetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (173)
#endif

/* _tds__SetDiscoveryMode has binding name '_tds__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (172)
#endif

/* _tds__GetDiscoveryModeResponse has binding name '_tds__GetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (171)
#endif

/* _tds__GetDiscoveryMode has binding name '_tds__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (170)
#endif

/* _tds__RemoveScopesResponse has binding name '_tds__RemoveScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (169)
#endif

/* _tds__RemoveScopes has binding name '_tds__RemoveScopes' for type '' */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (168)
#endif

/* _tds__AddScopesResponse has binding name '_tds__AddScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (167)
#endif

/* _tds__AddScopes has binding name '_tds__AddScopes' for type '' */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (166)
#endif

/* _tds__SetScopesResponse has binding name '_tds__SetScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (165)
#endif

/* _tds__SetScopes has binding name '_tds__SetScopes' for type '' */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (164)
#endif

/* _tds__GetScopesResponse has binding name '_tds__GetScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (163)
#endif

/* _tds__GetScopes has binding name '_tds__GetScopes' for type '' */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (162)
#endif

/* _tds__GetSystemLogResponse has binding name '_tds__GetSystemLogResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (161)
#endif

/* _tds__GetSystemLog has binding name '_tds__GetSystemLog' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (160)
#endif

/* _tds__GetSystemSupportInformationResponse has binding name '_tds__GetSystemSupportInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (159)
#endif

/* _tds__GetSystemSupportInformation has binding name '_tds__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (158)
#endif

/* _tds__GetSystemBackupResponse has binding name '_tds__GetSystemBackupResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (157)
#endif

/* _tds__GetSystemBackup has binding name '_tds__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (156)
#endif

/* _tds__RestoreSystemResponse has binding name '_tds__RestoreSystemResponse' for type '' */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (155)
#endif

/* _tds__RestoreSystem has binding name '_tds__RestoreSystem' for type '' */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (154)
#endif

/* _tds__SystemRebootResponse has binding name '_tds__SystemRebootResponse' for type '' */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (153)
#endif

/* _tds__SystemReboot has binding name '_tds__SystemReboot' for type '' */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (152)
#endif

/* _tds__UpgradeSystemFirmwareResponse has binding name '_tds__UpgradeSystemFirmwareResponse' for type '' */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (151)
#endif

/* _tds__UpgradeSystemFirmware has binding name '_tds__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (150)
#endif

/* _tds__SetSystemFactoryDefaultResponse has binding name '_tds__SetSystemFactoryDefaultResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (149)
#endif

/* _tds__SetSystemFactoryDefault has binding name '_tds__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (148)
#endif

/* _tds__GetSystemDateAndTimeResponse has binding name '_tds__GetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (147)
#endif

/* _tds__GetSystemDateAndTime has binding name '_tds__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (146)
#endif

/* _tds__SetSystemDateAndTimeResponse has binding name '_tds__SetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (145)
#endif

/* _tds__SetSystemDateAndTime has binding name '_tds__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (144)
#endif

/* _tds__GetDeviceInformationResponse has binding name '_tds__GetDeviceInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (143)
#endif

/* _tds__GetDeviceInformation has binding name '_tds__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (142)
#endif

/* _tds__GetServiceCapabilitiesResponse has binding name '_tds__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (141)
#endif

/* _tds__GetServiceCapabilities has binding name '_tds__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (140)
#endif

/* _tds__GetServicesResponse has binding name '_tds__GetServicesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (139)
#endif

/* _tds__GetServices has binding name '_tds__GetServices' for type '' */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (138)
#endif

/* tds__StorageConfiguration has binding name 'tds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (137)
#endif

/* tds__StorageConfigurationData has binding name 'tds__StorageConfigurationData' for type 'tds:StorageConfigurationData' */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (136)
#endif

/* tds__UserCredential has binding name 'tds__UserCredential' for type 'tds:UserCredential' */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (135)
#endif

/* tds__MiscCapabilities has binding name 'tds__MiscCapabilities' for type 'tds:MiscCapabilities' */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (134)
#endif

/* tds__SystemCapabilities has binding name 'tds__SystemCapabilities' for type 'tds:SystemCapabilities' */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (133)
#endif

/* tds__SecurityCapabilities has binding name 'tds__SecurityCapabilities' for type 'tds:SecurityCapabilities' */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (132)
#endif

/* tds__NetworkCapabilities has binding name 'tds__NetworkCapabilities' for type 'tds:NetworkCapabilities' */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (131)
#endif

/* tds__DeviceServiceCapabilities has binding name 'tds__DeviceServiceCapabilities' for type 'tds:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (130)
#endif

/* tds__Service has binding name 'tds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (129)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (128)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (127)
#endif

/* xsd__positiveInteger has binding name 'xsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_xsd__positiveInteger
#define SOAP_TYPE_xsd__positiveInteger (126)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (125)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (124)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (123)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (122)
#endif

/* xsd__anySimpleType has binding name 'xsd__anySimpleType' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (121)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (120)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (119)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (118)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (117)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (116)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (112)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (3522)
#endif

/* _saml2__EncryptedAttribute has binding name '_saml2__EncryptedAttribute' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAttribute
#define SOAP_TYPE__saml2__EncryptedAttribute (3521)
#endif

/* _saml2__Attribute has binding name '_saml2__Attribute' for type '' */
#ifndef SOAP_TYPE__saml2__Attribute
#define SOAP_TYPE__saml2__Attribute (3519)
#endif

/* _saml2__AttributeStatement has binding name '_saml2__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeStatement
#define SOAP_TYPE__saml2__AttributeStatement (3518)
#endif

/* _saml2__Evidence has binding name '_saml2__Evidence' for type '' */
#ifndef SOAP_TYPE__saml2__Evidence
#define SOAP_TYPE__saml2__Evidence (3517)
#endif

/* _saml2__Action has binding name '_saml2__Action' for type '' */
#ifndef SOAP_TYPE__saml2__Action
#define SOAP_TYPE__saml2__Action (3516)
#endif

/* _saml2__AuthzDecisionStatement has binding name '_saml2__AuthzDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthzDecisionStatement
#define SOAP_TYPE__saml2__AuthzDecisionStatement (3515)
#endif

/* _saml2__AuthnContext has binding name '_saml2__AuthnContext' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContext
#define SOAP_TYPE__saml2__AuthnContext (3510)
#endif

/* _saml2__SubjectLocality has binding name '_saml2__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectLocality
#define SOAP_TYPE__saml2__SubjectLocality (3509)
#endif

/* _saml2__AuthnStatement has binding name '_saml2__AuthnStatement' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnStatement
#define SOAP_TYPE__saml2__AuthnStatement (3508)
#endif

/* _saml2__Statement has binding name '_saml2__Statement' for type '' */
#ifndef SOAP_TYPE__saml2__Statement
#define SOAP_TYPE__saml2__Statement (3507)
#endif

/* _saml2__EncryptedAssertion has binding name '_saml2__EncryptedAssertion' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedAssertion
#define SOAP_TYPE__saml2__EncryptedAssertion (3506)
#endif

/* _saml2__Advice has binding name '_saml2__Advice' for type '' */
#ifndef SOAP_TYPE__saml2__Advice
#define SOAP_TYPE__saml2__Advice (3505)
#endif

/* _saml2__ProxyRestriction has binding name '_saml2__ProxyRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__ProxyRestriction
#define SOAP_TYPE__saml2__ProxyRestriction (3504)
#endif

/* _saml2__OneTimeUse has binding name '_saml2__OneTimeUse' for type '' */
#ifndef SOAP_TYPE__saml2__OneTimeUse
#define SOAP_TYPE__saml2__OneTimeUse (3503)
#endif

/* _saml2__AudienceRestriction has binding name '_saml2__AudienceRestriction' for type '' */
#ifndef SOAP_TYPE__saml2__AudienceRestriction
#define SOAP_TYPE__saml2__AudienceRestriction (3501)
#endif

/* _saml2__Condition has binding name '_saml2__Condition' for type '' */
#ifndef SOAP_TYPE__saml2__Condition
#define SOAP_TYPE__saml2__Condition (3500)
#endif

/* _saml2__Conditions has binding name '_saml2__Conditions' for type '' */
#ifndef SOAP_TYPE__saml2__Conditions
#define SOAP_TYPE__saml2__Conditions (3499)
#endif

/* _saml2__SubjectConfirmationData has binding name '_saml2__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmationData
#define SOAP_TYPE__saml2__SubjectConfirmationData (3498)
#endif

/* _saml2__SubjectConfirmation has binding name '_saml2__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml2__SubjectConfirmation
#define SOAP_TYPE__saml2__SubjectConfirmation (3497)
#endif

/* _saml2__Subject has binding name '_saml2__Subject' for type '' */
#ifndef SOAP_TYPE__saml2__Subject
#define SOAP_TYPE__saml2__Subject (3496)
#endif

/* _saml2__Assertion has binding name '_saml2__Assertion' for type '' */
#ifndef SOAP_TYPE__saml2__Assertion
#define SOAP_TYPE__saml2__Assertion (3495)
#endif

/* _saml2__Issuer has binding name '_saml2__Issuer' for type '' */
#ifndef SOAP_TYPE__saml2__Issuer
#define SOAP_TYPE__saml2__Issuer (3492)
#endif

/* _saml2__EncryptedID has binding name '_saml2__EncryptedID' for type '' */
#ifndef SOAP_TYPE__saml2__EncryptedID
#define SOAP_TYPE__saml2__EncryptedID (3491)
#endif

/* _saml2__NameID has binding name '_saml2__NameID' for type '' */
#ifndef SOAP_TYPE__saml2__NameID
#define SOAP_TYPE__saml2__NameID (3490)
#endif

/* _saml2__BaseID has binding name '_saml2__BaseID' for type '' */
#ifndef SOAP_TYPE__saml2__BaseID
#define SOAP_TYPE__saml2__BaseID (3489)
#endif

/* struct saml2__AttributeType has binding name 'saml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_saml2__AttributeType
#define SOAP_TYPE_saml2__AttributeType (3452)
#endif

/* struct saml2__AttributeStatementType has binding name 'saml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_saml2__AttributeStatementType
#define SOAP_TYPE_saml2__AttributeStatementType (3451)
#endif

/* struct saml2__EvidenceType has binding name 'saml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_saml2__EvidenceType
#define SOAP_TYPE_saml2__EvidenceType (3450)
#endif

/* struct saml2__ActionType has binding name 'saml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_saml2__ActionType
#define SOAP_TYPE_saml2__ActionType (3449)
#endif

/* struct saml2__AuthzDecisionStatementType has binding name 'saml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_saml2__AuthzDecisionStatementType
#define SOAP_TYPE_saml2__AuthzDecisionStatementType (3448)
#endif

/* struct saml2__AuthnContextType has binding name 'saml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_saml2__AuthnContextType
#define SOAP_TYPE_saml2__AuthnContextType (3447)
#endif

/* struct saml2__SubjectLocalityType has binding name 'saml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml2__SubjectLocalityType
#define SOAP_TYPE_saml2__SubjectLocalityType (3446)
#endif

/* struct saml2__AuthnStatementType has binding name 'saml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_saml2__AuthnStatementType
#define SOAP_TYPE_saml2__AuthnStatementType (3445)
#endif

/* struct saml2__StatementAbstractType has binding name 'saml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_saml2__StatementAbstractType
#define SOAP_TYPE_saml2__StatementAbstractType (3444)
#endif

/* struct saml2__AdviceType has binding name 'saml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_saml2__AdviceType
#define SOAP_TYPE_saml2__AdviceType (3443)
#endif

/* struct saml2__ProxyRestrictionType has binding name 'saml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_saml2__ProxyRestrictionType
#define SOAP_TYPE_saml2__ProxyRestrictionType (3442)
#endif

/* struct saml2__OneTimeUseType has binding name 'saml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_saml2__OneTimeUseType
#define SOAP_TYPE_saml2__OneTimeUseType (3441)
#endif

/* struct saml2__AudienceRestrictionType has binding name 'saml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_saml2__AudienceRestrictionType
#define SOAP_TYPE_saml2__AudienceRestrictionType (3440)
#endif

/* struct saml2__ConditionAbstractType has binding name 'saml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml2__ConditionAbstractType
#define SOAP_TYPE_saml2__ConditionAbstractType (3439)
#endif

/* struct saml2__ConditionsType has binding name 'saml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_saml2__ConditionsType
#define SOAP_TYPE_saml2__ConditionsType (3438)
#endif

/* struct saml2__KeyInfoConfirmationDataType has binding name 'saml2__KeyInfoConfirmationDataType' for type 'saml2:KeyInfoConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__KeyInfoConfirmationDataType
#define SOAP_TYPE_saml2__KeyInfoConfirmationDataType (3437)
#endif

/* struct saml2__SubjectConfirmationDataType has binding name 'saml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationDataType
#define SOAP_TYPE_saml2__SubjectConfirmationDataType (3436)
#endif

/* struct saml2__SubjectConfirmationType has binding name 'saml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml2__SubjectConfirmationType
#define SOAP_TYPE_saml2__SubjectConfirmationType (3435)
#endif

/* struct saml2__SubjectType has binding name 'saml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_saml2__SubjectType
#define SOAP_TYPE_saml2__SubjectType (3434)
#endif

/* struct saml2__AssertionType has binding name 'saml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_saml2__AssertionType
#define SOAP_TYPE_saml2__AssertionType (3433)
#endif

/* struct saml2__EncryptedElementType has binding name 'saml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_saml2__EncryptedElementType
#define SOAP_TYPE_saml2__EncryptedElementType (3432)
#endif

/* struct saml2__NameIDType has binding name 'saml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_saml2__NameIDType
#define SOAP_TYPE_saml2__NameIDType (3431)
#endif

/* struct saml2__BaseIDAbstractType has binding name 'saml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_saml2__BaseIDAbstractType
#define SOAP_TYPE_saml2__BaseIDAbstractType (3430)
#endif

/* _saml1__Attribute has binding name '_saml1__Attribute' for type '' */
#ifndef SOAP_TYPE__saml1__Attribute
#define SOAP_TYPE__saml1__Attribute (3428)
#endif

/* _saml1__AttributeDesignator has binding name '_saml1__AttributeDesignator' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeDesignator
#define SOAP_TYPE__saml1__AttributeDesignator (3427)
#endif

/* _saml1__AttributeStatement has binding name '_saml1__AttributeStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeStatement
#define SOAP_TYPE__saml1__AttributeStatement (3426)
#endif

/* _saml1__Evidence has binding name '_saml1__Evidence' for type '' */
#ifndef SOAP_TYPE__saml1__Evidence
#define SOAP_TYPE__saml1__Evidence (3425)
#endif

/* _saml1__Action has binding name '_saml1__Action' for type '' */
#ifndef SOAP_TYPE__saml1__Action
#define SOAP_TYPE__saml1__Action (3424)
#endif

/* _saml1__AuthorizationDecisionStatement has binding name '_saml1__AuthorizationDecisionStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorizationDecisionStatement
#define SOAP_TYPE__saml1__AuthorizationDecisionStatement (3423)
#endif

/* _saml1__AuthorityBinding has binding name '_saml1__AuthorityBinding' for type '' */
#ifndef SOAP_TYPE__saml1__AuthorityBinding
#define SOAP_TYPE__saml1__AuthorityBinding (3422)
#endif

/* _saml1__SubjectLocality has binding name '_saml1__SubjectLocality' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectLocality
#define SOAP_TYPE__saml1__SubjectLocality (3421)
#endif

/* _saml1__AuthenticationStatement has binding name '_saml1__AuthenticationStatement' for type '' */
#ifndef SOAP_TYPE__saml1__AuthenticationStatement
#define SOAP_TYPE__saml1__AuthenticationStatement (3420)
#endif

/* _saml1__SubjectConfirmation has binding name '_saml1__SubjectConfirmation' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmation
#define SOAP_TYPE__saml1__SubjectConfirmation (3417)
#endif

/* _saml1__NameIdentifier has binding name '_saml1__NameIdentifier' for type '' */
#ifndef SOAP_TYPE__saml1__NameIdentifier
#define SOAP_TYPE__saml1__NameIdentifier (3416)
#endif

/* _saml1__Subject has binding name '_saml1__Subject' for type '' */
#ifndef SOAP_TYPE__saml1__Subject
#define SOAP_TYPE__saml1__Subject (3415)
#endif

/* _saml1__SubjectStatement has binding name '_saml1__SubjectStatement' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectStatement
#define SOAP_TYPE__saml1__SubjectStatement (3414)
#endif

/* _saml1__Statement has binding name '_saml1__Statement' for type '' */
#ifndef SOAP_TYPE__saml1__Statement
#define SOAP_TYPE__saml1__Statement (3413)
#endif

/* _saml1__Advice has binding name '_saml1__Advice' for type '' */
#ifndef SOAP_TYPE__saml1__Advice
#define SOAP_TYPE__saml1__Advice (3412)
#endif

/* _saml1__DoNotCacheCondition has binding name '_saml1__DoNotCacheCondition' for type '' */
#ifndef SOAP_TYPE__saml1__DoNotCacheCondition
#define SOAP_TYPE__saml1__DoNotCacheCondition (3411)
#endif

/* _saml1__AudienceRestrictionCondition has binding name '_saml1__AudienceRestrictionCondition' for type '' */
#ifndef SOAP_TYPE__saml1__AudienceRestrictionCondition
#define SOAP_TYPE__saml1__AudienceRestrictionCondition (3409)
#endif

/* _saml1__Condition has binding name '_saml1__Condition' for type '' */
#ifndef SOAP_TYPE__saml1__Condition
#define SOAP_TYPE__saml1__Condition (3408)
#endif

/* _saml1__Conditions has binding name '_saml1__Conditions' for type '' */
#ifndef SOAP_TYPE__saml1__Conditions
#define SOAP_TYPE__saml1__Conditions (3407)
#endif

/* _saml1__Assertion has binding name '_saml1__Assertion' for type '' */
#ifndef SOAP_TYPE__saml1__Assertion
#define SOAP_TYPE__saml1__Assertion (3406)
#endif

/* struct saml1__AttributeType has binding name 'saml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_saml1__AttributeType
#define SOAP_TYPE_saml1__AttributeType (3374)
#endif

/* struct saml1__AttributeDesignatorType has binding name 'saml1__AttributeDesignatorType' for type 'saml1:AttributeDesignatorType' */
#ifndef SOAP_TYPE_saml1__AttributeDesignatorType
#define SOAP_TYPE_saml1__AttributeDesignatorType (3373)
#endif

/* struct saml1__AttributeStatementType has binding name 'saml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_saml1__AttributeStatementType
#define SOAP_TYPE_saml1__AttributeStatementType (3372)
#endif

/* struct saml1__EvidenceType has binding name 'saml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_saml1__EvidenceType
#define SOAP_TYPE_saml1__EvidenceType (3371)
#endif

/* struct saml1__ActionType has binding name 'saml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_saml1__ActionType
#define SOAP_TYPE_saml1__ActionType (3370)
#endif

/* struct saml1__AuthorizationDecisionStatementType has binding name 'saml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_saml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_saml1__AuthorizationDecisionStatementType (3369)
#endif

/* struct saml1__AuthorityBindingType has binding name 'saml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_saml1__AuthorityBindingType
#define SOAP_TYPE_saml1__AuthorityBindingType (3368)
#endif

/* struct saml1__SubjectLocalityType has binding name 'saml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_saml1__SubjectLocalityType
#define SOAP_TYPE_saml1__SubjectLocalityType (3367)
#endif

/* struct saml1__AuthenticationStatementType has binding name 'saml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_saml1__AuthenticationStatementType
#define SOAP_TYPE_saml1__AuthenticationStatementType (3366)
#endif

/* struct saml1__SubjectConfirmationType has binding name 'saml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_saml1__SubjectConfirmationType
#define SOAP_TYPE_saml1__SubjectConfirmationType (3365)
#endif

/* struct saml1__NameIdentifierType has binding name 'saml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_saml1__NameIdentifierType
#define SOAP_TYPE_saml1__NameIdentifierType (3364)
#endif

/* struct saml1__SubjectType has binding name 'saml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_saml1__SubjectType
#define SOAP_TYPE_saml1__SubjectType (3363)
#endif

/* struct saml1__SubjectStatementAbstractType has binding name 'saml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_saml1__SubjectStatementAbstractType
#define SOAP_TYPE_saml1__SubjectStatementAbstractType (3362)
#endif

/* struct saml1__StatementAbstractType has binding name 'saml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_saml1__StatementAbstractType
#define SOAP_TYPE_saml1__StatementAbstractType (3361)
#endif

/* struct saml1__AdviceType has binding name 'saml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_saml1__AdviceType
#define SOAP_TYPE_saml1__AdviceType (3360)
#endif

/* struct saml1__DoNotCacheConditionType has binding name 'saml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_saml1__DoNotCacheConditionType
#define SOAP_TYPE_saml1__DoNotCacheConditionType (3359)
#endif

/* struct saml1__AudienceRestrictionConditionType has binding name 'saml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_saml1__AudienceRestrictionConditionType
#define SOAP_TYPE_saml1__AudienceRestrictionConditionType (3358)
#endif

/* struct saml1__ConditionAbstractType has binding name 'saml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_saml1__ConditionAbstractType
#define SOAP_TYPE_saml1__ConditionAbstractType (3357)
#endif

/* struct saml1__ConditionsType has binding name 'saml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_saml1__ConditionsType
#define SOAP_TYPE_saml1__ConditionsType (3356)
#endif

/* struct saml1__AssertionType has binding name 'saml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_saml1__AssertionType
#define SOAP_TYPE_saml1__AssertionType (3355)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (3349)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (3348)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (3347)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (3333)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (3332)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (3331)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (3330)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (3329)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (3328)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (3327)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (3326)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (3325)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (3324)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (3323)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (3322)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (3311)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (3310)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (3309)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (3308)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (3305)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (3303)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (3302)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (3301)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (3299)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (3298)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (3297)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (3296)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (3295)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (3294)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (3293)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (3291)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (3289)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (3288)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (3285)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (3281)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (3280)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (3279)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (3278)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (3277)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (3274)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (3273)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (3271)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (3270)
#endif

/* struct SOAP_ENV__Envelope has binding name 'SOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (114)
#endif

/* struct _xop__Include has binding name '_xop__Include' for type '' */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (109)
#endif

/* _wsdd__AppSequence has binding name '_wsdd__AppSequence' for type '' */
#ifndef SOAP_TYPE__wsdd__AppSequence
#define SOAP_TYPE__wsdd__AppSequence (88)
#endif

/* _wsdd__Sig has binding name '_wsdd__Sig' for type '' */
#ifndef SOAP_TYPE__wsdd__Sig
#define SOAP_TYPE__wsdd__Sig (87)
#endif

/* _wsdd__Security has binding name '_wsdd__Security' for type '' */
#ifndef SOAP_TYPE__wsdd__Security
#define SOAP_TYPE__wsdd__Security (86)
#endif

/* _wsdd__Scopes has binding name '_wsdd__Scopes' for type '' */
#ifndef SOAP_TYPE__wsdd__Scopes
#define SOAP_TYPE__wsdd__Scopes (82)
#endif

/* _wsdd__ResolveMatches has binding name '_wsdd__ResolveMatches' for type '' */
#ifndef SOAP_TYPE__wsdd__ResolveMatches
#define SOAP_TYPE__wsdd__ResolveMatches (80)
#endif

/* _wsdd__Resolve has binding name '_wsdd__Resolve' for type '' */
#ifndef SOAP_TYPE__wsdd__Resolve
#define SOAP_TYPE__wsdd__Resolve (79)
#endif

/* _wsdd__ProbeMatches has binding name '_wsdd__ProbeMatches' for type '' */
#ifndef SOAP_TYPE__wsdd__ProbeMatches
#define SOAP_TYPE__wsdd__ProbeMatches (78)
#endif

/* _wsdd__Probe has binding name '_wsdd__Probe' for type '' */
#ifndef SOAP_TYPE__wsdd__Probe
#define SOAP_TYPE__wsdd__Probe (77)
#endif

/* _wsdd__Bye has binding name '_wsdd__Bye' for type '' */
#ifndef SOAP_TYPE__wsdd__Bye
#define SOAP_TYPE__wsdd__Bye (76)
#endif

/* _wsdd__Hello has binding name '_wsdd__Hello' for type '' */
#ifndef SOAP_TYPE__wsdd__Hello
#define SOAP_TYPE__wsdd__Hello (75)
#endif

/* struct wsdd__AppSequenceType has binding name 'wsdd__AppSequenceType' for type 'wsdd:AppSequenceType' */
#ifndef SOAP_TYPE_wsdd__AppSequenceType
#define SOAP_TYPE_wsdd__AppSequenceType (64)
#endif

/* struct wsdd__SigType has binding name 'wsdd__SigType' for type 'wsdd:SigType' */
#ifndef SOAP_TYPE_wsdd__SigType
#define SOAP_TYPE_wsdd__SigType (63)
#endif

/* struct wsdd__SecurityType has binding name 'wsdd__SecurityType' for type 'wsdd:SecurityType' */
#ifndef SOAP_TYPE_wsdd__SecurityType
#define SOAP_TYPE_wsdd__SecurityType (62)
#endif

/* struct wsdd__ScopesType has binding name 'wsdd__ScopesType' for type 'wsdd:ScopesType' */
#ifndef SOAP_TYPE_wsdd__ScopesType
#define SOAP_TYPE_wsdd__ScopesType (61)
#endif

/* struct wsdd__ResolveMatchType has binding name 'wsdd__ResolveMatchType' for type 'wsdd:ResolveMatchType' */
#ifndef SOAP_TYPE_wsdd__ResolveMatchType
#define SOAP_TYPE_wsdd__ResolveMatchType (60)
#endif

/* struct wsdd__ResolveMatchesType has binding name 'wsdd__ResolveMatchesType' for type 'wsdd:ResolveMatchesType' */
#ifndef SOAP_TYPE_wsdd__ResolveMatchesType
#define SOAP_TYPE_wsdd__ResolveMatchesType (59)
#endif

/* struct wsdd__ResolveType has binding name 'wsdd__ResolveType' for type 'wsdd:ResolveType' */
#ifndef SOAP_TYPE_wsdd__ResolveType
#define SOAP_TYPE_wsdd__ResolveType (58)
#endif

/* struct wsdd__ProbeMatchType has binding name 'wsdd__ProbeMatchType' for type 'wsdd:ProbeMatchType' */
#ifndef SOAP_TYPE_wsdd__ProbeMatchType
#define SOAP_TYPE_wsdd__ProbeMatchType (57)
#endif

/* struct wsdd__ProbeMatchesType has binding name 'wsdd__ProbeMatchesType' for type 'wsdd:ProbeMatchesType' */
#ifndef SOAP_TYPE_wsdd__ProbeMatchesType
#define SOAP_TYPE_wsdd__ProbeMatchesType (56)
#endif

/* struct wsdd__ProbeType has binding name 'wsdd__ProbeType' for type 'wsdd:ProbeType' */
#ifndef SOAP_TYPE_wsdd__ProbeType
#define SOAP_TYPE_wsdd__ProbeType (55)
#endif

/* struct wsdd__ByeType has binding name 'wsdd__ByeType' for type 'wsdd:ByeType' */
#ifndef SOAP_TYPE_wsdd__ByeType
#define SOAP_TYPE_wsdd__ByeType (54)
#endif

/* struct wsdd__HelloType has binding name 'wsdd__HelloType' for type 'wsdd:HelloType' */
#ifndef SOAP_TYPE_wsdd__HelloType
#define SOAP_TYPE_wsdd__HelloType (53)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (52)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (48)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (46)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (44)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (38)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (37)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (35)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (28)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (27)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (26)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (25)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (23)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (22)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (21)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (12)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (11)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (10)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (9)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (8)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (3528)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (3527)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (3526)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (3525)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (3524)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (3523)
#endif

/* _saml2__AttributeValue has binding name '_saml2__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml2__AttributeValue
#define SOAP_TYPE__saml2__AttributeValue (3520)
#endif

/* _saml2__AuthenticatingAuthority has binding name '_saml2__AuthenticatingAuthority' for type '' */
#ifndef SOAP_TYPE__saml2__AuthenticatingAuthority
#define SOAP_TYPE__saml2__AuthenticatingAuthority (3514)
#endif

/* _saml2__AuthnContextDecl has binding name '_saml2__AuthnContextDecl' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDecl
#define SOAP_TYPE__saml2__AuthnContextDecl (3513)
#endif

/* _saml2__AuthnContextDeclRef has binding name '_saml2__AuthnContextDeclRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextDeclRef
#define SOAP_TYPE__saml2__AuthnContextDeclRef (3512)
#endif

/* _saml2__AuthnContextClassRef has binding name '_saml2__AuthnContextClassRef' for type '' */
#ifndef SOAP_TYPE__saml2__AuthnContextClassRef
#define SOAP_TYPE__saml2__AuthnContextClassRef (3511)
#endif

/* _saml2__Audience has binding name '_saml2__Audience' for type '' */
#ifndef SOAP_TYPE__saml2__Audience
#define SOAP_TYPE__saml2__Audience (3502)
#endif

/* _saml2__AssertionURIRef has binding name '_saml2__AssertionURIRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionURIRef
#define SOAP_TYPE__saml2__AssertionURIRef (3494)
#endif

/* _saml2__AssertionIDRef has binding name '_saml2__AssertionIDRef' for type '' */
#ifndef SOAP_TYPE__saml2__AssertionIDRef
#define SOAP_TYPE__saml2__AssertionIDRef (3493)
#endif

/* struct ds__KeyInfoType ** has binding name 'PointerToPointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerToPointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerToPointerTo_ds__KeyInfo (3488)
#endif

/* struct __saml2__union_AttributeStatementType * has binding name 'PointerTo__saml2__union_AttributeStatementType' for type '-saml2:union-AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType
#define SOAP_TYPE_PointerTo__saml2__union_AttributeStatementType (3487)
#endif

/* struct saml2__AttributeType * has binding name 'PointerTosaml2__AttributeType' for type 'saml2:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeType
#define SOAP_TYPE_PointerTosaml2__AttributeType (3486)
#endif

/* struct saml2__EvidenceType * has binding name 'PointerTosaml2__EvidenceType' for type 'saml2:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml2__EvidenceType
#define SOAP_TYPE_PointerTosaml2__EvidenceType (3484)
#endif

/* struct saml2__ActionType * has binding name 'PointerTosaml2__ActionType' for type 'saml2:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ActionType
#define SOAP_TYPE_PointerTosaml2__ActionType (3483)
#endif

/* struct saml2__AuthnContextType * has binding name 'PointerTosaml2__AuthnContextType' for type 'saml2:AuthnContextType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnContextType
#define SOAP_TYPE_PointerTosaml2__AuthnContextType (3482)
#endif

/* struct saml2__SubjectLocalityType * has binding name 'PointerTosaml2__SubjectLocalityType' for type 'saml2:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml2__SubjectLocalityType (3481)
#endif

/* struct __saml2__union_EvidenceType * has binding name 'PointerTo__saml2__union_EvidenceType' for type '-saml2:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml2__union_EvidenceType (3480)
#endif

/* struct __saml2__union_AdviceType * has binding name 'PointerTo__saml2__union_AdviceType' for type '-saml2:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AdviceType
#define SOAP_TYPE_PointerTo__saml2__union_AdviceType (3478)
#endif

/* struct saml2__AssertionType * has binding name 'PointerTosaml2__AssertionType' for type 'saml2:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AssertionType
#define SOAP_TYPE_PointerTosaml2__AssertionType (3477)
#endif

/* struct __saml2__union_ConditionsType * has binding name 'PointerTo__saml2__union_ConditionsType' for type '-saml2:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml2__union_ConditionsType (3475)
#endif

/* struct saml2__ProxyRestrictionType * has binding name 'PointerTosaml2__ProxyRestrictionType' for type 'saml2:ProxyRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__ProxyRestrictionType
#define SOAP_TYPE_PointerTosaml2__ProxyRestrictionType (3474)
#endif

/* struct saml2__OneTimeUseType * has binding name 'PointerTosaml2__OneTimeUseType' for type 'saml2:OneTimeUseType' */
#ifndef SOAP_TYPE_PointerTosaml2__OneTimeUseType
#define SOAP_TYPE_PointerTosaml2__OneTimeUseType (3473)
#endif

/* struct saml2__AudienceRestrictionType * has binding name 'PointerTosaml2__AudienceRestrictionType' for type 'saml2:AudienceRestrictionType' */
#ifndef SOAP_TYPE_PointerTosaml2__AudienceRestrictionType
#define SOAP_TYPE_PointerTosaml2__AudienceRestrictionType (3472)
#endif

/* struct saml2__ConditionAbstractType * has binding name 'PointerTosaml2__ConditionAbstractType' for type 'saml2:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml2__ConditionAbstractType (3471)
#endif

/* struct saml2__SubjectConfirmationDataType * has binding name 'PointerTosaml2__SubjectConfirmationDataType' for type 'saml2:SubjectConfirmationDataType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationDataType (3469)
#endif

/* struct saml2__SubjectConfirmationType * has binding name 'PointerTosaml2__SubjectConfirmationType' for type 'saml2:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml2__SubjectConfirmationType (3468)
#endif

/* struct saml2__EncryptedElementType * has binding name 'PointerTosaml2__EncryptedElementType' for type 'saml2:EncryptedElementType' */
#ifndef SOAP_TYPE_PointerTosaml2__EncryptedElementType
#define SOAP_TYPE_PointerTosaml2__EncryptedElementType (3467)
#endif

/* struct saml2__BaseIDAbstractType * has binding name 'PointerTosaml2__BaseIDAbstractType' for type 'saml2:BaseIDAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__BaseIDAbstractType
#define SOAP_TYPE_PointerTosaml2__BaseIDAbstractType (3466)
#endif

/* struct __saml2__union_AssertionType * has binding name 'PointerTo__saml2__union_AssertionType' for type '-saml2:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml2__union_AssertionType
#define SOAP_TYPE_PointerTo__saml2__union_AssertionType (3465)
#endif

/* struct saml2__AttributeStatementType * has binding name 'PointerTosaml2__AttributeStatementType' for type 'saml2:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AttributeStatementType
#define SOAP_TYPE_PointerTosaml2__AttributeStatementType (3464)
#endif

/* struct saml2__AuthzDecisionStatementType * has binding name 'PointerTosaml2__AuthzDecisionStatementType' for type 'saml2:AuthzDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType
#define SOAP_TYPE_PointerTosaml2__AuthzDecisionStatementType (3463)
#endif

/* struct saml2__AuthnStatementType * has binding name 'PointerTosaml2__AuthnStatementType' for type 'saml2:AuthnStatementType' */
#ifndef SOAP_TYPE_PointerTosaml2__AuthnStatementType
#define SOAP_TYPE_PointerTosaml2__AuthnStatementType (3462)
#endif

/* struct saml2__StatementAbstractType * has binding name 'PointerTosaml2__StatementAbstractType' for type 'saml2:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml2__StatementAbstractType
#define SOAP_TYPE_PointerTosaml2__StatementAbstractType (3461)
#endif

/* struct saml2__AdviceType * has binding name 'PointerTosaml2__AdviceType' for type 'saml2:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml2__AdviceType
#define SOAP_TYPE_PointerTosaml2__AdviceType (3459)
#endif

/* struct saml2__ConditionsType * has binding name 'PointerTosaml2__ConditionsType' for type 'saml2:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml2__ConditionsType
#define SOAP_TYPE_PointerTosaml2__ConditionsType (3458)
#endif

/* struct saml2__SubjectType * has binding name 'PointerTosaml2__SubjectType' for type 'saml2:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml2__SubjectType
#define SOAP_TYPE_PointerTosaml2__SubjectType (3457)
#endif

/* struct saml2__NameIDType * has binding name 'PointerTosaml2__NameIDType' for type 'saml2:NameIDType' */
#ifndef SOAP_TYPE_PointerTosaml2__NameIDType
#define SOAP_TYPE_PointerTosaml2__NameIDType (3456)
#endif

/* struct xenc__EncryptedKeyType ** has binding name 'PointerToPointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToPointerToxenc__EncryptedKeyType (3455)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (3454)
#endif

/* _saml1__AttributeValue has binding name '_saml1__AttributeValue' for type '' */
#ifndef SOAP_TYPE__saml1__AttributeValue
#define SOAP_TYPE__saml1__AttributeValue (3429)
#endif

/* _saml1__ConfirmationMethod has binding name '_saml1__ConfirmationMethod' for type '' */
#ifndef SOAP_TYPE__saml1__ConfirmationMethod
#define SOAP_TYPE__saml1__ConfirmationMethod (3419)
#endif

/* _saml1__SubjectConfirmationData has binding name '_saml1__SubjectConfirmationData' for type '' */
#ifndef SOAP_TYPE__saml1__SubjectConfirmationData
#define SOAP_TYPE__saml1__SubjectConfirmationData (3418)
#endif

/* _saml1__Audience has binding name '_saml1__Audience' for type '' */
#ifndef SOAP_TYPE__saml1__Audience
#define SOAP_TYPE__saml1__Audience (3410)
#endif

/* _saml1__AssertionIDReference has binding name '_saml1__AssertionIDReference' for type '' */
#ifndef SOAP_TYPE__saml1__AssertionIDReference
#define SOAP_TYPE__saml1__AssertionIDReference (3405)
#endif

/* struct saml1__AttributeType * has binding name 'PointerTosaml1__AttributeType' for type 'saml1:AttributeType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeType
#define SOAP_TYPE_PointerTosaml1__AttributeType (3404)
#endif

/* struct saml1__EvidenceType * has binding name 'PointerTosaml1__EvidenceType' for type 'saml1:EvidenceType' */
#ifndef SOAP_TYPE_PointerTosaml1__EvidenceType
#define SOAP_TYPE_PointerTosaml1__EvidenceType (3403)
#endif

/* struct saml1__ActionType * has binding name 'PointerTosaml1__ActionType' for type 'saml1:ActionType' */
#ifndef SOAP_TYPE_PointerTosaml1__ActionType
#define SOAP_TYPE_PointerTosaml1__ActionType (3402)
#endif

/* struct saml1__AuthorityBindingType * has binding name 'PointerTosaml1__AuthorityBindingType' for type 'saml1:AuthorityBindingType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorityBindingType
#define SOAP_TYPE_PointerTosaml1__AuthorityBindingType (3401)
#endif

/* struct saml1__SubjectLocalityType * has binding name 'PointerTosaml1__SubjectLocalityType' for type 'saml1:SubjectLocalityType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectLocalityType
#define SOAP_TYPE_PointerTosaml1__SubjectLocalityType (3400)
#endif

/* struct saml1__SubjectType * has binding name 'PointerTosaml1__SubjectType' for type 'saml1:SubjectType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectType
#define SOAP_TYPE_PointerTosaml1__SubjectType (3399)
#endif

/* struct __saml1__union_EvidenceType * has binding name 'PointerTo__saml1__union_EvidenceType' for type '-saml1:union-EvidenceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_EvidenceType
#define SOAP_TYPE_PointerTo__saml1__union_EvidenceType (3398)
#endif

/* char ** has binding name 'PointerTostring' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostring
#define SOAP_TYPE_PointerTostring (3396)
#endif

/* struct saml1__SubjectConfirmationType * has binding name 'PointerTosaml1__SubjectConfirmationType' for type 'saml1:SubjectConfirmationType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectConfirmationType
#define SOAP_TYPE_PointerTosaml1__SubjectConfirmationType (3395)
#endif

/* struct saml1__NameIdentifierType * has binding name 'PointerTosaml1__NameIdentifierType' for type 'saml1:NameIdentifierType' */
#ifndef SOAP_TYPE_PointerTosaml1__NameIdentifierType
#define SOAP_TYPE_PointerTosaml1__NameIdentifierType (3394)
#endif

/* struct __saml1__union_AdviceType * has binding name 'PointerTo__saml1__union_AdviceType' for type '-saml1:union-AdviceType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AdviceType
#define SOAP_TYPE_PointerTo__saml1__union_AdviceType (3393)
#endif

/* struct saml1__AssertionType * has binding name 'PointerTosaml1__AssertionType' for type 'saml1:AssertionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AssertionType
#define SOAP_TYPE_PointerTosaml1__AssertionType (3392)
#endif

/* struct __saml1__union_ConditionsType * has binding name 'PointerTo__saml1__union_ConditionsType' for type '-saml1:union-ConditionsType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_ConditionsType
#define SOAP_TYPE_PointerTo__saml1__union_ConditionsType (3390)
#endif

/* struct saml1__ConditionAbstractType * has binding name 'PointerTosaml1__ConditionAbstractType' for type 'saml1:ConditionAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionAbstractType
#define SOAP_TYPE_PointerTosaml1__ConditionAbstractType (3389)
#endif

/* struct saml1__DoNotCacheConditionType * has binding name 'PointerTosaml1__DoNotCacheConditionType' for type 'saml1:DoNotCacheConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType
#define SOAP_TYPE_PointerTosaml1__DoNotCacheConditionType (3388)
#endif

/* struct saml1__AudienceRestrictionConditionType * has binding name 'PointerTosaml1__AudienceRestrictionConditionType' for type 'saml1:AudienceRestrictionConditionType' */
#ifndef SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType
#define SOAP_TYPE_PointerTosaml1__AudienceRestrictionConditionType (3387)
#endif

/* struct ds__SignatureType * has binding name 'PointerTo_ds__Signature' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__Signature
#define SOAP_TYPE_PointerTo_ds__Signature (3385)
#endif

/* struct __saml1__union_AssertionType * has binding name 'PointerTo__saml1__union_AssertionType' for type '-saml1:union-AssertionType' */
#ifndef SOAP_TYPE_PointerTo__saml1__union_AssertionType
#define SOAP_TYPE_PointerTo__saml1__union_AssertionType (3384)
#endif

/* struct saml1__AttributeStatementType * has binding name 'PointerTosaml1__AttributeStatementType' for type 'saml1:AttributeStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AttributeStatementType
#define SOAP_TYPE_PointerTosaml1__AttributeStatementType (3383)
#endif

/* struct saml1__AuthorizationDecisionStatementType * has binding name 'PointerTosaml1__AuthorizationDecisionStatementType' for type 'saml1:AuthorizationDecisionStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType
#define SOAP_TYPE_PointerTosaml1__AuthorizationDecisionStatementType (3382)
#endif

/* struct saml1__AuthenticationStatementType * has binding name 'PointerTosaml1__AuthenticationStatementType' for type 'saml1:AuthenticationStatementType' */
#ifndef SOAP_TYPE_PointerTosaml1__AuthenticationStatementType
#define SOAP_TYPE_PointerTosaml1__AuthenticationStatementType (3381)
#endif

/* struct saml1__SubjectStatementAbstractType * has binding name 'PointerTosaml1__SubjectStatementAbstractType' for type 'saml1:SubjectStatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType
#define SOAP_TYPE_PointerTosaml1__SubjectStatementAbstractType (3380)
#endif

/* struct saml1__StatementAbstractType * has binding name 'PointerTosaml1__StatementAbstractType' for type 'saml1:StatementAbstractType' */
#ifndef SOAP_TYPE_PointerTosaml1__StatementAbstractType
#define SOAP_TYPE_PointerTosaml1__StatementAbstractType (3379)
#endif

/* struct saml1__AdviceType * has binding name 'PointerTosaml1__AdviceType' for type 'saml1:AdviceType' */
#ifndef SOAP_TYPE_PointerTosaml1__AdviceType
#define SOAP_TYPE_PointerTosaml1__AdviceType (3377)
#endif

/* struct saml1__ConditionsType * has binding name 'PointerTosaml1__ConditionsType' for type 'saml1:ConditionsType' */
#ifndef SOAP_TYPE_PointerTosaml1__ConditionsType
#define SOAP_TYPE_PointerTosaml1__ConditionsType (3376)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (3354)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (3353)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (3350)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (3345)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (3344)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (3343)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (3342)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (3340)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (3339)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (3338)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (3337)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (3336)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (3335)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (3334)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (3321)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (3320)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (3319)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (3318)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (3317)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (3316)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (3315)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (3314)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (3313)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (3312)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (3307)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (3306)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (3304)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (3300)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (3292)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (3290)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (3287)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (3286)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (3284)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (3283)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (3282)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (3276)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (3275)
#endif

/* _trt__DeleteOSD * has binding name 'PointerTo_trt__DeleteOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__DeleteOSD
#define SOAP_TYPE_PointerTo_trt__DeleteOSD (3265)
#endif

/* _trt__CreateOSD * has binding name 'PointerTo_trt__CreateOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__CreateOSD
#define SOAP_TYPE_PointerTo_trt__CreateOSD (3261)
#endif

/* _trt__SetOSD * has binding name 'PointerTo_trt__SetOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetOSD
#define SOAP_TYPE_PointerTo_trt__SetOSD (3257)
#endif

/* _trt__GetOSDOptions * has binding name 'PointerTo_trt__GetOSDOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetOSDOptions
#define SOAP_TYPE_PointerTo_trt__GetOSDOptions (3253)
#endif

/* _trt__GetOSD * has binding name 'PointerTo_trt__GetOSD' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetOSD
#define SOAP_TYPE_PointerTo_trt__GetOSD (3249)
#endif

/* _trt__GetOSDs * has binding name 'PointerTo_trt__GetOSDs' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetOSDs
#define SOAP_TYPE_PointerTo_trt__GetOSDs (3245)
#endif

/* _trt__SetVideoSourceMode * has binding name 'PointerTo_trt__SetVideoSourceMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetVideoSourceMode
#define SOAP_TYPE_PointerTo_trt__SetVideoSourceMode (3241)
#endif

/* _trt__GetVideoSourceModes * has binding name 'PointerTo_trt__GetVideoSourceModes' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoSourceModes
#define SOAP_TYPE_PointerTo_trt__GetVideoSourceModes (3237)
#endif

/* _trt__GetSnapshotUri * has binding name 'PointerTo_trt__GetSnapshotUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetSnapshotUri
#define SOAP_TYPE_PointerTo_trt__GetSnapshotUri (3233)
#endif

/* _trt__SetSynchronizationPoint * has binding name 'PointerTo_trt__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint
#define SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint (3229)
#endif

/* _trt__StopMulticastStreaming * has binding name 'PointerTo_trt__StopMulticastStreaming' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__StopMulticastStreaming
#define SOAP_TYPE_PointerTo_trt__StopMulticastStreaming (3225)
#endif

/* _trt__StartMulticastStreaming * has binding name 'PointerTo_trt__StartMulticastStreaming' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__StartMulticastStreaming
#define SOAP_TYPE_PointerTo_trt__StartMulticastStreaming (3221)
#endif

/* _trt__GetStreamUri * has binding name 'PointerTo_trt__GetStreamUri' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetStreamUri
#define SOAP_TYPE_PointerTo_trt__GetStreamUri (3217)
#endif

/* _trt__GetGuaranteedNumberOfVideoEncoderInstances * has binding name 'PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances (3213)
#endif

/* _trt__GetAudioDecoderConfigurationOptions * has binding name 'PointerTo_trt__GetAudioDecoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptions (3209)
#endif

/* _trt__GetAudioOutputConfigurationOptions * has binding name 'PointerTo_trt__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptions (3205)
#endif

/* _trt__GetMetadataConfigurationOptions * has binding name 'PointerTo_trt__GetMetadataConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptions (3201)
#endif

/* _trt__GetAudioEncoderConfigurationOptions * has binding name 'PointerTo_trt__GetAudioEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptions (3197)
#endif

/* _trt__GetAudioSourceConfigurationOptions * has binding name 'PointerTo_trt__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptions (3193)
#endif

/* _trt__GetVideoEncoderConfigurationOptions * has binding name 'PointerTo_trt__GetVideoEncoderConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions (3189)
#endif

/* _trt__GetVideoSourceConfigurationOptions * has binding name 'PointerTo_trt__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptions (3185)
#endif

/* _trt__SetAudioDecoderConfiguration * has binding name 'PointerTo_trt__SetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfiguration (3181)
#endif

/* _trt__SetAudioOutputConfiguration * has binding name 'PointerTo_trt__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_trt__SetAudioOutputConfiguration (3177)
#endif

/* _trt__SetMetadataConfiguration * has binding name 'PointerTo_trt__SetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetMetadataConfiguration
#define SOAP_TYPE_PointerTo_trt__SetMetadataConfiguration (3173)
#endif

/* _trt__SetVideoAnalyticsConfiguration * has binding name 'PointerTo_trt__SetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfiguration (3169)
#endif

/* _trt__SetAudioEncoderConfiguration * has binding name 'PointerTo_trt__SetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfiguration (3165)
#endif

/* _trt__SetAudioSourceConfiguration * has binding name 'PointerTo_trt__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__SetAudioSourceConfiguration (3161)
#endif

/* _trt__SetVideoEncoderConfiguration * has binding name 'PointerTo_trt__SetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration (3157)
#endif

/* _trt__SetVideoSourceConfiguration * has binding name 'PointerTo_trt__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__SetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__SetVideoSourceConfiguration (3153)
#endif

/* _trt__GetCompatibleAudioDecoderConfigurations * has binding name 'PointerTo_trt__GetCompatibleAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurations (3149)
#endif

/* _trt__GetCompatibleAudioOutputConfigurations * has binding name 'PointerTo_trt__GetCompatibleAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurations (3145)
#endif

/* _trt__GetCompatibleMetadataConfigurations * has binding name 'PointerTo_trt__GetCompatibleMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurations (3141)
#endif

/* _trt__GetCompatibleVideoAnalyticsConfigurations * has binding name 'PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations (3137)
#endif

/* _trt__GetCompatibleAudioSourceConfigurations * has binding name 'PointerTo_trt__GetCompatibleAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurations (3133)
#endif

/* _trt__GetCompatibleAudioEncoderConfigurations * has binding name 'PointerTo_trt__GetCompatibleAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurations (3129)
#endif

/* _trt__GetCompatibleVideoSourceConfigurations * has binding name 'PointerTo_trt__GetCompatibleVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurations (3125)
#endif

/* _trt__GetCompatibleVideoEncoderConfigurations * has binding name 'PointerTo_trt__GetCompatibleVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurations (3121)
#endif

/* _trt__GetAudioDecoderConfiguration * has binding name 'PointerTo_trt__GetAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfiguration (3117)
#endif

/* _trt__GetAudioOutputConfiguration * has binding name 'PointerTo_trt__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_trt__GetAudioOutputConfiguration (3113)
#endif

/* _trt__GetMetadataConfiguration * has binding name 'PointerTo_trt__GetMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetMetadataConfiguration
#define SOAP_TYPE_PointerTo_trt__GetMetadataConfiguration (3109)
#endif

/* _trt__GetVideoAnalyticsConfiguration * has binding name 'PointerTo_trt__GetVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfiguration (3105)
#endif

/* _trt__GetAudioEncoderConfiguration * has binding name 'PointerTo_trt__GetAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfiguration (3101)
#endif

/* _trt__GetAudioSourceConfiguration * has binding name 'PointerTo_trt__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__GetAudioSourceConfiguration (3097)
#endif

/* _trt__GetVideoEncoderConfiguration * has binding name 'PointerTo_trt__GetVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration (3093)
#endif

/* _trt__GetVideoSourceConfiguration * has binding name 'PointerTo_trt__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__GetVideoSourceConfiguration (3089)
#endif

/* _trt__GetAudioDecoderConfigurations * has binding name 'PointerTo_trt__GetAudioDecoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurations (3085)
#endif

/* _trt__GetAudioOutputConfigurations * has binding name 'PointerTo_trt__GetAudioOutputConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurations
#define SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurations (3081)
#endif

/* _trt__GetMetadataConfigurations * has binding name 'PointerTo_trt__GetMetadataConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetMetadataConfigurations
#define SOAP_TYPE_PointerTo_trt__GetMetadataConfigurations (3077)
#endif

/* _trt__GetVideoAnalyticsConfigurations * has binding name 'PointerTo_trt__GetVideoAnalyticsConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurations
#define SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurations (3073)
#endif

/* _trt__GetAudioEncoderConfigurations * has binding name 'PointerTo_trt__GetAudioEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurations (3069)
#endif

/* _trt__GetAudioSourceConfigurations * has binding name 'PointerTo_trt__GetAudioSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurations
#define SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurations (3065)
#endif

/* _trt__GetVideoEncoderConfigurations * has binding name 'PointerTo_trt__GetVideoEncoderConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurations
#define SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurations (3061)
#endif

/* _trt__GetVideoSourceConfigurations * has binding name 'PointerTo_trt__GetVideoSourceConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurations
#define SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurations (3057)
#endif

/* _trt__DeleteProfile * has binding name 'PointerTo_trt__DeleteProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__DeleteProfile
#define SOAP_TYPE_PointerTo_trt__DeleteProfile (3053)
#endif

/* _trt__RemoveAudioDecoderConfiguration * has binding name 'PointerTo_trt__RemoveAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfiguration (3049)
#endif

/* _trt__RemoveAudioOutputConfiguration * has binding name 'PointerTo_trt__RemoveAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfiguration (3045)
#endif

/* _trt__RemoveMetadataConfiguration * has binding name 'PointerTo_trt__RemoveMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveMetadataConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveMetadataConfiguration (3041)
#endif

/* _trt__RemoveVideoAnalyticsConfiguration * has binding name 'PointerTo_trt__RemoveVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfiguration (3037)
#endif

/* _trt__RemovePTZConfiguration * has binding name 'PointerTo_trt__RemovePTZConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemovePTZConfiguration
#define SOAP_TYPE_PointerTo_trt__RemovePTZConfiguration (3033)
#endif

/* _trt__RemoveAudioSourceConfiguration * has binding name 'PointerTo_trt__RemoveAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfiguration (3029)
#endif

/* _trt__RemoveAudioEncoderConfiguration * has binding name 'PointerTo_trt__RemoveAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfiguration (3025)
#endif

/* _trt__RemoveVideoSourceConfiguration * has binding name 'PointerTo_trt__RemoveVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfiguration (3021)
#endif

/* _trt__RemoveVideoEncoderConfiguration * has binding name 'PointerTo_trt__RemoveVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfiguration (3017)
#endif

/* _trt__AddAudioDecoderConfiguration * has binding name 'PointerTo_trt__AddAudioDecoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfiguration
#define SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfiguration (3013)
#endif

/* _trt__AddAudioOutputConfiguration * has binding name 'PointerTo_trt__AddAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_trt__AddAudioOutputConfiguration (3009)
#endif

/* _trt__AddMetadataConfiguration * has binding name 'PointerTo_trt__AddMetadataConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddMetadataConfiguration
#define SOAP_TYPE_PointerTo_trt__AddMetadataConfiguration (3005)
#endif

/* _trt__AddVideoAnalyticsConfiguration * has binding name 'PointerTo_trt__AddVideoAnalyticsConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfiguration (3001)
#endif

/* _trt__AddPTZConfiguration * has binding name 'PointerTo_trt__AddPTZConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddPTZConfiguration
#define SOAP_TYPE_PointerTo_trt__AddPTZConfiguration (2997)
#endif

/* _trt__AddAudioSourceConfiguration * has binding name 'PointerTo_trt__AddAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__AddAudioSourceConfiguration (2993)
#endif

/* _trt__AddAudioEncoderConfiguration * has binding name 'PointerTo_trt__AddAudioEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfiguration (2989)
#endif

/* _trt__AddVideoSourceConfiguration * has binding name 'PointerTo_trt__AddVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_trt__AddVideoSourceConfiguration (2985)
#endif

/* _trt__AddVideoEncoderConfiguration * has binding name 'PointerTo_trt__AddVideoEncoderConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfiguration
#define SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfiguration (2981)
#endif

/* _trt__GetProfiles * has binding name 'PointerTo_trt__GetProfiles' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetProfiles
#define SOAP_TYPE_PointerTo_trt__GetProfiles (2977)
#endif

/* _trt__GetProfile * has binding name 'PointerTo_trt__GetProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetProfile
#define SOAP_TYPE_PointerTo_trt__GetProfile (2973)
#endif

/* _trt__CreateProfile * has binding name 'PointerTo_trt__CreateProfile' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__CreateProfile
#define SOAP_TYPE_PointerTo_trt__CreateProfile (2969)
#endif

/* _trt__GetAudioOutputs * has binding name 'PointerTo_trt__GetAudioOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioOutputs
#define SOAP_TYPE_PointerTo_trt__GetAudioOutputs (2965)
#endif

/* _trt__GetAudioSources * has binding name 'PointerTo_trt__GetAudioSources' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetAudioSources
#define SOAP_TYPE_PointerTo_trt__GetAudioSources (2961)
#endif

/* _trt__GetVideoSources * has binding name 'PointerTo_trt__GetVideoSources' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetVideoSources
#define SOAP_TYPE_PointerTo_trt__GetVideoSources (2957)
#endif

/* _trt__GetServiceCapabilities * has binding name 'PointerTo_trt__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_trt__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_trt__GetServiceCapabilities (2953)
#endif

/* _tptz__GetCompatibleConfigurations * has binding name 'PointerTo_tptz__GetCompatibleConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetCompatibleConfigurations
#define SOAP_TYPE_PointerTo_tptz__GetCompatibleConfigurations (2949)
#endif

/* _tptz__RemovePresetTour * has binding name 'PointerTo_tptz__RemovePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__RemovePresetTour
#define SOAP_TYPE_PointerTo_tptz__RemovePresetTour (2945)
#endif

/* _tptz__OperatePresetTour * has binding name 'PointerTo_tptz__OperatePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__OperatePresetTour
#define SOAP_TYPE_PointerTo_tptz__OperatePresetTour (2941)
#endif

/* _tptz__ModifyPresetTour * has binding name 'PointerTo_tptz__ModifyPresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__ModifyPresetTour
#define SOAP_TYPE_PointerTo_tptz__ModifyPresetTour (2937)
#endif

/* _tptz__CreatePresetTour * has binding name 'PointerTo_tptz__CreatePresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__CreatePresetTour
#define SOAP_TYPE_PointerTo_tptz__CreatePresetTour (2933)
#endif

/* _tptz__GetPresetTourOptions * has binding name 'PointerTo_tptz__GetPresetTourOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions
#define SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions (2929)
#endif

/* _tptz__GetPresetTour * has binding name 'PointerTo_tptz__GetPresetTour' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetPresetTour
#define SOAP_TYPE_PointerTo_tptz__GetPresetTour (2925)
#endif

/* _tptz__GetPresetTours * has binding name 'PointerTo_tptz__GetPresetTours' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetPresetTours
#define SOAP_TYPE_PointerTo_tptz__GetPresetTours (2921)
#endif

/* _tptz__Stop * has binding name 'PointerTo_tptz__Stop' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__Stop
#define SOAP_TYPE_PointerTo_tptz__Stop (2917)
#endif

/* _tptz__GeoMove * has binding name 'PointerTo_tptz__GeoMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GeoMove
#define SOAP_TYPE_PointerTo_tptz__GeoMove (2913)
#endif

/* _tptz__AbsoluteMove * has binding name 'PointerTo_tptz__AbsoluteMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__AbsoluteMove
#define SOAP_TYPE_PointerTo_tptz__AbsoluteMove (2909)
#endif

/* _tptz__SendAuxiliaryCommand * has binding name 'PointerTo_tptz__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand
#define SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand (2905)
#endif

/* _tptz__RelativeMove * has binding name 'PointerTo_tptz__RelativeMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__RelativeMove
#define SOAP_TYPE_PointerTo_tptz__RelativeMove (2901)
#endif

/* _tptz__ContinuousMove * has binding name 'PointerTo_tptz__ContinuousMove' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__ContinuousMove
#define SOAP_TYPE_PointerTo_tptz__ContinuousMove (2897)
#endif

/* _tptz__SetHomePosition * has binding name 'PointerTo_tptz__SetHomePosition' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__SetHomePosition
#define SOAP_TYPE_PointerTo_tptz__SetHomePosition (2893)
#endif

/* _tptz__GotoHomePosition * has binding name 'PointerTo_tptz__GotoHomePosition' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GotoHomePosition
#define SOAP_TYPE_PointerTo_tptz__GotoHomePosition (2889)
#endif

/* _tptz__GetConfigurationOptions * has binding name 'PointerTo_tptz__GetConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions
#define SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions (2885)
#endif

/* _tptz__SetConfiguration * has binding name 'PointerTo_tptz__SetConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__SetConfiguration
#define SOAP_TYPE_PointerTo_tptz__SetConfiguration (2881)
#endif

/* _tptz__GetNode * has binding name 'PointerTo_tptz__GetNode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetNode
#define SOAP_TYPE_PointerTo_tptz__GetNode (2877)
#endif

/* _tptz__GetNodes * has binding name 'PointerTo_tptz__GetNodes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetNodes
#define SOAP_TYPE_PointerTo_tptz__GetNodes (2873)
#endif

/* _tptz__GetConfiguration * has binding name 'PointerTo_tptz__GetConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetConfiguration
#define SOAP_TYPE_PointerTo_tptz__GetConfiguration (2869)
#endif

/* _tptz__GetStatus * has binding name 'PointerTo_tptz__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetStatus
#define SOAP_TYPE_PointerTo_tptz__GetStatus (2865)
#endif

/* _tptz__GotoPreset * has binding name 'PointerTo_tptz__GotoPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GotoPreset
#define SOAP_TYPE_PointerTo_tptz__GotoPreset (2861)
#endif

/* _tptz__RemovePreset * has binding name 'PointerTo_tptz__RemovePreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__RemovePreset
#define SOAP_TYPE_PointerTo_tptz__RemovePreset (2857)
#endif

/* _tptz__SetPreset * has binding name 'PointerTo_tptz__SetPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__SetPreset
#define SOAP_TYPE_PointerTo_tptz__SetPreset (2853)
#endif

/* _tptz__GetPresets * has binding name 'PointerTo_tptz__GetPresets' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetPresets
#define SOAP_TYPE_PointerTo_tptz__GetPresets (2849)
#endif

/* _tptz__GetConfigurations * has binding name 'PointerTo_tptz__GetConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetConfigurations
#define SOAP_TYPE_PointerTo_tptz__GetConfigurations (2845)
#endif

/* _tptz__GetServiceCapabilities * has binding name 'PointerTo_tptz__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities (2841)
#endif

/* _tmd__SendReceiveSerialCommand * has binding name 'PointerTo_tmd__SendReceiveSerialCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SendReceiveSerialCommand
#define SOAP_TYPE_PointerTo_tmd__SendReceiveSerialCommand (2837)
#endif

/* _tmd__GetSerialPortConfigurationOptions * has binding name 'PointerTo_tmd__GetSerialPortConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetSerialPortConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetSerialPortConfigurationOptions (2833)
#endif

/* _tmd__SetSerialPortConfiguration * has binding name 'PointerTo_tmd__SetSerialPortConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetSerialPortConfiguration
#define SOAP_TYPE_PointerTo_tmd__SetSerialPortConfiguration (2829)
#endif

/* _tmd__GetSerialPortConfiguration * has binding name 'PointerTo_tmd__GetSerialPortConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetSerialPortConfiguration
#define SOAP_TYPE_PointerTo_tmd__GetSerialPortConfiguration (2825)
#endif

/* _tmd__GetSerialPorts * has binding name 'PointerTo_tmd__GetSerialPorts' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetSerialPorts
#define SOAP_TYPE_PointerTo_tmd__GetSerialPorts (2821)
#endif

/* _tmd__SetDigitalInputConfigurations * has binding name 'PointerTo_tmd__SetDigitalInputConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetDigitalInputConfigurations
#define SOAP_TYPE_PointerTo_tmd__SetDigitalInputConfigurations (2817)
#endif

/* _tmd__GetDigitalInputConfigurationOptions * has binding name 'PointerTo_tmd__GetDigitalInputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetDigitalInputConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetDigitalInputConfigurationOptions (2813)
#endif

/* _tmd__GetDigitalInputs * has binding name 'PointerTo_tmd__GetDigitalInputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetDigitalInputs
#define SOAP_TYPE_PointerTo_tmd__GetDigitalInputs (2809)
#endif

/* _tmd__SetRelayOutputSettings * has binding name 'PointerTo_tmd__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetRelayOutputSettings
#define SOAP_TYPE_PointerTo_tmd__SetRelayOutputSettings (2803)
#endif

/* _tmd__GetAudioOutputConfigurationOptions * has binding name 'PointerTo_tmd__GetAudioOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfigurationOptions (2797)
#endif

/* _tmd__GetAudioSourceConfigurationOptions * has binding name 'PointerTo_tmd__GetAudioSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfigurationOptions (2793)
#endif

/* _tmd__GetVideoOutputConfigurationOptions * has binding name 'PointerTo_tmd__GetVideoOutputConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfigurationOptions (2789)
#endif

/* _tmd__GetVideoSourceConfigurationOptions * has binding name 'PointerTo_tmd__GetVideoSourceConfigurationOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfigurationOptions
#define SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfigurationOptions (2785)
#endif

/* _tmd__SetAudioOutputConfiguration * has binding name 'PointerTo_tmd__SetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_tmd__SetAudioOutputConfiguration (2781)
#endif

/* _tmd__SetAudioSourceConfiguration * has binding name 'PointerTo_tmd__SetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_tmd__SetAudioSourceConfiguration (2777)
#endif

/* _tmd__SetVideoOutputConfiguration * has binding name 'PointerTo_tmd__SetVideoOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetVideoOutputConfiguration
#define SOAP_TYPE_PointerTo_tmd__SetVideoOutputConfiguration (2773)
#endif

/* _tmd__SetVideoSourceConfiguration * has binding name 'PointerTo_tmd__SetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__SetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_tmd__SetVideoSourceConfiguration (2769)
#endif

/* _tmd__GetAudioOutputConfiguration * has binding name 'PointerTo_tmd__GetAudioOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfiguration
#define SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfiguration (2765)
#endif

/* _tmd__GetAudioSourceConfiguration * has binding name 'PointerTo_tmd__GetAudioSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfiguration
#define SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfiguration (2761)
#endif

/* _tmd__GetVideoOutputConfiguration * has binding name 'PointerTo_tmd__GetVideoOutputConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfiguration
#define SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfiguration (2757)
#endif

/* _tmd__GetVideoSourceConfiguration * has binding name 'PointerTo_tmd__GetVideoSourceConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfiguration
#define SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfiguration (2753)
#endif

/* _tmd__GetVideoOutputs * has binding name 'PointerTo_tmd__GetVideoOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetVideoOutputs
#define SOAP_TYPE_PointerTo_tmd__GetVideoOutputs (2749)
#endif

/* tmd__Get * has binding name 'PointerTotmd__Get' for type 'tmd:Get' */
#ifndef SOAP_TYPE_PointerTotmd__Get
#define SOAP_TYPE_PointerTotmd__Get (2741)
#endif

/* _tmd__GetRelayOutputOptions * has binding name 'PointerTo_tmd__GetRelayOutputOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetRelayOutputOptions
#define SOAP_TYPE_PointerTo_tmd__GetRelayOutputOptions (2737)
#endif

/* _tmd__GetServiceCapabilities * has binding name 'PointerTo_tmd__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tmd__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tmd__GetServiceCapabilities (2733)
#endif

/* _timg__SetCurrentPreset * has binding name 'PointerTo_timg__SetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__SetCurrentPreset
#define SOAP_TYPE_PointerTo_timg__SetCurrentPreset (2729)
#endif

/* _timg__GetCurrentPreset * has binding name 'PointerTo_timg__GetCurrentPreset' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetCurrentPreset
#define SOAP_TYPE_PointerTo_timg__GetCurrentPreset (2725)
#endif

/* _timg__GetPresets * has binding name 'PointerTo_timg__GetPresets' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetPresets
#define SOAP_TYPE_PointerTo_timg__GetPresets (2721)
#endif

/* _timg__GetMoveOptions * has binding name 'PointerTo_timg__GetMoveOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetMoveOptions
#define SOAP_TYPE_PointerTo_timg__GetMoveOptions (2717)
#endif

/* _timg__GetStatus * has binding name 'PointerTo_timg__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetStatus
#define SOAP_TYPE_PointerTo_timg__GetStatus (2713)
#endif

/* _timg__Stop * has binding name 'PointerTo_timg__Stop' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__Stop
#define SOAP_TYPE_PointerTo_timg__Stop (2709)
#endif

/* _timg__Move * has binding name 'PointerTo_timg__Move' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__Move
#define SOAP_TYPE_PointerTo_timg__Move (2705)
#endif

/* _timg__GetOptions * has binding name 'PointerTo_timg__GetOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetOptions
#define SOAP_TYPE_PointerTo_timg__GetOptions (2701)
#endif

/* _timg__SetImagingSettings * has binding name 'PointerTo_timg__SetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__SetImagingSettings
#define SOAP_TYPE_PointerTo_timg__SetImagingSettings (2697)
#endif

/* _timg__GetImagingSettings * has binding name 'PointerTo_timg__GetImagingSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetImagingSettings
#define SOAP_TYPE_PointerTo_timg__GetImagingSettings (2693)
#endif

/* _timg__GetServiceCapabilities * has binding name 'PointerTo_timg__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_timg__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_timg__GetServiceCapabilities (2689)
#endif

/* _wsnt__ResumeSubscription * has binding name 'PointerTo_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__ResumeSubscription
#define SOAP_TYPE_PointerTo_wsnt__ResumeSubscription (2685)
#endif

/* _wsnt__PauseSubscription * has binding name 'PointerTo_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__PauseSubscription
#define SOAP_TYPE_PointerTo_wsnt__PauseSubscription (2681)
#endif

/* _wsnt__CreatePullPoint * has binding name 'PointerTo_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__CreatePullPoint
#define SOAP_TYPE_PointerTo_wsnt__CreatePullPoint (2673)
#endif

/* _wsnt__DestroyPullPoint * has binding name 'PointerTo_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint
#define SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint (2667)
#endif

/* _wsnt__GetMessages * has binding name 'PointerTo_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__GetMessages
#define SOAP_TYPE_PointerTo_wsnt__GetMessages (2663)
#endif

/* _wsnt__Notify * has binding name 'PointerTo_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Notify
#define SOAP_TYPE_PointerTo_wsnt__Notify (2660)
#endif

/* _wsnt__GetCurrentMessage * has binding name 'PointerTo_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage
#define SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage (2656)
#endif

/* _wsnt__Subscribe * has binding name 'PointerTo_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe
#define SOAP_TYPE_PointerTo_wsnt__Subscribe (2652)
#endif

/* _wsnt__Renew * has binding name 'PointerTo_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Renew
#define SOAP_TYPE_PointerTo_wsnt__Renew (2646)
#endif

/* _tev__GetEventProperties * has binding name 'PointerTo_tev__GetEventProperties' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__GetEventProperties
#define SOAP_TYPE_PointerTo_tev__GetEventProperties (2642)
#endif

/* _tev__CreatePullPointSubscription * has binding name 'PointerTo_tev__CreatePullPointSubscription' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription
#define SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription (2638)
#endif

/* _tev__GetServiceCapabilities * has binding name 'PointerTo_tev__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tev__GetServiceCapabilities (2634)
#endif

/* _wsnt__Unsubscribe * has binding name 'PointerTo_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Unsubscribe
#define SOAP_TYPE_PointerTo_wsnt__Unsubscribe (2630)
#endif

/* _tev__SetSynchronizationPoint * has binding name 'PointerTo_tev__SetSynchronizationPoint' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint
#define SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint (2626)
#endif

/* _tev__Seek * has binding name 'PointerTo_tev__Seek' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__Seek
#define SOAP_TYPE_PointerTo_tev__Seek (2622)
#endif

/* _tev__PullMessages * has binding name 'PointerTo_tev__PullMessages' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__PullMessages
#define SOAP_TYPE_PointerTo_tev__PullMessages (2618)
#endif

/* _tds__DeleteGeoLocation * has binding name 'PointerTo_tds__DeleteGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteGeoLocation
#define SOAP_TYPE_PointerTo_tds__DeleteGeoLocation (2434)
#endif

/* _tds__SetGeoLocation * has binding name 'PointerTo_tds__SetGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetGeoLocation
#define SOAP_TYPE_PointerTo_tds__SetGeoLocation (2430)
#endif

/* _tds__GetGeoLocation * has binding name 'PointerTo_tds__GetGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetGeoLocation
#define SOAP_TYPE_PointerTo_tds__GetGeoLocation (2426)
#endif

/* _tds__DeleteStorageConfiguration * has binding name 'PointerTo_tds__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration (2422)
#endif

/* _tds__SetStorageConfiguration * has binding name 'PointerTo_tds__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__SetStorageConfiguration (2418)
#endif

/* _tds__GetStorageConfiguration * has binding name 'PointerTo_tds__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__GetStorageConfiguration (2414)
#endif

/* _tds__CreateStorageConfiguration * has binding name 'PointerTo_tds__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration (2410)
#endif

/* _tds__GetStorageConfigurations * has binding name 'PointerTo_tds__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetStorageConfigurations
#define SOAP_TYPE_PointerTo_tds__GetStorageConfigurations (2406)
#endif

/* _tds__StartSystemRestore * has binding name 'PointerTo_tds__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StartSystemRestore
#define SOAP_TYPE_PointerTo_tds__StartSystemRestore (2402)
#endif

/* _tds__StartFirmwareUpgrade * has binding name 'PointerTo_tds__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade
#define SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade (2398)
#endif

/* _tds__GetSystemUris * has binding name 'PointerTo_tds__GetSystemUris' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemUris
#define SOAP_TYPE_PointerTo_tds__GetSystemUris (2394)
#endif

/* _tds__ScanAvailableDot11Networks * has binding name 'PointerTo_tds__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks
#define SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks (2390)
#endif

/* _tds__GetDot11Status * has binding name 'PointerTo_tds__GetDot11Status' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot11Status
#define SOAP_TYPE_PointerTo_tds__GetDot11Status (2386)
#endif

/* _tds__GetDot11Capabilities * has binding name 'PointerTo_tds__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot11Capabilities
#define SOAP_TYPE_PointerTo_tds__GetDot11Capabilities (2382)
#endif

/* _tds__DeleteDot1XConfiguration * has binding name 'PointerTo_tds__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration (2378)
#endif

/* _tds__GetDot1XConfigurations * has binding name 'PointerTo_tds__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations
#define SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations (2374)
#endif

/* _tds__GetDot1XConfiguration * has binding name 'PointerTo_tds__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration (2370)
#endif

/* _tds__SetDot1XConfiguration * has binding name 'PointerTo_tds__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration (2366)
#endif

/* _tds__CreateDot1XConfiguration * has binding name 'PointerTo_tds__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration (2362)
#endif

/* _tds__LoadCACertificates * has binding name 'PointerTo_tds__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCACertificates
#define SOAP_TYPE_PointerTo_tds__LoadCACertificates (2358)
#endif

/* _tds__GetCertificateInformation * has binding name 'PointerTo_tds__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificateInformation
#define SOAP_TYPE_PointerTo_tds__GetCertificateInformation (2354)
#endif

/* _tds__LoadCertificateWithPrivateKey * has binding name 'PointerTo_tds__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey (2350)
#endif

/* _tds__GetCACertificates * has binding name 'PointerTo_tds__GetCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCACertificates
#define SOAP_TYPE_PointerTo_tds__GetCACertificates (2346)
#endif

/* _tds__SendAuxiliaryCommand * has binding name 'PointerTo_tds__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand
#define SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand (2342)
#endif

/* _tds__SetRelayOutputState * has binding name 'PointerTo_tds__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRelayOutputState
#define SOAP_TYPE_PointerTo_tds__SetRelayOutputState (2338)
#endif

/* _tds__SetRelayOutputSettings * has binding name 'PointerTo_tds__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings
#define SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings (2334)
#endif

/* _tds__GetRelayOutputs * has binding name 'PointerTo_tds__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRelayOutputs
#define SOAP_TYPE_PointerTo_tds__GetRelayOutputs (2330)
#endif

/* _tds__SetClientCertificateMode * has binding name 'PointerTo_tds__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetClientCertificateMode
#define SOAP_TYPE_PointerTo_tds__SetClientCertificateMode (2326)
#endif

/* _tds__GetClientCertificateMode * has binding name 'PointerTo_tds__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetClientCertificateMode
#define SOAP_TYPE_PointerTo_tds__GetClientCertificateMode (2322)
#endif

/* _tds__LoadCertificates * has binding name 'PointerTo_tds__LoadCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCertificates
#define SOAP_TYPE_PointerTo_tds__LoadCertificates (2318)
#endif

/* _tds__GetPkcs10Request * has binding name 'PointerTo_tds__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetPkcs10Request
#define SOAP_TYPE_PointerTo_tds__GetPkcs10Request (2314)
#endif

/* _tds__DeleteCertificates * has binding name 'PointerTo_tds__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteCertificates
#define SOAP_TYPE_PointerTo_tds__DeleteCertificates (2310)
#endif

/* _tds__SetCertificatesStatus * has binding name 'PointerTo_tds__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetCertificatesStatus
#define SOAP_TYPE_PointerTo_tds__SetCertificatesStatus (2306)
#endif

/* _tds__GetCertificatesStatus * has binding name 'PointerTo_tds__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificatesStatus
#define SOAP_TYPE_PointerTo_tds__GetCertificatesStatus (2302)
#endif

/* _tds__GetCertificates * has binding name 'PointerTo_tds__GetCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificates
#define SOAP_TYPE_PointerTo_tds__GetCertificates (2298)
#endif

/* _tds__CreateCertificate * has binding name 'PointerTo_tds__CreateCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateCertificate
#define SOAP_TYPE_PointerTo_tds__CreateCertificate (2294)
#endif

/* _tds__SetAccessPolicy * has binding name 'PointerTo_tds__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetAccessPolicy
#define SOAP_TYPE_PointerTo_tds__SetAccessPolicy (2290)
#endif

/* _tds__GetAccessPolicy * has binding name 'PointerTo_tds__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetAccessPolicy
#define SOAP_TYPE_PointerTo_tds__GetAccessPolicy (2286)
#endif

/* _tds__RemoveIPAddressFilter * has binding name 'PointerTo_tds__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter (2282)
#endif

/* _tds__AddIPAddressFilter * has binding name 'PointerTo_tds__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__AddIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__AddIPAddressFilter (2278)
#endif

/* _tds__SetIPAddressFilter * has binding name 'PointerTo_tds__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__SetIPAddressFilter (2274)
#endif

/* _tds__GetIPAddressFilter * has binding name 'PointerTo_tds__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__GetIPAddressFilter (2270)
#endif

/* _tds__SetZeroConfiguration * has binding name 'PointerTo_tds__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetZeroConfiguration
#define SOAP_TYPE_PointerTo_tds__SetZeroConfiguration (2266)
#endif

/* _tds__GetZeroConfiguration * has binding name 'PointerTo_tds__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetZeroConfiguration
#define SOAP_TYPE_PointerTo_tds__GetZeroConfiguration (2262)
#endif

/* _tds__SetNetworkDefaultGateway * has binding name 'PointerTo_tds__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway (2258)
#endif

/* _tds__GetNetworkDefaultGateway * has binding name 'PointerTo_tds__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway (2254)
#endif

/* _tds__SetNetworkProtocols * has binding name 'PointerTo_tds__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkProtocols
#define SOAP_TYPE_PointerTo_tds__SetNetworkProtocols (2250)
#endif

/* _tds__GetNetworkProtocols * has binding name 'PointerTo_tds__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkProtocols
#define SOAP_TYPE_PointerTo_tds__GetNetworkProtocols (2246)
#endif

/* _tds__SetNetworkInterfaces * has binding name 'PointerTo_tds__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces
#define SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces (2242)
#endif

/* _tds__GetNetworkInterfaces * has binding name 'PointerTo_tds__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces
#define SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces (2238)
#endif

/* _tds__SetDynamicDNS * has binding name 'PointerTo_tds__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDynamicDNS
#define SOAP_TYPE_PointerTo_tds__SetDynamicDNS (2234)
#endif

/* _tds__GetDynamicDNS * has binding name 'PointerTo_tds__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDynamicDNS
#define SOAP_TYPE_PointerTo_tds__GetDynamicDNS (2230)
#endif

/* _tds__SetNTP * has binding name 'PointerTo_tds__SetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNTP
#define SOAP_TYPE_PointerTo_tds__SetNTP (2226)
#endif

/* _tds__GetNTP * has binding name 'PointerTo_tds__GetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNTP
#define SOAP_TYPE_PointerTo_tds__GetNTP (2222)
#endif

/* _tds__SetDNS * has binding name 'PointerTo_tds__SetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDNS
#define SOAP_TYPE_PointerTo_tds__SetDNS (2218)
#endif

/* _tds__GetDNS * has binding name 'PointerTo_tds__GetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDNS
#define SOAP_TYPE_PointerTo_tds__GetDNS (2214)
#endif

/* _tds__SetHostnameFromDHCP * has binding name 'PointerTo_tds__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP
#define SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP (2210)
#endif

/* _tds__SetHostname * has binding name 'PointerTo_tds__SetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetHostname
#define SOAP_TYPE_PointerTo_tds__SetHostname (2206)
#endif

/* _tds__GetHostname * has binding name 'PointerTo_tds__GetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetHostname
#define SOAP_TYPE_PointerTo_tds__GetHostname (2202)
#endif

/* _tds__SetDPAddresses * has binding name 'PointerTo_tds__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDPAddresses
#define SOAP_TYPE_PointerTo_tds__SetDPAddresses (2198)
#endif

/* _tds__GetCapabilities * has binding name 'PointerTo_tds__GetCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCapabilities
#define SOAP_TYPE_PointerTo_tds__GetCapabilities (2194)
#endif

/* _tds__GetWsdlUrl * has binding name 'PointerTo_tds__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetWsdlUrl
#define SOAP_TYPE_PointerTo_tds__GetWsdlUrl (2190)
#endif

/* _tds__SetUser * has binding name 'PointerTo_tds__SetUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetUser
#define SOAP_TYPE_PointerTo_tds__SetUser (2186)
#endif

/* _tds__DeleteUsers * has binding name 'PointerTo_tds__DeleteUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteUsers
#define SOAP_TYPE_PointerTo_tds__DeleteUsers (2182)
#endif

/* _tds__CreateUsers * has binding name 'PointerTo_tds__CreateUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateUsers
#define SOAP_TYPE_PointerTo_tds__CreateUsers (2178)
#endif

/* _tds__GetUsers * has binding name 'PointerTo_tds__GetUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetUsers
#define SOAP_TYPE_PointerTo_tds__GetUsers (2174)
#endif

/* _tds__SetRemoteUser * has binding name 'PointerTo_tds__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRemoteUser
#define SOAP_TYPE_PointerTo_tds__SetRemoteUser (2170)
#endif

/* _tds__GetRemoteUser * has binding name 'PointerTo_tds__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRemoteUser
#define SOAP_TYPE_PointerTo_tds__GetRemoteUser (2166)
#endif

/* _tds__GetEndpointReference * has binding name 'PointerTo_tds__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetEndpointReference
#define SOAP_TYPE_PointerTo_tds__GetEndpointReference (2162)
#endif

/* _tds__GetDPAddresses * has binding name 'PointerTo_tds__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDPAddresses
#define SOAP_TYPE_PointerTo_tds__GetDPAddresses (2158)
#endif

/* _tds__SetRemoteDiscoveryMode * has binding name 'PointerTo_tds__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode (2154)
#endif

/* _tds__GetRemoteDiscoveryMode * has binding name 'PointerTo_tds__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode (2150)
#endif

/* _tds__SetDiscoveryMode * has binding name 'PointerTo_tds__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__SetDiscoveryMode (2146)
#endif

/* _tds__GetDiscoveryMode * has binding name 'PointerTo_tds__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__GetDiscoveryMode (2142)
#endif

/* _tds__RemoveScopes * has binding name 'PointerTo_tds__RemoveScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RemoveScopes
#define SOAP_TYPE_PointerTo_tds__RemoveScopes (2138)
#endif

/* _tds__AddScopes * has binding name 'PointerTo_tds__AddScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__AddScopes
#define SOAP_TYPE_PointerTo_tds__AddScopes (2134)
#endif

/* _tds__SetScopes * has binding name 'PointerTo_tds__SetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetScopes
#define SOAP_TYPE_PointerTo_tds__SetScopes (2130)
#endif

/* _tds__GetScopes * has binding name 'PointerTo_tds__GetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetScopes
#define SOAP_TYPE_PointerTo_tds__GetScopes (2126)
#endif

/* _tds__GetSystemSupportInformation * has binding name 'PointerTo_tds__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation
#define SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation (2122)
#endif

/* _tds__GetSystemLog * has binding name 'PointerTo_tds__GetSystemLog' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemLog
#define SOAP_TYPE_PointerTo_tds__GetSystemLog (2118)
#endif

/* _tds__GetSystemBackup * has binding name 'PointerTo_tds__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemBackup
#define SOAP_TYPE_PointerTo_tds__GetSystemBackup (2114)
#endif

/* _tds__RestoreSystem * has binding name 'PointerTo_tds__RestoreSystem' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RestoreSystem
#define SOAP_TYPE_PointerTo_tds__RestoreSystem (2110)
#endif

/* _tds__SystemReboot * has binding name 'PointerTo_tds__SystemReboot' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SystemReboot
#define SOAP_TYPE_PointerTo_tds__SystemReboot (2106)
#endif

/* _tds__UpgradeSystemFirmware * has binding name 'PointerTo_tds__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware
#define SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware (2102)
#endif

/* _tds__SetSystemFactoryDefault * has binding name 'PointerTo_tds__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault
#define SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault (2098)
#endif

/* _tds__GetSystemDateAndTime * has binding name 'PointerTo_tds__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime
#define SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime (2094)
#endif

/* _tds__SetSystemDateAndTime * has binding name 'PointerTo_tds__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime
#define SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime (2090)
#endif

/* _tds__GetDeviceInformation * has binding name 'PointerTo_tds__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDeviceInformation
#define SOAP_TYPE_PointerTo_tds__GetDeviceInformation (2086)
#endif

/* _tds__GetServiceCapabilities * has binding name 'PointerTo_tds__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tds__GetServiceCapabilities (2082)
#endif

/* _tds__GetServices * has binding name 'PointerTo_tds__GetServices' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetServices
#define SOAP_TYPE_PointerTo_tds__GetServices (2078)
#endif

/* _tas__DeleteNetworkInterfaceDot1XConfiguration * has binding name 'PointerTo_tas__DeleteNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__DeleteNetworkInterfaceDot1XConfiguration (2066)
#endif

/* _tas__GetNetworkInterfaceDot1XConfiguration * has binding name 'PointerTo_tas__GetNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__GetNetworkInterfaceDot1XConfiguration (2062)
#endif

/* _tas__SetNetworkInterfaceDot1XConfiguration * has binding name 'PointerTo_tas__SetNetworkInterfaceDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__SetNetworkInterfaceDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__SetNetworkInterfaceDot1XConfiguration (2058)
#endif

/* _tas__DeleteDot1XConfiguration * has binding name 'PointerTo_tas__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__DeleteDot1XConfiguration (2054)
#endif

/* _tas__GetDot1XConfiguration * has binding name 'PointerTo_tas__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__GetDot1XConfiguration (2050)
#endif

/* _tas__GetAllDot1XConfigurations * has binding name 'PointerTo_tas__GetAllDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllDot1XConfigurations
#define SOAP_TYPE_PointerTo_tas__GetAllDot1XConfigurations (2046)
#endif

/* _tas__AddDot1XConfiguration * has binding name 'PointerTo_tas__AddDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__AddDot1XConfiguration
#define SOAP_TYPE_PointerTo_tas__AddDot1XConfiguration (2042)
#endif

/* _tas__GetAssignedCertPathValidationPolicies * has binding name 'PointerTo_tas__GetAssignedCertPathValidationPolicies' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAssignedCertPathValidationPolicies
#define SOAP_TYPE_PointerTo_tas__GetAssignedCertPathValidationPolicies (2038)
#endif

/* _tas__ReplaceCertPathValidationPolicyAssignment * has binding name 'PointerTo_tas__ReplaceCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__ReplaceCertPathValidationPolicyAssignment
#define SOAP_TYPE_PointerTo_tas__ReplaceCertPathValidationPolicyAssignment (2034)
#endif

/* _tas__RemoveCertPathValidationPolicyAssignment * has binding name 'PointerTo_tas__RemoveCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__RemoveCertPathValidationPolicyAssignment
#define SOAP_TYPE_PointerTo_tas__RemoveCertPathValidationPolicyAssignment (2030)
#endif

/* _tas__AddCertPathValidationPolicyAssignment * has binding name 'PointerTo_tas__AddCertPathValidationPolicyAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__AddCertPathValidationPolicyAssignment
#define SOAP_TYPE_PointerTo_tas__AddCertPathValidationPolicyAssignment (2026)
#endif

/* _tas__GetClientAuthenticationRequired * has binding name 'PointerTo_tas__GetClientAuthenticationRequired' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetClientAuthenticationRequired
#define SOAP_TYPE_PointerTo_tas__GetClientAuthenticationRequired (2022)
#endif

/* _tas__SetClientAuthenticationRequired * has binding name 'PointerTo_tas__SetClientAuthenticationRequired' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__SetClientAuthenticationRequired
#define SOAP_TYPE_PointerTo_tas__SetClientAuthenticationRequired (2018)
#endif

/* _tas__GetEnabledTLSVersions * has binding name 'PointerTo_tas__GetEnabledTLSVersions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetEnabledTLSVersions
#define SOAP_TYPE_PointerTo_tas__GetEnabledTLSVersions (2014)
#endif

/* _tas__SetEnabledTLSVersions * has binding name 'PointerTo_tas__SetEnabledTLSVersions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__SetEnabledTLSVersions
#define SOAP_TYPE_PointerTo_tas__SetEnabledTLSVersions (2010)
#endif

/* _tas__GetAssignedServerCertificates * has binding name 'PointerTo_tas__GetAssignedServerCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAssignedServerCertificates
#define SOAP_TYPE_PointerTo_tas__GetAssignedServerCertificates (2006)
#endif

/* _tas__ReplaceServerCertificateAssignment * has binding name 'PointerTo_tas__ReplaceServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__ReplaceServerCertificateAssignment
#define SOAP_TYPE_PointerTo_tas__ReplaceServerCertificateAssignment (2002)
#endif

/* _tas__RemoveServerCertificateAssignment * has binding name 'PointerTo_tas__RemoveServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__RemoveServerCertificateAssignment
#define SOAP_TYPE_PointerTo_tas__RemoveServerCertificateAssignment (1998)
#endif

/* _tas__AddServerCertificateAssignment * has binding name 'PointerTo_tas__AddServerCertificateAssignment' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__AddServerCertificateAssignment
#define SOAP_TYPE_PointerTo_tas__AddServerCertificateAssignment (1994)
#endif

/* _tas__DeleteCertPathValidationPolicy * has binding name 'PointerTo_tas__DeleteCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteCertPathValidationPolicy
#define SOAP_TYPE_PointerTo_tas__DeleteCertPathValidationPolicy (1990)
#endif

/* _tas__GetAllCertPathValidationPolicies * has binding name 'PointerTo_tas__GetAllCertPathValidationPolicies' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllCertPathValidationPolicies
#define SOAP_TYPE_PointerTo_tas__GetAllCertPathValidationPolicies (1986)
#endif

/* _tas__GetCertPathValidationPolicy * has binding name 'PointerTo_tas__GetCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetCertPathValidationPolicy
#define SOAP_TYPE_PointerTo_tas__GetCertPathValidationPolicy (1982)
#endif

/* _tas__CreateCertPathValidationPolicy * has binding name 'PointerTo_tas__CreateCertPathValidationPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreateCertPathValidationPolicy
#define SOAP_TYPE_PointerTo_tas__CreateCertPathValidationPolicy (1978)
#endif

/* _tas__DeleteCRL * has binding name 'PointerTo_tas__DeleteCRL' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteCRL
#define SOAP_TYPE_PointerTo_tas__DeleteCRL (1974)
#endif

/* _tas__GetAllCRLs * has binding name 'PointerTo_tas__GetAllCRLs' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllCRLs
#define SOAP_TYPE_PointerTo_tas__GetAllCRLs (1970)
#endif

/* _tas__GetCRL * has binding name 'PointerTo_tas__GetCRL' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetCRL
#define SOAP_TYPE_PointerTo_tas__GetCRL (1966)
#endif

/* _tas__UploadCRL * has binding name 'PointerTo_tas__UploadCRL' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadCRL
#define SOAP_TYPE_PointerTo_tas__UploadCRL (1962)
#endif

/* _tas__DeletePassphrase * has binding name 'PointerTo_tas__DeletePassphrase' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeletePassphrase
#define SOAP_TYPE_PointerTo_tas__DeletePassphrase (1958)
#endif

/* _tas__GetAllPassphrases * has binding name 'PointerTo_tas__GetAllPassphrases' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllPassphrases
#define SOAP_TYPE_PointerTo_tas__GetAllPassphrases (1954)
#endif

/* _tas__UploadPassphrase * has binding name 'PointerTo_tas__UploadPassphrase' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadPassphrase
#define SOAP_TYPE_PointerTo_tas__UploadPassphrase (1950)
#endif

/* _tas__DeleteCertificationPath * has binding name 'PointerTo_tas__DeleteCertificationPath' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteCertificationPath
#define SOAP_TYPE_PointerTo_tas__DeleteCertificationPath (1946)
#endif

/* _tas__GetAllCertificationPaths * has binding name 'PointerTo_tas__GetAllCertificationPaths' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllCertificationPaths
#define SOAP_TYPE_PointerTo_tas__GetAllCertificationPaths (1942)
#endif

/* _tas__GetCertificationPath * has binding name 'PointerTo_tas__GetCertificationPath' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetCertificationPath
#define SOAP_TYPE_PointerTo_tas__GetCertificationPath (1938)
#endif

/* _tas__CreateCertificationPath * has binding name 'PointerTo_tas__CreateCertificationPath' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreateCertificationPath
#define SOAP_TYPE_PointerTo_tas__CreateCertificationPath (1934)
#endif

/* _tas__DeleteCertificate * has binding name 'PointerTo_tas__DeleteCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteCertificate
#define SOAP_TYPE_PointerTo_tas__DeleteCertificate (1930)
#endif

/* _tas__GetAllCertificates * has binding name 'PointerTo_tas__GetAllCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllCertificates
#define SOAP_TYPE_PointerTo_tas__GetAllCertificates (1926)
#endif

/* _tas__GetCertificate * has binding name 'PointerTo_tas__GetCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetCertificate
#define SOAP_TYPE_PointerTo_tas__GetCertificate (1922)
#endif

/* _tas__UploadCertificate * has binding name 'PointerTo_tas__UploadCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadCertificate
#define SOAP_TYPE_PointerTo_tas__UploadCertificate (1918)
#endif

/* _tas__CreateSelfSignedCertificate * has binding name 'PointerTo_tas__CreateSelfSignedCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreateSelfSignedCertificate
#define SOAP_TYPE_PointerTo_tas__CreateSelfSignedCertificate (1914)
#endif

/* _tas__CreatePKCS10CSR * has binding name 'PointerTo_tas__CreatePKCS10CSR' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreatePKCS10CSR
#define SOAP_TYPE_PointerTo_tas__CreatePKCS10CSR (1910)
#endif

/* _tas__DeleteKey * has binding name 'PointerTo_tas__DeleteKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DeleteKey
#define SOAP_TYPE_PointerTo_tas__DeleteKey (1906)
#endif

/* _tas__GetAllKeys * has binding name 'PointerTo_tas__GetAllKeys' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetAllKeys
#define SOAP_TYPE_PointerTo_tas__GetAllKeys (1902)
#endif

/* _tas__GetPrivateKeyStatus * has binding name 'PointerTo_tas__GetPrivateKeyStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetPrivateKeyStatus
#define SOAP_TYPE_PointerTo_tas__GetPrivateKeyStatus (1898)
#endif

/* _tas__GetKeyStatus * has binding name 'PointerTo_tas__GetKeyStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetKeyStatus
#define SOAP_TYPE_PointerTo_tas__GetKeyStatus (1894)
#endif

/* _tas__UploadCertificateWithPrivateKeyInPKCS12 * has binding name 'PointerTo_tas__UploadCertificateWithPrivateKeyInPKCS12' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadCertificateWithPrivateKeyInPKCS12
#define SOAP_TYPE_PointerTo_tas__UploadCertificateWithPrivateKeyInPKCS12 (1890)
#endif

/* _tas__UploadKeyPairInPKCS8 * has binding name 'PointerTo_tas__UploadKeyPairInPKCS8' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadKeyPairInPKCS8
#define SOAP_TYPE_PointerTo_tas__UploadKeyPairInPKCS8 (1886)
#endif

/* _tas__CreateRSAKeyPair * has binding name 'PointerTo_tas__CreateRSAKeyPair' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreateRSAKeyPair
#define SOAP_TYPE_PointerTo_tas__CreateRSAKeyPair (1882)
#endif

/* _tas__GetServiceCapabilities * has binding name 'PointerTo_tas__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tas__GetServiceCapabilities (1878)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType * has binding name 'PointerTowsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType (1876)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType * has binding name 'PointerTowsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType (1875)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType * has binding name 'PointerTowsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType (1874)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType * has binding name 'PointerTowsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType (1873)
#endif

/* wsnt__UnableToGetMessagesFaultType * has binding name 'PointerTowsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType (1872)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType * has binding name 'PointerTowsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType (1871)
#endif

/* wsnt__UnableToDestroyPullPointFaultType * has binding name 'PointerTowsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType (1870)
#endif

/* wsnt__UnableToCreatePullPointFaultType * has binding name 'PointerTowsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType (1869)
#endif

/* wsnt__TopicNotSupportedFaultType * has binding name 'PointerTowsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType (1868)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType * has binding name 'PointerTowsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType (1867)
#endif

/* wsnt__SubscribeCreationFailedFaultType * has binding name 'PointerTowsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType (1866)
#endif

/* wsnt__ResumeFailedFaultType * has binding name 'PointerTowsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType
#define SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType (1865)
#endif

/* wsrfr__ResourceUnknownFaultType * has binding name 'PointerTowsrfr__ResourceUnknownFaultType' for type 'wsrfr:ResourceUnknownFaultType' */
#ifndef SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType
#define SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType (1864)
#endif

/* _tev__PullMessagesFaultResponse * has binding name 'PointerTo_tev__PullMessagesFaultResponse' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse
#define SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse (1863)
#endif

/* wsnt__PauseFailedFaultType * has binding name 'PointerTowsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__PauseFailedFaultType
#define SOAP_TYPE_PointerTowsnt__PauseFailedFaultType (1862)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType * has binding name 'PointerTowsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType (1861)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType * has binding name 'PointerTowsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType (1860)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType * has binding name 'PointerTowsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType (1859)
#endif

/* wsnt__InvalidTopicExpressionFaultType * has binding name 'PointerTowsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType (1858)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType * has binding name 'PointerTowsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType (1857)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType * has binding name 'PointerTowsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType (1856)
#endif

/* wsnt__InvalidFilterFaultType * has binding name 'PointerTowsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType
#define SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType (1855)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (1854)
#endif

/* std::string * has binding name 'PointerTowstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTowstop__ConcreteTopicExpression
#define SOAP_TYPE_PointerTowstop__ConcreteTopicExpression (1852)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (1851)
#endif

/* wstop__TopicType * has binding name 'PointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicType
#define SOAP_TYPE_PointerTowstop__TopicType (1849)
#endif

/* wstop__QueryExpressionType * has binding name 'PointerTowstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTowstop__QueryExpressionType
#define SOAP_TYPE_PointerTowstop__QueryExpressionType (1848)
#endif

/* tt__OSDConfigurationExtension * has binding name 'PointerTott__OSDConfigurationExtension' for type 'tt:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDConfigurationExtension (1845)
#endif

/* tt__OSDImgConfiguration * has binding name 'PointerTott__OSDImgConfiguration' for type 'tt:OSDImgConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDImgConfiguration
#define SOAP_TYPE_PointerTott__OSDImgConfiguration (1844)
#endif

/* tt__OSDTextConfiguration * has binding name 'PointerTott__OSDTextConfiguration' for type 'tt:OSDTextConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDTextConfiguration
#define SOAP_TYPE_PointerTott__OSDTextConfiguration (1843)
#endif

/* tt__OSDPosConfiguration * has binding name 'PointerTott__OSDPosConfiguration' for type 'tt:OSDPosConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDPosConfiguration
#define SOAP_TYPE_PointerTott__OSDPosConfiguration (1842)
#endif

/* tt__OSDReference * has binding name 'PointerTott__OSDReference' for type 'tt:OSDReference' */
#ifndef SOAP_TYPE_PointerTott__OSDReference
#define SOAP_TYPE_PointerTott__OSDReference (1841)
#endif

/* tt__PTZConfigurationExtension * has binding name 'PointerTott__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension (1840)
#endif

/* tt__ZoomLimits * has binding name 'PointerTott__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_PointerTott__ZoomLimits
#define SOAP_TYPE_PointerTott__ZoomLimits (1839)
#endif

/* tt__PanTiltLimits * has binding name 'PointerTott__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_PointerTott__PanTiltLimits
#define SOAP_TYPE_PointerTott__PanTiltLimits (1838)
#endif

/* tt__PTZNodeExtension * has binding name 'PointerTott__PTZNodeExtension' for type 'tt:PTZNodeExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZNodeExtension
#define SOAP_TYPE_PointerTott__PTZNodeExtension (1837)
#endif

/* enum tt__DigitalIdleState * has binding name 'PointerTott__DigitalIdleState' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_PointerTott__DigitalIdleState
#define SOAP_TYPE_PointerTott__DigitalIdleState (1836)
#endif

/* tt__NetworkInterfaceExtension * has binding name 'PointerTott__NetworkInterfaceExtension' for type 'tt:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceExtension
#define SOAP_TYPE_PointerTott__NetworkInterfaceExtension (1835)
#endif

/* tt__IPv6NetworkInterface * has binding name 'PointerTott__IPv6NetworkInterface' for type 'tt:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__IPv6NetworkInterface
#define SOAP_TYPE_PointerTott__IPv6NetworkInterface (1834)
#endif

/* tt__IPv4NetworkInterface * has binding name 'PointerTott__IPv4NetworkInterface' for type 'tt:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__IPv4NetworkInterface
#define SOAP_TYPE_PointerTott__IPv4NetworkInterface (1833)
#endif

/* tt__NetworkInterfaceLink * has binding name 'PointerTott__NetworkInterfaceLink' for type 'tt:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceLink
#define SOAP_TYPE_PointerTott__NetworkInterfaceLink (1832)
#endif

/* tt__NetworkInterfaceInfo * has binding name 'PointerTott__NetworkInterfaceInfo' for type 'tt:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceInfo
#define SOAP_TYPE_PointerTott__NetworkInterfaceInfo (1831)
#endif

/* tt__VideoOutputExtension * has binding name 'PointerTott__VideoOutputExtension' for type 'tt:VideoOutputExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoOutputExtension
#define SOAP_TYPE_PointerTott__VideoOutputExtension (1830)
#endif

/* tt__Layout * has binding name 'PointerTott__Layout' for type 'tt:Layout' */
#ifndef SOAP_TYPE_PointerTott__Layout
#define SOAP_TYPE_PointerTott__Layout (1829)
#endif

/* tt__MetadataConfigurationExtension * has binding name 'PointerTott__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationExtension
#define SOAP_TYPE_PointerTott__MetadataConfigurationExtension (1828)
#endif

/* tt__EventSubscription * has binding name 'PointerTott__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_PointerTott__EventSubscription
#define SOAP_TYPE_PointerTott__EventSubscription (1827)
#endif

/* tt__PTZFilter * has binding name 'PointerTott__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_PointerTott__PTZFilter
#define SOAP_TYPE_PointerTott__PTZFilter (1826)
#endif

/* tt__RuleEngineConfiguration * has binding name 'PointerTott__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfiguration
#define SOAP_TYPE_PointerTott__RuleEngineConfiguration (1825)
#endif

/* tt__AnalyticsEngineConfiguration * has binding name 'PointerTott__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration (1824)
#endif

/* tt__MulticastConfiguration * has binding name 'PointerTott__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_PointerTott__MulticastConfiguration
#define SOAP_TYPE_PointerTott__MulticastConfiguration (1823)
#endif

/* tt__H264Configuration * has binding name 'PointerTott__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_PointerTott__H264Configuration
#define SOAP_TYPE_PointerTott__H264Configuration (1822)
#endif

/* tt__Mpeg4Configuration * has binding name 'PointerTott__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Configuration
#define SOAP_TYPE_PointerTott__Mpeg4Configuration (1821)
#endif

/* tt__VideoRateControl * has binding name 'PointerTott__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_PointerTott__VideoRateControl
#define SOAP_TYPE_PointerTott__VideoRateControl (1820)
#endif

/* tt__VideoSourceConfigurationExtension * has binding name 'PointerTott__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension (1819)
#endif

/* tt__IntRectangle * has binding name 'PointerTott__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_PointerTott__IntRectangle
#define SOAP_TYPE_PointerTott__IntRectangle (1818)
#endif

/* tt__VideoSourceExtension * has binding name 'PointerTott__VideoSourceExtension' for type 'tt:VideoSourceExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceExtension
#define SOAP_TYPE_PointerTott__VideoSourceExtension (1817)
#endif

/* tt__ImagingSettings * has binding name 'PointerTott__ImagingSettings' for type 'tt:ImagingSettings' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettings
#define SOAP_TYPE_PointerTott__ImagingSettings (1816)
#endif

/* tas__Dot1XConfiguration * has binding name 'PointerTotas__Dot1XConfiguration' for type 'tas:Dot1XConfiguration' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XConfiguration
#define SOAP_TYPE_PointerTotas__Dot1XConfiguration (1814)
#endif

/* tas__CertPathValidationPolicy * has binding name 'PointerTotas__CertPathValidationPolicy' for type 'tas:CertPathValidationPolicy' */
#ifndef SOAP_TYPE_PointerTotas__CertPathValidationPolicy
#define SOAP_TYPE_PointerTotas__CertPathValidationPolicy (1811)
#endif

/* _tas__CreateCertPathValidationPolicy_anyParameters * has binding name 'PointerTo_tas__CreateCertPathValidationPolicy_anyParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CreateCertPathValidationPolicy_anyParameters
#define SOAP_TYPE_PointerTo_tas__CreateCertPathValidationPolicy_anyParameters (1810)
#endif

/* tas__CRL * has binding name 'PointerTotas__CRL' for type 'tas:CRL' */
#ifndef SOAP_TYPE_PointerTotas__CRL
#define SOAP_TYPE_PointerTotas__CRL (1807)
#endif

/* _tas__UploadCRL_anyParameters * has binding name 'PointerTo_tas__UploadCRL_anyParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__UploadCRL_anyParameters
#define SOAP_TYPE_PointerTo_tas__UploadCRL_anyParameters (1806)
#endif

/* tas__PassphraseAttribute * has binding name 'PointerTotas__PassphraseAttribute' for type 'tas:PassphraseAttribute' */
#ifndef SOAP_TYPE_PointerTotas__PassphraseAttribute
#define SOAP_TYPE_PointerTotas__PassphraseAttribute (1803)
#endif

/* tas__CertificationPath * has binding name 'PointerTotas__CertificationPath' for type 'tas:CertificationPath' */
#ifndef SOAP_TYPE_PointerTotas__CertificationPath
#define SOAP_TYPE_PointerTotas__CertificationPath (1801)
#endif

/* tas__CertificateIDs * has binding name 'PointerTotas__CertificateIDs' for type 'tas:CertificateIDs' */
#ifndef SOAP_TYPE_PointerTotas__CertificateIDs
#define SOAP_TYPE_PointerTotas__CertificateIDs (1800)
#endif

/* tas__X509Certificate * has binding name 'PointerTotas__X509Certificate' for type 'tas:X509Certificate' */
#ifndef SOAP_TYPE_PointerTotas__X509Certificate
#define SOAP_TYPE_PointerTotas__X509Certificate (1798)
#endif

/* tas__CSRAttribute * has binding name 'PointerTotas__CSRAttribute' for type 'tas:CSRAttribute' */
#ifndef SOAP_TYPE_PointerTotas__CSRAttribute
#define SOAP_TYPE_PointerTotas__CSRAttribute (1795)
#endif

/* tas__DistinguishedName * has binding name 'PointerTotas__DistinguishedName' for type 'tas:DistinguishedName' */
#ifndef SOAP_TYPE_PointerTotas__DistinguishedName
#define SOAP_TYPE_PointerTotas__DistinguishedName (1794)
#endif

/* tas__KeyAttribute * has binding name 'PointerTotas__KeyAttribute' for type 'tas:KeyAttribute' */
#ifndef SOAP_TYPE_PointerTotas__KeyAttribute
#define SOAP_TYPE_PointerTotas__KeyAttribute (1792)
#endif

/* tas__Capabilities * has binding name 'PointerTotas__Capabilities' for type 'tas:Capabilities' */
#ifndef SOAP_TYPE_PointerTotas__Capabilities
#define SOAP_TYPE_PointerTotas__Capabilities (1791)
#endif

/* tas__Dot1XCapabilities * has binding name 'PointerTotas__Dot1XCapabilities' for type 'tas:Dot1XCapabilities' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XCapabilities
#define SOAP_TYPE_PointerTotas__Dot1XCapabilities (1790)
#endif

/* tas__TLSServerCapabilities * has binding name 'PointerTotas__TLSServerCapabilities' for type 'tas:TLSServerCapabilities' */
#ifndef SOAP_TYPE_PointerTotas__TLSServerCapabilities
#define SOAP_TYPE_PointerTotas__TLSServerCapabilities (1789)
#endif

/* tas__KeystoreCapabilities * has binding name 'PointerTotas__KeystoreCapabilities' for type 'tas:KeystoreCapabilities' */
#ifndef SOAP_TYPE_PointerTotas__KeystoreCapabilities
#define SOAP_TYPE_PointerTotas__KeystoreCapabilities (1788)
#endif

/* std::string * has binding name 'PointerTotas__TLSVersions' for type 'tas:TLSVersions' */
#ifndef SOAP_TYPE_PointerTotas__TLSVersions
#define SOAP_TYPE_PointerTotas__TLSVersions (1787)
#endif

/* std::string * has binding name 'PointerTotas__PasswordBasedMACAlgorithms' for type 'tas:PasswordBasedMACAlgorithms' */
#ifndef SOAP_TYPE_PointerTotas__PasswordBasedMACAlgorithms
#define SOAP_TYPE_PointerTotas__PasswordBasedMACAlgorithms (1786)
#endif

/* std::string * has binding name 'PointerTotas__PasswordBasedEncryptionAlgorithms' for type 'tas:PasswordBasedEncryptionAlgorithms' */
#ifndef SOAP_TYPE_PointerTotas__PasswordBasedEncryptionAlgorithms
#define SOAP_TYPE_PointerTotas__PasswordBasedEncryptionAlgorithms (1785)
#endif

/* std::string * has binding name 'PointerTotas__X509Versions' for type 'tas:X509Versions' */
#ifndef SOAP_TYPE_PointerTotas__X509Versions
#define SOAP_TYPE_PointerTotas__X509Versions (1784)
#endif

/* std::string * has binding name 'PointerTotas__RSAKeyLengths' for type 'tas:RSAKeyLengths' */
#ifndef SOAP_TYPE_PointerTotas__RSAKeyLengths
#define SOAP_TYPE_PointerTotas__RSAKeyLengths (1783)
#endif

/* _tas__KeystoreCapabilities_anyElement * has binding name 'PointerTo_tas__KeystoreCapabilities_anyElement' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__KeystoreCapabilities_anyElement
#define SOAP_TYPE_PointerTo_tas__KeystoreCapabilities_anyElement (1782)
#endif

/* tas__AlgorithmIdentifier * has binding name 'PointerTotas__AlgorithmIdentifier' for type 'tas:AlgorithmIdentifier' */
#ifndef SOAP_TYPE_PointerTotas__AlgorithmIdentifier
#define SOAP_TYPE_PointerTotas__AlgorithmIdentifier (1779)
#endif

/* _tas__CertPathValidationPolicy_anyParameters * has binding name 'PointerTo_tas__CertPathValidationPolicy_anyParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CertPathValidationPolicy_anyParameters
#define SOAP_TYPE_PointerTo_tas__CertPathValidationPolicy_anyParameters (1778)
#endif

/* tas__TrustAnchor * has binding name 'PointerTotas__TrustAnchor' for type 'tas:TrustAnchor' */
#ifndef SOAP_TYPE_PointerTotas__TrustAnchor
#define SOAP_TYPE_PointerTotas__TrustAnchor (1775)
#endif

/* tas__CertPathValidationParameters * has binding name 'PointerTotas__CertPathValidationParameters' for type 'tas:CertPathValidationParameters' */
#ifndef SOAP_TYPE_PointerTotas__CertPathValidationParameters
#define SOAP_TYPE_PointerTotas__CertPathValidationParameters (1774)
#endif

/* _tas__CertPathValidationParameters_anyParameters * has binding name 'PointerTo_tas__CertPathValidationParameters_anyParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CertPathValidationParameters_anyParameters
#define SOAP_TYPE_PointerTo_tas__CertPathValidationParameters_anyParameters (1773)
#endif

/* std::string * has binding name 'PointerTotas__Dot1XID' for type 'tas:Dot1XID' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XID
#define SOAP_TYPE_PointerTotas__Dot1XID (1771)
#endif

/* tas__Dot1XStageExtension * has binding name 'PointerTotas__Dot1XStageExtension' for type 'tas:Dot1XStageExtension' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XStageExtension
#define SOAP_TYPE_PointerTotas__Dot1XStageExtension (1770)
#endif

/* tas__Dot1XStage * has binding name 'PointerTotas__Dot1XStage' for type 'tas:Dot1XStage' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XStage
#define SOAP_TYPE_PointerTotas__Dot1XStage (1769)
#endif

/* std::string * has binding name 'PointerTotas__PassphraseID' for type 'tas:PassphraseID' */
#ifndef SOAP_TYPE_PointerTotas__PassphraseID
#define SOAP_TYPE_PointerTotas__PassphraseID (1768)
#endif

/* std::string * has binding name 'PointerTotas__CertificationPathID' for type 'tas:CertificationPathID' */
#ifndef SOAP_TYPE_PointerTotas__CertificationPathID
#define SOAP_TYPE_PointerTotas__CertificationPathID (1767)
#endif

/* std::string * has binding name 'PointerTotas__Dot1XMethods' for type 'tas:Dot1XMethods' */
#ifndef SOAP_TYPE_PointerTotas__Dot1XMethods
#define SOAP_TYPE_PointerTotas__Dot1XMethods (1766)
#endif

/* std::string * has binding name 'PointerToxsd__positiveInteger' for type 'xsd:positiveInteger' */
#ifndef SOAP_TYPE_PointerToxsd__positiveInteger
#define SOAP_TYPE_PointerToxsd__positiveInteger (1765)
#endif

/* _tas__CertificationPath_anyElement * has binding name 'PointerTo_tas__CertificationPath_anyElement' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CertificationPath_anyElement
#define SOAP_TYPE_PointerTo_tas__CertificationPath_anyElement (1764)
#endif

/* _tas__CSRAttribute_anyAttribute * has binding name 'PointerTo_tas__CSRAttribute_anyAttribute' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__CSRAttribute_anyAttribute
#define SOAP_TYPE_PointerTo_tas__CSRAttribute_anyAttribute (1760)
#endif

/* tas__BasicRequestAttribute * has binding name 'PointerTotas__BasicRequestAttribute' for type 'tas:BasicRequestAttribute' */
#ifndef SOAP_TYPE_PointerTotas__BasicRequestAttribute
#define SOAP_TYPE_PointerTotas__BasicRequestAttribute (1758)
#endif

/* tas__X509v3Extension * has binding name 'PointerTotas__X509v3Extension' for type 'tas:X509v3Extension' */
#ifndef SOAP_TYPE_PointerTotas__X509v3Extension
#define SOAP_TYPE_PointerTotas__X509v3Extension (1757)
#endif

/* _tas__AlgorithmIdentifier_anyParameters * has binding name 'PointerTo_tas__AlgorithmIdentifier_anyParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__AlgorithmIdentifier_anyParameters
#define SOAP_TYPE_PointerTo_tas__AlgorithmIdentifier_anyParameters (1756)
#endif

/* xsd__base64Binary * has binding name 'PointerTotas__Base64DERencodedASN1Value' for type 'tas:Base64DERencodedASN1Value' */
#ifndef SOAP_TYPE_PointerTotas__Base64DERencodedASN1Value
#define SOAP_TYPE_PointerTotas__Base64DERencodedASN1Value (1754)
#endif

/* _tas__DistinguishedName_anyAttribute * has binding name 'PointerTo_tas__DistinguishedName_anyAttribute' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__DistinguishedName_anyAttribute
#define SOAP_TYPE_PointerTo_tas__DistinguishedName_anyAttribute (1753)
#endif

/* tas__MultiValuedRDN * has binding name 'PointerTotas__MultiValuedRDN' for type 'tas:MultiValuedRDN' */
#ifndef SOAP_TYPE_PointerTotas__MultiValuedRDN
#define SOAP_TYPE_PointerTotas__MultiValuedRDN (1750)
#endif

/* tas__DNAttributeTypeAndValue * has binding name 'PointerTotas__DNAttributeTypeAndValue' for type 'tas:DNAttributeTypeAndValue' */
#ifndef SOAP_TYPE_PointerTotas__DNAttributeTypeAndValue
#define SOAP_TYPE_PointerTotas__DNAttributeTypeAndValue (1747)
#endif

/* _tas__KeyAttribute_Extension * has binding name 'PointerTo_tas__KeyAttribute_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tas__KeyAttribute_Extension
#define SOAP_TYPE_PointerTo_tas__KeyAttribute_Extension (1746)
#endif

/* tt__PTZPresetTourOptions * has binding name 'PointerTott__PTZPresetTourOptions' for type 'tt:PTZPresetTourOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourOptions (1744)
#endif

/* tt__PresetTour * has binding name 'PointerTott__PresetTour' for type 'tt:PresetTour' */
#ifndef SOAP_TYPE_PointerTott__PresetTour
#define SOAP_TYPE_PointerTott__PresetTour (1742)
#endif

/* tt__PTZStatus * has binding name 'PointerTott__PTZStatus' for type 'tt:PTZStatus' */
#ifndef SOAP_TYPE_PointerTott__PTZStatus
#define SOAP_TYPE_PointerTott__PTZStatus (1741)
#endif

/* tt__PTZPreset * has binding name 'PointerTott__PTZPreset' for type 'tt:PTZPreset' */
#ifndef SOAP_TYPE_PointerTott__PTZPreset
#define SOAP_TYPE_PointerTott__PTZPreset (1739)
#endif

/* tt__PTZConfigurationOptions * has binding name 'PointerTott__PTZConfigurationOptions' for type 'tt:PTZConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationOptions
#define SOAP_TYPE_PointerTott__PTZConfigurationOptions (1738)
#endif

/* __tptz__SetConfigurationResponse_sequence * has binding name 'PointerTo__tptz__SetConfigurationResponse_sequence' for type '-tptz:SetConfigurationResponse-sequence' */
#ifndef SOAP_TYPE_PointerTo__tptz__SetConfigurationResponse_sequence
#define SOAP_TYPE_PointerTo__tptz__SetConfigurationResponse_sequence (1737)
#endif

/* tt__PTZNode * has binding name 'PointerTott__PTZNode' for type 'tt:PTZNode' */
#ifndef SOAP_TYPE_PointerTott__PTZNode
#define SOAP_TYPE_PointerTott__PTZNode (1733)
#endif

/* tptz__Capabilities * has binding name 'PointerTotptz__Capabilities' for type 'tptz:Capabilities' */
#ifndef SOAP_TYPE_PointerTotptz__Capabilities
#define SOAP_TYPE_PointerTotptz__Capabilities (1732)
#endif

/* tt__OSDConfigurationOptions * has binding name 'PointerTott__OSDConfigurationOptions' for type 'tt:OSDConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDConfigurationOptions
#define SOAP_TYPE_PointerTott__OSDConfigurationOptions (1731)
#endif

/* tt__OSDConfiguration * has binding name 'PointerTott__OSDConfiguration' for type 'tt:OSDConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDConfiguration
#define SOAP_TYPE_PointerTott__OSDConfiguration (1729)
#endif

/* trt__VideoSourceMode * has binding name 'PointerTotrt__VideoSourceMode' for type 'trt:VideoSourceMode' */
#ifndef SOAP_TYPE_PointerTotrt__VideoSourceMode
#define SOAP_TYPE_PointerTotrt__VideoSourceMode (1727)
#endif

/* tt__MediaUri * has binding name 'PointerTott__MediaUri' for type 'tt:MediaUri' */
#ifndef SOAP_TYPE_PointerTott__MediaUri
#define SOAP_TYPE_PointerTott__MediaUri (1726)
#endif

/* tt__StreamSetup * has binding name 'PointerTott__StreamSetup' for type 'tt:StreamSetup' */
#ifndef SOAP_TYPE_PointerTott__StreamSetup
#define SOAP_TYPE_PointerTott__StreamSetup (1725)
#endif

/* tt__AudioDecoderConfigurationOptions * has binding name 'PointerTott__AudioDecoderConfigurationOptions' for type 'tt:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptions (1724)
#endif

/* tt__MetadataConfigurationOptions * has binding name 'PointerTott__MetadataConfigurationOptions' for type 'tt:MetadataConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationOptions
#define SOAP_TYPE_PointerTott__MetadataConfigurationOptions (1723)
#endif

/* tt__AudioEncoderConfigurationOptions * has binding name 'PointerTott__AudioEncoderConfigurationOptions' for type 'tt:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioEncoderConfigurationOptions (1722)
#endif

/* tt__VideoEncoderConfigurationOptions * has binding name 'PointerTott__VideoEncoderConfigurationOptions' for type 'tt:VideoEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderConfigurationOptions
#define SOAP_TYPE_PointerTott__VideoEncoderConfigurationOptions (1721)
#endif

/* tt__Profile * has binding name 'PointerTott__Profile' for type 'tt:Profile' */
#ifndef SOAP_TYPE_PointerTott__Profile
#define SOAP_TYPE_PointerTott__Profile (1711)
#endif

/* tt__AudioOutput * has binding name 'PointerTott__AudioOutput' for type 'tt:AudioOutput' */
#ifndef SOAP_TYPE_PointerTott__AudioOutput
#define SOAP_TYPE_PointerTott__AudioOutput (1709)
#endif

/* tt__AudioSource * has binding name 'PointerTott__AudioSource' for type 'tt:AudioSource' */
#ifndef SOAP_TYPE_PointerTott__AudioSource
#define SOAP_TYPE_PointerTott__AudioSource (1707)
#endif

/* tt__VideoSource * has binding name 'PointerTott__VideoSource' for type 'tt:VideoSource' */
#ifndef SOAP_TYPE_PointerTott__VideoSource
#define SOAP_TYPE_PointerTott__VideoSource (1705)
#endif

/* trt__Capabilities * has binding name 'PointerTotrt__Capabilities' for type 'trt:Capabilities' */
#ifndef SOAP_TYPE_PointerTotrt__Capabilities
#define SOAP_TYPE_PointerTotrt__Capabilities (1704)
#endif

/* trt__VideoSourceModeExtension * has binding name 'PointerTotrt__VideoSourceModeExtension' for type 'trt:VideoSourceModeExtension' */
#ifndef SOAP_TYPE_PointerTotrt__VideoSourceModeExtension
#define SOAP_TYPE_PointerTotrt__VideoSourceModeExtension (1703)
#endif

/* std::string * has binding name 'PointerTott__Description' for type 'tt:Description' */
#ifndef SOAP_TYPE_PointerTott__Description
#define SOAP_TYPE_PointerTott__Description (1702)
#endif

/* trt__StreamingCapabilities * has binding name 'PointerTotrt__StreamingCapabilities' for type 'trt:StreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTotrt__StreamingCapabilities
#define SOAP_TYPE_PointerTotrt__StreamingCapabilities (1701)
#endif

/* trt__ProfileCapabilities * has binding name 'PointerTotrt__ProfileCapabilities' for type 'trt:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTotrt__ProfileCapabilities
#define SOAP_TYPE_PointerTotrt__ProfileCapabilities (1700)
#endif

/* timg__ImagingPreset * has binding name 'PointerTotimg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_PointerTotimg__ImagingPreset
#define SOAP_TYPE_PointerTotimg__ImagingPreset (1698)
#endif

/* tt__ImagingStatus20 * has binding name 'PointerTott__ImagingStatus20' for type 'tt:ImagingStatus20' */
#ifndef SOAP_TYPE_PointerTott__ImagingStatus20
#define SOAP_TYPE_PointerTott__ImagingStatus20 (1697)
#endif

/* tt__MoveOptions20 * has binding name 'PointerTott__MoveOptions20' for type 'tt:MoveOptions20' */
#ifndef SOAP_TYPE_PointerTott__MoveOptions20
#define SOAP_TYPE_PointerTott__MoveOptions20 (1696)
#endif

/* tt__FocusMove * has binding name 'PointerTott__FocusMove' for type 'tt:FocusMove' */
#ifndef SOAP_TYPE_PointerTott__FocusMove
#define SOAP_TYPE_PointerTott__FocusMove (1695)
#endif

/* tt__ImagingOptions20 * has binding name 'PointerTott__ImagingOptions20' for type 'tt:ImagingOptions20' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20
#define SOAP_TYPE_PointerTott__ImagingOptions20 (1694)
#endif

/* timg__Capabilities * has binding name 'PointerTotimg__Capabilities' for type 'timg:Capabilities' */
#ifndef SOAP_TYPE_PointerTotimg__Capabilities
#define SOAP_TYPE_PointerTotimg__Capabilities (1693)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (1692)
#endif

/* tmd__SerialData * has binding name 'PointerTotmd__SerialData' for type 'tmd:SerialData' */
#ifndef SOAP_TYPE_PointerTotmd__SerialData
#define SOAP_TYPE_PointerTotmd__SerialData (1691)
#endif

/* tmd__SerialPortConfigurationOptions * has binding name 'PointerTotmd__SerialPortConfigurationOptions' for type 'tmd:SerialPortConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTotmd__SerialPortConfigurationOptions
#define SOAP_TYPE_PointerTotmd__SerialPortConfigurationOptions (1690)
#endif

/* tmd__SerialPortConfiguration * has binding name 'PointerTotmd__SerialPortConfiguration' for type 'tmd:SerialPortConfiguration' */
#ifndef SOAP_TYPE_PointerTotmd__SerialPortConfiguration
#define SOAP_TYPE_PointerTotmd__SerialPortConfiguration (1689)
#endif

/* tmd__SerialPort * has binding name 'PointerTotmd__SerialPort' for type 'tmd:SerialPort' */
#ifndef SOAP_TYPE_PointerTotmd__SerialPort
#define SOAP_TYPE_PointerTotmd__SerialPort (1687)
#endif

/* tmd__DigitalInputConfigurationOptions * has binding name 'PointerTotmd__DigitalInputConfigurationOptions' for type 'tmd:DigitalInputConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTotmd__DigitalInputConfigurationOptions
#define SOAP_TYPE_PointerTotmd__DigitalInputConfigurationOptions (1686)
#endif

/* tt__DigitalInput * has binding name 'PointerTott__DigitalInput' for type 'tt:DigitalInput' */
#ifndef SOAP_TYPE_PointerTott__DigitalInput
#define SOAP_TYPE_PointerTott__DigitalInput (1684)
#endif

/* tt__AudioOutputConfigurationOptions * has binding name 'PointerTott__AudioOutputConfigurationOptions' for type 'tt:AudioOutputConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioOutputConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioOutputConfigurationOptions (1683)
#endif

/* tt__AudioSourceConfigurationOptions * has binding name 'PointerTott__AudioSourceConfigurationOptions' for type 'tt:AudioSourceConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioSourceConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioSourceConfigurationOptions (1682)
#endif

/* tt__VideoOutputConfigurationOptions * has binding name 'PointerTott__VideoOutputConfigurationOptions' for type 'tt:VideoOutputConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__VideoOutputConfigurationOptions
#define SOAP_TYPE_PointerTott__VideoOutputConfigurationOptions (1681)
#endif

/* tt__VideoSourceConfigurationOptions * has binding name 'PointerTott__VideoSourceConfigurationOptions' for type 'tt:VideoSourceConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationOptions
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationOptions (1680)
#endif

/* tt__VideoOutputConfiguration * has binding name 'PointerTott__VideoOutputConfiguration' for type 'tt:VideoOutputConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoOutputConfiguration
#define SOAP_TYPE_PointerTott__VideoOutputConfiguration (1679)
#endif

/* tt__VideoOutput * has binding name 'PointerTott__VideoOutput' for type 'tt:VideoOutput' */
#ifndef SOAP_TYPE_PointerTott__VideoOutput
#define SOAP_TYPE_PointerTott__VideoOutput (1677)
#endif

/* tmd__RelayOutputOptions * has binding name 'PointerTotmd__RelayOutputOptions' for type 'tmd:RelayOutputOptions' */
#ifndef SOAP_TYPE_PointerTotmd__RelayOutputOptions
#define SOAP_TYPE_PointerTotmd__RelayOutputOptions (1675)
#endif

/* tmd__Capabilities * has binding name 'PointerTotmd__Capabilities' for type 'tmd:Capabilities' */
#ifndef SOAP_TYPE_PointerTotmd__Capabilities
#define SOAP_TYPE_PointerTotmd__Capabilities (1674)
#endif

/* tt__FloatList * has binding name 'PointerTott__FloatList' for type 'tt:FloatList' */
#ifndef SOAP_TYPE_PointerTott__FloatList
#define SOAP_TYPE_PointerTott__FloatList (1672)
#endif

/* tmd__ParityBitList * has binding name 'PointerTotmd__ParityBitList' for type 'tmd:ParityBitList' */
#ifndef SOAP_TYPE_PointerTotmd__ParityBitList
#define SOAP_TYPE_PointerTotmd__ParityBitList (1671)
#endif

/* xsd__base64Binary * has binding name 'PointerToxsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_PointerToxsd__base64Binary
#define SOAP_TYPE_PointerToxsd__base64Binary (1669)
#endif

/* tmd__RelayOutputOptionsExtension * has binding name 'PointerTotmd__RelayOutputOptionsExtension' for type 'tmd:RelayOutputOptionsExtension' */
#ifndef SOAP_TYPE_PointerTotmd__RelayOutputOptionsExtension
#define SOAP_TYPE_PointerTotmd__RelayOutputOptionsExtension (1667)
#endif

/* std::string * has binding name 'PointerTotmd__DelayTimes' for type 'tmd:DelayTimes' */
#ifndef SOAP_TYPE_PointerTotmd__DelayTimes
#define SOAP_TYPE_PointerTotmd__DelayTimes (1666)
#endif

/* _tev__CreatePullPointSubscription_SubscriptionPolicy * has binding name 'PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy (1664)
#endif

/* tev__Capabilities * has binding name 'PointerTotev__Capabilities' for type 'tev:Capabilities' */
#ifndef SOAP_TYPE_PointerTotev__Capabilities
#define SOAP_TYPE_PointerTotev__Capabilities (1662)
#endif

/* wstop__Documentation * has binding name 'PointerTowstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_PointerTowstop__Documentation
#define SOAP_TYPE_PointerTowstop__Documentation (1661)
#endif

/* _wsrfbf__BaseFaultType_FaultCause * has binding name 'PointerTo_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause (1660)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (1657)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode * has binding name 'PointerTo_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode (1655)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (1653)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy (1652)
#endif

/* std::string * has binding name 'PointerTowsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType (1650)
#endif

/* wsnt__NotificationMessageHolderType * has binding name 'PointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType (1648)
#endif

/* wsnt__SubscriptionPolicyType * has binding name 'PointerTowsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType
#define SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType (1647)
#endif

/* wstop__TopicSetType * has binding name 'PointerTowstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicSetType
#define SOAP_TYPE_PointerTowstop__TopicSetType (1646)
#endif

/* wsnt__TopicExpressionType * has binding name 'PointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionType (1643)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTowsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType (1642)
#endif

/* enum tt__PropertyOperation * has binding name 'PointerTott__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_PointerTott__PropertyOperation
#define SOAP_TYPE_PointerTott__PropertyOperation (1641)
#endif

/* tt__MessageExtension * has binding name 'PointerTott__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_PointerTott__MessageExtension
#define SOAP_TYPE_PointerTott__MessageExtension (1640)
#endif

/* tt__LocalOrientation * has binding name 'PointerTott__LocalOrientation' for type 'tt:LocalOrientation' */
#ifndef SOAP_TYPE_PointerTott__LocalOrientation
#define SOAP_TYPE_PointerTott__LocalOrientation (1639)
#endif

/* tt__LocalLocation * has binding name 'PointerTott__LocalLocation' for type 'tt:LocalLocation' */
#ifndef SOAP_TYPE_PointerTott__LocalLocation
#define SOAP_TYPE_PointerTott__LocalLocation (1638)
#endif

/* tt__GeoOrientation * has binding name 'PointerTott__GeoOrientation' for type 'tt:GeoOrientation' */
#ifndef SOAP_TYPE_PointerTott__GeoOrientation
#define SOAP_TYPE_PointerTott__GeoOrientation (1637)
#endif

/* tt__GeoLocation * has binding name 'PointerTott__GeoLocation' for type 'tt:GeoLocation' */
#ifndef SOAP_TYPE_PointerTott__GeoLocation
#define SOAP_TYPE_PointerTott__GeoLocation (1636)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (1635)
#endif

/* enum tt__MoveStatus * has binding name 'PointerTott__MoveStatus' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_PointerTott__MoveStatus
#define SOAP_TYPE_PointerTott__MoveStatus (1633)
#endif

/* tt__PTZMoveStatus * has binding name 'PointerTott__PTZMoveStatus' for type 'tt:PTZMoveStatus' */
#ifndef SOAP_TYPE_PointerTott__PTZMoveStatus
#define SOAP_TYPE_PointerTott__PTZMoveStatus (1632)
#endif

/* tt__OSDConfigurationOptionsExtension * has binding name 'PointerTott__OSDConfigurationOptionsExtension' for type 'tt:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__OSDConfigurationOptionsExtension (1631)
#endif

/* tt__OSDImgOptions * has binding name 'PointerTott__OSDImgOptions' for type 'tt:OSDImgOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDImgOptions
#define SOAP_TYPE_PointerTott__OSDImgOptions (1630)
#endif

/* tt__OSDTextOptions * has binding name 'PointerTott__OSDTextOptions' for type 'tt:OSDTextOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDTextOptions
#define SOAP_TYPE_PointerTott__OSDTextOptions (1629)
#endif

/* tt__MaximumNumberOfOSDs * has binding name 'PointerTott__MaximumNumberOfOSDs' for type 'tt:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_PointerTott__MaximumNumberOfOSDs
#define SOAP_TYPE_PointerTott__MaximumNumberOfOSDs (1627)
#endif

/* tt__OSDImgOptionsExtension * has binding name 'PointerTott__OSDImgOptionsExtension' for type 'tt:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDImgOptionsExtension
#define SOAP_TYPE_PointerTott__OSDImgOptionsExtension (1626)
#endif

/* tt__OSDTextOptionsExtension * has binding name 'PointerTott__OSDTextOptionsExtension' for type 'tt:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDTextOptionsExtension
#define SOAP_TYPE_PointerTott__OSDTextOptionsExtension (1625)
#endif

/* tt__OSDColorOptions * has binding name 'PointerTott__OSDColorOptions' for type 'tt:OSDColorOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDColorOptions
#define SOAP_TYPE_PointerTott__OSDColorOptions (1624)
#endif

/* tt__OSDColorOptionsExtension * has binding name 'PointerTott__OSDColorOptionsExtension' for type 'tt:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDColorOptionsExtension
#define SOAP_TYPE_PointerTott__OSDColorOptionsExtension (1623)
#endif

/* tt__ColorOptions * has binding name 'PointerTott__ColorOptions' for type 'tt:ColorOptions' */
#ifndef SOAP_TYPE_PointerTott__ColorOptions
#define SOAP_TYPE_PointerTott__ColorOptions (1622)
#endif

/* std::vector<tt__ColorspaceRange *> * has binding name 'PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange (1620)
#endif

/* tt__ColorspaceRange * has binding name 'PointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTott__ColorspaceRange
#define SOAP_TYPE_PointerTott__ColorspaceRange (1618)
#endif

/* std::vector<tt__Color *> * has binding name 'PointerTostd__vectorTemplateOfPointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__Color
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__Color (1617)
#endif

/* tt__OSDImgConfigurationExtension * has binding name 'PointerTott__OSDImgConfigurationExtension' for type 'tt:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDImgConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDImgConfigurationExtension (1615)
#endif

/* tt__OSDTextConfigurationExtension * has binding name 'PointerTott__OSDTextConfigurationExtension' for type 'tt:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDTextConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDTextConfigurationExtension (1614)
#endif

/* tt__OSDColor * has binding name 'PointerTott__OSDColor' for type 'tt:OSDColor' */
#ifndef SOAP_TYPE_PointerTott__OSDColor
#define SOAP_TYPE_PointerTott__OSDColor (1613)
#endif

/* tt__Color * has binding name 'PointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_PointerTott__Color
#define SOAP_TYPE_PointerTott__Color (1612)
#endif

/* tt__OSDPosConfigurationExtension * has binding name 'PointerTott__OSDPosConfigurationExtension' for type 'tt:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDPosConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDPosConfigurationExtension (1611)
#endif

/* tt__LayoutExtension * has binding name 'PointerTott__LayoutExtension' for type 'tt:LayoutExtension' */
#ifndef SOAP_TYPE_PointerTott__LayoutExtension
#define SOAP_TYPE_PointerTott__LayoutExtension (1610)
#endif

/* tt__PaneLayout * has binding name 'PointerTott__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_PointerTott__PaneLayout
#define SOAP_TYPE_PointerTott__PaneLayout (1608)
#endif

/* tt__ItemList * has binding name 'PointerTott__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_PointerTott__ItemList
#define SOAP_TYPE_PointerTott__ItemList (1607)
#endif

/* tt__RuleEngineConfigurationExtension * has binding name 'PointerTott__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension (1606)
#endif

/* tt__AnalyticsEngineConfigurationExtension * has binding name 'PointerTott__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension (1605)
#endif

/* tt__Config * has binding name 'PointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_PointerTott__Config
#define SOAP_TYPE_PointerTott__Config (1603)
#endif

/* tt__Vector * has binding name 'PointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_PointerTott__Vector
#define SOAP_TYPE_PointerTott__Vector (1601)
#endif

/* tt__ItemListExtension * has binding name 'PointerTott__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_PointerTott__ItemListExtension
#define SOAP_TYPE_PointerTott__ItemListExtension (1600)
#endif

/* tt__FocusOptions20Extension * has binding name 'PointerTott__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20Extension
#define SOAP_TYPE_PointerTott__FocusOptions20Extension (1595)
#endif

/* tt__WhiteBalanceOptions20Extension * has binding name 'PointerTott__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension (1593)
#endif

/* tt__FocusConfiguration20Extension * has binding name 'PointerTott__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20Extension
#define SOAP_TYPE_PointerTott__FocusConfiguration20Extension (1591)
#endif

/* tt__WhiteBalance20Extension * has binding name 'PointerTott__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20Extension
#define SOAP_TYPE_PointerTott__WhiteBalance20Extension (1590)
#endif

/* tt__ContinuousFocusOptions * has binding name 'PointerTott__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocusOptions
#define SOAP_TYPE_PointerTott__ContinuousFocusOptions (1589)
#endif

/* tt__RelativeFocusOptions20 * has binding name 'PointerTott__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocusOptions20
#define SOAP_TYPE_PointerTott__RelativeFocusOptions20 (1588)
#endif

/* tt__AbsoluteFocusOptions * has binding name 'PointerTott__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocusOptions
#define SOAP_TYPE_PointerTott__AbsoluteFocusOptions (1587)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension (1582)
#endif

/* tt__ImageStabilizationOptionsExtension * has binding name 'PointerTott__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension (1581)
#endif

/* tt__ImagingOptions20Extension4 * has binding name 'PointerTott__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension4
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension4 (1579)
#endif

/* tt__NoiseReductionOptions * has binding name 'PointerTott__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_PointerTott__NoiseReductionOptions
#define SOAP_TYPE_PointerTott__NoiseReductionOptions (1578)
#endif

/* tt__DefoggingOptions * has binding name 'PointerTott__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_PointerTott__DefoggingOptions
#define SOAP_TYPE_PointerTott__DefoggingOptions (1577)
#endif

/* tt__ToneCompensationOptions * has binding name 'PointerTott__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationOptions
#define SOAP_TYPE_PointerTott__ToneCompensationOptions (1576)
#endif

/* tt__ImagingOptions20Extension3 * has binding name 'PointerTott__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension3
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension3 (1575)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions (1574)
#endif

/* tt__ImagingOptions20Extension2 * has binding name 'PointerTott__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension2
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension2 (1573)
#endif

/* tt__ImageStabilizationOptions * has binding name 'PointerTott__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptions
#define SOAP_TYPE_PointerTott__ImageStabilizationOptions (1572)
#endif

/* tt__ImagingOptions20Extension * has binding name 'PointerTott__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension (1571)
#endif

/* tt__WhiteBalanceOptions20 * has binding name 'PointerTott__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20 (1570)
#endif

/* tt__WideDynamicRangeOptions20 * has binding name 'PointerTott__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRangeOptions20
#define SOAP_TYPE_PointerTott__WideDynamicRangeOptions20 (1569)
#endif

/* tt__FocusOptions20 * has binding name 'PointerTott__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20
#define SOAP_TYPE_PointerTott__FocusOptions20 (1567)
#endif

/* tt__ExposureOptions20 * has binding name 'PointerTott__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_PointerTott__ExposureOptions20
#define SOAP_TYPE_PointerTott__ExposureOptions20 (1566)
#endif

/* tt__BacklightCompensationOptions20 * has binding name 'PointerTott__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensationOptions20
#define SOAP_TYPE_PointerTott__BacklightCompensationOptions20 (1565)
#endif

/* tt__DefoggingExtension * has binding name 'PointerTott__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_PointerTott__DefoggingExtension
#define SOAP_TYPE_PointerTott__DefoggingExtension (1564)
#endif

/* tt__ToneCompensationExtension * has binding name 'PointerTott__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationExtension
#define SOAP_TYPE_PointerTott__ToneCompensationExtension (1563)
#endif

/* enum tt__ExposurePriority * has binding name 'PointerTott__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_PointerTott__ExposurePriority
#define SOAP_TYPE_PointerTott__ExposurePriority (1562)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension (1561)
#endif

/* tt__ImageStabilizationExtension * has binding name 'PointerTott__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationExtension (1560)
#endif

/* tt__ImagingSettingsExtension204 * has binding name 'PointerTott__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension204
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension204 (1559)
#endif

/* tt__NoiseReduction * has binding name 'PointerTott__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_PointerTott__NoiseReduction
#define SOAP_TYPE_PointerTott__NoiseReduction (1558)
#endif

/* tt__Defogging * has binding name 'PointerTott__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_PointerTott__Defogging
#define SOAP_TYPE_PointerTott__Defogging (1557)
#endif

/* tt__ToneCompensation * has binding name 'PointerTott__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensation
#define SOAP_TYPE_PointerTott__ToneCompensation (1556)
#endif

/* tt__ImagingSettingsExtension203 * has binding name 'PointerTott__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension203
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension203 (1555)
#endif

/* tt__IrCutFilterAutoAdjustment * has binding name 'PointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment (1553)
#endif

/* tt__ImagingSettingsExtension202 * has binding name 'PointerTott__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension202
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension202 (1552)
#endif

/* tt__ImageStabilization * has binding name 'PointerTott__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilization
#define SOAP_TYPE_PointerTott__ImageStabilization (1551)
#endif

/* tt__ImagingSettingsExtension20 * has binding name 'PointerTott__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension20
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension20 (1550)
#endif

/* tt__WhiteBalance20 * has binding name 'PointerTott__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20
#define SOAP_TYPE_PointerTott__WhiteBalance20 (1549)
#endif

/* tt__WideDynamicRange20 * has binding name 'PointerTott__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRange20
#define SOAP_TYPE_PointerTott__WideDynamicRange20 (1548)
#endif

/* tt__FocusConfiguration20 * has binding name 'PointerTott__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20
#define SOAP_TYPE_PointerTott__FocusConfiguration20 (1547)
#endif

/* tt__Exposure20 * has binding name 'PointerTott__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_PointerTott__Exposure20
#define SOAP_TYPE_PointerTott__Exposure20 (1546)
#endif

/* tt__BacklightCompensation20 * has binding name 'PointerTott__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensation20
#define SOAP_TYPE_PointerTott__BacklightCompensation20 (1545)
#endif

/* tt__FocusStatus20Extension * has binding name 'PointerTott__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20Extension
#define SOAP_TYPE_PointerTott__FocusStatus20Extension (1544)
#endif

/* tt__ImagingStatus20Extension * has binding name 'PointerTott__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingStatus20Extension
#define SOAP_TYPE_PointerTott__ImagingStatus20Extension (1543)
#endif

/* tt__FocusStatus20 * has binding name 'PointerTott__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20
#define SOAP_TYPE_PointerTott__FocusStatus20 (1542)
#endif

/* tt__ContinuousFocus * has binding name 'PointerTott__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocus
#define SOAP_TYPE_PointerTott__ContinuousFocus (1541)
#endif

/* tt__RelativeFocus * has binding name 'PointerTott__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocus
#define SOAP_TYPE_PointerTott__RelativeFocus (1540)
#endif

/* tt__AbsoluteFocus * has binding name 'PointerTott__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocus
#define SOAP_TYPE_PointerTott__AbsoluteFocus (1539)
#endif

/* tt__Rectangle * has binding name 'PointerTott__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_PointerTott__Rectangle
#define SOAP_TYPE_PointerTott__Rectangle (1538)
#endif

/* tt__ImagingSettingsExtension * has binding name 'PointerTott__ImagingSettingsExtension' for type 'tt:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension (1537)
#endif

/* tt__WhiteBalance * has binding name 'PointerTott__WhiteBalance' for type 'tt:WhiteBalance' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance
#define SOAP_TYPE_PointerTott__WhiteBalance (1536)
#endif

/* tt__WideDynamicRange * has binding name 'PointerTott__WideDynamicRange' for type 'tt:WideDynamicRange' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRange
#define SOAP_TYPE_PointerTott__WideDynamicRange (1535)
#endif

/* enum tt__IrCutFilterMode * has binding name 'PointerTott__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterMode
#define SOAP_TYPE_PointerTott__IrCutFilterMode (1534)
#endif

/* tt__FocusConfiguration * has binding name 'PointerTott__FocusConfiguration' for type 'tt:FocusConfiguration' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration
#define SOAP_TYPE_PointerTott__FocusConfiguration (1533)
#endif

/* tt__Exposure * has binding name 'PointerTott__Exposure' for type 'tt:Exposure' */
#ifndef SOAP_TYPE_PointerTott__Exposure
#define SOAP_TYPE_PointerTott__Exposure (1532)
#endif

/* tt__BacklightCompensation * has binding name 'PointerTott__BacklightCompensation' for type 'tt:BacklightCompensation' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensation
#define SOAP_TYPE_PointerTott__BacklightCompensation (1531)
#endif

/* tt__PTZPresetTourStartingConditionOptionsExtension * has binding name 'PointerTott__PTZPresetTourStartingConditionOptionsExtension' for type 'tt:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension (1530)
#endif

/* tt__PTZPresetTourPresetDetailOptionsExtension * has binding name 'PointerTott__PTZPresetTourPresetDetailOptionsExtension' for type 'tt:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension (1528)
#endif

/* tt__PTZPresetTourPresetDetailOptions * has binding name 'PointerTott__PTZPresetTourPresetDetailOptions' for type 'tt:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions (1527)
#endif

/* tt__PTZPresetTourSpotOptions * has binding name 'PointerTott__PTZPresetTourSpotOptions' for type 'tt:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions (1526)
#endif

/* tt__PTZPresetTourStartingConditionOptions * has binding name 'PointerTott__PTZPresetTourStartingConditionOptions' for type 'tt:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions (1525)
#endif

/* tt__PTZPresetTourStartingConditionExtension * has binding name 'PointerTott__PTZPresetTourStartingConditionExtension' for type 'tt:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension (1524)
#endif

/* enum tt__PTZPresetTourDirection * has binding name 'PointerTott__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourDirection
#define SOAP_TYPE_PointerTott__PTZPresetTourDirection (1523)
#endif

/* tt__PTZPresetTourStatusExtension * has binding name 'PointerTott__PTZPresetTourStatusExtension' for type 'tt:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension (1522)
#endif

/* tt__PTZPresetTourTypeExtension * has binding name 'PointerTott__PTZPresetTourTypeExtension' for type 'tt:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension (1520)
#endif

/* tt__PTZPresetTourSpotExtension * has binding name 'PointerTott__PTZPresetTourSpotExtension' for type 'tt:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension (1519)
#endif

/* tt__PTZSpeed * has binding name 'PointerTott__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_PointerTott__PTZSpeed
#define SOAP_TYPE_PointerTott__PTZSpeed (1518)
#endif

/* tt__PTZPresetTourPresetDetail * has binding name 'PointerTott__PTZPresetTourPresetDetail' for type 'tt:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail (1517)
#endif

/* tt__PTZPresetTourExtension * has binding name 'PointerTott__PTZPresetTourExtension' for type 'tt:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourExtension (1516)
#endif

/* tt__PTZPresetTourSpot * has binding name 'PointerTott__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpot
#define SOAP_TYPE_PointerTott__PTZPresetTourSpot (1514)
#endif

/* tt__PTZPresetTourStartingCondition * has binding name 'PointerTott__PTZPresetTourStartingCondition' for type 'tt:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition (1513)
#endif

/* tt__PTZPresetTourStatus * has binding name 'PointerTott__PTZPresetTourStatus' for type 'tt:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStatus
#define SOAP_TYPE_PointerTott__PTZPresetTourStatus (1512)
#endif

/* tt__PTZVector * has binding name 'PointerTott__PTZVector' for type 'tt:PTZVector' */
#ifndef SOAP_TYPE_PointerTott__PTZVector
#define SOAP_TYPE_PointerTott__PTZVector (1511)
#endif

/* std::string * has binding name 'PointerTott__Name' for type 'tt:Name' */
#ifndef SOAP_TYPE_PointerTott__Name
#define SOAP_TYPE_PointerTott__Name (1510)
#endif

/* tt__Vector1D * has binding name 'PointerTott__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_PointerTott__Vector1D
#define SOAP_TYPE_PointerTott__Vector1D (1509)
#endif

/* tt__Vector2D * has binding name 'PointerTott__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_PointerTott__Vector2D
#define SOAP_TYPE_PointerTott__Vector2D (1508)
#endif

/* tt__FloatRange * has binding name 'PointerTott__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_PointerTott__FloatRange
#define SOAP_TYPE_PointerTott__FloatRange (1507)
#endif

/* tt__PTZSpacesExtension * has binding name 'PointerTott__PTZSpacesExtension' for type 'tt:PTZSpacesExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZSpacesExtension
#define SOAP_TYPE_PointerTott__PTZSpacesExtension (1506)
#endif

/* tt__Space1DDescription * has binding name 'PointerTott__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space1DDescription
#define SOAP_TYPE_PointerTott__Space1DDescription (1503)
#endif

/* tt__Space2DDescription * has binding name 'PointerTott__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space2DDescription
#define SOAP_TYPE_PointerTott__Space2DDescription (1502)
#endif

/* tt__ReverseOptionsExtension * has binding name 'PointerTott__ReverseOptionsExtension' for type 'tt:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__ReverseOptionsExtension
#define SOAP_TYPE_PointerTott__ReverseOptionsExtension (1501)
#endif

/* tt__EFlipOptionsExtension * has binding name 'PointerTott__EFlipOptionsExtension' for type 'tt:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__EFlipOptionsExtension
#define SOAP_TYPE_PointerTott__EFlipOptionsExtension (1499)
#endif

/* tt__PTControlDirectionOptionsExtension * has binding name 'PointerTott__PTControlDirectionOptionsExtension' for type 'tt:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension
#define SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension (1497)
#endif

/* tt__ReverseOptions * has binding name 'PointerTott__ReverseOptions' for type 'tt:ReverseOptions' */
#ifndef SOAP_TYPE_PointerTott__ReverseOptions
#define SOAP_TYPE_PointerTott__ReverseOptions (1496)
#endif

/* tt__EFlipOptions * has binding name 'PointerTott__EFlipOptions' for type 'tt:EFlipOptions' */
#ifndef SOAP_TYPE_PointerTott__EFlipOptions
#define SOAP_TYPE_PointerTott__EFlipOptions (1495)
#endif

/* std::string * has binding name 'PointerTott__IntAttrList' for type 'tt:IntAttrList' */
#ifndef SOAP_TYPE_PointerTott__IntAttrList
#define SOAP_TYPE_PointerTott__IntAttrList (1494)
#endif

/* tt__PTZConfigurationOptions2 * has binding name 'PointerTott__PTZConfigurationOptions2' for type 'tt:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationOptions2
#define SOAP_TYPE_PointerTott__PTZConfigurationOptions2 (1493)
#endif

/* tt__PTControlDirectionOptions * has binding name 'PointerTott__PTControlDirectionOptions' for type 'tt:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionOptions
#define SOAP_TYPE_PointerTott__PTControlDirectionOptions (1492)
#endif

/* tt__DurationRange * has binding name 'PointerTott__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_PointerTott__DurationRange
#define SOAP_TYPE_PointerTott__DurationRange (1491)
#endif

/* tt__PTZSpaces * has binding name 'PointerTott__PTZSpaces' for type 'tt:PTZSpaces' */
#ifndef SOAP_TYPE_PointerTott__PTZSpaces
#define SOAP_TYPE_PointerTott__PTZSpaces (1490)
#endif

/* tt__PTControlDirectionExtension * has binding name 'PointerTott__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionExtension
#define SOAP_TYPE_PointerTott__PTControlDirectionExtension (1489)
#endif

/* tt__Reverse * has binding name 'PointerTott__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_PointerTott__Reverse
#define SOAP_TYPE_PointerTott__Reverse (1488)
#endif

/* tt__EFlip * has binding name 'PointerTott__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_PointerTott__EFlip
#define SOAP_TYPE_PointerTott__EFlip (1487)
#endif

/* tt__PTZConfigurationExtension2 * has binding name 'PointerTott__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension2
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension2 (1486)
#endif

/* tt__PTControlDirection * has binding name 'PointerTott__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirection
#define SOAP_TYPE_PointerTott__PTControlDirection (1485)
#endif

/* tt__PTZPresetTourSupportedExtension * has binding name 'PointerTott__PTZPresetTourSupportedExtension' for type 'tt:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension (1484)
#endif

/* tt__PTZNodeExtension2 * has binding name 'PointerTott__PTZNodeExtension2' for type 'tt:PTZNodeExtension2' */
#ifndef SOAP_TYPE_PointerTott__PTZNodeExtension2
#define SOAP_TYPE_PointerTott__PTZNodeExtension2 (1482)
#endif

/* tt__PTZPresetTourSupported * has binding name 'PointerTott__PTZPresetTourSupported' for type 'tt:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSupported
#define SOAP_TYPE_PointerTott__PTZPresetTourSupported (1481)
#endif

/* tt__EapMethodExtension * has binding name 'PointerTott__EapMethodExtension' for type 'tt:EapMethodExtension' */
#ifndef SOAP_TYPE_PointerTott__EapMethodExtension
#define SOAP_TYPE_PointerTott__EapMethodExtension (1480)
#endif

/* tt__TLSConfiguration * has binding name 'PointerTott__TLSConfiguration' for type 'tt:TLSConfiguration' */
#ifndef SOAP_TYPE_PointerTott__TLSConfiguration
#define SOAP_TYPE_PointerTott__TLSConfiguration (1479)
#endif

/* tt__Dot1XConfigurationExtension * has binding name 'PointerTott__Dot1XConfigurationExtension' for type 'tt:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot1XConfigurationExtension
#define SOAP_TYPE_PointerTott__Dot1XConfigurationExtension (1478)
#endif

/* tt__EAPMethodConfiguration * has binding name 'PointerTott__EAPMethodConfiguration' for type 'tt:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_PointerTott__EAPMethodConfiguration
#define SOAP_TYPE_PointerTott__EAPMethodConfiguration (1477)
#endif

/* tt__CertificateInformationExtension * has binding name 'PointerTott__CertificateInformationExtension' for type 'tt:CertificateInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__CertificateInformationExtension
#define SOAP_TYPE_PointerTott__CertificateInformationExtension (1476)
#endif

/* tt__DateTimeRange * has binding name 'PointerTott__DateTimeRange' for type 'tt:DateTimeRange' */
#ifndef SOAP_TYPE_PointerTott__DateTimeRange
#define SOAP_TYPE_PointerTott__DateTimeRange (1475)
#endif

/* tt__CertificateUsage * has binding name 'PointerTott__CertificateUsage' for type 'tt:CertificateUsage' */
#ifndef SOAP_TYPE_PointerTott__CertificateUsage
#define SOAP_TYPE_PointerTott__CertificateUsage (1474)
#endif

/* tt__UserExtension * has binding name 'PointerTott__UserExtension' for type 'tt:UserExtension' */
#ifndef SOAP_TYPE_PointerTott__UserExtension
#define SOAP_TYPE_PointerTott__UserExtension (1473)
#endif

/* tt__Date * has binding name 'PointerTott__Date' for type 'tt:Date' */
#ifndef SOAP_TYPE_PointerTott__Date
#define SOAP_TYPE_PointerTott__Date (1472)
#endif

/* tt__Time * has binding name 'PointerTott__Time' for type 'tt:Time' */
#ifndef SOAP_TYPE_PointerTott__Time
#define SOAP_TYPE_PointerTott__Time (1471)
#endif

/* tt__SystemDateTimeExtension * has binding name 'PointerTott__SystemDateTimeExtension' for type 'tt:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_PointerTott__SystemDateTimeExtension
#define SOAP_TYPE_PointerTott__SystemDateTimeExtension (1470)
#endif

/* tt__SystemLogUri * has binding name 'PointerTott__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_PointerTott__SystemLogUri
#define SOAP_TYPE_PointerTott__SystemLogUri (1468)
#endif

/* tt__AnalyticsDeviceExtension * has binding name 'PointerTott__AnalyticsDeviceExtension' for type 'tt:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceExtension
#define SOAP_TYPE_PointerTott__AnalyticsDeviceExtension (1467)
#endif

/* tt__SystemCapabilitiesExtension2 * has binding name 'PointerTott__SystemCapabilitiesExtension2' for type 'tt:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2 (1466)
#endif

/* tt__SystemCapabilitiesExtension * has binding name 'PointerTott__SystemCapabilitiesExtension' for type 'tt:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilitiesExtension
#define SOAP_TYPE_PointerTott__SystemCapabilitiesExtension (1465)
#endif

/* tt__SecurityCapabilitiesExtension2 * has binding name 'PointerTott__SecurityCapabilitiesExtension2' for type 'tt:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2 (1463)
#endif

/* tt__SecurityCapabilitiesExtension * has binding name 'PointerTott__SecurityCapabilitiesExtension' for type 'tt:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension
#define SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension (1462)
#endif

/* tt__NetworkCapabilitiesExtension2 * has binding name 'PointerTott__NetworkCapabilitiesExtension2' for type 'tt:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2 (1461)
#endif

/* tt__NetworkCapabilitiesExtension * has binding name 'PointerTott__NetworkCapabilitiesExtension' for type 'tt:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension
#define SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension (1460)
#endif

/* tt__RealTimeStreamingCapabilitiesExtension * has binding name 'PointerTott__RealTimeStreamingCapabilitiesExtension' for type 'tt:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension (1459)
#endif

/* tt__ProfileCapabilities * has binding name 'PointerTott__ProfileCapabilities' for type 'tt:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ProfileCapabilities
#define SOAP_TYPE_PointerTott__ProfileCapabilities (1458)
#endif

/* tt__MediaCapabilitiesExtension * has binding name 'PointerTott__MediaCapabilitiesExtension' for type 'tt:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__MediaCapabilitiesExtension
#define SOAP_TYPE_PointerTott__MediaCapabilitiesExtension (1457)
#endif

/* tt__RealTimeStreamingCapabilities * has binding name 'PointerTott__RealTimeStreamingCapabilities' for type 'tt:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities
#define SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities (1456)
#endif

/* tt__IOCapabilitiesExtension2 * has binding name 'PointerTott__IOCapabilitiesExtension2' for type 'tt:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__IOCapabilitiesExtension2 (1455)
#endif

/* tt__IOCapabilitiesExtension * has binding name 'PointerTott__IOCapabilitiesExtension' for type 'tt:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilitiesExtension
#define SOAP_TYPE_PointerTott__IOCapabilitiesExtension (1453)
#endif

/* tt__DeviceCapabilitiesExtension * has binding name 'PointerTott__DeviceCapabilitiesExtension' for type 'tt:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension
#define SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension (1452)
#endif

/* tt__SecurityCapabilities * has binding name 'PointerTott__SecurityCapabilities' for type 'tt:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilities
#define SOAP_TYPE_PointerTott__SecurityCapabilities (1451)
#endif

/* tt__IOCapabilities * has binding name 'PointerTott__IOCapabilities' for type 'tt:IOCapabilities' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilities
#define SOAP_TYPE_PointerTott__IOCapabilities (1450)
#endif

/* tt__SystemCapabilities * has binding name 'PointerTott__SystemCapabilities' for type 'tt:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilities
#define SOAP_TYPE_PointerTott__SystemCapabilities (1449)
#endif

/* tt__NetworkCapabilities * has binding name 'PointerTott__NetworkCapabilities' for type 'tt:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilities
#define SOAP_TYPE_PointerTott__NetworkCapabilities (1448)
#endif

/* tt__CapabilitiesExtension2 * has binding name 'PointerTott__CapabilitiesExtension2' for type 'tt:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__CapabilitiesExtension2
#define SOAP_TYPE_PointerTott__CapabilitiesExtension2 (1447)
#endif

/* tt__AnalyticsDeviceCapabilities * has binding name 'PointerTott__AnalyticsDeviceCapabilities' for type 'tt:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities
#define SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities (1446)
#endif

/* tt__ReceiverCapabilities * has binding name 'PointerTott__ReceiverCapabilities' for type 'tt:ReceiverCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ReceiverCapabilities
#define SOAP_TYPE_PointerTott__ReceiverCapabilities (1445)
#endif

/* tt__ReplayCapabilities * has binding name 'PointerTott__ReplayCapabilities' for type 'tt:ReplayCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ReplayCapabilities
#define SOAP_TYPE_PointerTott__ReplayCapabilities (1444)
#endif

/* tt__SearchCapabilities * has binding name 'PointerTott__SearchCapabilities' for type 'tt:SearchCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SearchCapabilities
#define SOAP_TYPE_PointerTott__SearchCapabilities (1443)
#endif

/* tt__RecordingCapabilities * has binding name 'PointerTott__RecordingCapabilities' for type 'tt:RecordingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__RecordingCapabilities
#define SOAP_TYPE_PointerTott__RecordingCapabilities (1442)
#endif

/* tt__DisplayCapabilities * has binding name 'PointerTott__DisplayCapabilities' for type 'tt:DisplayCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DisplayCapabilities
#define SOAP_TYPE_PointerTott__DisplayCapabilities (1441)
#endif

/* tt__DeviceIOCapabilities * has binding name 'PointerTott__DeviceIOCapabilities' for type 'tt:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DeviceIOCapabilities
#define SOAP_TYPE_PointerTott__DeviceIOCapabilities (1440)
#endif

/* tt__CapabilitiesExtension * has binding name 'PointerTott__CapabilitiesExtension' for type 'tt:CapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__CapabilitiesExtension
#define SOAP_TYPE_PointerTott__CapabilitiesExtension (1439)
#endif

/* tt__PTZCapabilities * has binding name 'PointerTott__PTZCapabilities' for type 'tt:PTZCapabilities' */
#ifndef SOAP_TYPE_PointerTott__PTZCapabilities
#define SOAP_TYPE_PointerTott__PTZCapabilities (1438)
#endif

/* tt__MediaCapabilities * has binding name 'PointerTott__MediaCapabilities' for type 'tt:MediaCapabilities' */
#ifndef SOAP_TYPE_PointerTott__MediaCapabilities
#define SOAP_TYPE_PointerTott__MediaCapabilities (1437)
#endif

/* tt__ImagingCapabilities * has binding name 'PointerTott__ImagingCapabilities' for type 'tt:ImagingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ImagingCapabilities
#define SOAP_TYPE_PointerTott__ImagingCapabilities (1436)
#endif

/* tt__EventCapabilities * has binding name 'PointerTott__EventCapabilities' for type 'tt:EventCapabilities' */
#ifndef SOAP_TYPE_PointerTott__EventCapabilities
#define SOAP_TYPE_PointerTott__EventCapabilities (1435)
#endif

/* tt__DeviceCapabilities * has binding name 'PointerTott__DeviceCapabilities' for type 'tt:DeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DeviceCapabilities
#define SOAP_TYPE_PointerTott__DeviceCapabilities (1434)
#endif

/* tt__AnalyticsCapabilities * has binding name 'PointerTott__AnalyticsCapabilities' for type 'tt:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsCapabilities
#define SOAP_TYPE_PointerTott__AnalyticsCapabilities (1433)
#endif

/* tt__Dot11AvailableNetworksExtension * has binding name 'PointerTott__Dot11AvailableNetworksExtension' for type 'tt:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension
#define SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension (1432)
#endif

/* enum tt__Dot11SignalStrength * has binding name 'PointerTott__Dot11SignalStrength' for type 'tt:Dot11SignalStrength' */
#ifndef SOAP_TYPE_PointerTott__Dot11SignalStrength
#define SOAP_TYPE_PointerTott__Dot11SignalStrength (1429)
#endif

/* tt__Dot11PSKSetExtension * has binding name 'PointerTott__Dot11PSKSetExtension' for type 'tt:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKSetExtension
#define SOAP_TYPE_PointerTott__Dot11PSKSetExtension (1428)
#endif

/* std::string * has binding name 'PointerTott__Dot11PSKPassphrase' for type 'tt:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKPassphrase
#define SOAP_TYPE_PointerTott__Dot11PSKPassphrase (1427)
#endif

/* xsd__hexBinary * has binding name 'PointerTott__Dot11PSK' for type 'tt:Dot11PSK' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSK
#define SOAP_TYPE_PointerTott__Dot11PSK (1426)
#endif

/* tt__Dot11SecurityConfigurationExtension * has binding name 'PointerTott__Dot11SecurityConfigurationExtension' for type 'tt:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension (1425)
#endif

/* std::string * has binding name 'PointerTott__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_PointerTott__ReferenceToken
#define SOAP_TYPE_PointerTott__ReferenceToken (1424)
#endif

/* tt__Dot11PSKSet * has binding name 'PointerTott__Dot11PSKSet' for type 'tt:Dot11PSKSet' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKSet
#define SOAP_TYPE_PointerTott__Dot11PSKSet (1423)
#endif

/* enum tt__Dot11Cipher * has binding name 'PointerTott__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_PointerTott__Dot11Cipher
#define SOAP_TYPE_PointerTott__Dot11Cipher (1422)
#endif

/* tt__Dot11SecurityConfiguration * has binding name 'PointerTott__Dot11SecurityConfiguration' for type 'tt:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_PointerTott__Dot11SecurityConfiguration
#define SOAP_TYPE_PointerTott__Dot11SecurityConfiguration (1421)
#endif

/* tt__IPAddressFilterExtension * has binding name 'PointerTott__IPAddressFilterExtension' for type 'tt:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_PointerTott__IPAddressFilterExtension
#define SOAP_TYPE_PointerTott__IPAddressFilterExtension (1420)
#endif

/* tt__NetworkZeroConfigurationExtension2 * has binding name 'PointerTott__NetworkZeroConfigurationExtension2' for type 'tt:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2 (1419)
#endif

/* tt__NetworkZeroConfigurationExtension * has binding name 'PointerTott__NetworkZeroConfigurationExtension' for type 'tt:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension
#define SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension (1417)
#endif

/* enum tt__IPv6DHCPConfiguration * has binding name 'PointerTott__IPv6DHCPConfiguration' for type 'tt:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv6DHCPConfiguration
#define SOAP_TYPE_PointerTott__IPv6DHCPConfiguration (1416)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension2 * has binding name 'PointerTott__NetworkInterfaceSetConfigurationExtension2' for type 'tt:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2 (1415)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension * has binding name 'PointerTott__NetworkInterfaceSetConfigurationExtension' for type 'tt:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension (1414)
#endif

/* tt__IPv6NetworkInterfaceSetConfiguration * has binding name 'PointerTott__IPv6NetworkInterfaceSetConfiguration' for type 'tt:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration (1413)
#endif

/* tt__IPv4NetworkInterfaceSetConfiguration * has binding name 'PointerTott__IPv4NetworkInterfaceSetConfiguration' for type 'tt:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration (1412)
#endif

/* tt__DynamicDNSInformationExtension * has binding name 'PointerTott__DynamicDNSInformationExtension' for type 'tt:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__DynamicDNSInformationExtension
#define SOAP_TYPE_PointerTott__DynamicDNSInformationExtension (1411)
#endif

/* tt__NTPInformationExtension * has binding name 'PointerTott__NTPInformationExtension' for type 'tt:NTPInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__NTPInformationExtension
#define SOAP_TYPE_PointerTott__NTPInformationExtension (1410)
#endif

/* tt__DNSInformationExtension * has binding name 'PointerTott__DNSInformationExtension' for type 'tt:DNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__DNSInformationExtension
#define SOAP_TYPE_PointerTott__DNSInformationExtension (1409)
#endif

/* tt__HostnameInformationExtension * has binding name 'PointerTott__HostnameInformationExtension' for type 'tt:HostnameInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__HostnameInformationExtension
#define SOAP_TYPE_PointerTott__HostnameInformationExtension (1408)
#endif

/* tt__NetworkHostExtension * has binding name 'PointerTott__NetworkHostExtension' for type 'tt:NetworkHostExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkHostExtension
#define SOAP_TYPE_PointerTott__NetworkHostExtension (1407)
#endif

/* std::string * has binding name 'PointerTott__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_PointerTott__IPv6Address
#define SOAP_TYPE_PointerTott__IPv6Address (1406)
#endif

/* std::string * has binding name 'PointerTott__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_PointerTott__IPv4Address
#define SOAP_TYPE_PointerTott__IPv4Address (1405)
#endif

/* tt__NetworkProtocolExtension * has binding name 'PointerTott__NetworkProtocolExtension' for type 'tt:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkProtocolExtension
#define SOAP_TYPE_PointerTott__NetworkProtocolExtension (1404)
#endif

/* tt__IPv6ConfigurationExtension * has binding name 'PointerTott__IPv6ConfigurationExtension' for type 'tt:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__IPv6ConfigurationExtension
#define SOAP_TYPE_PointerTott__IPv6ConfigurationExtension (1403)
#endif

/* tt__PrefixedIPv6Address * has binding name 'PointerTott__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_PointerTott__PrefixedIPv6Address
#define SOAP_TYPE_PointerTott__PrefixedIPv6Address (1401)
#endif

/* tt__PrefixedIPv4Address * has binding name 'PointerTott__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_PointerTott__PrefixedIPv4Address
#define SOAP_TYPE_PointerTott__PrefixedIPv4Address (1399)
#endif

/* tt__IPv4Configuration * has binding name 'PointerTott__IPv4Configuration' for type 'tt:IPv4Configuration' */
#ifndef SOAP_TYPE_PointerTott__IPv4Configuration
#define SOAP_TYPE_PointerTott__IPv4Configuration (1398)
#endif

/* tt__IPv6Configuration * has binding name 'PointerTott__IPv6Configuration' for type 'tt:IPv6Configuration' */
#ifndef SOAP_TYPE_PointerTott__IPv6Configuration
#define SOAP_TYPE_PointerTott__IPv6Configuration (1397)
#endif

/* tt__NetworkInterfaceConnectionSetting * has binding name 'PointerTott__NetworkInterfaceConnectionSetting' for type 'tt:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting (1396)
#endif

/* tt__NetworkInterfaceExtension2 * has binding name 'PointerTott__NetworkInterfaceExtension2' for type 'tt:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceExtension2
#define SOAP_TYPE_PointerTott__NetworkInterfaceExtension2 (1395)
#endif

/* tt__Dot11Configuration * has binding name 'PointerTott__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_PointerTott__Dot11Configuration
#define SOAP_TYPE_PointerTott__Dot11Configuration (1393)
#endif

/* tt__Dot3Configuration * has binding name 'PointerTott__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_PointerTott__Dot3Configuration
#define SOAP_TYPE_PointerTott__Dot3Configuration (1391)
#endif

/* tt__Transport * has binding name 'PointerTott__Transport' for type 'tt:Transport' */
#ifndef SOAP_TYPE_PointerTott__Transport
#define SOAP_TYPE_PointerTott__Transport (1390)
#endif

/* tt__AudioDecoderConfigurationOptionsExtension * has binding name 'PointerTott__AudioDecoderConfigurationOptionsExtension' for type 'tt:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptionsExtension (1389)
#endif

/* tt__G726DecOptions * has binding name 'PointerTott__G726DecOptions' for type 'tt:G726DecOptions' */
#ifndef SOAP_TYPE_PointerTott__G726DecOptions
#define SOAP_TYPE_PointerTott__G726DecOptions (1388)
#endif

/* tt__G711DecOptions * has binding name 'PointerTott__G711DecOptions' for type 'tt:G711DecOptions' */
#ifndef SOAP_TYPE_PointerTott__G711DecOptions
#define SOAP_TYPE_PointerTott__G711DecOptions (1387)
#endif

/* tt__AACDecOptions * has binding name 'PointerTott__AACDecOptions' for type 'tt:AACDecOptions' */
#ifndef SOAP_TYPE_PointerTott__AACDecOptions
#define SOAP_TYPE_PointerTott__AACDecOptions (1386)
#endif

/* tt__PTZStatusFilterOptionsExtension * has binding name 'PointerTott__PTZStatusFilterOptionsExtension' for type 'tt:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_PointerTott__PTZStatusFilterOptionsExtension (1385)
#endif

/* tt__MetadataConfigurationOptionsExtension2 * has binding name 'PointerTott__MetadataConfigurationOptionsExtension2' for type 'tt:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension2 (1384)
#endif

/* tt__MetadataConfigurationOptionsExtension * has binding name 'PointerTott__MetadataConfigurationOptionsExtension' for type 'tt:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension (1383)
#endif

/* tt__PTZStatusFilterOptions * has binding name 'PointerTott__PTZStatusFilterOptions' for type 'tt:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZStatusFilterOptions
#define SOAP_TYPE_PointerTott__PTZStatusFilterOptions (1382)
#endif

/* _tt__EventSubscription_SubscriptionPolicy * has binding name 'PointerTo_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy (1381)
#endif

/* wsnt__FilterType * has binding name 'PointerTowsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_PointerTowsnt__FilterType
#define SOAP_TYPE_PointerTowsnt__FilterType (1379)
#endif

/* tt__AudioEncoderConfigurationOption * has binding name 'PointerTott__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption
#define SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption (1377)
#endif

/* tt__AudioSourceOptionsExtension * has binding name 'PointerTott__AudioSourceOptionsExtension' for type 'tt:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__AudioSourceOptionsExtension
#define SOAP_TYPE_PointerTott__AudioSourceOptionsExtension (1376)
#endif

/* tt__VideoResolution * has binding name 'PointerTott__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_PointerTott__VideoResolution
#define SOAP_TYPE_PointerTott__VideoResolution (1372)
#endif

/* tt__VideoEncoderOptionsExtension2 * has binding name 'PointerTott__VideoEncoderOptionsExtension2' for type 'tt:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2
#define SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2 (1371)
#endif

/* tt__H264Options2 * has binding name 'PointerTott__H264Options2' for type 'tt:H264Options2' */
#ifndef SOAP_TYPE_PointerTott__H264Options2
#define SOAP_TYPE_PointerTott__H264Options2 (1370)
#endif

/* tt__Mpeg4Options2 * has binding name 'PointerTott__Mpeg4Options2' for type 'tt:Mpeg4Options2' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Options2
#define SOAP_TYPE_PointerTott__Mpeg4Options2 (1369)
#endif

/* tt__JpegOptions2 * has binding name 'PointerTott__JpegOptions2' for type 'tt:JpegOptions2' */
#ifndef SOAP_TYPE_PointerTott__JpegOptions2
#define SOAP_TYPE_PointerTott__JpegOptions2 (1368)
#endif

/* tt__VideoEncoderOptionsExtension * has binding name 'PointerTott__VideoEncoderOptionsExtension' for type 'tt:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension
#define SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension (1367)
#endif

/* tt__H264Options * has binding name 'PointerTott__H264Options' for type 'tt:H264Options' */
#ifndef SOAP_TYPE_PointerTott__H264Options
#define SOAP_TYPE_PointerTott__H264Options (1366)
#endif

/* tt__Mpeg4Options * has binding name 'PointerTott__Mpeg4Options' for type 'tt:Mpeg4Options' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Options
#define SOAP_TYPE_PointerTott__Mpeg4Options (1365)
#endif

/* tt__JpegOptions * has binding name 'PointerTott__JpegOptions' for type 'tt:JpegOptions' */
#ifndef SOAP_TYPE_PointerTott__JpegOptions
#define SOAP_TYPE_PointerTott__JpegOptions (1364)
#endif

/* tt__RotateOptionsExtension * has binding name 'PointerTott__RotateOptionsExtension' for type 'tt:RotateOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__RotateOptionsExtension
#define SOAP_TYPE_PointerTott__RotateOptionsExtension (1363)
#endif

/* tt__IntList * has binding name 'PointerTott__IntList' for type 'tt:IntList' */
#ifndef SOAP_TYPE_PointerTott__IntList
#define SOAP_TYPE_PointerTott__IntList (1362)
#endif

/* tt__VideoSourceConfigurationOptionsExtension2 * has binding name 'PointerTott__VideoSourceConfigurationOptionsExtension2' for type 'tt:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension2 (1359)
#endif

/* tt__RotateOptions * has binding name 'PointerTott__RotateOptions' for type 'tt:RotateOptions' */
#ifndef SOAP_TYPE_PointerTott__RotateOptions
#define SOAP_TYPE_PointerTott__RotateOptions (1358)
#endif

/* tt__VideoSourceConfigurationOptionsExtension * has binding name 'PointerTott__VideoSourceConfigurationOptionsExtension' for type 'tt:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension (1357)
#endif

/* tt__IntRectangleRange * has binding name 'PointerTott__IntRectangleRange' for type 'tt:IntRectangleRange' */
#ifndef SOAP_TYPE_PointerTott__IntRectangleRange
#define SOAP_TYPE_PointerTott__IntRectangleRange (1356)
#endif

/* tt__LensProjection * has binding name 'PointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_PointerTott__LensProjection
#define SOAP_TYPE_PointerTott__LensProjection (1354)
#endif

/* tt__LensOffset * has binding name 'PointerTott__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_PointerTott__LensOffset
#define SOAP_TYPE_PointerTott__LensOffset (1353)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (1352)
#endif

/* tt__RotateExtension * has binding name 'PointerTott__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_PointerTott__RotateExtension
#define SOAP_TYPE_PointerTott__RotateExtension (1351)
#endif

/* tt__SceneOrientation * has binding name 'PointerTott__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_PointerTott__SceneOrientation
#define SOAP_TYPE_PointerTott__SceneOrientation (1350)
#endif

/* tt__LensDescription * has binding name 'PointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_PointerTott__LensDescription
#define SOAP_TYPE_PointerTott__LensDescription (1348)
#endif

/* tt__VideoSourceConfigurationExtension2 * has binding name 'PointerTott__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2 (1347)
#endif

/* tt__Rotate * has binding name 'PointerTott__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_PointerTott__Rotate
#define SOAP_TYPE_PointerTott__Rotate (1346)
#endif

/* tt__ProfileExtension2 * has binding name 'PointerTott__ProfileExtension2' for type 'tt:ProfileExtension2' */
#ifndef SOAP_TYPE_PointerTott__ProfileExtension2
#define SOAP_TYPE_PointerTott__ProfileExtension2 (1345)
#endif

/* tt__AudioDecoderConfiguration * has binding name 'PointerTott__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfiguration
#define SOAP_TYPE_PointerTott__AudioDecoderConfiguration (1344)
#endif

/* tt__AudioOutputConfiguration * has binding name 'PointerTott__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioOutputConfiguration
#define SOAP_TYPE_PointerTott__AudioOutputConfiguration (1343)
#endif

/* tt__ProfileExtension * has binding name 'PointerTott__ProfileExtension' for type 'tt:ProfileExtension' */
#ifndef SOAP_TYPE_PointerTott__ProfileExtension
#define SOAP_TYPE_PointerTott__ProfileExtension (1342)
#endif

/* tt__MetadataConfiguration * has binding name 'PointerTott__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfiguration
#define SOAP_TYPE_PointerTott__MetadataConfiguration (1341)
#endif

/* tt__PTZConfiguration * has binding name 'PointerTott__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_PointerTott__PTZConfiguration
#define SOAP_TYPE_PointerTott__PTZConfiguration (1340)
#endif

/* tt__VideoAnalyticsConfiguration * has binding name 'PointerTott__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration (1339)
#endif

/* tt__AudioEncoderConfiguration * has binding name 'PointerTott__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfiguration
#define SOAP_TYPE_PointerTott__AudioEncoderConfiguration (1338)
#endif

/* tt__VideoEncoderConfiguration * has binding name 'PointerTott__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderConfiguration
#define SOAP_TYPE_PointerTott__VideoEncoderConfiguration (1337)
#endif

/* tt__AudioSourceConfiguration * has binding name 'PointerTott__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioSourceConfiguration
#define SOAP_TYPE_PointerTott__AudioSourceConfiguration (1336)
#endif

/* tt__VideoSourceConfiguration * has binding name 'PointerTott__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfiguration
#define SOAP_TYPE_PointerTott__VideoSourceConfiguration (1335)
#endif

/* tt__VideoSourceExtension2 * has binding name 'PointerTott__VideoSourceExtension2' for type 'tt:VideoSourceExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceExtension2
#define SOAP_TYPE_PointerTott__VideoSourceExtension2 (1334)
#endif

/* tt__ImagingSettings20 * has binding name 'PointerTott__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettings20
#define SOAP_TYPE_PointerTott__ImagingSettings20 (1333)
#endif

/* tt__IntRange * has binding name 'PointerTott__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_PointerTott__IntRange
#define SOAP_TYPE_PointerTott__IntRange (1329)
#endif

/* tt__LocationEntity * has binding name 'PointerTott__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_PointerTott__LocationEntity
#define SOAP_TYPE_PointerTott__LocationEntity (1327)
#endif

/* tds__StorageConfigurationData * has binding name 'PointerTotds__StorageConfigurationData' for type 'tds:StorageConfigurationData' */
#ifndef SOAP_TYPE_PointerTotds__StorageConfigurationData
#define SOAP_TYPE_PointerTotds__StorageConfigurationData (1326)
#endif

/* tds__StorageConfiguration * has binding name 'PointerTotds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_PointerTotds__StorageConfiguration
#define SOAP_TYPE_PointerTotds__StorageConfiguration (1324)
#endif

/* _tds__GetSystemUrisResponse_Extension * has binding name 'PointerTo_tds__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension (1323)
#endif

/* tt__SystemLogUriList * has binding name 'PointerTott__SystemLogUriList' for type 'tt:SystemLogUriList' */
#ifndef SOAP_TYPE_PointerTott__SystemLogUriList
#define SOAP_TYPE_PointerTott__SystemLogUriList (1321)
#endif

/* tt__Dot11AvailableNetworks * has binding name 'PointerTott__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_PointerTott__Dot11AvailableNetworks
#define SOAP_TYPE_PointerTott__Dot11AvailableNetworks (1319)
#endif

/* tt__Dot11Status * has binding name 'PointerTott__Dot11Status' for type 'tt:Dot11Status' */
#ifndef SOAP_TYPE_PointerTott__Dot11Status
#define SOAP_TYPE_PointerTott__Dot11Status (1318)
#endif

/* tt__Dot11Capabilities * has binding name 'PointerTott__Dot11Capabilities' for type 'tt:Dot11Capabilities' */
#ifndef SOAP_TYPE_PointerTott__Dot11Capabilities
#define SOAP_TYPE_PointerTott__Dot11Capabilities (1317)
#endif

/* std::string * has binding name 'PointerTott__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_PointerTott__AuxiliaryData
#define SOAP_TYPE_PointerTott__AuxiliaryData (1316)
#endif

/* tt__RelayOutputSettings * has binding name 'PointerTott__RelayOutputSettings' for type 'tt:RelayOutputSettings' */
#ifndef SOAP_TYPE_PointerTott__RelayOutputSettings
#define SOAP_TYPE_PointerTott__RelayOutputSettings (1315)
#endif

/* tt__RelayOutput * has binding name 'PointerTott__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_PointerTott__RelayOutput
#define SOAP_TYPE_PointerTott__RelayOutput (1313)
#endif

/* tt__Dot1XConfiguration * has binding name 'PointerTott__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_PointerTott__Dot1XConfiguration
#define SOAP_TYPE_PointerTott__Dot1XConfiguration (1310)
#endif

/* tt__CertificateInformation * has binding name 'PointerTott__CertificateInformation' for type 'tt:CertificateInformation' */
#ifndef SOAP_TYPE_PointerTott__CertificateInformation
#define SOAP_TYPE_PointerTott__CertificateInformation (1309)
#endif

/* tt__CertificateWithPrivateKey * has binding name 'PointerTott__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_PointerTott__CertificateWithPrivateKey
#define SOAP_TYPE_PointerTott__CertificateWithPrivateKey (1307)
#endif

/* tt__CertificateStatus * has binding name 'PointerTott__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_PointerTott__CertificateStatus
#define SOAP_TYPE_PointerTott__CertificateStatus (1305)
#endif

/* tt__Certificate * has binding name 'PointerTott__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_PointerTott__Certificate
#define SOAP_TYPE_PointerTott__Certificate (1303)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (1302)
#endif

/* std::string * has binding name 'PointerToxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_PointerToxsd__token
#define SOAP_TYPE_PointerToxsd__token (1300)
#endif

/* tt__BinaryData * has binding name 'PointerTott__BinaryData' for type 'tt:BinaryData' */
#ifndef SOAP_TYPE_PointerTott__BinaryData
#define SOAP_TYPE_PointerTott__BinaryData (1299)
#endif

/* tt__IPAddressFilter * has binding name 'PointerTott__IPAddressFilter' for type 'tt:IPAddressFilter' */
#ifndef SOAP_TYPE_PointerTott__IPAddressFilter
#define SOAP_TYPE_PointerTott__IPAddressFilter (1298)
#endif

/* tt__NetworkZeroConfiguration * has binding name 'PointerTott__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfiguration
#define SOAP_TYPE_PointerTott__NetworkZeroConfiguration (1297)
#endif

/* tt__NetworkGateway * has binding name 'PointerTott__NetworkGateway' for type 'tt:NetworkGateway' */
#ifndef SOAP_TYPE_PointerTott__NetworkGateway
#define SOAP_TYPE_PointerTott__NetworkGateway (1294)
#endif

/* tt__NetworkProtocol * has binding name 'PointerTott__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_PointerTott__NetworkProtocol
#define SOAP_TYPE_PointerTott__NetworkProtocol (1292)
#endif

/* tt__NetworkInterfaceSetConfiguration * has binding name 'PointerTott__NetworkInterfaceSetConfiguration' for type 'tt:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration (1291)
#endif

/* tt__NetworkInterface * has binding name 'PointerTott__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterface
#define SOAP_TYPE_PointerTott__NetworkInterface (1289)
#endif

/* std::string * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (1288)
#endif

/* std::string * has binding name 'PointerTott__DNSName' for type 'tt:DNSName' */
#ifndef SOAP_TYPE_PointerTott__DNSName
#define SOAP_TYPE_PointerTott__DNSName (1287)
#endif

/* tt__DynamicDNSInformation * has binding name 'PointerTott__DynamicDNSInformation' for type 'tt:DynamicDNSInformation' */
#ifndef SOAP_TYPE_PointerTott__DynamicDNSInformation
#define SOAP_TYPE_PointerTott__DynamicDNSInformation (1286)
#endif

/* tt__NTPInformation * has binding name 'PointerTott__NTPInformation' for type 'tt:NTPInformation' */
#ifndef SOAP_TYPE_PointerTott__NTPInformation
#define SOAP_TYPE_PointerTott__NTPInformation (1285)
#endif

/* tt__IPAddress * has binding name 'PointerTott__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_PointerTott__IPAddress
#define SOAP_TYPE_PointerTott__IPAddress (1283)
#endif

/* tt__DNSInformation * has binding name 'PointerTott__DNSInformation' for type 'tt:DNSInformation' */
#ifndef SOAP_TYPE_PointerTott__DNSInformation
#define SOAP_TYPE_PointerTott__DNSInformation (1281)
#endif

/* tt__HostnameInformation * has binding name 'PointerTott__HostnameInformation' for type 'tt:HostnameInformation' */
#ifndef SOAP_TYPE_PointerTott__HostnameInformation
#define SOAP_TYPE_PointerTott__HostnameInformation (1280)
#endif

/* tt__Capabilities * has binding name 'PointerTott__Capabilities' for type 'tt:Capabilities' */
#ifndef SOAP_TYPE_PointerTott__Capabilities
#define SOAP_TYPE_PointerTott__Capabilities (1279)
#endif

/* tt__User * has binding name 'PointerTott__User' for type 'tt:User' */
#ifndef SOAP_TYPE_PointerTott__User
#define SOAP_TYPE_PointerTott__User (1275)
#endif

/* tt__RemoteUser * has binding name 'PointerTott__RemoteUser' for type 'tt:RemoteUser' */
#ifndef SOAP_TYPE_PointerTott__RemoteUser
#define SOAP_TYPE_PointerTott__RemoteUser (1274)
#endif

/* tt__NetworkHost * has binding name 'PointerTott__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_PointerTott__NetworkHost
#define SOAP_TYPE_PointerTott__NetworkHost (1272)
#endif

/* tt__Scope * has binding name 'PointerTott__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_PointerTott__Scope
#define SOAP_TYPE_PointerTott__Scope (1269)
#endif

/* tt__SystemLog * has binding name 'PointerTott__SystemLog' for type 'tt:SystemLog' */
#ifndef SOAP_TYPE_PointerTott__SystemLog
#define SOAP_TYPE_PointerTott__SystemLog (1268)
#endif

/* tt__SupportInformation * has binding name 'PointerTott__SupportInformation' for type 'tt:SupportInformation' */
#ifndef SOAP_TYPE_PointerTott__SupportInformation
#define SOAP_TYPE_PointerTott__SupportInformation (1267)
#endif

/* tt__BackupFile * has binding name 'PointerTott__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_PointerTott__BackupFile
#define SOAP_TYPE_PointerTott__BackupFile (1265)
#endif

/* tt__AttachmentData * has binding name 'PointerTott__AttachmentData' for type 'tt:AttachmentData' */
#ifndef SOAP_TYPE_PointerTott__AttachmentData
#define SOAP_TYPE_PointerTott__AttachmentData (1264)
#endif

/* tt__SystemDateTime * has binding name 'PointerTott__SystemDateTime' for type 'tt:SystemDateTime' */
#ifndef SOAP_TYPE_PointerTott__SystemDateTime
#define SOAP_TYPE_PointerTott__SystemDateTime (1263)
#endif

/* tt__DateTime * has binding name 'PointerTott__DateTime' for type 'tt:DateTime' */
#ifndef SOAP_TYPE_PointerTott__DateTime
#define SOAP_TYPE_PointerTott__DateTime (1262)
#endif

/* tt__TimeZone * has binding name 'PointerTott__TimeZone' for type 'tt:TimeZone' */
#ifndef SOAP_TYPE_PointerTott__TimeZone
#define SOAP_TYPE_PointerTott__TimeZone (1261)
#endif

/* tds__DeviceServiceCapabilities * has binding name 'PointerTotds__DeviceServiceCapabilities' for type 'tds:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__DeviceServiceCapabilities
#define SOAP_TYPE_PointerTotds__DeviceServiceCapabilities (1260)
#endif

/* tds__Service * has binding name 'PointerTotds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_PointerTotds__Service
#define SOAP_TYPE_PointerTotds__Service (1258)
#endif

/* _tds__StorageConfigurationData_Extension * has binding name 'PointerTo_tds__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension
#define SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension (1257)
#endif

/* tds__UserCredential * has binding name 'PointerTotds__UserCredential' for type 'tds:UserCredential' */
#ifndef SOAP_TYPE_PointerTotds__UserCredential
#define SOAP_TYPE_PointerTotds__UserCredential (1255)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (1254)
#endif

/* _tds__UserCredential_Extension * has binding name 'PointerTo_tds__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__UserCredential_Extension
#define SOAP_TYPE_PointerTo_tds__UserCredential_Extension (1253)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (1251)
#endif

/* std::string * has binding name 'PointerTott__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_PointerTott__StringAttrList
#define SOAP_TYPE_PointerTott__StringAttrList (1250)
#endif

/* std::string * has binding name 'PointerTotds__EAPMethodTypes' for type 'tds:EAPMethodTypes' */
#ifndef SOAP_TYPE_PointerTotds__EAPMethodTypes
#define SOAP_TYPE_PointerTotds__EAPMethodTypes (1249)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (1248)
#endif

/* tds__MiscCapabilities * has binding name 'PointerTotds__MiscCapabilities' for type 'tds:MiscCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__MiscCapabilities
#define SOAP_TYPE_PointerTotds__MiscCapabilities (1246)
#endif

/* tds__SystemCapabilities * has binding name 'PointerTotds__SystemCapabilities' for type 'tds:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__SystemCapabilities
#define SOAP_TYPE_PointerTotds__SystemCapabilities (1245)
#endif

/* tds__SecurityCapabilities * has binding name 'PointerTotds__SecurityCapabilities' for type 'tds:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__SecurityCapabilities
#define SOAP_TYPE_PointerTotds__SecurityCapabilities (1244)
#endif

/* tds__NetworkCapabilities * has binding name 'PointerTotds__NetworkCapabilities' for type 'tds:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__NetworkCapabilities
#define SOAP_TYPE_PointerTotds__NetworkCapabilities (1243)
#endif

/* tt__OnvifVersion * has binding name 'PointerTott__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_PointerTott__OnvifVersion
#define SOAP_TYPE_PointerTott__OnvifVersion (1242)
#endif

/* _tds__Service_Capabilities * has binding name 'PointerTo_tds__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__Service_Capabilities
#define SOAP_TYPE_PointerTo_tds__Service_Capabilities (1241)
#endif

/* struct SOAP_ENV__Header * has binding name 'PointerToSOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Header
#define SOAP_TYPE_PointerToSOAP_ENV__Header (115)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (111)
#endif

/* struct wsdd__ResolveMatchesType * has binding name 'PointerTowsdd__ResolveMatchesType' for type 'wsdd:ResolveMatchesType' */
#ifndef SOAP_TYPE_PointerTowsdd__ResolveMatchesType
#define SOAP_TYPE_PointerTowsdd__ResolveMatchesType (106)
#endif

/* struct wsdd__ResolveType * has binding name 'PointerTowsdd__ResolveType' for type 'wsdd:ResolveType' */
#ifndef SOAP_TYPE_PointerTowsdd__ResolveType
#define SOAP_TYPE_PointerTowsdd__ResolveType (103)
#endif

/* struct wsdd__ProbeMatchesType * has binding name 'PointerTowsdd__ProbeMatchesType' for type 'wsdd:ProbeMatchesType' */
#ifndef SOAP_TYPE_PointerTowsdd__ProbeMatchesType
#define SOAP_TYPE_PointerTowsdd__ProbeMatchesType (100)
#endif

/* struct wsdd__ProbeType * has binding name 'PointerTowsdd__ProbeType' for type 'wsdd:ProbeType' */
#ifndef SOAP_TYPE_PointerTowsdd__ProbeType
#define SOAP_TYPE_PointerTowsdd__ProbeType (97)
#endif

/* struct wsdd__ByeType * has binding name 'PointerTowsdd__ByeType' for type 'wsdd:ByeType' */
#ifndef SOAP_TYPE_PointerTowsdd__ByeType
#define SOAP_TYPE_PointerTowsdd__ByeType (94)
#endif

/* struct wsdd__HelloType * has binding name 'PointerTowsdd__HelloType' for type 'wsdd:HelloType' */
#ifndef SOAP_TYPE_PointerTowsdd__HelloType
#define SOAP_TYPE_PointerTowsdd__HelloType (91)
#endif

/* struct wsdd__AppSequenceType * has binding name 'PointerTowsdd__AppSequenceType' for type 'wsdd:AppSequenceType' */
#ifndef SOAP_TYPE_PointerTowsdd__AppSequenceType
#define SOAP_TYPE_PointerTowsdd__AppSequenceType (90)
#endif

/* _wsdd__Id has binding name '_wsdd__Id' for type '' */
#ifndef SOAP_TYPE__wsdd__Id
#define SOAP_TYPE__wsdd__Id (89)
#endif

/* _wsdd__SupportedMatchingRules has binding name '_wsdd__SupportedMatchingRules' for type '' */
#ifndef SOAP_TYPE__wsdd__SupportedMatchingRules
#define SOAP_TYPE__wsdd__SupportedMatchingRules (85)
#endif

/* _wsdd__XAddrs has binding name '_wsdd__XAddrs' for type '' */
#ifndef SOAP_TYPE__wsdd__XAddrs
#define SOAP_TYPE__wsdd__XAddrs (83)
#endif

/* _wsdd__Types has binding name '_wsdd__Types' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsdd__Types
#define SOAP_TYPE__wsdd__Types (81)
#endif

/* struct wsdd__SigType * has binding name 'PointerTowsdd__SigType' for type 'wsdd:SigType' */
#ifndef SOAP_TYPE_PointerTowsdd__SigType
#define SOAP_TYPE_PointerTowsdd__SigType (74)
#endif

/* struct wsdd__ResolveMatchType * has binding name 'PointerTowsdd__ResolveMatchType' for type 'wsdd:ResolveMatchType' */
#ifndef SOAP_TYPE_PointerTowsdd__ResolveMatchType
#define SOAP_TYPE_PointerTowsdd__ResolveMatchType (73)
#endif

/* struct wsdd__ProbeMatchType * has binding name 'PointerTowsdd__ProbeMatchType' for type 'wsdd:ProbeMatchType' */
#ifndef SOAP_TYPE_PointerTowsdd__ProbeMatchType
#define SOAP_TYPE_PointerTowsdd__ProbeMatchType (72)
#endif

/* unsigned int * has binding name 'PointerTounsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_PointerTounsignedInt
#define SOAP_TYPE_PointerTounsignedInt (71)
#endif

/* struct wsdd__ScopesType * has binding name 'PointerTowsdd__ScopesType' for type 'wsdd:ScopesType' */
#ifndef SOAP_TYPE_PointerTowsdd__ScopesType
#define SOAP_TYPE_PointerTowsdd__ScopesType (69)
#endif

/* wsdd__FaultCodeOpenType has binding name 'wsdd__FaultCodeOpenType' for type 'wsdd:FaultCodeOpenType' */
#ifndef SOAP_TYPE_wsdd__FaultCodeOpenType
#define SOAP_TYPE_wsdd__FaultCodeOpenType (67)
#endif

/* wsdd__UriListType has binding name 'wsdd__UriListType' for type 'wsdd:UriListType' */
#ifndef SOAP_TYPE_wsdd__UriListType
#define SOAP_TYPE_wsdd__UriListType (66)
#endif

/* wsdd__QNameListType has binding name 'wsdd__QNameListType' for type 'xsd:QName' */
#ifndef SOAP_TYPE_wsdd__QNameListType
#define SOAP_TYPE_wsdd__QNameListType (65)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (49)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (47)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (45)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (43)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (42)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (41)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (40)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (39)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (34)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (33)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (30)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (29)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (24)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (20)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (19)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (18)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (17)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (14)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (13)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<_wstop__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic (1853)
#endif

/* std::vector<wstop__TopicType *>  has binding name 'std__vectorTemplateOfPointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType (1850)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (1846)
#endif

/* std::vector<tas__Dot1XConfiguration *>  has binding name 'std__vectorTemplateOfPointerTotas__Dot1XConfiguration' for type 'tas:Dot1XConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__Dot1XConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__Dot1XConfiguration (1815)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftas__CertPathValidationPolicyID' for type 'tas:CertPathValidationPolicyID' */
#ifndef SOAP_TYPE_std__vectorTemplateOftas__CertPathValidationPolicyID
#define SOAP_TYPE_std__vectorTemplateOftas__CertPathValidationPolicyID (1813)
#endif

/* std::vector<tas__CertPathValidationPolicy *>  has binding name 'std__vectorTemplateOfPointerTotas__CertPathValidationPolicy' for type 'tas:CertPathValidationPolicy' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__CertPathValidationPolicy
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__CertPathValidationPolicy (1812)
#endif

/* std::vector<tas__CRL *>  has binding name 'std__vectorTemplateOfPointerTotas__CRL' for type 'tas:CRL' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__CRL
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__CRL (1808)
#endif

/* std::vector<tas__PassphraseAttribute *>  has binding name 'std__vectorTemplateOfPointerTotas__PassphraseAttribute' for type 'tas:PassphraseAttribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__PassphraseAttribute
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__PassphraseAttribute (1804)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftas__CertificationPathID' for type 'tas:CertificationPathID' */
#ifndef SOAP_TYPE_std__vectorTemplateOftas__CertificationPathID
#define SOAP_TYPE_std__vectorTemplateOftas__CertificationPathID (1802)
#endif

/* std::vector<tas__X509Certificate *>  has binding name 'std__vectorTemplateOfPointerTotas__X509Certificate' for type 'tas:X509Certificate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__X509Certificate
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__X509Certificate (1799)
#endif

/* std::vector<tas__X509v3Extension *>  has binding name 'std__vectorTemplateOfPointerTotas__X509v3Extension' for type 'tas:X509v3Extension' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__X509v3Extension
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__X509v3Extension (1797)
#endif

/* std::vector<tas__CSRAttribute *>  has binding name 'std__vectorTemplateOfPointerTotas__CSRAttribute' for type 'tas:CSRAttribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__CSRAttribute
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__CSRAttribute (1796)
#endif

/* std::vector<tas__KeyAttribute *>  has binding name 'std__vectorTemplateOfPointerTotas__KeyAttribute' for type 'tas:KeyAttribute' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__KeyAttribute
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__KeyAttribute (1793)
#endif

/* std::vector<tas__AlgorithmIdentifier *>  has binding name 'std__vectorTemplateOfPointerTotas__AlgorithmIdentifier' for type 'tas:AlgorithmIdentifier' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__AlgorithmIdentifier
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__AlgorithmIdentifier (1780)
#endif

/* std::vector<tas__TrustAnchor *>  has binding name 'std__vectorTemplateOfPointerTotas__TrustAnchor' for type 'tas:TrustAnchor' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__TrustAnchor
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__TrustAnchor (1776)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftas__CertificateID' for type 'tas:CertificateID' */
#ifndef SOAP_TYPE_std__vectorTemplateOftas__CertificateID
#define SOAP_TYPE_std__vectorTemplateOftas__CertificateID (1762)
#endif

/* std::vector<tas__MultiValuedRDN *>  has binding name 'std__vectorTemplateOfPointerTotas__MultiValuedRDN' for type 'tas:MultiValuedRDN' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__MultiValuedRDN
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__MultiValuedRDN (1751)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftas__DNAttributeValue' for type 'tas:DNAttributeValue' */
#ifndef SOAP_TYPE_std__vectorTemplateOftas__DNAttributeValue
#define SOAP_TYPE_std__vectorTemplateOftas__DNAttributeValue (1749)
#endif

/* std::vector<tas__DNAttributeTypeAndValue *>  has binding name 'std__vectorTemplateOfPointerTotas__DNAttributeTypeAndValue' for type 'tas:DNAttributeTypeAndValue' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotas__DNAttributeTypeAndValue
#define SOAP_TYPE_std__vectorTemplateOfPointerTotas__DNAttributeTypeAndValue (1748)
#endif

/* std::vector<tt__PresetTour *>  has binding name 'std__vectorTemplateOfPointerTott__PresetTour' for type 'tt:PresetTour' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour (1743)
#endif

/* std::vector<tt__PTZPreset *>  has binding name 'std__vectorTemplateOfPointerTott__PTZPreset' for type 'tt:PTZPreset' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset (1740)
#endif

/* std::vector<tt__PTZConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration (1735)
#endif

/* std::vector<tt__PTZNode *>  has binding name 'std__vectorTemplateOfPointerTott__PTZNode' for type 'tt:PTZNode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode (1734)
#endif

/* std::vector<tt__OSDConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__OSDConfiguration' for type 'tt:OSDConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__OSDConfiguration (1730)
#endif

/* std::vector<trt__VideoSourceMode *>  has binding name 'std__vectorTemplateOfPointerTotrt__VideoSourceMode' for type 'trt:VideoSourceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode
#define SOAP_TYPE_std__vectorTemplateOfPointerTotrt__VideoSourceMode (1728)
#endif

/* std::vector<tt__AudioDecoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioDecoderConfiguration (1720)
#endif

/* std::vector<tt__AudioOutputConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutputConfiguration (1719)
#endif

/* std::vector<tt__MetadataConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__MetadataConfiguration (1718)
#endif

/* std::vector<tt__VideoAnalyticsConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoAnalyticsConfiguration (1717)
#endif

/* std::vector<tt__AudioSourceConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSourceConfiguration (1716)
#endif

/* std::vector<tt__AudioEncoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfiguration (1715)
#endif

/* std::vector<tt__VideoSourceConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSourceConfiguration (1714)
#endif

/* std::vector<tt__VideoEncoderConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoEncoderConfiguration (1713)
#endif

/* std::vector<tt__Profile *>  has binding name 'std__vectorTemplateOfPointerTott__Profile' for type 'tt:Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Profile (1712)
#endif

/* std::vector<tt__AudioOutput *>  has binding name 'std__vectorTemplateOfPointerTott__AudioOutput' for type 'tt:AudioOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioOutput (1710)
#endif

/* std::vector<tt__AudioSource *>  has binding name 'std__vectorTemplateOfPointerTott__AudioSource' for type 'tt:AudioSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioSource (1708)
#endif

/* std::vector<tt__VideoSource *>  has binding name 'std__vectorTemplateOfPointerTott__VideoSource' for type 'tt:VideoSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoSource (1706)
#endif

/* std::vector<timg__ImagingPreset *>  has binding name 'std__vectorTemplateOfPointerTotimg__ImagingPreset' for type 'timg:ImagingPreset' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset
#define SOAP_TYPE_std__vectorTemplateOfPointerTotimg__ImagingPreset (1699)
#endif

/* std::vector<tmd__SerialPort *>  has binding name 'std__vectorTemplateOfPointerTotmd__SerialPort' for type 'tmd:SerialPort' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotmd__SerialPort
#define SOAP_TYPE_std__vectorTemplateOfPointerTotmd__SerialPort (1688)
#endif

/* std::vector<tt__DigitalInput *>  has binding name 'std__vectorTemplateOfPointerTott__DigitalInput' for type 'tt:DigitalInput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__DigitalInput
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__DigitalInput (1685)
#endif

/* std::vector<tt__VideoOutput *>  has binding name 'std__vectorTemplateOfPointerTott__VideoOutput' for type 'tt:VideoOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoOutput (1678)
#endif

/* std::vector<tmd__RelayOutputOptions *>  has binding name 'std__vectorTemplateOfPointerTotmd__RelayOutputOptions' for type 'tmd:RelayOutputOptions' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotmd__RelayOutputOptions
#define SOAP_TYPE_std__vectorTemplateOfPointerTotmd__RelayOutputOptions (1676)
#endif

/* std::vector<enum tmd__ParityBit>  has binding name 'std__vectorTemplateOftmd__ParityBit' for type 'tmd:ParityBit' */
#ifndef SOAP_TYPE_std__vectorTemplateOftmd__ParityBit
#define SOAP_TYPE_std__vectorTemplateOftmd__ParityBit (1673)
#endif

/* std::vector<enum tt__DigitalIdleState>  has binding name 'std__vectorTemplateOftt__DigitalIdleState' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__DigitalIdleState
#define SOAP_TYPE_std__vectorTemplateOftt__DigitalIdleState (1668)
#endif

/* std::vector<enum tt__RelayMode>  has binding name 'std__vectorTemplateOftt__RelayMode' for type 'tt:RelayMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__RelayMode
#define SOAP_TYPE_std__vectorTemplateOftt__RelayMode (1665)
#endif

/* std::vector<_wsrfbf__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description (1658)
#endif

/* std::vector<wsnt__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType (1649)
#endif

/* std::vector<wsnt__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType (1645)
#endif

/* std::vector<enum tt__OSDType>  has binding name 'std__vectorTemplateOftt__OSDType' for type 'tt:OSDType' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__OSDType
#define SOAP_TYPE_std__vectorTemplateOftt__OSDType (1628)
#endif

/* std::vector<tt__ColorspaceRange *>  has binding name 'std__vectorTemplateOfPointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange (1619)
#endif

/* std::vector<tt__Color *>  has binding name 'std__vectorTemplateOfPointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Color
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Color (1616)
#endif

/* std::vector<tt__PaneLayout *>  has binding name 'std__vectorTemplateOfPointerTott__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout (1609)
#endif

/* std::vector<tt__Config *>  has binding name 'std__vectorTemplateOfPointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Config
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Config (1604)
#endif

/* std::vector<tt__Vector *>  has binding name 'std__vectorTemplateOfPointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector (1602)
#endif

/* std::vector<_tt__ItemList_ElementItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem (1599)
#endif

/* std::vector<_tt__ItemList_SimpleItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem (1597)
#endif

/* std::vector<enum tt__AutoFocusMode>  has binding name 'std__vectorTemplateOftt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode
#define SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode (1594)
#endif

/* std::vector<enum tt__WhiteBalanceMode>  has binding name 'std__vectorTemplateOftt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode
#define SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode (1592)
#endif

/* std::vector<enum tt__ExposurePriority>  has binding name 'std__vectorTemplateOftt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority
#define SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority (1586)
#endif

/* std::vector<enum tt__ExposureMode>  has binding name 'std__vectorTemplateOftt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposureMode
#define SOAP_TYPE_std__vectorTemplateOftt__ExposureMode (1585)
#endif

/* std::vector<enum tt__BacklightCompensationMode>  has binding name 'std__vectorTemplateOftt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode
#define SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode (1584)
#endif

/* std::vector<enum tt__WideDynamicMode>  has binding name 'std__vectorTemplateOftt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode
#define SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode (1583)
#endif

/* std::vector<enum tt__ImageStabilizationMode>  has binding name 'std__vectorTemplateOftt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode
#define SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode (1580)
#endif

/* std::vector<enum tt__IrCutFilterMode>  has binding name 'std__vectorTemplateOftt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode
#define SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode (1568)
#endif

/* std::vector<tt__IrCutFilterAutoAdjustment *>  has binding name 'std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment (1554)
#endif

/* std::vector<enum tt__PTZPresetTourDirection>  has binding name 'std__vectorTemplateOftt__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection
#define SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection (1529)
#endif

/* std::vector<tt__PTZPresetTourSpot *>  has binding name 'std__vectorTemplateOfPointerTott__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot (1515)
#endif

/* std::vector<tt__Space1DDescription *>  has binding name 'std__vectorTemplateOfPointerTott__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription (1505)
#endif

/* std::vector<tt__Space2DDescription *>  has binding name 'std__vectorTemplateOfPointerTott__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription (1504)
#endif

/* std::vector<enum tt__ReverseMode>  has binding name 'std__vectorTemplateOftt__ReverseMode' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ReverseMode
#define SOAP_TYPE_std__vectorTemplateOftt__ReverseMode (1500)
#endif

/* std::vector<enum tt__EFlipMode>  has binding name 'std__vectorTemplateOftt__EFlipMode' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__EFlipMode
#define SOAP_TYPE_std__vectorTemplateOftt__EFlipMode (1498)
#endif

/* std::vector<enum tt__PTZPresetTourOperation>  has binding name 'std__vectorTemplateOftt__PTZPresetTourOperation' for type 'tt:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation
#define SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation (1483)
#endif

/* std::vector<tt__SystemLogUri *>  has binding name 'std__vectorTemplateOfPointerTott__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri (1469)
#endif

/* std::vector<tt__OnvifVersion *>  has binding name 'std__vectorTemplateOfPointerTott__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion (1464)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData
#define SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData (1454)
#endif

/* std::vector<enum tt__Dot11Cipher>  has binding name 'std__vectorTemplateOftt__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher
#define SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher (1431)
#endif

/* std::vector<enum tt__Dot11AuthAndMangementSuite>  has binding name 'std__vectorTemplateOftt__Dot11AuthAndMangementSuite' for type 'tt:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite (1430)
#endif

/* std::vector<tt__NetworkZeroConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration (1418)
#endif

/* std::vector<tt__PrefixedIPv6Address *>  has binding name 'std__vectorTemplateOfPointerTott__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address (1402)
#endif

/* std::vector<tt__PrefixedIPv4Address *>  has binding name 'std__vectorTemplateOfPointerTott__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address (1400)
#endif

/* std::vector<tt__Dot11Configuration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration (1394)
#endif

/* std::vector<tt__Dot3Configuration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration (1392)
#endif

/* std::vector<tt__AudioEncoderConfigurationOption *>  has binding name 'std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption (1378)
#endif

/* std::vector<enum tt__H264Profile>  has binding name 'std__vectorTemplateOftt__H264Profile' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__H264Profile
#define SOAP_TYPE_std__vectorTemplateOftt__H264Profile (1375)
#endif

/* std::vector<enum tt__Mpeg4Profile>  has binding name 'std__vectorTemplateOftt__Mpeg4Profile' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile
#define SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile (1374)
#endif

/* std::vector<tt__VideoResolution *>  has binding name 'std__vectorTemplateOfPointerTott__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution (1373)
#endif

/* std::vector<enum tt__RotateMode>  has binding name 'std__vectorTemplateOftt__RotateMode' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__RotateMode
#define SOAP_TYPE_std__vectorTemplateOftt__RotateMode (1361)
#endif

/* std::vector<enum tt__SceneOrientationMode>  has binding name 'std__vectorTemplateOftt__SceneOrientationMode' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode
#define SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode (1360)
#endif

/* std::vector<tt__LensProjection *>  has binding name 'std__vectorTemplateOfPointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection (1355)
#endif

/* std::vector<tt__LensDescription *>  has binding name 'std__vectorTemplateOfPointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription (1349)
#endif

/* std::vector<float>  has binding name 'std__vectorTemplateOffloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_std__vectorTemplateOffloat
#define SOAP_TYPE_std__vectorTemplateOffloat (1332)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_std__vectorTemplateOfint
#define SOAP_TYPE_std__vectorTemplateOfint (1331)
#endif

/* std::vector<tt__LocationEntity *>  has binding name 'std__vectorTemplateOfPointerTott__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity (1328)
#endif

/* std::vector<tds__StorageConfiguration *>  has binding name 'std__vectorTemplateOfPointerTotds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration (1325)
#endif

/* std::vector<tt__Dot11AvailableNetworks *>  has binding name 'std__vectorTemplateOfPointerTott__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks (1320)
#endif

/* std::vector<tt__RelayOutput *>  has binding name 'std__vectorTemplateOfPointerTott__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput (1314)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken
#define SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken (1312)
#endif

/* std::vector<tt__Dot1XConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration (1311)
#endif

/* std::vector<tt__CertificateWithPrivateKey *>  has binding name 'std__vectorTemplateOfPointerTott__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey (1308)
#endif

/* std::vector<tt__CertificateStatus *>  has binding name 'std__vectorTemplateOfPointerTott__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus (1306)
#endif

/* std::vector<tt__Certificate *>  has binding name 'std__vectorTemplateOfPointerTott__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate (1304)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IPv6Address
#define SOAP_TYPE_std__vectorTemplateOftt__IPv6Address (1296)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IPv4Address
#define SOAP_TYPE_std__vectorTemplateOftt__IPv4Address (1295)
#endif

/* std::vector<tt__NetworkProtocol *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol (1293)
#endif

/* std::vector<tt__NetworkInterface *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface (1290)
#endif

/* std::vector<tt__IPAddress *>  has binding name 'std__vectorTemplateOfPointerTott__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress (1284)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__token
#define SOAP_TYPE_std__vectorTemplateOfxsd__token (1282)
#endif

/* std::vector<enum tt__CapabilityCategory>  has binding name 'std__vectorTemplateOftt__CapabilityCategory' for type 'tt:CapabilityCategory' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory
#define SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory (1278)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (1277)
#endif

/* std::vector<tt__User *>  has binding name 'std__vectorTemplateOfPointerTott__User' for type 'tt:User' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__User
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__User (1276)
#endif

/* std::vector<tt__NetworkHost *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost (1273)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (1271)
#endif

/* std::vector<tt__Scope *>  has binding name 'std__vectorTemplateOfPointerTott__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope (1270)
#endif

/* std::vector<tt__BackupFile *>  has binding name 'std__vectorTemplateOfPointerTott__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile (1266)
#endif

/* std::vector<tds__Service *>  has binding name 'std__vectorTemplateOfPointerTotds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service
#define SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service (1259)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
